function isString$3(x) {
  return typeof x === "string" || x instanceof String;
}
function numberFormatter$2(rawNumber) {
  var dec = String(rawNumber).split(/[.,]/), sep = ",", decsep = ".";
  return dec[0].split("").reverse().reduce(function(prev, now, i) {
    return i % 3 === 0 ? prev + sep + now : prev + now;
  }).split("").reverse().join("") + (dec[1] ? decsep + dec[1] : "");
}
const numberUnFormatter = (formatedNumber) => formatedNumber.split(",").join().replace(",", "", "g");
const splitLines$6 = function(string) {
  return string.split(/\n|\r\n|\r/g);
};
function stripQuotes$2(str) {
  if (str === void 0) {
    return str;
  }
  if (str.startsWith("'") || str.startsWith('"')) {
    str = str.substring(1);
  }
  if (str.endsWith("'") || str.endsWith('"')) {
    str = str.substring(0, str.length - 1);
  }
  return str;
}
function getFilename$3(urlOrFile) {
  if (urlOrFile.name !== void 0) {
    return urlOrFile.name;
  } else if (isString$3(urlOrFile)) {
    let index2 = urlOrFile.lastIndexOf("/");
    let filename = index2 < 0 ? urlOrFile : urlOrFile.substr(index2 + 1);
    index2 = filename.indexOf("?");
    if (index2 > 0) {
      filename = filename.substr(0, index2);
    }
    return filename;
  } else {
    throw Error(`Expected File or string, got ${typeof urlOrFile}`);
  }
}
function isFile$2(object) {
  if (!object) {
    return false;
  }
  return typeof object !== "function" && (object instanceof File || object.hasOwnProperty("name") && typeof object.slice === "function" && typeof object.arrayBuffer === "function");
}
if (typeof process === "object" && typeof window === "undefined") {
  global.atob = function(str) {
    return Buffer.from(str, "base64").toString("binary");
  };
}
function parseUri$1(str) {
  var o = options$1, m = o.parser["loose"].exec(str), uri = {}, i = 14;
  while (i--) uri[o.key[i]] = m[i] || "";
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2;
  });
  return uri;
}
const options$1 = {
  key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
  q: {
    name: "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1$1 = 4;
const Z_BINARY$1 = 0;
const Z_TEXT$1 = 1;
const Z_UNKNOWN$1$1 = 2;
function zero$1$2(buf) {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
const STORED_BLOCK$1 = 0;
const STATIC_TREES$1 = 1;
const DYN_TREES$1 = 2;
const MIN_MATCH$1$2 = 3;
const MAX_MATCH$1$2 = 258;
const LENGTH_CODES$1$2 = 29;
const LITERALS$1$2 = 256;
const L_CODES$1$2 = LITERALS$1$2 + 1 + LENGTH_CODES$1$2;
const D_CODES$1$2 = 30;
const BL_CODES$1$1 = 19;
const HEAP_SIZE$1$1 = 2 * L_CODES$1$2 + 1;
const MAX_BITS$1$1 = 15;
const Buf_size$1 = 16;
const MAX_BL_BITS$1 = 7;
const END_BLOCK$1 = 256;
const REP_3_6$1 = 16;
const REPZ_3_10$1 = 17;
const REPZ_11_138$1 = 18;
const extra_lbits$1 = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits$1 = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits$1 = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order$1 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN$2 = 512;
const static_ltree$2 = new Array((L_CODES$1$2 + 2) * 2);
zero$1$2(static_ltree$2);
const static_dtree$2 = new Array(D_CODES$1$2 * 2);
zero$1$2(static_dtree$2);
const _dist_code$2 = new Array(DIST_CODE_LEN$2);
zero$1$2(_dist_code$2);
const _length_code$2 = new Array(MAX_MATCH$1$2 - MIN_MATCH$1$2 + 1);
zero$1$2(_length_code$2);
const base_length$2 = new Array(LENGTH_CODES$1$2);
zero$1$2(base_length$2);
const base_dist$2 = new Array(D_CODES$1$2);
zero$1$2(base_dist$2);
function StaticTreeDesc$1(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc$1;
let static_d_desc$1;
let static_bl_desc$1;
function TreeDesc$1(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code$1 = (dist) => {
  return dist < 256 ? _dist_code$2[dist] : _dist_code$2[256 + (dist >>> 7)];
};
const put_short$1 = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits$1 = (s, value, length) => {
  if (s.bi_valid > Buf_size$1 - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short$1(s, s.bi_buf);
    s.bi_buf = value >> Buf_size$1 - s.bi_valid;
    s.bi_valid += length - Buf_size$1;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code$1 = (s, c, tree) => {
  send_bits$1(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse$1 = (code, len2) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
};
const bi_flush$1 = (s) => {
  if (s.bi_valid === 16) {
    put_short$1(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen$1 = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes$1 = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len2 = tree[n * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse$1(next_code[len2]++, len2);
  }
};
const tr_static_init$1 = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1$2 - 1; code++) {
    base_length$2[code] = length;
    for (n = 0; n < 1 << extra_lbits$1[code]; n++) {
      _length_code$2[length++] = code;
    }
  }
  _length_code$2[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist$2[code] = dist;
    for (n = 0; n < 1 << extra_dbits$1[code]; n++) {
      _dist_code$2[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1$2; code++) {
    base_dist$2[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits$1[code] - 7; n++) {
      _dist_code$2[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree$2[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree$2[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree$2[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree$2[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes$1(static_ltree$2, L_CODES$1$2 + 1, bl_count);
  for (n = 0; n < D_CODES$1$2; n++) {
    static_dtree$2[n * 2 + 1] = 5;
    static_dtree$2[n * 2] = bi_reverse$1(n, 5);
  }
  static_l_desc$1 = new StaticTreeDesc$1(static_ltree$2, extra_lbits$1, LITERALS$1$2 + 1, L_CODES$1$2, MAX_BITS$1$1);
  static_d_desc$1 = new StaticTreeDesc$1(static_dtree$2, extra_dbits$1, 0, D_CODES$1$2, MAX_BITS$1$1);
  static_bl_desc$1 = new StaticTreeDesc$1(new Array(0), extra_blbits$1, 0, BL_CODES$1$1, MAX_BL_BITS$1);
};
const init_block$1 = (s) => {
  let n;
  for (n = 0; n < L_CODES$1$2; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1$2; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK$1 * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup$1 = (s) => {
  if (s.bi_valid > 8) {
    put_short$1(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller$1 = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap$1 = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller$1(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller$1(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block$1 = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code$1(s, lc, ltree);
      } else {
        code = _length_code$2[lc];
        send_code$1(s, code + LITERALS$1$2 + 1, ltree);
        extra = extra_lbits$1[code];
        if (extra !== 0) {
          lc -= base_length$2[code];
          send_bits$1(s, lc, extra);
        }
        dist--;
        code = d_code$1(dist);
        send_code$1(s, code, dtree);
        extra = extra_dbits$1[code];
        if (extra !== 0) {
          dist -= base_dist$2[code];
          send_bits$1(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code$1(s, END_BLOCK$1, ltree);
};
const build_tree$1 = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap$1(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap$1(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap$1(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen$1(s, desc);
  gen_codes$1(tree, max_code, s.bl_count);
};
const scan_tree$1 = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6$1 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10$1 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138$1 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree$1 = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code$1(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code$1(s, curlen, s.bl_tree);
        count--;
      }
      send_code$1(s, REP_3_6$1, s.bl_tree);
      send_bits$1(s, count - 3, 2);
    } else if (count <= 10) {
      send_code$1(s, REPZ_3_10$1, s.bl_tree);
      send_bits$1(s, count - 3, 3);
    } else {
      send_code$1(s, REPZ_11_138$1, s.bl_tree);
      send_bits$1(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree$1 = (s) => {
  let max_blindex;
  scan_tree$1(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree$1(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree$1(s, s.bl_desc);
  for (max_blindex = BL_CODES$1$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order$1[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees$1 = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits$1(s, lcodes - 257, 5);
  send_bits$1(s, dcodes - 1, 5);
  send_bits$1(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits$1(s, s.bl_tree[bl_order$1[rank2] * 2 + 1], 3);
  }
  send_tree$1(s, s.dyn_ltree, lcodes - 1);
  send_tree$1(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type$1 = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY$1;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT$1;
  }
  for (n = 32; n < LITERALS$1$2; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT$1;
    }
  }
  return Z_BINARY$1;
};
let static_init_done$1 = false;
const _tr_init$1$1 = (s) => {
  if (!static_init_done$1) {
    tr_static_init$1();
    static_init_done$1 = true;
  }
  s.l_desc = new TreeDesc$1(s.dyn_ltree, static_l_desc$1);
  s.d_desc = new TreeDesc$1(s.dyn_dtree, static_d_desc$1);
  s.bl_desc = new TreeDesc$1(s.bl_tree, static_bl_desc$1);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block$1(s);
};
const _tr_stored_block$1$1 = (s, buf, stored_len, last) => {
  send_bits$1(s, (STORED_BLOCK$1 << 1) + (last ? 1 : 0), 3);
  bi_windup$1(s);
  put_short$1(s, stored_len);
  put_short$1(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1$1 = (s) => {
  send_bits$1(s, STATIC_TREES$1 << 1, 3);
  send_code$1(s, END_BLOCK$1, static_ltree$2);
  bi_flush$1(s);
};
const _tr_flush_block$1$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1$1) {
      s.strm.data_type = detect_data_type$1(s);
    }
    build_tree$1(s, s.l_desc);
    build_tree$1(s, s.d_desc);
    max_blindex = build_bl_tree$1(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1$1 || static_lenb === opt_lenb) {
    send_bits$1(s, (STATIC_TREES$1 << 1) + (last ? 1 : 0), 3);
    compress_block$1(s, static_ltree$2, static_dtree$2);
  } else {
    send_bits$1(s, (DYN_TREES$1 << 1) + (last ? 1 : 0), 3);
    send_all_trees$1(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block$1(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block$1(s);
  if (last) {
    bi_windup$1(s);
  }
};
const _tr_tally$1$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code$2[lc] + LITERALS$1$2 + 1) * 2]++;
    s.dyn_dtree[d_code$1(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1$1 = _tr_init$1$1;
var _tr_stored_block_1$1 = _tr_stored_block$1$1;
var _tr_flush_block_1$1 = _tr_flush_block$1$1;
var _tr_tally_1$1 = _tr_tally$1$1;
var _tr_align_1$1 = _tr_align$1$1;
var trees$1 = {
  _tr_init: _tr_init_1$1,
  _tr_stored_block: _tr_stored_block_1$1,
  _tr_flush_block: _tr_flush_block_1$1,
  _tr_tally: _tr_tally_1$1,
  _tr_align: _tr_align_1$1
};
const adler32$2 = (adler, buf, len2, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len2 !== 0) {
    n = len2 > 2e3 ? 2e3 : len2;
    len2 -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1$2 = adler32$2;
const makeTable$2 = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable$2 = new Uint32Array(makeTable$2());
const crc32$2 = (crc, buf, len2, pos) => {
  const t = crcTable$2;
  const end = pos + len2;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1$2 = crc32$2;
var messages$2 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: _tr_init$2, _tr_stored_block: _tr_stored_block$2, _tr_flush_block: _tr_flush_block$2, _tr_tally: _tr_tally$2, _tr_align: _tr_align$2 } = trees$1;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2$1,
  Z_PARTIAL_FLUSH: Z_PARTIAL_FLUSH$1,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1$1,
  Z_FINISH: Z_FINISH$3$1,
  Z_BLOCK: Z_BLOCK$1$1,
  Z_OK: Z_OK$3$1,
  Z_STREAM_END: Z_STREAM_END$3$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2$1,
  Z_DATA_ERROR: Z_DATA_ERROR$2$1,
  Z_BUF_ERROR: Z_BUF_ERROR$1$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1$1,
  Z_FILTERED: Z_FILTERED$1,
  Z_HUFFMAN_ONLY: Z_HUFFMAN_ONLY$1,
  Z_RLE: Z_RLE$1,
  Z_FIXED: Z_FIXED$2,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1$1,
  Z_UNKNOWN: Z_UNKNOWN$2,
  Z_DEFLATED: Z_DEFLATED$2$1
} = constants$2$2;
const MAX_MEM_LEVEL$1 = 9;
const MAX_WBITS$1$1 = 15;
const DEF_MEM_LEVEL$1 = 8;
const LENGTH_CODES$2 = 29;
const LITERALS$2 = 256;
const L_CODES$2 = LITERALS$2 + 1 + LENGTH_CODES$2;
const D_CODES$2 = 30;
const BL_CODES$2 = 19;
const HEAP_SIZE$2 = 2 * L_CODES$2 + 1;
const MAX_BITS$2 = 15;
const MIN_MATCH$2 = 3;
const MAX_MATCH$2 = 258;
const MIN_LOOKAHEAD$1 = MAX_MATCH$2 + MIN_MATCH$2 + 1;
const PRESET_DICT$1 = 32;
const INIT_STATE$1 = 42;
const GZIP_STATE$1 = 57;
const EXTRA_STATE$1 = 69;
const NAME_STATE$1 = 73;
const COMMENT_STATE$1 = 91;
const HCRC_STATE$1 = 103;
const BUSY_STATE$1 = 113;
const FINISH_STATE$1 = 666;
const BS_NEED_MORE$1 = 1;
const BS_BLOCK_DONE$1 = 2;
const BS_FINISH_STARTED$1 = 3;
const BS_FINISH_DONE$1 = 4;
const OS_CODE$1 = 3;
const err$1 = (strm, errorCode) => {
  strm.msg = messages$2[errorCode];
  return errorCode;
};
const rank$1 = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero$2 = (buf) => {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
};
const slide_hash$1 = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB$1 = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH$1 = HASH_ZLIB$1;
const flush_pending$1 = (strm) => {
  const s = strm.state;
  let len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len2), strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only$1 = (s, last) => {
  _tr_flush_block$2(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending$1(s.strm);
};
const put_byte$1 = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB$1 = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf$1 = (strm, buf, start, size) => {
  let len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len2), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1$2(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1$2(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
};
const longest_match$1 = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len2;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD$1 ? s.strstart - (s.w_size - MIN_LOOKAHEAD$1) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH$2;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH$2 - (strend - scan);
    scan = strend - MAX_MATCH$2;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window$1 = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD$1)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash$1(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf$1(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$2) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH$1(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH$1(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$2) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD$1 && s.strm.avail_in !== 0);
};
const deflate_stored$1 = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len2, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len2 = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len2 > left + s.strm.avail_in) {
      len2 = left + s.strm.avail_in;
    }
    if (len2 > have) {
      len2 = have;
    }
    if (len2 < min_block && (len2 === 0 && flush !== Z_FINISH$3$1 || flush === Z_NO_FLUSH$2$1 || len2 !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3$1 && len2 === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block$2(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len2;
    s.pending_buf[s.pending - 3] = len2 >> 8;
    s.pending_buf[s.pending - 2] = ~len2;
    s.pending_buf[s.pending - 1] = ~len2 >> 8;
    flush_pending$1(s.strm);
    if (left) {
      if (left > len2) {
        left = len2;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len2 -= left;
    }
    if (len2) {
      read_buf$1(s.strm, s.strm.output, s.strm.next_out, len2);
      s.strm.next_out += len2;
      s.strm.avail_out -= len2;
      s.strm.total_out += len2;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE$1;
  }
  if (flush !== Z_NO_FLUSH$2$1 && flush !== Z_FINISH$3$1 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE$1;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf$1(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3$1) && flush !== Z_NO_FLUSH$2$1 && s.strm.avail_in === 0 && left <= have) {
    len2 = left > have ? have : left;
    last = flush === Z_FINISH$3$1 && s.strm.avail_in === 0 && len2 === left ? 1 : 0;
    _tr_stored_block$2(s, s.block_start, len2, last);
    s.block_start += len2;
    flush_pending$1(s.strm);
  }
  return last ? BS_FINISH_STARTED$1 : BS_NEED_MORE$1;
};
const deflate_fast$1 = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window$1(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2$1) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = HASH$1(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match$1(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = _tr_tally$2(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$2) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH$1(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH$1(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally$2(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$3$1) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.sym_next) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
};
const deflate_slow$1 = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD$1) {
      fill_window$1(s);
      if (s.lookahead < MIN_LOOKAHEAD$1 && flush === Z_NO_FLUSH$2$1) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$2) {
      s.ins_h = HASH$1(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$2 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD$1) {
      s.match_length = longest_match$1(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED$1 || s.match_length === MIN_MATCH$2 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$2 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$2 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$2;
      bflush = _tr_tally$2(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$2);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH$1(s, s.ins_h, s.window[s.strstart + MIN_MATCH$2 - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$2 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only$1(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE$1;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally$2(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only$1(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally$2(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$2 - 1 ? s.strstart : MIN_MATCH$2 - 1;
  if (flush === Z_FINISH$3$1) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.sym_next) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
};
const deflate_rle$1 = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$2) {
      fill_window$1(s);
      if (s.lookahead <= MAX_MATCH$2 && flush === Z_NO_FLUSH$2$1) {
        return BS_NEED_MORE$1;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$2 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$2;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$2 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$2) {
      bflush = _tr_tally$2(s, 1, s.match_length - MIN_MATCH$2);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally$2(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3$1) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.sym_next) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
};
const deflate_huff$1 = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window$1(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2$1) {
          return BS_NEED_MORE$1;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally$2(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only$1(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE$1;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3$1) {
    flush_block_only$1(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED$1;
    }
    return BS_FINISH_DONE$1;
  }
  if (s.sym_next) {
    flush_block_only$1(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE$1;
    }
  }
  return BS_BLOCK_DONE$1;
};
function Config$1(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table$1 = [
  /*      good lazy nice chain */
  new Config$1(0, 0, 0, 0, deflate_stored$1),
  /* 0 store only */
  new Config$1(4, 4, 8, 4, deflate_fast$1),
  /* 1 max speed, no lazy matches */
  new Config$1(4, 5, 16, 8, deflate_fast$1),
  /* 2 */
  new Config$1(4, 6, 32, 32, deflate_fast$1),
  /* 3 */
  new Config$1(4, 4, 16, 16, deflate_slow$1),
  /* 4 lazy matches */
  new Config$1(8, 16, 32, 32, deflate_slow$1),
  /* 5 */
  new Config$1(8, 16, 128, 128, deflate_slow$1),
  /* 6 */
  new Config$1(8, 32, 128, 256, deflate_slow$1),
  /* 7 */
  new Config$1(32, 128, 258, 1024, deflate_slow$1),
  /* 8 */
  new Config$1(32, 258, 258, 4096, deflate_slow$1)
  /* 9 max compression */
];
const lm_init$1 = (s) => {
  s.window_size = 2 * s.w_size;
  zero$2(s.head);
  s.max_lazy_match = configuration_table$1[s.level].max_lazy;
  s.good_match = configuration_table$1[s.level].good_length;
  s.nice_match = configuration_table$1[s.level].nice_length;
  s.max_chain_length = configuration_table$1[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState$1() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2$1;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE$2 * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES$2 + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES$2 + 1) * 2);
  zero$2(this.dyn_ltree);
  zero$2(this.dyn_dtree);
  zero$2(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS$2 + 1);
  this.heap = new Uint16Array(2 * L_CODES$2 + 1);
  zero$2(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES$2 + 1);
  zero$2(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck$1 = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE$1 && //#ifdef GZIP
  s.status !== GZIP_STATE$1 && //#endif
  s.status !== EXTRA_STATE$1 && s.status !== NAME_STATE$1 && s.status !== COMMENT_STATE$1 && s.status !== HCRC_STATE$1 && s.status !== BUSY_STATE$1 && s.status !== FINISH_STATE$1) {
    return 1;
  }
  return 0;
};
const deflateResetKeep$1 = (strm) => {
  if (deflateStateCheck$1(strm)) {
    return err$1(strm, Z_STREAM_ERROR$2$1);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$2;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE$1 : (
    //#endif
    s.wrap ? INIT_STATE$1 : BUSY_STATE$1
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init$2(s);
  return Z_OK$3$1;
};
const deflateReset$1 = (strm) => {
  const ret = deflateResetKeep$1(strm);
  if (ret === Z_OK$3$1) {
    lm_init$1(strm.state);
  }
  return ret;
};
const deflateSetHeader$1 = (strm, head) => {
  if (deflateStateCheck$1(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2$1;
  }
  strm.state.gzhead = head;
  return Z_OK$3$1;
};
const deflateInit2$1 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2$1;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL$1 || method !== Z_DEFLATED$2$1 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$2 || windowBits === 8 && wrap !== 1) {
    return err$1(strm, Z_STREAM_ERROR$2$1);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState$1();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE$1;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$2 - 1) / MIN_MATCH$2);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset$1(strm);
};
const deflateInit$1 = (strm, level) => {
  return deflateInit2$1(strm, level, Z_DEFLATED$2$1, MAX_WBITS$1$1, DEF_MEM_LEVEL$1, Z_DEFAULT_STRATEGY$1$1);
};
const deflate$2$1 = (strm, flush) => {
  if (deflateStateCheck$1(strm) || flush > Z_BLOCK$1$1 || flush < 0) {
    return strm ? err$1(strm, Z_STREAM_ERROR$2$1) : Z_STREAM_ERROR$2$1;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE$1 && flush !== Z_FINISH$3$1) {
    return err$1(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1$1 : Z_STREAM_ERROR$2$1);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending$1(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3$1;
    }
  } else if (strm.avail_in === 0 && rank$1(flush) <= rank$1(old_flush) && flush !== Z_FINISH$3$1) {
    return err$1(strm, Z_BUF_ERROR$1$1);
  }
  if (s.status === FINISH_STATE$1 && strm.avail_in !== 0) {
    return err$1(strm, Z_BUF_ERROR$1$1);
  }
  if (s.status === INIT_STATE$1 && s.wrap === 0) {
    s.status = BUSY_STATE$1;
  }
  if (s.status === INIT_STATE$1) {
    let header = Z_DEFLATED$2$1 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT$1;
    }
    header += 31 - header % 31;
    putShortMSB$1(s, header);
    if (s.strstart !== 0) {
      putShortMSB$1(s, strm.adler >>> 16);
      putShortMSB$1(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE$1;
    flush_pending$1(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3$1;
    }
  }
  if (s.status === GZIP_STATE$1) {
    strm.adler = 0;
    put_byte$1(s, 31);
    put_byte$1(s, 139);
    put_byte$1(s, 8);
    if (!s.gzhead) {
      put_byte$1(s, 0);
      put_byte$1(s, 0);
      put_byte$1(s, 0);
      put_byte$1(s, 0);
      put_byte$1(s, 0);
      put_byte$1(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
      put_byte$1(s, OS_CODE$1);
      s.status = BUSY_STATE$1;
      flush_pending$1(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3$1;
      }
    } else {
      put_byte$1(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte$1(s, s.gzhead.time & 255);
      put_byte$1(s, s.gzhead.time >> 8 & 255);
      put_byte$1(s, s.gzhead.time >> 16 & 255);
      put_byte$1(s, s.gzhead.time >> 24 & 255);
      put_byte$1(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY$1 || s.level < 2 ? 4 : 0);
      put_byte$1(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte$1(s, s.gzhead.extra.length & 255);
        put_byte$1(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE$1;
    }
  }
  if (s.status === EXTRA_STATE$1) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending$1(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3$1;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE$1;
  }
  if (s.status === NAME_STATE$1) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$1(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3$1;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$1(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE$1;
  }
  if (s.status === COMMENT_STATE$1) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending$1(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3$1;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte$1(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$2(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE$1;
  }
  if (s.status === HCRC_STATE$1) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending$1(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3$1;
        }
      }
      put_byte$1(s, strm.adler & 255);
      put_byte$1(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE$1;
    flush_pending$1(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3$1;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2$1 && s.status !== FINISH_STATE$1) {
    let bstate = s.level === 0 ? deflate_stored$1(s, flush) : s.strategy === Z_HUFFMAN_ONLY$1 ? deflate_huff$1(s, flush) : s.strategy === Z_RLE$1 ? deflate_rle$1(s, flush) : configuration_table$1[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED$1 || bstate === BS_FINISH_DONE$1) {
      s.status = FINISH_STATE$1;
    }
    if (bstate === BS_NEED_MORE$1 || bstate === BS_FINISH_STARTED$1) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3$1;
    }
    if (bstate === BS_BLOCK_DONE$1) {
      if (flush === Z_PARTIAL_FLUSH$1) {
        _tr_align$2(s);
      } else if (flush !== Z_BLOCK$1$1) {
        _tr_stored_block$2(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1$1) {
          zero$2(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending$1(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3$1;
      }
    }
  }
  if (flush !== Z_FINISH$3$1) {
    return Z_OK$3$1;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3$1;
  }
  if (s.wrap === 2) {
    put_byte$1(s, strm.adler & 255);
    put_byte$1(s, strm.adler >> 8 & 255);
    put_byte$1(s, strm.adler >> 16 & 255);
    put_byte$1(s, strm.adler >> 24 & 255);
    put_byte$1(s, strm.total_in & 255);
    put_byte$1(s, strm.total_in >> 8 & 255);
    put_byte$1(s, strm.total_in >> 16 & 255);
    put_byte$1(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB$1(s, strm.adler >>> 16);
    putShortMSB$1(s, strm.adler & 65535);
  }
  flush_pending$1(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3$1 : Z_STREAM_END$3$1;
};
const deflateEnd$1 = (strm) => {
  if (deflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$2$1;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE$1 ? err$1(strm, Z_DATA_ERROR$2$1) : Z_OK$3$1;
};
const deflateSetDictionary$1 = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$2$1;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE$1 || s.lookahead) {
    return Z_STREAM_ERROR$2$1;
  }
  if (wrap === 1) {
    strm.adler = adler32_1$2(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero$2(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window$1(s);
  while (s.lookahead >= MIN_MATCH$2) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH$2 - 1);
    do {
      s.ins_h = HASH$1(s, s.ins_h, s.window[str + MIN_MATCH$2 - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$2 - 1;
    fill_window$1(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$2 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3$1;
};
var deflateInit_1$1 = deflateInit$1;
var deflateInit2_1$1 = deflateInit2$1;
var deflateReset_1$1 = deflateReset$1;
var deflateResetKeep_1$1 = deflateResetKeep$1;
var deflateSetHeader_1$1 = deflateSetHeader$1;
var deflate_2$1$1 = deflate$2$1;
var deflateEnd_1$1 = deflateEnd$1;
var deflateSetDictionary_1$1 = deflateSetDictionary$1;
var deflateInfo$1 = "pako deflate (from Nodeca project)";
var deflate_1$2$1 = {
  deflateInit: deflateInit_1$1,
  deflateInit2: deflateInit2_1$1,
  deflateReset: deflateReset_1$1,
  deflateResetKeep: deflateResetKeep_1$1,
  deflateSetHeader: deflateSetHeader_1$1,
  deflate: deflate_2$1$1,
  deflateEnd: deflateEnd_1$1,
  deflateSetDictionary: deflateSetDictionary_1$1,
  deflateInfo: deflateInfo$1
};
const _has$2 = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign$2 = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has$2(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks$2 = (chunks) => {
  let len2 = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len2 += chunks[i].length;
  }
  const result = new Uint8Array(len2);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common$2 = {
  assign: assign$2,
  flattenChunks: flattenChunks$2
};
let STR_APPLY_UIA_OK$2 = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK$2 = false;
}
const _utf8len$2 = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len$2[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len$2[254] = _utf8len$2[254] = 1;
var string2buf$2 = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring$2 = (buf, len2) => {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK$2) {
      return String.fromCharCode.apply(null, buf.length === len2 ? buf : buf.subarray(0, len2));
    }
  }
  let result = "";
  for (let i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string$2 = (buf, max) => {
  const len2 = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len$2[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring$2(utf16buf, out);
};
var utf8border$2 = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len$2[buf[pos]] > max ? pos : max;
};
var strings$2 = {
  string2buf: string2buf$2,
  buf2string: buf2string$2,
  utf8border: utf8border$2
};
function ZStream$2() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream$2 = ZStream$2;
const toString$1$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1$1,
  Z_SYNC_FLUSH: Z_SYNC_FLUSH$1,
  Z_FULL_FLUSH: Z_FULL_FLUSH$2,
  Z_FINISH: Z_FINISH$2$1,
  Z_OK: Z_OK$2$1,
  Z_STREAM_END: Z_STREAM_END$2$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$2,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$2,
  Z_DEFLATED: Z_DEFLATED$1$1
} = constants$2$2;
function Deflate$1$1(options2) {
  this.options = common$2.assign({
    level: Z_DEFAULT_COMPRESSION$2,
    method: Z_DEFLATED$1$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$2
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream$2();
  this.strm.avail_out = 0;
  let status = deflate_1$2$1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2$1) {
    throw new Error(messages$2[status]);
  }
  if (opt.header) {
    deflate_1$2$1.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$2.string2buf(opt.dictionary);
    } else if (toString$1$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2$1.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2$1) {
      throw new Error(messages$2[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2$1 : Z_NO_FLUSH$1$1;
  if (typeof data === "string") {
    strm.input = strings$2.string2buf(data);
  } else if (toString$1$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH$1 || _flush_mode === Z_FULL_FLUSH$2) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2$1.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2$1) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2$1.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2$1;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2$1) {
    this.result = common$2.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1$1(input, options2) {
  const deflator = new Deflate$1$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages$2[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1$1(input, options2);
}
var deflateRaw_1$1$1 = deflateRaw$1$1;
var deflate_1$1$1 = {
  deflateRaw: deflateRaw_1$1$1
};
const BAD$1$2 = 16209;
const TYPE$1$2 = 16191;
var inffast$2 = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len2;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1$2;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1$2;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len2 > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output[_out++] = output[from++];
                      if (len2 > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1$2;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1$2;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1$2;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len2 = bits >> 3;
  _in -= len2;
  bits -= len2 << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS$2 = 15;
const ENOUGH_LENS$1$2 = 852;
const ENOUGH_DISTS$1$2 = 592;
const CODES$1$2 = 0;
const LENS$1$2 = 1;
const DISTS$1$2 = 2;
const lbase$2 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext$2 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase$2 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext$2 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table$2 = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len2 = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS$2 + 1);
  const offs = new Uint16Array(MAXBITS$2 + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS$2; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS$2; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS$2; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1$2 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len2 = 1; len2 < MAXBITS$2; len2++) {
    offs[len2 + 1] = offs[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1$2) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1$2) {
    base = lbase$2;
    extra = lext$2;
    match = 257;
  } else {
    base = dbase$2;
    extra = dext$2;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1$2 && used > ENOUGH_LENS$1$2 || type === DISTS$1$2 && used > ENOUGH_DISTS$1$2) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1$2 && used > ENOUGH_LENS$1$2 || type === DISTS$1$2 && used > ENOUGH_DISTS$1$2) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees$2 = inflate_table$2;
const CODES$3 = 0;
const LENS$3 = 1;
const DISTS$3 = 2;
const {
  Z_FINISH: Z_FINISH$1$2,
  Z_BLOCK: Z_BLOCK$3,
  Z_TREES: Z_TREES$2,
  Z_OK: Z_OK$1$2,
  Z_STREAM_END: Z_STREAM_END$1$2,
  Z_NEED_DICT: Z_NEED_DICT$1$2,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1$2,
  Z_DATA_ERROR: Z_DATA_ERROR$1$2,
  Z_MEM_ERROR: Z_MEM_ERROR$1$2,
  Z_BUF_ERROR: Z_BUF_ERROR$3,
  Z_DEFLATED: Z_DEFLATED$4
} = constants$2$2;
const HEAD$2 = 16180;
const FLAGS$2 = 16181;
const TIME$2 = 16182;
const OS$2 = 16183;
const EXLEN$2 = 16184;
const EXTRA$2 = 16185;
const NAME$2 = 16186;
const COMMENT$2 = 16187;
const HCRC$2 = 16188;
const DICTID$2 = 16189;
const DICT$2 = 16190;
const TYPE$3 = 16191;
const TYPEDO$2 = 16192;
const STORED$2 = 16193;
const COPY_$2 = 16194;
const COPY$2 = 16195;
const TABLE$2 = 16196;
const LENLENS$2 = 16197;
const CODELENS$2 = 16198;
const LEN_$2 = 16199;
const LEN$2 = 16200;
const LENEXT$2 = 16201;
const DIST$2 = 16202;
const DISTEXT$2 = 16203;
const MATCH$2 = 16204;
const LIT$2 = 16205;
const CHECK$2 = 16206;
const LENGTH$2 = 16207;
const DONE$2 = 16208;
const BAD$3 = 16209;
const MEM$2 = 16210;
const SYNC$2 = 16211;
const ENOUGH_LENS$3 = 852;
const ENOUGH_DISTS$3 = 592;
const MAX_WBITS$3 = 15;
const DEF_WBITS$2 = MAX_WBITS$3;
const zswap32$2 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState$2() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck$1 = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD$2 || state.mode > SYNC$2) {
    return 1;
  }
  return 0;
};
const inflateResetKeep$2 = (strm) => {
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD$2;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$3);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$3);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1$2;
};
const inflateReset$2 = (strm) => {
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep$2(strm);
};
const inflateReset2$2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1$2;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset$2(strm);
};
const inflateInit2$2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1$2;
  }
  const state = new InflateState$2();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD$2;
  const ret = inflateReset2$2(strm, windowBits);
  if (ret !== Z_OK$1$2) {
    strm.state = null;
  }
  return ret;
};
const inflateInit$2 = (strm) => {
  return inflateInit2$2(strm, DEF_WBITS$2);
};
let virgin$2 = true;
let lenfix$2, distfix$2;
const fixedtables$2 = (state) => {
  if (virgin$2) {
    lenfix$2 = new Int32Array(512);
    distfix$2 = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees$2(LENS$3, state.lens, 0, 288, lenfix$2, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees$2(DISTS$3, state.lens, 0, 32, distfix$2, 0, state.work, { bits: 5 });
    virgin$2 = false;
  }
  state.lencode = lenfix$2;
  state.lenbits = 9;
  state.distcode = distfix$2;
  state.distbits = 5;
};
const updatewindow$2 = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len2;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck$1(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1$2;
  }
  state = strm.state;
  if (state.mode === TYPE$3) {
    state.mode = TYPEDO$2;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1$2;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD$2:
          if (state.wrap === 0) {
            state.mode = TYPEDO$2;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$2(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS$2;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$3;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$4) {
            strm.msg = "unknown compression method";
            state.mode = BAD$3;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          }
          if (len2 > 15 || len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$3;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID$2 : TYPE$3;
          hold = 0;
          bits = 0;
          break;
        case FLAGS$2:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$4) {
            strm.msg = "unknown compression method";
            state.mode = BAD$3;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$3;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$2(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME$2;
        /* falls through */
        case TIME$2:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1$2(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS$2;
        /* falls through */
        case OS$2:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$2(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN$2;
        /* falls through */
        case EXLEN$2:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1$2(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA$2;
        /* falls through */
        case EXTRA$2:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1$2(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$2;
        /* falls through */
        case NAME$2:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1$2(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT$2;
        /* falls through */
        case COMMENT$2:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1$2(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC$2;
        /* falls through */
        case HCRC$2:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$3;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$3;
          break;
        case DICTID$2:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32$2(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT$2;
        /* falls through */
        case DICT$2:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1$2;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$3;
        /* falls through */
        case TYPE$3:
          if (flush === Z_BLOCK$3 || flush === Z_TREES$2) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO$2:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK$2;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED$2;
              break;
            case 1:
              fixedtables$2(state);
              state.mode = LEN_$2;
              if (flush === Z_TREES$2) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE$2;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$3;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED$2:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$3;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_$2;
          if (flush === Z_TREES$2) {
            break inf_leave;
          }
        /* falls through */
        case COPY_$2:
          state.mode = COPY$2;
        /* falls through */
        case COPY$2:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$3;
          break;
        case TABLE$2:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$3;
            break;
          }
          state.have = 0;
          state.mode = LENLENS$2;
        /* falls through */
        case LENLENS$2:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees$2(CODES$3, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$3;
            break;
          }
          state.have = 0;
          state.mode = CODELENS$2;
        /* falls through */
        case CODELENS$2:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$3;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$3;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD$3) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$3;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees$2(LENS$3, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$3;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees$2(DISTS$3, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$3;
            break;
          }
          state.mode = LEN_$2;
          if (flush === Z_TREES$2) {
            break inf_leave;
          }
        /* falls through */
        case LEN_$2:
          state.mode = LEN$2;
        /* falls through */
        case LEN$2:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast$2(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$3) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT$2;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$3;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$3;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT$2;
        /* falls through */
        case LENEXT$2:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST$2;
        /* falls through */
        case DIST$2:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$3;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT$2;
        /* falls through */
        case DISTEXT$2:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$3;
            break;
          }
          state.mode = MATCH$2;
        /* falls through */
        case MATCH$2:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$3;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN$2;
          }
          break;
        case LIT$2:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN$2;
          break;
        case CHECK$2:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1$2(state.check, output, _out, put - _out) : adler32_1$2(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32$2(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$3;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH$2;
        /* falls through */
        case LENGTH$2:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$3;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE$2;
        /* falls through */
        case DONE$2:
          ret = Z_STREAM_END$1$2;
          break inf_leave;
        case BAD$3:
          ret = Z_DATA_ERROR$1$2;
          break inf_leave;
        case MEM$2:
          return Z_MEM_ERROR$1$2;
        case SYNC$2:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1$2;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$3 && (state.mode < CHECK$2 || flush !== Z_FINISH$1$2)) {
    if (updatewindow$2(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1$2(state.check, output, _out, strm.next_out - _out) : adler32_1$2(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$3 ? 128 : 0) + (state.mode === LEN_$2 || state.mode === COPY_$2 ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1$2) && ret === Z_OK$1$2) {
    ret = Z_BUF_ERROR$3;
  }
  return ret;
};
const inflateEnd$2 = (strm) => {
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1$2;
};
const inflateGetHeader$2 = (strm, head) => {
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1$2;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1$2;
};
const inflateSetDictionary$2 = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck$1(strm)) {
    return Z_STREAM_ERROR$1$2;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT$2) {
    return Z_STREAM_ERROR$1$2;
  }
  if (state.mode === DICT$2) {
    dictid = 1;
    dictid = adler32_1$2(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1$2;
    }
  }
  ret = updatewindow$2(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM$2;
    return Z_MEM_ERROR$1$2;
  }
  state.havedict = 1;
  return Z_OK$1$2;
};
var inflateReset_1$2 = inflateReset$2;
var inflateReset2_1$2 = inflateReset2$2;
var inflateResetKeep_1$2 = inflateResetKeep$2;
var inflateInit_1$2 = inflateInit$2;
var inflateInit2_1$2 = inflateInit2$2;
var inflate_2$1$2 = inflate$2$2;
var inflateEnd_1$2 = inflateEnd$2;
var inflateGetHeader_1$2 = inflateGetHeader$2;
var inflateSetDictionary_1$2 = inflateSetDictionary$2;
var inflateInfo$2 = "pako inflate (from Nodeca project)";
var inflate_1$2$2 = {
  inflateReset: inflateReset_1$2,
  inflateReset2: inflateReset2_1$2,
  inflateResetKeep: inflateResetKeep_1$2,
  inflateInit: inflateInit_1$2,
  inflateInit2: inflateInit2_1$2,
  inflate: inflate_2$1$2,
  inflateEnd: inflateEnd_1$2,
  inflateGetHeader: inflateGetHeader_1$2,
  inflateSetDictionary: inflateSetDictionary_1$2,
  inflateInfo: inflateInfo$2
};
function GZheader$2() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader$2 = GZheader$2;
const toString$4 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$4,
  Z_FINISH: Z_FINISH$5,
  Z_OK: Z_OK$5,
  Z_STREAM_END: Z_STREAM_END$5,
  Z_NEED_DICT: Z_NEED_DICT$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$4,
  Z_DATA_ERROR: Z_DATA_ERROR$4,
  Z_MEM_ERROR: Z_MEM_ERROR$3
} = constants$2$2;
function Inflate$1$2(options2) {
  this.options = common$2.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream$2();
  this.strm.avail_out = 0;
  let status = inflate_1$2$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK$5) {
    throw new Error(messages$2[status]);
  }
  this.header = new gzheader$2();
  inflate_1$2$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings$2.string2buf(opt.dictionary);
    } else if (toString$4.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$5) {
        throw new Error(messages$2[status]);
      }
    }
  }
}
Inflate$1$2.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$5 : Z_NO_FLUSH$4;
  if (toString$4.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT$3 && dictionary) {
      status = inflate_1$2$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK$5) {
        status = inflate_1$2$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$4) {
        status = Z_NEED_DICT$3;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END$5 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2$2.inflateReset(strm);
      status = inflate_1$2$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR$4:
      case Z_DATA_ERROR$4:
      case Z_NEED_DICT$3:
      case Z_MEM_ERROR$3:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$5) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings$2.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings$2.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK$5 && last_avail_out === 0) continue;
    if (status === Z_STREAM_END$5) {
      status = inflate_1$2$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1$2.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1$2.prototype.onEnd = function(status) {
  if (status === Z_OK$5) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common$2.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1$2(input, options2) {
  const inflator = new Inflate$1$2(options2);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages$2[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1$2(input, options2);
}
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1$2 = inflate$1$2;
var inflate_1$1$2 = {
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1$2
};
const { deflateRaw: deflateRaw$2 } = deflate_1$1$1;
const { inflateRaw, ungzip: ungzip$3 } = inflate_1$1$2;
var deflateRaw_1$2 = deflateRaw$2;
var inflateRaw_1$2 = inflateRaw;
var ungzip_1$2 = ungzip$3;
const FEXTRA$1 = 4;
function isgzipped$1(data) {
  const b = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  return b[0] === 31 && b[1] === 139;
}
function ungzip_blocks$1(data) {
  const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  const b = ba[3] & FEXTRA$1;
  if (b !== 0 && ba[12] === 66 && ba[13] === 67) {
    return unbgzf$1(ba.buffer);
  } else {
    return ungzip_1$2(ba);
  }
}
function unbgzf$1(data, lim) {
  const oBlockList = [];
  let ptr = 0;
  let totalSize = 0;
  lim = lim || data.byteLength - 18;
  while (ptr < lim) {
    try {
      const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data, ptr, 18);
      const xlen = ba[11] << 8 | ba[10];
      const flg = ba[3];
      const fextra = flg & FEXTRA$1;
      const si1 = ba[12];
      const si2 = ba[13];
      const slen = ba[15] << 8 | ba[14];
      const bsize = (ba[17] << 8 | ba[16]) + 1;
      const start = 12 + xlen + ptr;
      const bytesLeft = data.byteLength - start;
      const cDataSize = bsize - xlen - 19;
      if (bytesLeft < cDataSize || cDataSize <= 0) break;
      const a = new Uint8Array(data, start, cDataSize);
      const unc = inflateRaw_1$2(a);
      ptr += cDataSize - 1 + 26;
      totalSize += unc.byteLength;
      oBlockList.push(unc);
    } catch (e) {
      console.error(e);
      break;
    }
  }
  if (oBlockList.length === 1) {
    return oBlockList[0];
  } else {
    const out = new Uint8Array(totalSize);
    let cursor = 0;
    for (let i = 0; i < oBlockList.length; ++i) {
      var b = new Uint8Array(oBlockList[i]);
      arrayCopy$1(b, 0, out, cursor, b.length);
      cursor += b.length;
    }
    return out;
  }
}
const testArray$1 = new Uint8Array(1);
const hasSubarray$1 = typeof testArray$1.subarray === "function";
function arrayCopy$1(src, srcOffset, dest, destOffset, count) {
  if (count === 0) {
    return;
  }
  if (!src) {
    throw "Undef src";
  } else if (!dest) {
    throw "Undef dest";
  }
  if (count === src.length) {
    arrayCopy_fast$1(src, dest, destOffset);
  } else if (hasSubarray$1) {
    arrayCopy_fast$1(src.subarray(srcOffset, srcOffset + count), dest, destOffset);
  } else if (src.BYTES_PER_ELEMENT === 1 && count > 100) {
    arrayCopy_fast$1(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
  } else {
    arrayCopy_slow$1(src, srcOffset, dest, destOffset, count);
  }
}
function arrayCopy_slow$1(src, srcOffset, dest, destOffset, count) {
  for (let i = 0; i < count; ++i) {
    dest[destOffset + i] = src[srcOffset + i];
  }
}
function arrayCopy_fast$1(src, dest, destOffset) {
  dest.set(src, destOffset);
}
function compressString$1(str) {
  const bytes = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  const compressedBytes = new deflateRaw_1$2(bytes);
  const compressedString = String.fromCharCode.apply(null, compressedBytes);
  let enc = btoa(compressedString);
  return enc.replace(/\+/g, ".").replace(/\//g, "_").replace(/=/g, "-");
}
function uncompressString$1(enc) {
  enc = enc.replace(/\./g, "+").replace(/_/g, "/").replace(/-/g, "=");
  const compressedString = atob(enc);
  const compressedBytes = [];
  for (let i = 0; i < compressedString.length; i++) {
    compressedBytes.push(compressedString.charCodeAt(i));
  }
  const bytes = inflateRaw_1$2(compressedBytes);
  let str = "";
  for (let b of bytes) {
    str += String.fromCharCode(b);
  }
  return str;
}
function decodeDataURI$2(dataURI, gzip) {
  const split = dataURI.split(",");
  const info = split[0].split(":")[1];
  let dataString = split[1];
  if (info.indexOf("base64") >= 0) {
    dataString = atob(dataString);
    const bytes = new Uint8Array(dataString.length);
    for (let i = 0; i < dataString.length; i++) {
      bytes[i] = dataString.charCodeAt(i);
    }
    let plain;
    if (info.indexOf("gzip") > 0) {
      plain = ungzip_1$2(bytes);
    } else {
      plain = bytes;
    }
    return plain;
  } else {
    return decodeURIComponent(dataString);
  }
}
const IGVMath$1 = {
  lerp: (v0, v1, t) => {
    return (1 - t) * v0 + t * v1;
  },
  mean: function(array) {
    var t = 0, n = 0, i;
    for (i = 0; i < array.length; i++) {
      if (!isNaN(array[i])) {
        t += array[i];
        n++;
      }
    }
    return n > 0 ? t / n : 0;
  },
  meanAndStdev: function(array) {
    var v, t = 0, t22 = 0, n = 0, i;
    for (i = 0; i < array.length; i++) {
      v = array[i];
      if (!isNaN(v)) {
        t += v;
        t22 += v * v;
        n++;
      }
    }
    return n > 0 ? { mean: t / n, stdev: Math.sqrt(t22 - t * t / n) } : { mean: 0, stdev: 0 };
  },
  median: function(numbers) {
    var median = 0, numsLen = numbers.length;
    numbers.sort();
    if (numsLen % 2 === 0) {
      median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
    } else {
      median = numbers[(numsLen - 1) / 2];
    }
    return median;
  },
  // Fast percentile function for "p" near edges.  This needs profiled for p in middle (e.g. median)
  percentile: function(array, p) {
    if (array.length === 0) return void 0;
    var k = Math.floor(array.length * ((100 - p) / 100));
    if (k === 0) {
      array.sort(function(a, b) {
        return b - a;
      });
      return array[k];
    } else {
      return selectElement$1(array, k);
    }
  },
  clamp: function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  },
  log2: function(x) {
    return Math.log(x) / Math.LN2;
  }
};
function selectElement$1(array, k) {
  var heap = new BinaryHeap$1(), i;
  for (i = 0; i < array.length; i++) {
    var item = array[i];
    if (heap.content.length < k || item > heap.content[0]) {
      if (heap.content.length === k) {
        heap.pop();
      }
      heap.push(item);
    }
  }
  return heap.content[0];
}
function BinaryHeap$1() {
  this.content = [];
}
BinaryHeap$1.prototype = {
  push: function(element) {
    this.content.push(element);
    this.bubbleUp(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },
  remove: function(node) {
    var length = this.content.length;
    for (var i = 0; i < length; i++) {
      if (this.content[i] !== node) continue;
      var end = this.content.pop();
      if (i === length - 1) break;
      this.content[i] = end;
      this.bubbleUp(i);
      this.sinkDown(i);
      break;
    }
  },
  size: function() {
    return this.content.length;
  },
  bubbleUp: function(n) {
    var element = this.content[n], score = element;
    while (n > 0) {
      var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];
      if (score >= parent)
        break;
      this.content[parentN] = element;
      this.content[n] = parent;
      n = parentN;
    }
  },
  sinkDown: function(n) {
    var length = this.content.length, element = this.content[n], elemScore = element;
    while (true) {
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      var swap2 = null;
      if (child1N < length) {
        var child1 = this.content[child1N], child1Score = child1;
        if (child1Score < elemScore)
          swap2 = child1N;
      }
      if (child2N < length) {
        var child2 = this.content[child2N], child2Score = child2;
        if (child2Score < (swap2 == null ? elemScore : child1Score))
          swap2 = child2N;
      }
      if (swap2 == null) break;
      this.content[n] = this.content[swap2];
      this.content[swap2] = element;
      n = swap2;
    }
  }
};
function _random$1(min, max) {
  return Math.random() * (max - min) + min;
}
const IGVColor$1 = {
  rgbListFromHSV: () => {
    let s = 1;
    let accumulation = [];
    for (let v = 1; v >= 0.5; v -= 0.1) {
      for (let h = 0; h < 1; h += 1 / 28) {
        const r = "rgb(" + IGVColor$1.hsvToRgb(h, s, v).join(",") + ")";
        accumulation.push(r);
      }
    }
    accumulation.pop();
    accumulation.push(IGVColor$1.rgbColor(16, 16, 16));
    return accumulation;
  },
  rgbToHex: function(rgb) {
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return rgb && rgb.length === 4 ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : "";
  },
  hexToRgb: function(hex) {
    var cooked = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (null === cooked) {
      return void 0;
    }
    return "rgb(" + parseInt(cooked[1], 16) + "," + parseInt(cooked[2], 16) + "," + parseInt(cooked[3], 16) + ")";
  },
  /**
   * Converts an HSV color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   v       The value
   * @return  Array   The RGB representation
   */
  hsvToRgb: function(h, s, v) {
    var r, g, b;
    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;
        break;
      case 1:
        r = q, g = v, b = p;
        break;
      case 2:
        r = p, g = v, b = t;
        break;
      case 3:
        r = p, g = q, b = v;
        break;
      case 4:
        r = t, g = p, b = v;
        break;
      case 5:
        r = v, g = p, b = q;
        break;
    }
    return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
  },
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   l       The lightness
   * @return  Array   The RGB representation
   */
  hslToRgb: function(h, s, l) {
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = IGVColor$1.hue2rgb(p, q, h + 1 / 3);
      g = IGVColor$1.hue2rgb(p, q, h);
      b = IGVColor$1.hue2rgb(p, q, h - 1 / 3);
    }
    return [r * 255, g * 255, b * 255];
  },
  hue2rgb: (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  },
  rgbaColor: function(r, g, b, a) {
    r = IGVMath$1.clamp(r, 0, 255);
    g = IGVMath$1.clamp(g, 0, 255);
    b = IGVMath$1.clamp(b, 0, 255);
    a = IGVMath$1.clamp(a, 0, 1);
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  },
  rgbColor: function(r, g, b) {
    r = IGVMath$1.clamp(r, 0, 255);
    g = IGVMath$1.clamp(g, 0, 255);
    b = IGVMath$1.clamp(b, 0, 255);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  greyScale: function(value) {
    var grey = IGVMath$1.clamp(value, 0, 255);
    return "rgb(" + grey + "," + grey + "," + grey + ")";
  },
  randomGrey: function(min, max) {
    min = IGVMath$1.clamp(min, 0, 255);
    max = IGVMath$1.clamp(max, 0, 255);
    var g = Math.round(_random$1(min, max)).toString(10);
    return "rgb(" + g + "," + g + "," + g + ")";
  },
  randomRGB: function(min, max) {
    min = IGVMath$1.clamp(min, 0, 255);
    max = IGVMath$1.clamp(max, 0, 255);
    var r = Math.round(_random$1(min, max)).toString(10);
    var g = Math.round(_random$1(min, max)).toString(10);
    var b = Math.round(_random$1(min, max)).toString(10);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  randomRGBConstantAlpha: function(min, max, alpha) {
    min = IGVMath$1.clamp(min, 0, 255);
    max = IGVMath$1.clamp(max, 0, 255);
    var r = Math.round(_random$1(min, max)).toString(10);
    var g = Math.round(_random$1(min, max)).toString(10);
    var b = Math.round(_random$1(min, max)).toString(10);
    return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
  },
  addAlpha: function(color, alpha) {
    if (color === "0" || color === ".") {
      color = "rgb(0,0,0)";
    } else {
      const c = this.colorNameToHex(color);
      if (c) {
        color = c;
      }
    }
    var isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    if (color.startsWith("rgba")) {
      const idx = color.lastIndexOf(",");
      return color.substring(0, idx + 1) + alpha.toString() + ")";
    }
    if (isHex) {
      color = IGVColor$1.hexToRgb(color);
    }
    if (color.startsWith("rgb")) {
      return color.replace("rgb", "rgba").replace(")", ", " + alpha + ")");
    } else {
      console.log(color + " is not an rgb style string");
      return color;
    }
  },
  rgbComponents: function(color) {
    if (color === "0" || color === ".") {
      return [0, 0, 0];
    }
    const isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    if (isHex) {
      color = IGVColor$1.hexToRgb(color);
    } else {
      if (!color.startsWith("rgb")) {
        const hex = this.colorNameToHex(color);
        color = this.hexToRgb(hex);
      }
    }
    if (color.startsWith("rgb(")) {
      return color.substring(4, color.length - 1).split(",").map((s) => Number.parseInt(s.trim()));
    } else if (color.startsWith("rgba(")) {
      return color.substring(5, color.length - 1).split(",").map((s, i) => {
        s = s.trim();
        return i === 3 ? Number.parseFloat(s) : Number.parseInt(s);
      });
    } else {
      throw Error("Unrecognized color string: color");
    }
  },
  /**
   *
   * @param dest  RGB components as an array
   * @param src  RGB components as an array
   * @param alpha   alpha transparancy in the range 0-1
   * @returns {}
   */
  getCompositeColor: function(dest, src, alpha) {
    var r = Math.floor(alpha * src[0] + (1 - alpha) * dest[0]), g = Math.floor(alpha * src[1] + (1 - alpha) * dest[1]), b = Math.floor(alpha * src[2] + (1 - alpha) * dest[2]);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  createColorString: function(str) {
    str = stripQuotes$2(str);
    if (str.includes(",")) {
      return str.startsWith("rgb") ? str : "rgb(" + str + ")";
    } else {
      return str;
    }
  },
  darkenLighten: function(color, amt) {
    let src;
    let hexColor = this.colorNameToHex(color);
    if (hexColor) {
      src = IGVColor$1.hexToRgb(hexColor);
    } else {
      src = color.startsWith("rgb(") ? color : IGVColor$1.hexToRgb(color);
    }
    const components = src.replace(")", "").substring(4).split(",");
    const r = Math.max(0, Math.min(255, Number.parseInt(components[0].trim()) + amt));
    const g = Math.max(0, Math.min(255, Number.parseInt(components[1].trim()) + amt));
    const b = Math.max(0, Math.min(255, Number.parseInt(components[2].trim()) + amt));
    return "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
  },
  /**
   * Convert html/css color name to hex value.  Adapted from https://gist.github.com/mxfh/4719348
   * @param colorName
   * @returns {*}
   */
  colorNameToHex: function(colorName) {
    const definedColorNames = {
      "aliceblue": "#f0f8ff",
      "antiquewhite": "#faebd7",
      "aqua": "#00ffff",
      "aquamarine": "#7fffd4",
      "azure": "#f0ffff",
      "beige": "#f5f5dc",
      "bisque": "#ffe4c4",
      "black": "#000000",
      "blanchedalmond": "#ffebcd",
      "blue": "#0000ff",
      "blueviolet": "#8a2be2",
      "brown": "#a52a2a",
      "burlywood": "#deb887",
      "cadetblue": "#5f9ea0",
      "chartreuse": "#7fff00",
      "chocolate": "#d2691e",
      "coral": "#ff7f50",
      "cornflowerblue": "#6495ed",
      "cornsilk": "#fff8dc",
      "crimson": "#dc143c",
      "cyan": "#00ffff",
      "darkblue": "#00008b",
      "darkcyan": "#008b8b",
      "darkgoldenrod": "#b8860b",
      "darkgray": "#a9a9a9",
      "darkgreen": "#006400",
      "darkkhaki": "#bdb76b",
      "darkmagenta": "#8b008b",
      "darkolivegreen": "#556b2f",
      "darkorange": "#ff8c00",
      "darkorchid": "#9932cc",
      "darkred": "#8b0000",
      "darksalmon": "#e9967a",
      "darkseagreen": "#8fbc8f",
      "darkslateblue": "#483d8b",
      "darkslategray": "#2f4f4f",
      "darkturquoise": "#00ced1",
      "darkviolet": "#9400d3",
      "deeppink": "#ff1493",
      "deepskyblue": "#00bfff",
      "dimgray": "#696969",
      "dodgerblue": "#1e90ff",
      "firebrick": "#b22222",
      "floralwhite": "#fffaf0",
      "forestgreen": "#228b22",
      "fuchsia": "#ff00ff",
      "gainsboro": "#dcdcdc",
      "ghostwhite": "#f8f8ff",
      "gold": "#ffd700",
      "goldenrod": "#daa520",
      "gray": "#808080",
      "green": "#008000",
      "greenyellow": "#adff2f",
      "honeydew": "#f0fff0",
      "hotpink": "#ff69b4",
      "indianred ": "#cd5c5c",
      "indigo ": "#4b0082",
      "ivory": "#fffff0",
      "khaki": "#f0e68c",
      "lavender": "#e6e6fa",
      "lavenderblush": "#fff0f5",
      "lawngreen": "#7cfc00",
      "lemonchiffon": "#fffacd",
      "lightblue": "#add8e6",
      "lightcoral": "#f08080",
      "lightcyan": "#e0ffff",
      "lightgoldenrodyellow": "#fafad2",
      "lightgrey": "#d3d3d3",
      "lightgreen": "#90ee90",
      "lightpink": "#ffb6c1",
      "lightsalmon": "#ffa07a",
      "lightseagreen": "#20b2aa",
      "lightskyblue": "#87cefa",
      "lightslategray": "#778899",
      "lightsteelblue": "#b0c4de",
      "lightyellow": "#ffffe0",
      "lime": "#00ff00",
      "limegreen": "#32cd32",
      "linen": "#faf0e6",
      "magenta": "#ff00ff",
      "maroon": "#800000",
      "mediumaquamarine": "#66cdaa",
      "mediumblue": "#0000cd",
      "mediumorchid": "#ba55d3",
      "mediumpurple": "#9370d8",
      "mediumseagreen": "#3cb371",
      "mediumslateblue": "#7b68ee",
      "mediumspringgreen": "#00fa9a",
      "mediumturquoise": "#48d1cc",
      "mediumvioletred": "#c71585",
      "midnightblue": "#191970",
      "mintcream": "#f5fffa",
      "mistyrose": "#ffe4e1",
      "moccasin": "#ffe4b5",
      "navajowhite": "#ffdead",
      "navy": "#000080",
      "oldlace": "#fdf5e6",
      "olive": "#808000",
      "olivedrab": "#6b8e23",
      "orange": "#ffa500",
      "orangered": "#ff4500",
      "orchid": "#da70d6",
      "palegoldenrod": "#eee8aa",
      "palegreen": "#98fb98",
      "paleturquoise": "#afeeee",
      "palevioletred": "#d87093",
      "papayawhip": "#ffefd5",
      "peachpuff": "#ffdab9",
      "peru": "#cd853f",
      "pink": "#ffc0cb",
      "plum": "#dda0dd",
      "powderblue": "#b0e0e6",
      "purple": "#800080",
      "red": "#ff0000",
      "rosybrown": "#bc8f8f",
      "royalblue": "#4169e1",
      "saddlebrown": "#8b4513",
      "salmon": "#fa8072",
      "sandybrown": "#f4a460",
      "seagreen": "#2e8b57",
      "seashell": "#fff5ee",
      "sienna": "#a0522d",
      "silver": "#c0c0c0",
      "skyblue": "#87ceeb",
      "slateblue": "#6a5acd",
      "slategray": "#708090",
      "snow": "#fffafa",
      "springgreen": "#00ff7f",
      "steelblue": "#4682b4",
      "tan": "#d2b48c",
      "teal": "#008080",
      "thistle": "#d8bfd8",
      "tomato": "#ff6347",
      "turquoise": "#40e0d0",
      "violet": "#ee82ee",
      "wheat": "#f5deb3",
      "white": "#ffffff",
      "whitesmoke": "#f5f5f5",
      "yellow": "#ffff00",
      "yellowgreen": "#9acd32",
      "darkgrey": "#a9a9a9",
      "darkslategrey": "#2f4f4f",
      "dimgrey": "#696969",
      "grey": "#808080",
      "lightgray": "#d3d3d3",
      "lightslategrey": "#778899",
      "slategrey": "#708090"
    };
    return definedColorNames[colorName];
  }
};
const DEFAULT_HOST$1 = "googleapis";
let Oauth$1 = class Oauth {
  constructor() {
    this.oauthTokens = {};
  }
  setToken(token, host) {
    host = host || DEFAULT_HOST$1;
    this.oauthTokens[host] = token;
  }
  getToken(host) {
    host = host || DEFAULT_HOST$1;
    let token;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp$1(key);
      if (regex.test(host)) {
        token = this.oauthTokens[key];
        break;
      }
    }
    return token;
  }
  removeToken(host) {
    host = host || DEFAULT_HOST$1;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp$1(key);
      if (regex.test(host)) {
        this.oauthTokens[key] = void 0;
      }
    }
  }
  // Special object for google -- legacy support
  // google: {
  //     setToken: function (token) {
  //         oauth.setToken(token);
  //     }
  // }
};
function wildcardToRegExp$1(s) {
  return new RegExp("^" + s.split(/\*+/).map(regExpEscape$1).join(".*") + "$");
}
function regExpEscape$1(s) {
  return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}
function isGoogleURL$2(url) {
  return url.includes("googleapis") && !url.includes("urlshortener") || isGoogleStorageURL$2(url) || isGoogleDriveURL$2(url);
}
function isGoogleStorageURL$2(url) {
  return url.startsWith("gs://") || url.startsWith("https://www.googleapis.com/storage") || url.startsWith("https://storage.cloud.google.com") || url.startsWith("https://storage.googleapis.com");
}
function isGoogleDriveURL$2(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
}
function translateGoogleCloudURL$1(gsUrl) {
  let { bucket, object } = parseBucketName$1(gsUrl);
  object = encode$1(object);
  const qIdx = gsUrl.indexOf("?");
  const paramString = qIdx > 0 ? gsUrl.substring(qIdx) + "&alt=media" : "?alt=media";
  return `https://storage.googleapis.com/storage/v1/b/${bucket}/o/${object}${paramString}`;
}
function parseBucketName$1(url) {
  let bucket;
  let object;
  if (url.startsWith("gs://")) {
    const i = url.indexOf("/", 5);
    if (i >= 0) {
      bucket = url.substring(5, i);
      const qIdx = url.indexOf("?");
      object = qIdx < 0 ? url.substring(i + 1) : url.substring(i + 1, qIdx);
    }
  } else if (url.startsWith("https://storage.googleapis.com") || url.startsWith("https://storage.cloud.google.com")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    if (bucketIdx > 0) {
      const objIdx = url.indexOf("/o/", bucketIdx);
      if (objIdx > 0) {
        const queryIdx = url.indexOf("?", objIdx);
        bucket = url.substring(bucketIdx + 6, objIdx);
        object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
      }
    } else {
      const idx1 = url.indexOf("/", 8);
      const idx2 = url.indexOf("/", idx1 + 1);
      const idx3 = url.indexOf("?", idx2);
      if (idx2 > 0) {
        bucket = url.substring(idx1 + 1, idx2);
        object = idx3 < 0 ? url.substring(idx2 + 1) : url.substring(idx2 + 1, idx3);
      }
    }
  } else if (url.startsWith("https://www.googleapis.com/storage/v1/b")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    const objIdx = url.indexOf("/o/", bucketIdx);
    if (objIdx > 0) {
      const queryIdx = url.indexOf("?", objIdx);
      bucket = url.substring(bucketIdx + 6, objIdx);
      object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
    }
  }
  if (bucket && object) {
    return {
      bucket,
      object
    };
  } else {
    throw Error(`Unrecognized Google Storage URI: ${url}`);
  }
}
function encode$1(objectName) {
  let result = "";
  objectName.split("").forEach(function(letter) {
    if (encodings$3.has(letter)) {
      result += encodings$3.get(letter);
    } else {
      result += letter;
    }
  });
  return result;
}
const encodings$3 = /* @__PURE__ */ new Map();
encodings$3.set("!", "%21");
encodings$3.set("#", "%23");
encodings$3.set("$", "%24");
encodings$3.set("%", "%25");
encodings$3.set("&", "%26");
encodings$3.set("'", "%27");
encodings$3.set("(", "%28");
encodings$3.set(")", "%29");
encodings$3.set("*", "%2A");
encodings$3.set("+", "%2B");
encodings$3.set(",", "%2C");
encodings$3.set("/", "%2F");
encodings$3.set(":", "%3A");
encodings$3.set(";", "%3B");
encodings$3.set("=", "%3D");
encodings$3.set("?", "%3F");
encodings$3.set("@", "%40");
encodings$3.set("[", "%5B");
encodings$3.set("]", "%5D");
encodings$3.set(" ", "%20");
function isInitialized$1() {
  return window.google && window.google.igv;
}
function getCurrentAccessToken$1() {
  return isInitialized$1() && google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt ? google.igv.tokenResponse.access_token : void 0;
}
async function getAccessToken$1(scope) {
  if (!isInitialized$1()) {
    throw Error("Google oAuth has not been initialized");
  }
  if (google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt && google.accounts.oauth2.hasGrantedAllScopes(google.igv.tokenResponse, scope)) {
    return google.igv.tokenResponse.access_token;
  } else {
    const tokenClient = google.igv.tokenClient;
    return new Promise((resolve, reject) => {
      try {
        tokenClient.callback = (tokenResponse) => {
          if (tokenResponse.error !== void 0) {
            reject(tokenResponse);
          }
          google.igv.tokenResponse = tokenResponse;
          google.igv.tokenExpiresAt = Date.now() + tokenResponse.expires_in * 1e3;
          resolve(tokenResponse.access_token);
        };
        tokenClient.requestAccessToken({ scope });
      } catch (err2) {
        console.log(err2);
      }
    });
  }
}
function getScopeForURL$1(url) {
  if (isGoogleDriveURL$2(url)) {
    return "https://www.googleapis.com/auth/drive.readonly";
  } else if (isGoogleStorageURL$2(url)) {
    return "https://www.googleapis.com/auth/devstorage.read_only";
  } else {
    return "https://www.googleapis.com/auth/userinfo.profile";
  }
}
function getDriveDownloadURL$2(link2) {
  var id = getGoogleDriveFileID$2(link2);
  return id ? "https://www.googleapis.com/drive/v3/files/" + id + "?alt=media&supportsTeamDrives=true" : link2;
}
function getGoogleDriveFileID$2(link2) {
  if (link2.includes("/open?id=")) {
    const i1 = link2.indexOf("/open?id=") + 9;
    const i2 = link2.indexOf("&");
    if (i1 > 0 && i2 > i1) {
      return link2.substring(i1, i2);
    } else if (i1 > 0) {
      return link2.substring(i1);
    }
  } else if (link2.includes("/file/d/")) {
    const i1 = link2.indexOf("/file/d/") + 8;
    const i2 = link2.lastIndexOf("/");
    return link2.substring(i1, i2);
  } else if (link2.startsWith("https://www.googleapis.com/drive")) {
    let i1 = link2.indexOf("/files/");
    const i2 = link2.indexOf("?");
    if (i1 > 0) {
      i1 += 7;
      return i2 > 0 ? link2.substring(i1, i2) : link2.substring(i1);
    }
  }
  throw Error("Unknown Google Drive url format: " + link2);
}
let Throttle$1 = class Throttle {
  constructor(options2) {
    this.requestsPerSecond = options2.requestsPerSecond || 10;
    this.lastStartTime = 0;
    this.queued = [];
  }
  /**
   * Adds a promise
   * @param {Function} async function to be executed
   * @param {Object} options A set of options.
   * @return {Promise} A promise
   */
  add(asyncFunction, options2) {
    var self2 = this;
    return new Promise(function(resolve, reject) {
      self2.queued.push({
        resolve,
        reject,
        asyncFunction
      });
      self2.dequeue();
    });
  }
  /**
   * Adds all the promises passed as parameters
   * @param {Function} promises An array of functions that return a promise
   * @param {Object} options A set of options.
   * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
   * @param {number} options.weight A "weight" of each operation resolving by array of promises
   * @return {Promise} A promise that succeeds when all the promises passed as options do
   */
  addAll(promises, options2) {
    var addedPromises = promises.map((function(promise) {
      return this.add(promise, options2);
    }).bind(this));
    return Promise.all(addedPromises);
  }
  /**
   * Dequeues a promise
   * @return {void}
   */
  dequeue() {
    if (this.queued.length > 0) {
      var now = /* @__PURE__ */ new Date(), inc = 1e3 / this.requestsPerSecond + 1, elapsed = now - this.lastStartTime;
      if (elapsed >= inc) {
        this._execute();
      } else {
        setTimeout((function() {
          this.dequeue();
        }).bind(this), inc - elapsed);
      }
    }
  }
  /**
   * Executes the promise
   * @private
   * @return {void}
   */
  async _execute() {
    this.lastStartTime = /* @__PURE__ */ new Date();
    var candidate = this.queued.shift();
    const f = candidate.asyncFunction;
    try {
      const r = await f();
      candidate.resolve(r);
    } catch (e) {
      candidate.reject(e);
    }
  }
};
let IGVXhr$1 = class IGVXhr {
  constructor() {
    this.apiKey = void 0;
    this.googleThrottle = new Throttle$1({
      requestsPerSecond: 8
    });
    this.RANGE_WARNING_GIVEN = false;
    this.oauth = new Oauth$1();
    this.contentLengthMap = /* @__PURE__ */ new Map();
  }
  setApiKey(key) {
    this.apiKey = key;
  }
  async loadArrayBuffer(url, options2) {
    options2 = options2 || {};
    if (!options2.responseType) {
      options2.responseType = "arraybuffer";
    }
    if (isFile$2(url)) {
      return this._loadFileSlice(url, options2);
    } else {
      return this.load(url, options2);
    }
  }
  async loadJson(url, options2) {
    options2 = options2 || {};
    const method = options2.method || (options2.sendData ? "POST" : "GET");
    if (method === "POST") {
      options2.contentType = "application/json";
    }
    const result = await this.loadString(url, options2);
    if (result) {
      return JSON.parse(result);
    } else {
      return result;
    }
  }
  async loadString(path, options2) {
    options2 = options2 || {};
    if (path instanceof File) {
      return this._loadStringFromFile(path, options2);
    } else {
      return this._loadStringFromUrl(path, options2);
    }
  }
  async load(url, options2) {
    options2 = options2 || {};
    const urlType = typeof url;
    url = await (typeof url === "function" ? url() : url);
    if (isFile$2(url)) {
      return this._loadFileSlice(url, options2);
    } else if (typeof url.startsWith === "function") {
      if (url.startsWith("data:")) {
        const buffer = decodeDataURI$2(url).buffer;
        if (options2.range) {
          const rangeEnd = options2.range.size ? options2.range.start + options2.range.size : buffer.byteLength;
          return buffer.slice(options2.range.start, rangeEnd);
        } else {
          return buffer;
        }
      } else {
        if (url.startsWith("https://drive.google.com")) {
          url = getDriveDownloadURL$2(url);
        }
        if (isGoogleDriveURL$2(url) || url.startsWith("https://www.dropbox.com")) {
          return this.googleThrottle.add(async () => {
            return this._loadURL(url, options2);
          });
        } else {
          return this._loadURL(url, options2);
        }
      }
    } else {
      throw Error(`url must be either a 'File', 'string', 'function', or 'Promise'.  Actual type: ${urlType}`);
    }
  }
  async getContentLength(url, options2) {
    if (!this.contentLengthMap.has(url)) {
      options2 = options2 || {};
      options2.method = "HEAD";
      options2.GET_CONTENT_LENGTH = true;
      const contentLengthString = await this._loadURL(url, options2);
      const contentLength = contentLengthString ? Number.parseInt(contentLengthString) : -1;
      this.contentLengthMap.set(url, contentLength);
    }
    return this.contentLengthMap.get(url);
  }
  async _loadURL(url, options2) {
    const self2 = this;
    url = mapUrl$3(url);
    options2 = options2 || {};
    let oauthToken = options2.oauthToken || this.getOauthToken(url);
    if (oauthToken) {
      oauthToken = await (typeof oauthToken === "function" ? oauthToken() : oauthToken);
    }
    let contentLength = -1;
    if (options2.range && !isAmazonV4Signed(url) && !isGoogleStorageSigned$1(url)) {
      contentLength = await this.getContentLength(url);
    }
    return new Promise(function(resolve, reject) {
      if (isGoogleURL$2(url) && !isGoogleStorageSigned$1(url)) {
        if (isGoogleStorageURL$2(url)) {
          url = translateGoogleCloudURL$1(url);
        }
        url = addApiKey$1(url);
        if (isGoogleDriveURL$2(url)) {
          addTeamDrive$1(url);
        }
        if (!oauthToken) {
          oauthToken = getCurrentGoogleAccessToken$1();
        }
      }
      const headers = options2.headers || {};
      if (oauthToken) {
        addOauthHeaders$1(headers, oauthToken);
      }
      const range = options2.range;
      const xhr = new XMLHttpRequest();
      const sendData = options2.sendData || options2.body;
      const method = options2.method || (sendData ? "POST" : "GET");
      const responseType = options2.responseType;
      const contentType = options2.contentType;
      const mimeType = options2.mimeType;
      xhr.open(method, url);
      if (options2.timeout) {
        xhr.timeout = options2.timeout;
      }
      if (range) {
        let rangeEnd = "";
        if (range.size) {
          rangeEnd = range.start + range.size - 1;
          if (contentLength > 0) {
            rangeEnd = Math.min(rangeEnd, contentLength - 1);
          }
        }
        xhr.setRequestHeader("Range", "bytes=" + range.start + "-" + rangeEnd);
      }
      if (contentType) {
        xhr.setRequestHeader("Content-Type", contentType);
      }
      if (mimeType) {
        xhr.overrideMimeType(mimeType);
      }
      if (responseType) {
        xhr.responseType = responseType;
      }
      if (headers) {
        for (let key of Object.keys(headers)) {
          const value = headers[key];
          xhr.setRequestHeader(key, value);
        }
      }
      if (options2.withCredentials === true) {
        xhr.withCredentials = true;
      }
      xhr.onload = async function(event) {
        if (options2.GET_CONTENT_LENGTH) {
          resolve(xhr.getResponseHeader("content-length"));
        }
        if (xhr.status === 0 || xhr.status >= 200 && xhr.status <= 300) {
          if (range && xhr.status !== 206 && range.start !== 0) {
            if (xhr.response.length > 1e5 && !self2.RANGE_WARNING_GIVEN) {
              alert(`Warning: Range header ignored for URL: ${url}.  This can have severe performance impacts.`);
            }
            resolve(xhr.response.slice(range.start, range.start + range.size));
          } else {
            resolve(xhr.response);
          }
        } else if (typeof gapi !== "undefined" && ((xhr.status === 404 || xhr.status === 401 || xhr.status === 403) && isGoogleURL$2(url)) && !options2.retries) {
          tryGoogleAuth();
        } else {
          if (xhr.status === 403) {
            handleError("Access forbidden: " + url);
          } else if (xhr.status === 416) {
            handleError("Unsatisfiable range");
          } else {
            handleError(xhr.status);
          }
        }
      };
      xhr.onerror = function(event) {
        if (isGoogleURL$2(url) && !options2.retries) {
          tryGoogleAuth();
        } else {
          handleError("Error accessing resource: " + url + " Status: " + xhr.status);
        }
      };
      xhr.ontimeout = function(event) {
        handleError("Timed out");
      };
      xhr.onabort = function(event) {
        console.log("Aborted");
        reject(event);
      };
      try {
        xhr.send(sendData);
      } catch (e) {
        if (isGoogleURL$2(url) && !options2.retries) {
          tryGoogleAuth();
        } else {
          handleError(e);
        }
      }
      function handleError(error) {
        if (reject) {
          reject(error);
        } else {
          throw error;
        }
      }
      async function tryGoogleAuth() {
        try {
          const accessToken = await fetchGoogleAccessToken$1(url);
          options2.retries = 1;
          options2.oauthToken = accessToken;
          const response = await self2.load(url, options2);
          resolve(response);
        } catch (e) {
          if (e.error) {
            const msg = e.error.startsWith("popup_blocked") ? "Google login popup blocked by browser." : e.error;
            alert(msg);
          } else {
            handleError(e);
          }
        }
      }
    });
  }
  async _loadFileSlice(localfile, options2) {
    let blob = options2 && options2.range ? localfile.slice(options2.range.start, options2.range.start + options2.range.size) : localfile;
    const arrayBuffer = await blob.arrayBuffer();
    if ("arraybuffer" === options2.responseType) {
      return arrayBuffer;
    } else {
      return arrayBufferToString$1(arrayBuffer);
    }
  }
  async _loadStringFromFile(localfile, options2) {
    const blob = options2.range ? localfile.slice(options2.range.start, options2.range.start + options2.range.size) : localfile;
    const arrayBuffer = await blob.arrayBuffer();
    return arrayBufferToString$1(arrayBuffer);
  }
  async _loadStringFromUrl(url, options2) {
    options2 = options2 || {};
    options2.responseType = "arraybuffer";
    const data = await this.load(url, options2);
    return arrayBufferToString$1(data);
  }
  /**
   * Explicity set an oAuth token for use with given host.  If host is undefined token is used for google api access*
   * @param token
   * @param host
   */
  setOauthToken(token, host) {
    this.oauth.setToken(token, host);
  }
  /**
   * Return an oauth token for the URL if we have one.  This method does not force sign-in, and the token may
   * or may not be valid.  Sign-in is triggered on request failure.
   * *
   * @param url
   * @returns {*}
   */
  getOauthToken(url) {
    const host = isGoogleURL$2(url) ? void 0 : parseUri$1(url).host;
    let token = this.oauth.getToken(host);
    if (token) {
      return token;
    } else if (host === void 0) {
      const googleToken = getCurrentGoogleAccessToken$1();
      if (googleToken && googleToken.expires_at > Date.now()) {
        return googleToken.access_token;
      }
    }
  }
};
function isGoogleStorageSigned$1(url) {
  return url.indexOf("X-Goog-Signature") > -1;
}
async function fetchGoogleAccessToken$1(url) {
  if (isInitialized$1()) {
    const scope = getScopeForURL$1(url);
    const access_token = await getAccessToken$1(scope);
    return access_token;
  } else {
    throw Error(
      `Authorization is required, but Google oAuth has not been initalized. Contact your site administrator for assistance.`
    );
  }
}
function getCurrentGoogleAccessToken$1() {
  if (isInitialized$1()) {
    const access_token = getCurrentAccessToken$1();
    return access_token;
  } else {
    return void 0;
  }
}
function addOauthHeaders$1(headers, acToken) {
  if (acToken) {
    headers["Cache-Control"] = "no-cache";
    headers["Authorization"] = "Bearer " + acToken;
  }
  return headers;
}
function addApiKey$1(url) {
  let apiKey2 = igvxhr$1.apiKey;
  if (!apiKey2 && typeof gapi !== "undefined") {
    apiKey2 = gapi.apiKey;
  }
  if (apiKey2 !== void 0 && !url.includes("key=")) {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "key=" + apiKey2;
  }
  return url;
}
function addTeamDrive$1(url) {
  if (url.includes("supportsTeamDrive")) {
    return url;
  } else {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "supportsTeamDrive=true";
  }
}
function mapUrl$3(url) {
  if (url.startsWith("https://www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.startsWith("https://drive.google.com")) {
    return getDriveDownloadURL$2(url);
  } else if (url.includes("//www.broadinstitute.org/igvdata")) {
    return url.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata");
  } else if (url.includes("//igvdata.broadinstitute.org")) {
    return url.replace("//igvdata.broadinstitute.org", "//s3.amazonaws.com/igv.broadinstitute.org");
  } else if (url.includes("//igv.genepattern.org")) {
    return url.replace("//igv.genepattern.org", "//igv-genepattern-org.s3.amazonaws.com");
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo")) {
    return url.replace("ftp://", "https://");
  } else {
    return url;
  }
}
function arrayBufferToString$1(arraybuffer) {
  let plain;
  if (isgzipped$1(arraybuffer)) {
    plain = ungzip_blocks$1(arraybuffer);
  } else {
    plain = new Uint8Array(arraybuffer);
  }
  if ("TextDecoder" in getGlobalObject$1()) {
    return new TextDecoder().decode(plain);
  } else {
    return decodeUTF8$1(plain);
  }
}
function decodeUTF8$1(octets) {
  var string = "";
  var i = 0;
  while (i < octets.length) {
    var octet = octets[i];
    var bytesNeeded = 0;
    var codePoint = 0;
    if (octet <= 127) {
      bytesNeeded = 0;
      codePoint = octet & 255;
    } else if (octet <= 223) {
      bytesNeeded = 1;
      codePoint = octet & 31;
    } else if (octet <= 239) {
      bytesNeeded = 2;
      codePoint = octet & 15;
    } else if (octet <= 244) {
      bytesNeeded = 3;
      codePoint = octet & 7;
    }
    if (octets.length - i - bytesNeeded > 0) {
      var k = 0;
      while (k < bytesNeeded) {
        octet = octets[i + k + 1];
        codePoint = codePoint << 6 | octet & 63;
        k += 1;
      }
    } else {
      codePoint = 65533;
      bytesNeeded = octets.length - i;
    }
    string += String.fromCodePoint(codePoint);
    i += bytesNeeded + 1;
  }
  return string;
}
function getGlobalObject$1() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof global !== "undefined") {
    return global;
  } else {
    return window;
  }
}
function isAmazonV4Signed(url) {
  return url.indexOf("X-Amz-Signature") > -1;
}
const igvxhr$1 = new IGVXhr$1();
var BLACK$1 = 1;
var NIL$1 = {};
NIL$1.color = BLACK$1;
NIL$1.parent = NIL$1;
NIL$1.left = NIL$1;
NIL$1.right = NIL$1;
/*!
 * jQuery JavaScript Library v3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
var arr = [];
var document$1 = window.document;
var getProto = Object.getPrototypeOf;
var slice = arr.slice;
var concat = arr.concat;
var push = arr.push;
var indexOf = arr.indexOf;
var class2type = {};
var toString$3 = class2type.toString;
var hasOwn = class2type.hasOwnProperty;
var fnToString = hasOwn.toString;
var ObjectFunctionString = fnToString.call(Object);
var support = {};
var isFunction = function isFunction2(obj) {
  return typeof obj === "function" && typeof obj.nodeType !== "number";
};
var isWindow = function isWindow2(obj) {
  return obj != null && obj === obj.window;
};
var preservedScriptAttributes = {
  type: true,
  src: true,
  noModule: true
};
function DOMEval(code, doc, node) {
  doc = doc || document$1;
  var i, script = doc.createElement("script");
  script.text = code;
  if (node) {
    for (i in preservedScriptAttributes) {
      if (node[i]) {
        script[i] = node[i];
      }
    }
  }
  doc.head.appendChild(script).parentNode.removeChild(script);
}
function toType(obj) {
  if (obj == null) {
    return obj + "";
  }
  return typeof obj === "object" || typeof obj === "function" ? class2type[toString$3.call(obj)] || "object" : typeof obj;
}
var version$1 = "3.3.1 -ajax,-ajax/jsonp,-ajax/load,-ajax/parseXML,-ajax/script,-ajax/var/location,-ajax/var/nonce,-ajax/var/rquery,-ajax/xhr,-manipulation/_evalUrl,-event/ajax,-effects,-effects/Tween,-effects/animatedSelector", jQuery = function(selector, context) {
  return new jQuery.fn.init(selector, context);
}, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
jQuery.fn = jQuery.prototype = {
  // The current version of jQuery being used
  jquery: version$1,
  constructor: jQuery,
  // The default length of a jQuery object is 0
  length: 0,
  toArray: function() {
    return slice.call(this);
  },
  // Get the Nth element in the matched element set OR
  // Get the whole matched element set as a clean array
  get: function(num) {
    if (num == null) {
      return slice.call(this);
    }
    return num < 0 ? this[num + this.length] : this[num];
  },
  // Take an array of elements and push it onto the stack
  // (returning the new matched element set)
  pushStack: function(elems) {
    var ret = jQuery.merge(this.constructor(), elems);
    ret.prevObject = this;
    return ret;
  },
  // Execute a callback for every element in the matched set.
  each: function(callback) {
    return jQuery.each(this, callback);
  },
  map: function(callback) {
    return this.pushStack(jQuery.map(this, function(elem, i) {
      return callback.call(elem, i, elem);
    }));
  },
  slice: function() {
    return this.pushStack(slice.apply(this, arguments));
  },
  first: function() {
    return this.eq(0);
  },
  last: function() {
    return this.eq(-1);
  },
  eq: function(i) {
    var len2 = this.length, j = +i + (i < 0 ? len2 : 0);
    return this.pushStack(j >= 0 && j < len2 ? [this[j]] : []);
  },
  end: function() {
    return this.prevObject || this.constructor();
  },
  // For internal use only.
  // Behaves like an Array's method, not like a jQuery method.
  push,
  sort: arr.sort,
  splice: arr.splice
};
jQuery.extend = jQuery.fn.extend = function() {
  var options2, name2, src, copy, copyIsArray, clone2, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
  if (typeof target === "boolean") {
    deep = target;
    target = arguments[i] || {};
    i++;
  }
  if (typeof target !== "object" && !isFunction(target)) {
    target = {};
  }
  if (i === length) {
    target = this;
    i--;
  }
  for (; i < length; i++) {
    if ((options2 = arguments[i]) != null) {
      for (name2 in options2) {
        src = target[name2];
        copy = options2[name2];
        if (target === copy) {
          continue;
        }
        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
          if (copyIsArray) {
            copyIsArray = false;
            clone2 = src && Array.isArray(src) ? src : [];
          } else {
            clone2 = src && jQuery.isPlainObject(src) ? src : {};
          }
          target[name2] = jQuery.extend(deep, clone2, copy);
        } else if (copy !== void 0) {
          target[name2] = copy;
        }
      }
    }
  }
  return target;
};
jQuery.extend({
  // Unique for each copy of jQuery on the page
  expando: "jQuery" + (version$1 + Math.random()).replace(/\D/g, ""),
  // Assume jQuery is ready without the ready module
  isReady: true,
  error: function(msg) {
    throw new Error(msg);
  },
  noop: function() {
  },
  isPlainObject: function(obj) {
    var proto, Ctor;
    if (!obj || toString$3.call(obj) !== "[object Object]") {
      return false;
    }
    proto = getProto(obj);
    if (!proto) {
      return true;
    }
    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
  },
  isEmptyObject: function(obj) {
    var name2;
    for (name2 in obj) {
      return false;
    }
    return true;
  },
  // Evaluates a script in a global context
  globalEval: function(code) {
    DOMEval(code);
  },
  each: function(obj, callback) {
    var length, i = 0;
    if (isArrayLike(obj)) {
      length = obj.length;
      for (; i < length; i++) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    } else {
      for (i in obj) {
        if (callback.call(obj[i], i, obj[i]) === false) {
          break;
        }
      }
    }
    return obj;
  },
  // Support: Android <=4.0 only
  trim: function(text2) {
    return text2 == null ? "" : (text2 + "").replace(rtrim, "");
  },
  // results is for internal usage only
  makeArray: function(arr2, results) {
    var ret = results || [];
    if (arr2 != null) {
      if (isArrayLike(Object(arr2))) {
        jQuery.merge(
          ret,
          typeof arr2 === "string" ? [arr2] : arr2
        );
      } else {
        push.call(ret, arr2);
      }
    }
    return ret;
  },
  inArray: function(elem, arr2, i) {
    return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
  },
  // Support: Android <=4.0 only, PhantomJS 1 only
  // push.apply(_, arraylike) throws on ancient WebKit
  merge: function(first, second) {
    var len2 = +second.length, j = 0, i = first.length;
    for (; j < len2; j++) {
      first[i++] = second[j];
    }
    first.length = i;
    return first;
  },
  grep: function(elems, callback, invert) {
    var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
    for (; i < length; i++) {
      callbackInverse = !callback(elems[i], i);
      if (callbackInverse !== callbackExpect) {
        matches.push(elems[i]);
      }
    }
    return matches;
  },
  // arg is for internal usage only
  map: function(elems, callback, arg) {
    var length, value, i = 0, ret = [];
    if (isArrayLike(elems)) {
      length = elems.length;
      for (; i < length; i++) {
        value = callback(elems[i], i, arg);
        if (value != null) {
          ret.push(value);
        }
      }
    } else {
      for (i in elems) {
        value = callback(elems[i], i, arg);
        if (value != null) {
          ret.push(value);
        }
      }
    }
    return concat.apply([], ret);
  },
  // A global GUID counter for objects
  guid: 1,
  // jQuery.support is not used in Core but other projects attach their
  // properties to it so it needs to exist.
  support
});
if (typeof Symbol === "function") {
  jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
}
jQuery.each(
  "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
  function(i, name2) {
    class2type["[object " + name2 + "]"] = name2.toLowerCase();
  }
);
function isArrayLike(obj) {
  var length = !!obj && "length" in obj && obj.length, type = toType(obj);
  if (isFunction(obj) || isWindow(obj)) {
    return false;
  }
  return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
}
var Sizzle = (
  /*!
  * Sizzle CSS Selector Engine v2.3.3
  * https://sizzlejs.com/
  *
  * Copyright jQuery Foundation and other contributors
  * Released under the MIT license
  * http://jquery.org/license
  *
  * Date: 2016-08-08
  */
  (function(window2) {
    var i, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document2, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * /* @__PURE__ */ new Date(), preferredDoc = window2.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }
      return 0;
    }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, push_native = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
      var i2 = 0, len2 = list.length;
      for (; i2 < len2; i2++) {
        if (list[i2] === elem) {
          return i2;
        }
      }
      return -1;
    }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
    `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim2 = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + `*([^\\]'"]*?)` + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
      var high = "0x" + escaped - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
      if (asCodePoint) {
        if (ch === "\0") {
          return "";
        }
        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      }
      return "\\" + ch;
    }, unloadHandler = function() {
      setDocument();
    }, disabledAncestor = addCombinator(
      function(elem) {
        return elem.disabled === true && ("form" in elem || "label" in elem);
      },
      { dir: "parentNode", next: "legend" }
    );
    try {
      push2.apply(
        arr2 = slice2.call(preferredDoc.childNodes),
        preferredDoc.childNodes
      );
      arr2[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push2 = {
        apply: arr2.length ? (
          // Leverage slice if possible
          function(target, els) {
            push_native.apply(target, slice2.call(els));
          }
        ) : (
          // Support: IE<9
          // Otherwise append directly
          function(target, els) {
            var j = target.length, i2 = 0;
            while (target[j++] = els[i2++]) {
            }
            target.length = j - 1;
          }
        )
      };
    }
    function Sizzle2(selector, context, results, seed) {
      var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document2) {
          setDocument(context);
        }
        context = context || document2;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
            if (m = match[1]) {
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push2.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
              push2.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support2.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if (nid = context.getAttribute("id")) {
                nid = nid.replace(rcssescape, fcssescape);
              } else {
                context.setAttribute("id", nid = expando);
              }
              groups = tokenize(selector);
              i2 = groups.length;
              while (i2--) {
                groups[i2] = "#" + nid + " " + toSelector(groups[i2]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push2.apply(
                  results,
                  newContext.querySelectorAll(newSelector)
                );
                return results;
              } catch (qsaError) {
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim2, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key + " "] = value;
      }
      return cache;
    }
    function markFunction(fn2) {
      fn2[expando] = true;
      return fn2;
    }
    function assert2(fn2) {
      var el = document2.createElement("fieldset");
      try {
        return !!fn2(el);
      } catch (e) {
        return false;
      } finally {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        el = null;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name2 = elem.nodeName.toLowerCase();
        return name2 === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name2 = elem.nodeName.toLowerCase();
        return (name2 === "input" || name2 === "button") && elem.type === type;
      };
    }
    function createDisabledPseudo(disabled) {
      return function(elem) {
        if ("form" in elem) {
          if (elem.parentNode && elem.disabled === false) {
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            }
            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
            /* jshint -W018 */
            elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled;
          }
          return elem.disabled === disabled;
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        }
        return false;
      };
    }
    function createPositionalPseudo(fn2) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches2) {
          var j, matchIndexes = fn2([], seed.length, argument), i2 = matchIndexes.length;
          while (i2--) {
            if (seed[j = matchIndexes[i2]]) {
              seed[j] = !(matches2[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support2 = Sizzle2.support = {};
    isXML = Sizzle2.isXML = function(elem) {
      var documentElement2 = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement2 ? documentElement2.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle2.setDocument = function(node) {
      var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document2 || doc.nodeType !== 9 || !doc.documentElement) {
        return document2;
      }
      document2 = doc;
      docElem = document2.documentElement;
      documentIsHTML = !isXML(document2);
      if (preferredDoc !== document2 && (subWindow = document2.defaultView) && subWindow.top !== subWindow) {
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false);
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      }
      support2.attributes = assert2(function(el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      support2.getElementsByTagName = assert2(function(el) {
        el.appendChild(document2.createComment(""));
        return !el.getElementsByTagName("*").length;
      });
      support2.getElementsByClassName = rnative.test(document2.getElementsByClassName);
      support2.getById = assert2(function(el) {
        docElem.appendChild(el).id = expando;
        return !document2.getElementsByName || !document2.getElementsByName(expando).length;
      });
      if (support2.getById) {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node2 && node2.value === attrId;
          };
        };
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node2, i2, elems, elem = context.getElementById(id);
            if (elem) {
              node2 = elem.getAttributeNode("id");
              if (node2 && node2.value === id) {
                return [elem];
              }
              elems = context.getElementsByName(id);
              i2 = 0;
              while (elem = elems[i2++]) {
                node2 = elem.getAttributeNode("id");
                if (node2 && node2.value === id) {
                  return [elem];
                }
              }
            }
            return [];
          }
        };
      }
      Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support2.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while (elem = results[i2++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support2.qsa = rnative.test(document2.querySelectorAll)) {
        assert2(function(el) {
          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + `*(?:''|"")`);
          }
          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert2(function(el) {
          el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
          var input = document2.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D");
          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          docElem.appendChild(el).disabled = true;
          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert2(function(el) {
          support2.disconnectedMatch = matches.call(el, "*");
          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
          // Otherwise we know they are disconnected
          1
        );
        if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
          if (a === document2 || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document2 || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (!aup || !bup) {
          return a === document2 ? -1 : b === document2 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i2] === bp[i2]) {
          i2++;
        }
        return i2 ? (
          // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i2], bp[i2])
        ) : (
          // Otherwise nodes in our document sort first
          ap[i2] === preferredDoc ? -1 : bp[i2] === preferredDoc ? 1 : 0
        );
      };
      return document2;
    };
    Sizzle2.matches = function(expr, elements) {
      return Sizzle2(expr, null, null, elements);
    };
    Sizzle2.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document2) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support2.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle2(expr, document2, null, [elem]).length > 0;
    };
    Sizzle2.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document2) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle2.attr = function(elem, name2) {
      if ((elem.ownerDocument || elem) !== document2) {
        setDocument(elem);
      }
      var fn2 = Expr.attrHandle[name2.toLowerCase()], val = fn2 && hasOwn2.call(Expr.attrHandle, name2.toLowerCase()) ? fn2(elem, name2, !documentIsHTML) : void 0;
      return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name2) : (val = elem.getAttributeNode(name2)) && val.specified ? val.value : null;
    };
    Sizzle2.escape = function(sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };
    Sizzle2.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle2.uniqueSort = function(results) {
      var elem, duplicates = [], j = 0, i2 = 0;
      hasDuplicate = !support2.detectDuplicates;
      sortInput = !support2.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i2++]) {
          if (elem === results[i2]) {
            j = duplicates.push(i2);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle2.getText = function(elem) {
      var node, ret = "", i2 = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        while (node = elem[i2++]) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle2.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": { dir: "parentNode", first: true },
        " ": { dir: "parentNode" },
        "+": { dir: "previousSibling", first: true },
        "~": { dir: "previousSibling" }
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle2.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd");
          } else if (match[3]) {
            Sizzle2.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess, unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
          (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
          (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name2, operator, check) {
          return function(elem) {
            var result = Sizzle2.attr(elem, name2);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
          return first === 1 && last === 0 ? (
            // Shortcut for :nth-*(n)
            function(elem) {
              return !!elem.parentNode;
            }
          ) : function(elem, context, xml2) {
            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml2 && !ofType, diff = false;
            if (parent) {
              if (simple) {
                while (dir2) {
                  node = elem;
                  while (node = node[dir2]) {
                    if (ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir2 = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                (diff = nodeIndex = 0) || start.pop()) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name2 : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args, fn2 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
          if (fn2[expando]) {
            return fn2(argument);
          }
          if (fn2.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
              var idx, matched = fn2(seed, argument), i2 = matched.length;
              while (i2--) {
                idx = indexOf2(seed, matched[i2]);
                seed[idx] = !(matches2[idx] = matched[i2]);
              }
            }) : function(elem) {
              return fn2(elem, 0, args);
            };
          }
          return fn2;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function(selector) {
          var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches2, context, xml2) {
            var elem, unmatched = matcher(seed, null, xml2, []), i2 = seed.length;
            while (i2--) {
              if (elem = unmatched[i2]) {
                seed[i2] = !(matches2[i2] = elem);
              }
            }
          }) : function(elem, context, xml2) {
            input[0] = elem;
            matcher(input, null, xml2, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle2(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text2) {
          text2 = text2.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text2) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle2.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        // Miscellaneous
        "target": function(elem) {
          var hash = window2.location && window2.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document2.activeElement && (!document2.hasFocus || document2.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function(elem) {
          var nodeName2 = elem.nodeName.toLowerCase();
          return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        // Contents
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name2 = elem.nodeName.toLowerCase();
          return name2 === "input" && elem.type === "button" || name2 === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i2 = 0;
          for (; i2 < length; i2 += 2) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i2 = 1;
          for (; i2 < length; i2 += 2) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i2 = argument < 0 ? argument + length : argument;
          for (; --i2 >= 0; ) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i2 = argument < 0 ? argument + length : argument;
          for (; ++i2 < length; ) {
            matchIndexes.push(i2);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in { submit: true, reset: true }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim2, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
        // Cache the tokens
        tokenCache(selector, groups).slice(0)
      );
    };
    function toSelector(tokens) {
      var i2 = 0, len2 = tokens.length, selector = "";
      for (; i2 < len2; i2++) {
        selector += tokens[i2].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
      return combinator.first ? (
        // Check against closest ancestor/preceding element
        function(elem, context, xml2) {
          while (elem = elem[dir2]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml2);
            }
          }
          return false;
        }
      ) : (
        // Check against all ancestor/preceding elements
        function(elem, context, xml2) {
          var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
          if (xml2) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml2)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {});
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir2] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  return newCache[2] = oldCache[2];
                } else {
                  uniqueCache[key] = newCache;
                  if (newCache[2] = matcher(elem, context, xml2)) {
                    return true;
                  }
                }
              }
            }
          }
          return false;
        }
      );
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml2) {
        var i2 = matchers.length;
        while (i2--) {
          if (!matchers[i2](elem, context, xml2)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i2 = 0, len2 = contexts.length;
      for (; i2 < len2; i2++) {
        Sizzle2(selector, contexts[i2], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml2) {
      var elem, newUnmatched = [], i2 = 0, len2 = unmatched.length, mapped = map != null;
      for (; i2 < len2; i2++) {
        if (elem = unmatched[i2]) {
          if (!filter || filter(elem, context, xml2)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i2);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml2) {
        var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml2) : elems, matcherOut = matcher ? (
          // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? (
            // ...intermediate processing is necessary
            []
          ) : (
            // ...otherwise use results directly
            results
          )
        ) : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml2);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml2);
          i2 = temp.length;
          while (i2--) {
            if (elem = temp[i2]) {
              matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i2 = matcherOut.length;
              while (i2--) {
                if (elem = matcherOut[i2]) {
                  temp.push(matcherIn[i2] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml2);
            }
            i2 = matcherOut.length;
            while (i2--) {
              if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(
            matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
          );
          if (postFinder) {
            postFinder(null, results, matcherOut, xml2);
          } else {
            push2.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len2 = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
        return elem === checkContext;
      }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
        return indexOf2(checkContext, elem) > -1;
      }, implicitRelative, true), matchers = [function(elem, context, xml2) {
        var ret = !leadingRelative && (xml2 || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml2) : matchAnyContext(elem, context, xml2));
        checkContext = null;
        return ret;
      }];
      for (; i2 < len2; i2++) {
        if (matcher = Expr.relative[tokens[i2].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
          if (matcher[expando]) {
            j = ++i2;
            for (; j < len2; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(
              i2 > 1 && elementMatcher(matchers),
              i2 > 1 && toSelector(
                // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
              ).replace(rtrim2, "$1"),
              matcher,
              i2 < j && matcherFromTokens(tokens.slice(i2, j)),
              j < len2 && matcherFromTokens(tokens = tokens.slice(j)),
              j < len2 && toSelector(tokens)
            );
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml2, results, outermost) {
        var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len2 = elems.length;
        if (outermost) {
          outermostContext = context === document2 || context || outermost;
        }
        for (; i2 !== len2 && (elem = elems[i2]) != null; i2++) {
          if (byElement && elem) {
            j = 0;
            if (!context && elem.ownerDocument !== document2) {
              setDocument(elem);
              xml2 = !documentIsHTML;
            }
            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document2, xml2)) {
                results.push(elem);
                break;
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
            }
          }
          if (bySet) {
            if (elem = !matcher && elem) {
              matchedCount--;
            }
            if (seed) {
              unmatched.push(elem);
            }
          }
        }
        matchedCount += i2;
        if (bySet && i2 !== matchedCount) {
          j = 0;
          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml2);
          }
          if (seed) {
            if (matchedCount > 0) {
              while (i2--) {
                if (!(unmatched[i2] || setMatched[i2])) {
                  setMatched[i2] = pop.call(results);
                }
              }
            }
            setMatched = condense(setMatched);
          }
          push2.apply(results, setMatched);
          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle2.uniqueSort(results);
          }
        }
        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
        return unmatched;
      };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle2.compile = function(selector, match) {
      var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i2 = match.length;
        while (i2--) {
          cached = matcherFromTokens(match[i2]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle2.select = function(selector, context, results, seed) {
      var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i2--) {
          token = tokens[i2];
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            if (seed = find(
              token.matches[0].replace(runescape, funescape),
              rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
            )) {
              tokens.splice(i2, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push2.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(
        seed,
        context,
        !documentIsHTML,
        results,
        !context || rsibling.test(selector) && testContext(context.parentNode) || context
      );
      return results;
    };
    support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support2.detectDuplicates = !!hasDuplicate;
    setDocument();
    return Sizzle2;
  })(window)
);
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;
var dir = function(elem, dir2, until) {
  var matched = [], truncate = until !== void 0;
  while ((elem = elem[dir2]) && elem.nodeType !== 9) {
    if (elem.nodeType === 1) {
      if (truncate && jQuery(elem).is(until)) {
        break;
      }
      matched.push(elem);
    }
  }
  return matched;
};
var siblings = function(n, elem) {
  var matched = [];
  for (; n; n = n.nextSibling) {
    if (n.nodeType === 1 && n !== elem) {
      matched.push(n);
    }
  }
  return matched;
};
var rneedsContext = jQuery.expr.match.needsContext;
function nodeName(elem, name2) {
  return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
}
var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
function winnow(elements, qualifier, not) {
  if (isFunction(qualifier)) {
    return jQuery.grep(elements, function(elem, i) {
      return !!qualifier.call(elem, i, elem) !== not;
    });
  }
  if (qualifier.nodeType) {
    return jQuery.grep(elements, function(elem) {
      return elem === qualifier !== not;
    });
  }
  if (typeof qualifier !== "string") {
    return jQuery.grep(elements, function(elem) {
      return indexOf.call(qualifier, elem) > -1 !== not;
    });
  }
  return jQuery.filter(qualifier, elements, not);
}
jQuery.filter = function(expr, elems, not) {
  var elem = elems[0];
  if (not) {
    expr = ":not(" + expr + ")";
  }
  if (elems.length === 1 && elem.nodeType === 1) {
    return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
  }
  return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
    return elem2.nodeType === 1;
  }));
};
jQuery.fn.extend({
  find: function(selector) {
    var i, ret, len2 = this.length, self2 = this;
    if (typeof selector !== "string") {
      return this.pushStack(jQuery(selector).filter(function() {
        for (i = 0; i < len2; i++) {
          if (jQuery.contains(self2[i], this)) {
            return true;
          }
        }
      }));
    }
    ret = this.pushStack([]);
    for (i = 0; i < len2; i++) {
      jQuery.find(selector, self2[i], ret);
    }
    return len2 > 1 ? jQuery.uniqueSort(ret) : ret;
  },
  filter: function(selector) {
    return this.pushStack(winnow(this, selector || [], false));
  },
  not: function(selector) {
    return this.pushStack(winnow(this, selector || [], true));
  },
  is: function(selector) {
    return !!winnow(
      this,
      // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
      false
    ).length;
  }
});
var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init$2 = jQuery.fn.init = function(selector, context, root) {
  var match, elem;
  if (!selector) {
    return this;
  }
  root = root || rootjQuery;
  if (typeof selector === "string") {
    if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
      match = [null, selector, null];
    } else {
      match = rquickExpr.exec(selector);
    }
    if (match && (match[1] || !context)) {
      if (match[1]) {
        context = context instanceof jQuery ? context[0] : context;
        jQuery.merge(this, jQuery.parseHTML(
          match[1],
          context && context.nodeType ? context.ownerDocument || context : document$1,
          true
        ));
        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
          for (match in context) {
            if (isFunction(this[match])) {
              this[match](context[match]);
            } else {
              this.attr(match, context[match]);
            }
          }
        }
        return this;
      } else {
        elem = document$1.getElementById(match[2]);
        if (elem) {
          this[0] = elem;
          this.length = 1;
        }
        return this;
      }
    } else if (!context || context.jquery) {
      return (context || root).find(selector);
    } else {
      return this.constructor(context).find(selector);
    }
  } else if (selector.nodeType) {
    this[0] = selector;
    this.length = 1;
    return this;
  } else if (isFunction(selector)) {
    return root.ready !== void 0 ? root.ready(selector) : (
      // Execute immediately if ready is not present
      selector(jQuery)
    );
  }
  return jQuery.makeArray(selector, this);
};
init$2.prototype = jQuery.fn;
rootjQuery = jQuery(document$1);
var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
  children: true,
  contents: true,
  next: true,
  prev: true
};
jQuery.fn.extend({
  has: function(target) {
    var targets = jQuery(target, this), l = targets.length;
    return this.filter(function() {
      var i = 0;
      for (; i < l; i++) {
        if (jQuery.contains(this, targets[i])) {
          return true;
        }
      }
    });
  },
  closest: function(selectors, context) {
    var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
    if (!rneedsContext.test(selectors)) {
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
            // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
          ))) {
            matched.push(cur);
            break;
          }
        }
      }
    }
    return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
  },
  // Determine the position of an element within the set
  index: function(elem) {
    if (!elem) {
      return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    }
    if (typeof elem === "string") {
      return indexOf.call(jQuery(elem), this[0]);
    }
    return indexOf.call(
      this,
      // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem
    );
  },
  add: function(selector, context) {
    return this.pushStack(
      jQuery.uniqueSort(
        jQuery.merge(this.get(), jQuery(selector, context))
      )
    );
  },
  addBack: function(selector) {
    return this.add(
      selector == null ? this.prevObject : this.prevObject.filter(selector)
    );
  }
});
function sibling(cur, dir2) {
  while ((cur = cur[dir2]) && cur.nodeType !== 1) {
  }
  return cur;
}
jQuery.each({
  parent: function(elem) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  },
  parents: function(elem) {
    return dir(elem, "parentNode");
  },
  parentsUntil: function(elem, i, until) {
    return dir(elem, "parentNode", until);
  },
  next: function(elem) {
    return sibling(elem, "nextSibling");
  },
  prev: function(elem) {
    return sibling(elem, "previousSibling");
  },
  nextAll: function(elem) {
    return dir(elem, "nextSibling");
  },
  prevAll: function(elem) {
    return dir(elem, "previousSibling");
  },
  nextUntil: function(elem, i, until) {
    return dir(elem, "nextSibling", until);
  },
  prevUntil: function(elem, i, until) {
    return dir(elem, "previousSibling", until);
  },
  siblings: function(elem) {
    return siblings((elem.parentNode || {}).firstChild, elem);
  },
  children: function(elem) {
    return siblings(elem.firstChild);
  },
  contents: function(elem) {
    if (nodeName(elem, "iframe")) {
      return elem.contentDocument;
    }
    if (nodeName(elem, "template")) {
      elem = elem.content || elem;
    }
    return jQuery.merge([], elem.childNodes);
  }
}, function(name2, fn2) {
  jQuery.fn[name2] = function(until, selector) {
    var matched = jQuery.map(this, fn2, until);
    if (name2.slice(-5) !== "Until") {
      selector = until;
    }
    if (selector && typeof selector === "string") {
      matched = jQuery.filter(selector, matched);
    }
    if (this.length > 1) {
      if (!guaranteedUnique[name2]) {
        jQuery.uniqueSort(matched);
      }
      if (rparentsprev.test(name2)) {
        matched.reverse();
      }
    }
    return this.pushStack(matched);
  };
});
var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
function createOptions(options2) {
  var object = {};
  jQuery.each(options2.match(rnothtmlwhite) || [], function(_, flag) {
    object[flag] = true;
  });
  return object;
}
jQuery.Callbacks = function(options2) {
  options2 = typeof options2 === "string" ? createOptions(options2) : jQuery.extend({}, options2);
  var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
    locked = locked || options2.once;
    fired = firing = true;
    for (; queue.length; firingIndex = -1) {
      memory = queue.shift();
      while (++firingIndex < list.length) {
        if (list[firingIndex].apply(memory[0], memory[1]) === false && options2.stopOnFalse) {
          firingIndex = list.length;
          memory = false;
        }
      }
    }
    if (!options2.memory) {
      memory = false;
    }
    firing = false;
    if (locked) {
      if (memory) {
        list = [];
      } else {
        list = "";
      }
    }
  }, self2 = {
    // Add a callback or a collection of callbacks to the list
    add: function() {
      if (list) {
        if (memory && !firing) {
          firingIndex = list.length - 1;
          queue.push(memory);
        }
        (function add(args) {
          jQuery.each(args, function(_, arg) {
            if (isFunction(arg)) {
              if (!options2.unique || !self2.has(arg)) {
                list.push(arg);
              }
            } else if (arg && arg.length && toType(arg) !== "string") {
              add(arg);
            }
          });
        })(arguments);
        if (memory && !firing) {
          fire();
        }
      }
      return this;
    },
    // Remove a callback from the list
    remove: function() {
      jQuery.each(arguments, function(_, arg) {
        var index2;
        while ((index2 = jQuery.inArray(arg, list, index2)) > -1) {
          list.splice(index2, 1);
          if (index2 <= firingIndex) {
            firingIndex--;
          }
        }
      });
      return this;
    },
    // Check if a given callback is in the list.
    // If no argument is given, return whether or not list has callbacks attached.
    has: function(fn2) {
      return fn2 ? jQuery.inArray(fn2, list) > -1 : list.length > 0;
    },
    // Remove all callbacks from the list
    empty: function() {
      if (list) {
        list = [];
      }
      return this;
    },
    // Disable .fire and .add
    // Abort any current/pending executions
    // Clear all callbacks and values
    disable: function() {
      locked = queue = [];
      list = memory = "";
      return this;
    },
    disabled: function() {
      return !list;
    },
    // Disable .fire
    // Also disable .add unless we have memory (since it would have no effect)
    // Abort any pending executions
    lock: function() {
      locked = queue = [];
      if (!memory && !firing) {
        list = memory = "";
      }
      return this;
    },
    locked: function() {
      return !!locked;
    },
    // Call all callbacks with the given context and arguments
    fireWith: function(context, args) {
      if (!locked) {
        args = args || [];
        args = [context, args.slice ? args.slice() : args];
        queue.push(args);
        if (!firing) {
          fire();
        }
      }
      return this;
    },
    // Call all the callbacks with the given arguments
    fire: function() {
      self2.fireWith(this, arguments);
      return this;
    },
    // To know if the callbacks have already been called at least once
    fired: function() {
      return !!fired;
    }
  };
  return self2;
};
function Identity(v) {
  return v;
}
function Thrower(ex) {
  throw ex;
}
function adoptValue(value, resolve, reject, noValue) {
  var method;
  try {
    if (value && isFunction(method = value.promise)) {
      method.call(value).done(resolve).fail(reject);
    } else if (value && isFunction(method = value.then)) {
      method.call(value, resolve, reject);
    } else {
      resolve.apply(void 0, [value].slice(noValue));
    }
  } catch (value2) {
    reject.apply(void 0, [value2]);
  }
}
jQuery.extend({
  Deferred: function(func) {
    var tuples = [
      // action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      [
        "notify",
        "progress",
        jQuery.Callbacks("memory"),
        jQuery.Callbacks("memory"),
        2
      ],
      [
        "resolve",
        "done",
        jQuery.Callbacks("once memory"),
        jQuery.Callbacks("once memory"),
        0,
        "resolved"
      ],
      [
        "reject",
        "fail",
        jQuery.Callbacks("once memory"),
        jQuery.Callbacks("once memory"),
        1,
        "rejected"
      ]
    ], state = "pending", promise = {
      state: function() {
        return state;
      },
      always: function() {
        deferred.done(arguments).fail(arguments);
        return this;
      },
      "catch": function(fn2) {
        return promise.then(null, fn2);
      },
      // Keep pipe for back-compat
      pipe: function() {
        var fns = arguments;
        return jQuery.Deferred(function(newDefer) {
          jQuery.each(tuples, function(i, tuple) {
            var fn2 = isFunction(fns[tuple[4]]) && fns[tuple[4]];
            deferred[tuple[1]](function() {
              var returned = fn2 && fn2.apply(this, arguments);
              if (returned && isFunction(returned.promise)) {
                returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
              } else {
                newDefer[tuple[0] + "With"](
                  this,
                  fn2 ? [returned] : arguments
                );
              }
            });
          });
          fns = null;
        }).promise();
      },
      then: function(onFulfilled, onRejected, onProgress) {
        var maxDepth = 0;
        function resolve(depth, deferred2, handler, special) {
          return function() {
            var that = this, args = arguments, mightThrow = function() {
              var returned, then;
              if (depth < maxDepth) {
                return;
              }
              returned = handler.apply(that, args);
              if (returned === deferred2.promise()) {
                throw new TypeError("Thenable self-resolution");
              }
              then = returned && // Support: Promises/A+ section 2.3.4
              // https://promisesaplus.com/#point-64
              // Only check objects and functions for thenability
              (typeof returned === "object" || typeof returned === "function") && returned.then;
              if (isFunction(then)) {
                if (special) {
                  then.call(
                    returned,
                    resolve(maxDepth, deferred2, Identity, special),
                    resolve(maxDepth, deferred2, Thrower, special)
                  );
                } else {
                  maxDepth++;
                  then.call(
                    returned,
                    resolve(maxDepth, deferred2, Identity, special),
                    resolve(maxDepth, deferred2, Thrower, special),
                    resolve(
                      maxDepth,
                      deferred2,
                      Identity,
                      deferred2.notifyWith
                    )
                  );
                }
              } else {
                if (handler !== Identity) {
                  that = void 0;
                  args = [returned];
                }
                (special || deferred2.resolveWith)(that, args);
              }
            }, process2 = special ? mightThrow : function() {
              try {
                mightThrow();
              } catch (e) {
                if (jQuery.Deferred.exceptionHook) {
                  jQuery.Deferred.exceptionHook(
                    e,
                    process2.stackTrace
                  );
                }
                if (depth + 1 >= maxDepth) {
                  if (handler !== Thrower) {
                    that = void 0;
                    args = [e];
                  }
                  deferred2.rejectWith(that, args);
                }
              }
            };
            if (depth) {
              process2();
            } else {
              if (jQuery.Deferred.getStackHook) {
                process2.stackTrace = jQuery.Deferred.getStackHook();
              }
              window.setTimeout(process2);
            }
          };
        }
        return jQuery.Deferred(function(newDefer) {
          tuples[0][3].add(
            resolve(
              0,
              newDefer,
              isFunction(onProgress) ? onProgress : Identity,
              newDefer.notifyWith
            )
          );
          tuples[1][3].add(
            resolve(
              0,
              newDefer,
              isFunction(onFulfilled) ? onFulfilled : Identity
            )
          );
          tuples[2][3].add(
            resolve(
              0,
              newDefer,
              isFunction(onRejected) ? onRejected : Thrower
            )
          );
        }).promise();
      },
      // Get a promise for this deferred
      // If obj is provided, the promise aspect is added to the object
      promise: function(obj) {
        return obj != null ? jQuery.extend(obj, promise) : promise;
      }
    }, deferred = {};
    jQuery.each(tuples, function(i, tuple) {
      var list = tuple[2], stateString = tuple[5];
      promise[tuple[1]] = list.add;
      if (stateString) {
        list.add(
          function() {
            state = stateString;
          },
          // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable,
          // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable,
          // progress_callbacks.lock
          tuples[0][2].lock,
          // progress_handlers.lock
          tuples[0][3].lock
        );
      }
      list.add(tuple[3].fire);
      deferred[tuple[0]] = function() {
        deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
        return this;
      };
      deferred[tuple[0] + "With"] = list.fireWith;
    });
    promise.promise(deferred);
    if (func) {
      func.call(deferred, deferred);
    }
    return deferred;
  },
  // Deferred helper
  when: function(singleValue) {
    var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i2) {
      return function(value) {
        resolveContexts[i2] = this;
        resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
        if (!--remaining) {
          master.resolveWith(resolveContexts, resolveValues);
        }
      };
    };
    if (remaining <= 1) {
      adoptValue(
        singleValue,
        master.done(updateFunc(i)).resolve,
        master.reject,
        !remaining
      );
      if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
        return master.then();
      }
    }
    while (i--) {
      adoptValue(resolveValues[i], updateFunc(i), master.reject);
    }
    return master.promise();
  }
});
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
jQuery.Deferred.exceptionHook = function(error, stack) {
  if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
    window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
  }
};
jQuery.readyException = function(error) {
  window.setTimeout(function() {
    throw error;
  });
};
var readyList = jQuery.Deferred();
jQuery.fn.ready = function(fn2) {
  readyList.then(fn2).catch(function(error) {
    jQuery.readyException(error);
  });
  return this;
};
jQuery.extend({
  // Is the DOM ready to be used? Set to true once it occurs.
  isReady: false,
  // A counter to track how many items to wait for before
  // the ready event fires. See #6781
  readyWait: 1,
  // Handle when the DOM is ready
  ready: function(wait) {
    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
      return;
    }
    jQuery.isReady = true;
    if (wait !== true && --jQuery.readyWait > 0) {
      return;
    }
    readyList.resolveWith(document$1, [jQuery]);
  }
});
jQuery.ready.then = readyList.then;
function completed() {
  document$1.removeEventListener("DOMContentLoaded", completed);
  window.removeEventListener("load", completed);
  jQuery.ready();
}
if (document$1.readyState === "complete" || document$1.readyState !== "loading" && !document$1.documentElement.doScroll) {
  window.setTimeout(jQuery.ready);
} else {
  document$1.addEventListener("DOMContentLoaded", completed);
  window.addEventListener("load", completed);
}
var access = function(elems, fn2, key, value, chainable, emptyGet, raw) {
  var i = 0, len2 = elems.length, bulk = key == null;
  if (toType(key) === "object") {
    chainable = true;
    for (i in key) {
      access(elems, fn2, i, key[i], true, emptyGet, raw);
    }
  } else if (value !== void 0) {
    chainable = true;
    if (!isFunction(value)) {
      raw = true;
    }
    if (bulk) {
      if (raw) {
        fn2.call(elems, value);
        fn2 = null;
      } else {
        bulk = fn2;
        fn2 = function(elem, key2, value2) {
          return bulk.call(jQuery(elem), value2);
        };
      }
    }
    if (fn2) {
      for (; i < len2; i++) {
        fn2(
          elems[i],
          key,
          raw ? value : value.call(elems[i], i, fn2(elems[i], key))
        );
      }
    }
  }
  if (chainable) {
    return elems;
  }
  if (bulk) {
    return fn2.call(elems);
  }
  return len2 ? fn2(elems[0], key) : emptyGet;
};
var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
function fcamelCase(all, letter) {
  return letter.toUpperCase();
}
function camelCase(string) {
  return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
}
var acceptData = function(owner) {
  return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
};
function Data() {
  this.expando = jQuery.expando + Data.uid++;
}
Data.uid = 1;
Data.prototype = {
  cache: function(owner) {
    var value = owner[this.expando];
    if (!value) {
      value = {};
      if (acceptData(owner)) {
        if (owner.nodeType) {
          owner[this.expando] = value;
        } else {
          Object.defineProperty(owner, this.expando, {
            value,
            configurable: true
          });
        }
      }
    }
    return value;
  },
  set: function(owner, data, value) {
    var prop, cache = this.cache(owner);
    if (typeof data === "string") {
      cache[camelCase(data)] = value;
    } else {
      for (prop in data) {
        cache[camelCase(prop)] = data[prop];
      }
    }
    return cache;
  },
  get: function(owner, key) {
    return key === void 0 ? this.cache(owner) : (
      // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)]
    );
  },
  access: function(owner, key, value) {
    if (key === void 0 || key && typeof key === "string" && value === void 0) {
      return this.get(owner, key);
    }
    this.set(owner, key, value);
    return value !== void 0 ? value : key;
  },
  remove: function(owner, key) {
    var i, cache = owner[this.expando];
    if (cache === void 0) {
      return;
    }
    if (key !== void 0) {
      if (Array.isArray(key)) {
        key = key.map(camelCase);
      } else {
        key = camelCase(key);
        key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
      }
      i = key.length;
      while (i--) {
        delete cache[key[i]];
      }
    }
    if (key === void 0 || jQuery.isEmptyObject(cache)) {
      if (owner.nodeType) {
        owner[this.expando] = void 0;
      } else {
        delete owner[this.expando];
      }
    }
  },
  hasData: function(owner) {
    var cache = owner[this.expando];
    return cache !== void 0 && !jQuery.isEmptyObject(cache);
  }
};
var dataPriv = new Data();
var dataUser = new Data();
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
function getData(data) {
  if (data === "true") {
    return true;
  }
  if (data === "false") {
    return false;
  }
  if (data === "null") {
    return null;
  }
  if (data === +data + "") {
    return +data;
  }
  if (rbrace.test(data)) {
    return JSON.parse(data);
  }
  return data;
}
function dataAttr(elem, key, data) {
  var name2;
  if (data === void 0 && elem.nodeType === 1) {
    name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
    data = elem.getAttribute(name2);
    if (typeof data === "string") {
      try {
        data = getData(data);
      } catch (e) {
      }
      dataUser.set(elem, key, data);
    } else {
      data = void 0;
    }
  }
  return data;
}
jQuery.extend({
  hasData: function(elem) {
    return dataUser.hasData(elem) || dataPriv.hasData(elem);
  },
  data: function(elem, name2, data) {
    return dataUser.access(elem, name2, data);
  },
  removeData: function(elem, name2) {
    dataUser.remove(elem, name2);
  },
  // TODO: Now that all calls to _data and _removeData have been replaced
  // with direct calls to dataPriv methods, these can be deprecated.
  _data: function(elem, name2, data) {
    return dataPriv.access(elem, name2, data);
  },
  _removeData: function(elem, name2) {
    dataPriv.remove(elem, name2);
  }
});
jQuery.fn.extend({
  data: function(key, value) {
    var i, name2, data, elem = this[0], attrs = elem && elem.attributes;
    if (key === void 0) {
      if (this.length) {
        data = dataUser.get(elem);
        if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
          i = attrs.length;
          while (i--) {
            if (attrs[i]) {
              name2 = attrs[i].name;
              if (name2.indexOf("data-") === 0) {
                name2 = camelCase(name2.slice(5));
                dataAttr(elem, name2, data[name2]);
              }
            }
          }
          dataPriv.set(elem, "hasDataAttrs", true);
        }
      }
      return data;
    }
    if (typeof key === "object") {
      return this.each(function() {
        dataUser.set(this, key);
      });
    }
    return access(this, function(value2) {
      var data2;
      if (elem && value2 === void 0) {
        data2 = dataUser.get(elem, key);
        if (data2 !== void 0) {
          return data2;
        }
        data2 = dataAttr(elem, key);
        if (data2 !== void 0) {
          return data2;
        }
        return;
      }
      this.each(function() {
        dataUser.set(this, key, value2);
      });
    }, null, value, arguments.length > 1, null, true);
  },
  removeData: function(key) {
    return this.each(function() {
      dataUser.remove(this, key);
    });
  }
});
jQuery.extend({
  queue: function(elem, type, data) {
    var queue;
    if (elem) {
      type = (type || "fx") + "queue";
      queue = dataPriv.get(elem, type);
      if (data) {
        if (!queue || Array.isArray(data)) {
          queue = dataPriv.access(elem, type, jQuery.makeArray(data));
        } else {
          queue.push(data);
        }
      }
      return queue || [];
    }
  },
  dequeue: function(elem, type) {
    type = type || "fx";
    var queue = jQuery.queue(elem, type), startLength = queue.length, fn2 = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
      jQuery.dequeue(elem, type);
    };
    if (fn2 === "inprogress") {
      fn2 = queue.shift();
      startLength--;
    }
    if (fn2) {
      if (type === "fx") {
        queue.unshift("inprogress");
      }
      delete hooks.stop;
      fn2.call(elem, next, hooks);
    }
    if (!startLength && hooks) {
      hooks.empty.fire();
    }
  },
  // Not public - generate a queueHooks object, or return the current one
  _queueHooks: function(elem, type) {
    var key = type + "queueHooks";
    return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
      empty: jQuery.Callbacks("once memory").add(function() {
        dataPriv.remove(elem, [type + "queue", key]);
      })
    });
  }
});
jQuery.fn.extend({
  queue: function(type, data) {
    var setter = 2;
    if (typeof type !== "string") {
      data = type;
      type = "fx";
      setter--;
    }
    if (arguments.length < setter) {
      return jQuery.queue(this[0], type);
    }
    return data === void 0 ? this : this.each(function() {
      var queue = jQuery.queue(this, type, data);
      jQuery._queueHooks(this, type);
      if (type === "fx" && queue[0] !== "inprogress") {
        jQuery.dequeue(this, type);
      }
    });
  },
  dequeue: function(type) {
    return this.each(function() {
      jQuery.dequeue(this, type);
    });
  },
  clearQueue: function(type) {
    return this.queue(type || "fx", []);
  },
  // Get a promise resolved when queues of a certain type
  // are emptied (fx is the type by default)
  promise: function(type, obj) {
    var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
      if (!--count) {
        defer.resolveWith(elements, [elements]);
      }
    };
    if (typeof type !== "string") {
      obj = type;
      type = void 0;
    }
    type = type || "fx";
    while (i--) {
      tmp = dataPriv.get(elements[i], type + "queueHooks");
      if (tmp && tmp.empty) {
        count++;
        tmp.empty.add(resolve);
      }
    }
    resolve();
    return defer.promise(obj);
  }
});
var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
var cssExpand = ["Top", "Right", "Bottom", "Left"];
var isHiddenWithinTree = function(elem, el) {
  elem = elem;
  return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
  // Support: Firefox <=43 - 45
  // Disconnected elements can have computed display: none, so first confirm that elem is
  // in the document.
  jQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, "display") === "none";
};
var swap = function(elem, options2, callback, args) {
  var ret, name2, old = {};
  for (name2 in options2) {
    old[name2] = elem.style[name2];
    elem.style[name2] = options2[name2];
  }
  ret = callback.apply(elem, []);
  for (name2 in options2) {
    elem.style[name2] = old[name2];
  }
  return ret;
};
function adjustCSS(elem, prop, valueParts, tween) {
  var adjusted, scale, maxIterations = 20, currentValue = function() {
    return jQuery.css(elem, prop, "");
  }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
  if (initialInUnit && initialInUnit[3] !== unit) {
    initial = initial / 2;
    unit = unit || initialInUnit[3];
    initialInUnit = +initial || 1;
    while (maxIterations--) {
      jQuery.style(elem, prop, initialInUnit + unit);
      if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
        maxIterations = 0;
      }
      initialInUnit = initialInUnit / scale;
    }
    initialInUnit = initialInUnit * 2;
    jQuery.style(elem, prop, initialInUnit + unit);
    valueParts = valueParts || [];
  }
  if (valueParts) {
    initialInUnit = +initialInUnit || +initial || 0;
    adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
  }
  return adjusted;
}
var defaultDisplayMap = {};
function getDefaultDisplay(elem) {
  var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
  if (display) {
    return display;
  }
  temp = doc.body.appendChild(doc.createElement(nodeName2));
  display = jQuery.css(temp, "display");
  temp.parentNode.removeChild(temp);
  if (display === "none") {
    display = "block";
  }
  defaultDisplayMap[nodeName2] = display;
  return display;
}
function showHide(elements, show2) {
  var display, elem, values = [], index2 = 0, length = elements.length;
  for (; index2 < length; index2++) {
    elem = elements[index2];
    if (!elem.style) {
      continue;
    }
    display = elem.style.display;
    if (show2) {
      if (display === "none") {
        values[index2] = dataPriv.get(elem, "display") || null;
        if (!values[index2]) {
          elem.style.display = "";
        }
      }
      if (elem.style.display === "" && isHiddenWithinTree(elem)) {
        values[index2] = getDefaultDisplay(elem);
      }
    } else {
      if (display !== "none") {
        values[index2] = "none";
        dataPriv.set(elem, "display", display);
      }
    }
  }
  for (index2 = 0; index2 < length; index2++) {
    if (values[index2] != null) {
      elements[index2].style.display = values[index2];
    }
  }
  return elements;
}
jQuery.fn.extend({
  show: function() {
    return showHide(this, true);
  },
  hide: function() {
    return showHide(this);
  },
  toggle: function(state) {
    if (typeof state === "boolean") {
      return state ? this.show() : this.hide();
    }
    return this.each(function() {
      if (isHiddenWithinTree(this)) {
        jQuery(this).show();
      } else {
        jQuery(this).hide();
      }
    });
  }
});
var rcheckableType = /^(?:checkbox|radio)$/i;
var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
var wrapMap = {
  // Support: IE <=9 only
  option: [1, "<select multiple='multiple'>", "</select>"],
  // XHTML parsers do not magically insert elements in the
  // same way that tag soup parsers do. So we cannot shorten
  // this by omitting <tbody> or other required elements.
  thead: [1, "<table>", "</table>"],
  col: [2, "<table><colgroup>", "</colgroup></table>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
  _default: [0, "", ""]
};
wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;
function getAll(context, tag) {
  var ret;
  if (typeof context.getElementsByTagName !== "undefined") {
    ret = context.getElementsByTagName(tag || "*");
  } else if (typeof context.querySelectorAll !== "undefined") {
    ret = context.querySelectorAll(tag || "*");
  } else {
    ret = [];
  }
  if (tag === void 0 || tag && nodeName(context, tag)) {
    return jQuery.merge([context], ret);
  }
  return ret;
}
function setGlobalEval(elems, refElements) {
  var i = 0, l = elems.length;
  for (; i < l; i++) {
    dataPriv.set(
      elems[i],
      "globalEval",
      !refElements || dataPriv.get(refElements[i], "globalEval")
    );
  }
}
var rhtml = /<|&#?\w+;/;
function buildFragment(elems, context, scripts, selection, ignored) {
  var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
  for (; i < l; i++) {
    elem = elems[i];
    if (elem || elem === 0) {
      if (toType(elem) === "object") {
        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
      } else if (!rhtml.test(elem)) {
        nodes.push(context.createTextNode(elem));
      } else {
        tmp = tmp || fragment.appendChild(context.createElement("div"));
        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
        wrap = wrapMap[tag] || wrapMap._default;
        tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
        j = wrap[0];
        while (j--) {
          tmp = tmp.lastChild;
        }
        jQuery.merge(nodes, tmp.childNodes);
        tmp = fragment.firstChild;
        tmp.textContent = "";
      }
    }
  }
  fragment.textContent = "";
  i = 0;
  while (elem = nodes[i++]) {
    if (selection && jQuery.inArray(elem, selection) > -1) {
      if (ignored) {
        ignored.push(elem);
      }
      continue;
    }
    contains = jQuery.contains(elem.ownerDocument, elem);
    tmp = getAll(fragment.appendChild(elem), "script");
    if (contains) {
      setGlobalEval(tmp);
    }
    if (scripts) {
      j = 0;
      while (elem = tmp[j++]) {
        if (rscriptType.test(elem.type || "")) {
          scripts.push(elem);
        }
      }
    }
  }
  return fragment;
}
(function() {
  var fragment = document$1.createDocumentFragment(), div2 = fragment.appendChild(document$1.createElement("div")), input = document$1.createElement("input");
  input.setAttribute("type", "radio");
  input.setAttribute("checked", "checked");
  input.setAttribute("name", "t");
  div2.appendChild(input);
  support.checkClone = div2.cloneNode(true).cloneNode(true).lastChild.checked;
  div2.innerHTML = "<textarea>x</textarea>";
  support.noCloneChecked = !!div2.cloneNode(true).lastChild.defaultValue;
})();
var documentElement = document$1.documentElement;
var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
function returnTrue() {
  return true;
}
function returnFalse() {
  return false;
}
function safeActiveElement() {
  try {
    return document$1.activeElement;
  } catch (err2) {
  }
}
function on(elem, types, selector, data, fn2, one) {
  var origFn, type;
  if (typeof types === "object") {
    if (typeof selector !== "string") {
      data = data || selector;
      selector = void 0;
    }
    for (type in types) {
      on(elem, type, selector, data, types[type], one);
    }
    return elem;
  }
  if (data == null && fn2 == null) {
    fn2 = selector;
    data = selector = void 0;
  } else if (fn2 == null) {
    if (typeof selector === "string") {
      fn2 = data;
      data = void 0;
    } else {
      fn2 = data;
      data = selector;
      selector = void 0;
    }
  }
  if (fn2 === false) {
    fn2 = returnFalse;
  } else if (!fn2) {
    return elem;
  }
  if (one === 1) {
    origFn = fn2;
    fn2 = function(event) {
      jQuery().off(event);
      return origFn.apply(this, arguments);
    };
    fn2.guid = origFn.guid || (origFn.guid = jQuery.guid++);
  }
  return elem.each(function() {
    jQuery.event.add(this, types, fn2, data, selector);
  });
}
jQuery.event = {
  global: {},
  add: function(elem, types, handler, data, selector) {
    var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
    if (!elemData) {
      return;
    }
    if (handler.handler) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }
    if (selector) {
      jQuery.find.matchesSelector(documentElement, selector);
    }
    if (!handler.guid) {
      handler.guid = jQuery.guid++;
    }
    if (!(events = elemData.events)) {
      events = elemData.events = {};
    }
    if (!(eventHandle = elemData.handle)) {
      eventHandle = elemData.handle = function(e) {
        return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
      };
    }
    types = (types || "").match(rnothtmlwhite) || [""];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || "").split(".").sort();
      if (!type) {
        continue;
      }
      special = jQuery.event.special[type] || {};
      type = (selector ? special.delegateType : special.bindType) || type;
      special = jQuery.event.special[type] || {};
      handleObj = jQuery.extend({
        type,
        origType,
        data,
        handler,
        guid: handler.guid,
        selector,
        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
        namespace: namespaces.join(".")
      }, handleObjIn);
      if (!(handlers = events[type])) {
        handlers = events[type] = [];
        handlers.delegateCount = 0;
        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
          if (elem.addEventListener) {
            elem.addEventListener(type, eventHandle);
          }
        }
      }
      if (special.add) {
        special.add.call(elem, handleObj);
        if (!handleObj.handler.guid) {
          handleObj.handler.guid = handler.guid;
        }
      }
      if (selector) {
        handlers.splice(handlers.delegateCount++, 0, handleObj);
      } else {
        handlers.push(handleObj);
      }
      jQuery.event.global[type] = true;
    }
  },
  // Detach an event or set of events from an element
  remove: function(elem, types, handler, selector, mappedTypes) {
    var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
    if (!elemData || !(events = elemData.events)) {
      return;
    }
    types = (types || "").match(rnothtmlwhite) || [""];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || "").split(".").sort();
      if (!type) {
        for (type in events) {
          jQuery.event.remove(elem, type + types[t], handler, selector, true);
        }
        continue;
      }
      special = jQuery.event.special[type] || {};
      type = (selector ? special.delegateType : special.bindType) || type;
      handlers = events[type] || [];
      tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
      origCount = j = handlers.length;
      while (j--) {
        handleObj = handlers[j];
        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
          handlers.splice(j, 1);
          if (handleObj.selector) {
            handlers.delegateCount--;
          }
          if (special.remove) {
            special.remove.call(elem, handleObj);
          }
        }
      }
      if (origCount && !handlers.length) {
        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
          jQuery.removeEvent(elem, type, elemData.handle);
        }
        delete events[type];
      }
    }
    if (jQuery.isEmptyObject(events)) {
      dataPriv.remove(elem, "handle events");
    }
  },
  dispatch: function(nativeEvent) {
    var event = jQuery.event.fix(nativeEvent);
    var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
    args[0] = event;
    for (i = 1; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    event.delegateTarget = this;
    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
      return;
    }
    handlerQueue = jQuery.event.handlers.call(this, event, handlers);
    i = 0;
    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
      event.currentTarget = matched.elem;
      j = 0;
      while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
        if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
          event.handleObj = handleObj;
          event.data = handleObj.data;
          ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
          if (ret !== void 0) {
            if ((event.result = ret) === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }
    if (special.postDispatch) {
      special.postDispatch.call(this, event);
    }
    return event.result;
  },
  handlers: function(event, handlers) {
    var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
    if (delegateCount && // Support: IE <=9
    // Black-hole SVG <use> instance trees (trac-13180)
    cur.nodeType && // Support: Firefox <=42
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11 only
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(event.type === "click" && event.button >= 1)) {
      for (; cur !== this; cur = cur.parentNode || this) {
        if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
          matchedHandlers = [];
          matchedSelectors = {};
          for (i = 0; i < delegateCount; i++) {
            handleObj = handlers[i];
            sel = handleObj.selector + " ";
            if (matchedSelectors[sel] === void 0) {
              matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
            }
            if (matchedSelectors[sel]) {
              matchedHandlers.push(handleObj);
            }
          }
          if (matchedHandlers.length) {
            handlerQueue.push({ elem: cur, handlers: matchedHandlers });
          }
        }
      }
    }
    cur = this;
    if (delegateCount < handlers.length) {
      handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
    }
    return handlerQueue;
  },
  addProp: function(name2, hook) {
    Object.defineProperty(jQuery.Event.prototype, name2, {
      enumerable: true,
      configurable: true,
      get: isFunction(hook) ? function() {
        if (this.originalEvent) {
          return hook(this.originalEvent);
        }
      } : function() {
        if (this.originalEvent) {
          return this.originalEvent[name2];
        }
      },
      set: function(value) {
        Object.defineProperty(this, name2, {
          enumerable: true,
          configurable: true,
          writable: true,
          value
        });
      }
    });
  },
  fix: function(originalEvent) {
    return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
  },
  special: {
    load: {
      // Prevent triggered image.load events from bubbling to window.load
      noBubble: true
    },
    focus: {
      // Fire native event if possible so blur/focus sequence is correct
      trigger: function() {
        if (this !== safeActiveElement() && this.focus) {
          this.focus();
          return false;
        }
      },
      delegateType: "focusin"
    },
    blur: {
      trigger: function() {
        if (this === safeActiveElement() && this.blur) {
          this.blur();
          return false;
        }
      },
      delegateType: "focusout"
    },
    click: {
      // For checkbox, fire native event so checked state will be right
      trigger: function() {
        if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
          this.click();
          return false;
        }
      },
      // For cross-browser consistency, don't fire native .click() on links
      _default: function(event) {
        return nodeName(event.target, "a");
      }
    },
    beforeunload: {
      postDispatch: function(event) {
        if (event.result !== void 0 && event.originalEvent) {
          event.originalEvent.returnValue = event.result;
        }
      }
    }
  }
};
jQuery.removeEvent = function(elem, type, handle) {
  if (elem.removeEventListener) {
    elem.removeEventListener(type, handle);
  }
};
jQuery.Event = function(src, props) {
  if (!(this instanceof jQuery.Event)) {
    return new jQuery.Event(src, props);
  }
  if (src && src.type) {
    this.originalEvent = src;
    this.type = src.type;
    this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
    src.returnValue === false ? returnTrue : returnFalse;
    this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
    this.currentTarget = src.currentTarget;
    this.relatedTarget = src.relatedTarget;
  } else {
    this.type = src;
  }
  if (props) {
    jQuery.extend(this, props);
  }
  this.timeStamp = src && src.timeStamp || Date.now();
  this[jQuery.expando] = true;
};
jQuery.Event.prototype = {
  constructor: jQuery.Event,
  isDefaultPrevented: returnFalse,
  isPropagationStopped: returnFalse,
  isImmediatePropagationStopped: returnFalse,
  isSimulated: false,
  preventDefault: function() {
    var e = this.originalEvent;
    this.isDefaultPrevented = returnTrue;
    if (e && !this.isSimulated) {
      e.preventDefault();
    }
  },
  stopPropagation: function() {
    var e = this.originalEvent;
    this.isPropagationStopped = returnTrue;
    if (e && !this.isSimulated) {
      e.stopPropagation();
    }
  },
  stopImmediatePropagation: function() {
    var e = this.originalEvent;
    this.isImmediatePropagationStopped = returnTrue;
    if (e && !this.isSimulated) {
      e.stopImmediatePropagation();
    }
    this.stopPropagation();
  }
};
jQuery.each({
  altKey: true,
  bubbles: true,
  cancelable: true,
  changedTouches: true,
  ctrlKey: true,
  detail: true,
  eventPhase: true,
  metaKey: true,
  pageX: true,
  pageY: true,
  shiftKey: true,
  view: true,
  "char": true,
  charCode: true,
  key: true,
  keyCode: true,
  button: true,
  buttons: true,
  clientX: true,
  clientY: true,
  offsetX: true,
  offsetY: true,
  pointerId: true,
  pointerType: true,
  screenX: true,
  screenY: true,
  targetTouches: true,
  toElement: true,
  touches: true,
  which: function(event) {
    var button = event.button;
    if (event.which == null && rkeyEvent.test(event.type)) {
      return event.charCode != null ? event.charCode : event.keyCode;
    }
    if (!event.which && button !== void 0 && rmouseEvent.test(event.type)) {
      if (button & 1) {
        return 1;
      }
      if (button & 2) {
        return 3;
      }
      if (button & 4) {
        return 2;
      }
      return 0;
    }
    return event.which;
  }
}, jQuery.event.addProp);
jQuery.each({
  mouseenter: "mouseover",
  mouseleave: "mouseout",
  pointerenter: "pointerover",
  pointerleave: "pointerout"
}, function(orig, fix) {
  jQuery.event.special[orig] = {
    delegateType: fix,
    bindType: fix,
    handle: function(event) {
      var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
      if (!related || related !== target && !jQuery.contains(target, related)) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply(this, arguments);
        event.type = fix;
      }
      return ret;
    }
  };
});
jQuery.fn.extend({
  on: function(types, selector, data, fn2) {
    return on(this, types, selector, data, fn2);
  },
  one: function(types, selector, data, fn2) {
    return on(this, types, selector, data, fn2, 1);
  },
  off: function(types, selector, fn2) {
    var handleObj, type;
    if (types && types.preventDefault && types.handleObj) {
      handleObj = types.handleObj;
      jQuery(types.delegateTarget).off(
        handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
        handleObj.selector,
        handleObj.handler
      );
      return this;
    }
    if (typeof types === "object") {
      for (type in types) {
        this.off(type, selector, types[type]);
      }
      return this;
    }
    if (selector === false || typeof selector === "function") {
      fn2 = selector;
      selector = void 0;
    }
    if (fn2 === false) {
      fn2 = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove(this, types, fn2, selector);
    });
  }
});
var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
function manipulationTarget(elem, content) {
  if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
    return jQuery(elem).children("tbody")[0] || elem;
  }
  return elem;
}
function disableScript(elem) {
  elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
  return elem;
}
function restoreScript(elem) {
  if ((elem.type || "").slice(0, 5) === "true/") {
    elem.type = elem.type.slice(5);
  } else {
    elem.removeAttribute("type");
  }
  return elem;
}
function cloneCopyEvent(src, dest) {
  var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
  if (dest.nodeType !== 1) {
    return;
  }
  if (dataPriv.hasData(src)) {
    pdataOld = dataPriv.access(src);
    pdataCur = dataPriv.set(dest, pdataOld);
    events = pdataOld.events;
    if (events) {
      delete pdataCur.handle;
      pdataCur.events = {};
      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    }
  }
  if (dataUser.hasData(src)) {
    udataOld = dataUser.access(src);
    udataCur = jQuery.extend({}, udataOld);
    dataUser.set(dest, udataCur);
  }
}
function fixInput(src, dest) {
  var nodeName2 = dest.nodeName.toLowerCase();
  if (nodeName2 === "input" && rcheckableType.test(src.type)) {
    dest.checked = src.checked;
  } else if (nodeName2 === "input" || nodeName2 === "textarea") {
    dest.defaultValue = src.defaultValue;
  }
}
function domManip(collection, args, callback, ignored) {
  args = concat.apply([], args);
  var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
  if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
    return collection.each(function(index2) {
      var self2 = collection.eq(index2);
      if (valueIsFunction) {
        args[0] = value.call(this, index2, self2.html());
      }
      domManip(self2, args, callback, ignored);
    });
  }
  if (l) {
    fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
    first = fragment.firstChild;
    if (fragment.childNodes.length === 1) {
      fragment = first;
    }
    if (first || ignored) {
      scripts = jQuery.map(getAll(fragment, "script"), disableScript);
      hasScripts = scripts.length;
      for (; i < l; i++) {
        node = fragment;
        if (i !== iNoClone) {
          node = jQuery.clone(node, true, true);
          if (hasScripts) {
            jQuery.merge(scripts, getAll(node, "script"));
          }
        }
        callback.call(collection[i], node, i);
      }
      if (hasScripts) {
        doc = scripts[scripts.length - 1].ownerDocument;
        jQuery.map(scripts, restoreScript);
        for (i = 0; i < hasScripts; i++) {
          node = scripts[i];
          if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
            if (node.src && (node.type || "").toLowerCase() !== "module") {
              if (jQuery._evalUrl) {
                jQuery._evalUrl(node.src);
              }
            } else {
              DOMEval(node.textContent.replace(rcleanScript, ""), doc, node);
            }
          }
        }
      }
    }
  }
  return collection;
}
function remove(elem, selector, keepData) {
  var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
  for (; (node = nodes[i]) != null; i++) {
    if (!keepData && node.nodeType === 1) {
      jQuery.cleanData(getAll(node));
    }
    if (node.parentNode) {
      if (keepData && jQuery.contains(node.ownerDocument, node)) {
        setGlobalEval(getAll(node, "script"));
      }
      node.parentNode.removeChild(node);
    }
  }
  return elem;
}
jQuery.extend({
  htmlPrefilter: function(html2) {
    return html2.replace(rxhtmlTag, "<$1></$2>");
  },
  clone: function(elem, dataAndEvents, deepDataAndEvents) {
    var i, l, srcElements, destElements, clone2 = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
    if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
      destElements = getAll(clone2);
      srcElements = getAll(elem);
      for (i = 0, l = srcElements.length; i < l; i++) {
        fixInput(srcElements[i], destElements[i]);
      }
    }
    if (dataAndEvents) {
      if (deepDataAndEvents) {
        srcElements = srcElements || getAll(elem);
        destElements = destElements || getAll(clone2);
        for (i = 0, l = srcElements.length; i < l; i++) {
          cloneCopyEvent(srcElements[i], destElements[i]);
        }
      } else {
        cloneCopyEvent(elem, clone2);
      }
    }
    destElements = getAll(clone2, "script");
    if (destElements.length > 0) {
      setGlobalEval(destElements, !inPage && getAll(elem, "script"));
    }
    return clone2;
  },
  cleanData: function(elems) {
    var data, elem, type, special = jQuery.event.special, i = 0;
    for (; (elem = elems[i]) !== void 0; i++) {
      if (acceptData(elem)) {
        if (data = elem[dataPriv.expando]) {
          if (data.events) {
            for (type in data.events) {
              if (special[type]) {
                jQuery.event.remove(elem, type);
              } else {
                jQuery.removeEvent(elem, type, data.handle);
              }
            }
          }
          elem[dataPriv.expando] = void 0;
        }
        if (elem[dataUser.expando]) {
          elem[dataUser.expando] = void 0;
        }
      }
    }
  }
});
jQuery.fn.extend({
  detach: function(selector) {
    return remove(this, selector, true);
  },
  remove: function(selector) {
    return remove(this, selector);
  },
  text: function(value) {
    return access(this, function(value2) {
      return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          this.textContent = value2;
        }
      });
    }, null, value, arguments.length);
  },
  append: function() {
    return domManip(this, arguments, function(elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.appendChild(elem);
      }
    });
  },
  prepend: function() {
    return domManip(this, arguments, function(elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.insertBefore(elem, target.firstChild);
      }
    });
  },
  before: function() {
    return domManip(this, arguments, function(elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this);
      }
    });
  },
  after: function() {
    return domManip(this, arguments, function(elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this.nextSibling);
      }
    });
  },
  empty: function() {
    var elem, i = 0;
    for (; (elem = this[i]) != null; i++) {
      if (elem.nodeType === 1) {
        jQuery.cleanData(getAll(elem, false));
        elem.textContent = "";
      }
    }
    return this;
  },
  clone: function(dataAndEvents, deepDataAndEvents) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    return this.map(function() {
      return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
    });
  },
  html: function(value) {
    return access(this, function(value2) {
      var elem = this[0] || {}, i = 0, l = this.length;
      if (value2 === void 0 && elem.nodeType === 1) {
        return elem.innerHTML;
      }
      if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
        value2 = jQuery.htmlPrefilter(value2);
        try {
          for (; i < l; i++) {
            elem = this[i] || {};
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.innerHTML = value2;
            }
          }
          elem = 0;
        } catch (e) {
        }
      }
      if (elem) {
        this.empty().append(value2);
      }
    }, null, value, arguments.length);
  },
  replaceWith: function() {
    var ignored = [];
    return domManip(this, arguments, function(elem) {
      var parent = this.parentNode;
      if (jQuery.inArray(this, ignored) < 0) {
        jQuery.cleanData(getAll(this));
        if (parent) {
          parent.replaceChild(elem, this);
        }
      }
    }, ignored);
  }
});
jQuery.each({
  appendTo: "append",
  prependTo: "prepend",
  insertBefore: "before",
  insertAfter: "after",
  replaceAll: "replaceWith"
}, function(name2, original) {
  jQuery.fn[name2] = function(selector) {
    var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
    for (; i <= last; i++) {
      elems = i === last ? this : this.clone(true);
      jQuery(insert[i])[original](elems);
      push.apply(ret, elems.get());
    }
    return this.pushStack(ret);
  };
});
var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
var getStyles = function(elem) {
  var view = elem.ownerDocument.defaultView;
  if (!view || !view.opener) {
    view = window;
  }
  return view.getComputedStyle(elem);
};
var rboxStyle = new RegExp(cssExpand.join("|"), "i");
(function() {
  function computeStyleTests() {
    if (!div2) {
      return;
    }
    container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
    div2.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
    documentElement.appendChild(container).appendChild(div2);
    var divStyle = window.getComputedStyle(div2);
    pixelPositionVal = divStyle.top !== "1%";
    reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
    div2.style.right = "60%";
    pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
    boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
    div2.style.position = "absolute";
    scrollboxSizeVal = div2.offsetWidth === 36 || "absolute";
    documentElement.removeChild(container);
    div2 = null;
  }
  function roundPixelMeasures(measure) {
    return Math.round(parseFloat(measure));
  }
  var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableMarginLeftVal, container = document$1.createElement("div"), div2 = document$1.createElement("div");
  if (!div2.style) {
    return;
  }
  div2.style.backgroundClip = "content-box";
  div2.cloneNode(true).style.backgroundClip = "";
  support.clearCloneStyle = div2.style.backgroundClip === "content-box";
  jQuery.extend(support, {
    boxSizingReliable: function() {
      computeStyleTests();
      return boxSizingReliableVal;
    },
    pixelBoxStyles: function() {
      computeStyleTests();
      return pixelBoxStylesVal;
    },
    pixelPosition: function() {
      computeStyleTests();
      return pixelPositionVal;
    },
    reliableMarginLeft: function() {
      computeStyleTests();
      return reliableMarginLeftVal;
    },
    scrollboxSize: function() {
      computeStyleTests();
      return scrollboxSizeVal;
    }
  });
})();
function curCSS(elem, name2, computed) {
  var width, minWidth, maxWidth, ret, style = elem.style;
  computed = computed || getStyles(elem);
  if (computed) {
    ret = computed.getPropertyValue(name2) || computed[name2];
    if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name2);
    }
    if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;
      style.minWidth = style.maxWidth = style.width = ret;
      ret = computed.width;
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth;
    }
  }
  return ret !== void 0 ? (
    // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + ""
  ) : ret;
}
function addGetHookIf(conditionFn, hookFn) {
  return {
    get: function() {
      if (conditionFn()) {
        delete this.get;
        return;
      }
      return (this.get = hookFn).apply(this, arguments);
    }
  };
}
var rdisplayswap = /^(none|table(?!-c[ea]).+)/, rcustomProp = /^--/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
  letterSpacing: "0",
  fontWeight: "400"
}, cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document$1.createElement("div").style;
function vendorPropName(name2) {
  if (name2 in emptyStyle) {
    return name2;
  }
  var capName = name2[0].toUpperCase() + name2.slice(1), i = cssPrefixes.length;
  while (i--) {
    name2 = cssPrefixes[i] + capName;
    if (name2 in emptyStyle) {
      return name2;
    }
  }
}
function finalPropName(name2) {
  var ret = jQuery.cssProps[name2];
  if (!ret) {
    ret = jQuery.cssProps[name2] = vendorPropName(name2) || name2;
  }
  return ret;
}
function setPositiveNumber(elem, value, subtract) {
  var matches = rcssNum.exec(value);
  return matches ? (
    // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
  ) : value;
}
function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
  var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
  if (box === (isBorderBox ? "border" : "content")) {
    return 0;
  }
  for (; i < 4; i += 2) {
    if (box === "margin") {
      delta += jQuery.css(elem, box + cssExpand[i], true, styles);
    }
    if (!isBorderBox) {
      delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
      if (box !== "padding") {
        delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
      } else {
        extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
      }
    } else {
      if (box === "content") {
        delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
      }
      if (box !== "margin") {
        delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
      }
    }
  }
  if (!isBorderBox && computedVal >= 0) {
    delta += Math.max(0, Math.ceil(
      elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
    ));
  }
  return delta;
}
function getWidthOrHeight(elem, dimension, extra) {
  var styles = getStyles(elem), val = curCSS(elem, dimension, styles), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox;
  if (rnumnonpx.test(val)) {
    if (!extra) {
      return val;
    }
    val = "auto";
  }
  valueIsBorderBox = valueIsBorderBox && (support.boxSizingReliable() || val === elem.style[dimension]);
  if (val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") {
    val = elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)];
    valueIsBorderBox = true;
  }
  val = parseFloat(val) || 0;
  return val + boxModelAdjustment(
    elem,
    dimension,
    extra || (isBorderBox ? "border" : "content"),
    valueIsBorderBox,
    styles,
    // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val
  ) + "px";
}
jQuery.extend({
  // Add in style property hooks for overriding the default
  // behavior of getting and setting a style property
  cssHooks: {
    opacity: {
      get: function(elem, computed) {
        if (computed) {
          var ret = curCSS(elem, "opacity");
          return ret === "" ? "1" : ret;
        }
      }
    }
  },
  // Don't automatically add "px" to these possibly-unitless properties
  cssNumber: {
    "animationIterationCount": true,
    "columnCount": true,
    "fillOpacity": true,
    "flexGrow": true,
    "flexShrink": true,
    "fontWeight": true,
    "lineHeight": true,
    "opacity": true,
    "order": true,
    "orphans": true,
    "widows": true,
    "zIndex": true,
    "zoom": true
  },
  // Add in properties whose names you wish to fix before
  // setting or getting the value
  cssProps: {},
  // Get and set the style property on a DOM Node
  style: function(elem, name2, value, extra) {
    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
      return;
    }
    var ret, type, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
    if (!isCustomProp) {
      name2 = finalPropName(origName);
    }
    hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
    if (value !== void 0) {
      type = typeof value;
      if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
        value = adjustCSS(elem, name2, ret);
        type = "number";
      }
      if (value == null || value !== value) {
        return;
      }
      if (type === "number") {
        value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
      }
      if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
        style[name2] = "inherit";
      }
      if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
        if (isCustomProp) {
          style.setProperty(name2, value);
        } else {
          style[name2] = value;
        }
      }
    } else {
      if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
        return ret;
      }
      return style[name2];
    }
  },
  css: function(elem, name2, extra, styles) {
    var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
    if (!isCustomProp) {
      name2 = finalPropName(origName);
    }
    hooks = jQuery.cssHooks[name2] || jQuery.cssHooks[origName];
    if (hooks && "get" in hooks) {
      val = hooks.get(elem, true, extra);
    }
    if (val === void 0) {
      val = curCSS(elem, name2, styles);
    }
    if (val === "normal" && name2 in cssNormalTransform) {
      val = cssNormalTransform[name2];
    }
    if (extra === "" || extra) {
      num = parseFloat(val);
      return extra === true || isFinite(num) ? num || 0 : val;
    }
    return val;
  }
});
jQuery.each(["height", "width"], function(i, dimension) {
  jQuery.cssHooks[dimension] = {
    get: function(elem, computed, extra) {
      if (computed) {
        return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
        // Table columns in Safari have non-zero offsetWidth & zero
        // getBoundingClientRect().width unless display is changed.
        // Support: IE <=11 only
        // Running getBoundingClientRect on a disconnected node
        // in IE throws an error.
        (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
          return getWidthOrHeight(elem, dimension, extra);
        }) : getWidthOrHeight(elem, dimension, extra);
      }
    },
    set: function(elem, value, extra) {
      var matches, styles = getStyles(elem), isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra && boxModelAdjustment(
        elem,
        dimension,
        extra,
        isBorderBox,
        styles
      );
      if (isBorderBox && support.scrollboxSize() === styles.position) {
        subtract -= Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
        );
      }
      if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
        elem.style[dimension] = value;
        value = jQuery.css(elem, dimension);
      }
      return setPositiveNumber(elem, value, subtract);
    }
  };
});
jQuery.cssHooks.marginLeft = addGetHookIf(
  support.reliableMarginLeft,
  function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }
);
jQuery.each({
  margin: "",
  padding: "",
  border: "Width"
}, function(prefix, suffix) {
  jQuery.cssHooks[prefix + suffix] = {
    expand: function(value) {
      var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
      for (; i < 4; i++) {
        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
      }
      return expanded;
    }
  };
  if (prefix !== "margin") {
    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
  }
});
jQuery.fn.extend({
  css: function(name2, value) {
    return access(this, function(elem, name3, value2) {
      var styles, len2, map = {}, i = 0;
      if (Array.isArray(name3)) {
        styles = getStyles(elem);
        len2 = name3.length;
        for (; i < len2; i++) {
          map[name3[i]] = jQuery.css(elem, name3[i], false, styles);
        }
        return map;
      }
      return value2 !== void 0 ? jQuery.style(elem, name3, value2) : jQuery.css(elem, name3);
    }, name2, value, arguments.length > 1);
  }
});
jQuery.fn.delay = function(time, type) {
  time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
  type = type || "fx";
  return this.queue(type, function(next, hooks) {
    var timeout = window.setTimeout(next, time);
    hooks.stop = function() {
      window.clearTimeout(timeout);
    };
  });
};
(function() {
  var input = document$1.createElement("input"), select = document$1.createElement("select"), opt = select.appendChild(document$1.createElement("option"));
  input.type = "checkbox";
  support.checkOn = input.value !== "";
  support.optSelected = opt.selected;
  input = document$1.createElement("input");
  input.value = "t";
  input.type = "radio";
  support.radioValue = input.value === "t";
})();
var boolHook, attrHandle = jQuery.expr.attrHandle;
jQuery.fn.extend({
  attr: function(name2, value) {
    return access(this, jQuery.attr, name2, value, arguments.length > 1);
  },
  removeAttr: function(name2) {
    return this.each(function() {
      jQuery.removeAttr(this, name2);
    });
  }
});
jQuery.extend({
  attr: function(elem, name2, value) {
    var ret, hooks, nType = elem.nodeType;
    if (nType === 3 || nType === 8 || nType === 2) {
      return;
    }
    if (typeof elem.getAttribute === "undefined") {
      return jQuery.prop(elem, name2, value);
    }
    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
      hooks = jQuery.attrHooks[name2.toLowerCase()] || (jQuery.expr.match.bool.test(name2) ? boolHook : void 0);
    }
    if (value !== void 0) {
      if (value === null) {
        jQuery.removeAttr(elem, name2);
        return;
      }
      if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
        return ret;
      }
      elem.setAttribute(name2, value + "");
      return value;
    }
    if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
      return ret;
    }
    ret = jQuery.find.attr(elem, name2);
    return ret == null ? void 0 : ret;
  },
  attrHooks: {
    type: {
      set: function(elem, value) {
        if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
          var val = elem.value;
          elem.setAttribute("type", value);
          if (val) {
            elem.value = val;
          }
          return value;
        }
      }
    }
  },
  removeAttr: function(elem, value) {
    var name2, i = 0, attrNames = value && value.match(rnothtmlwhite);
    if (attrNames && elem.nodeType === 1) {
      while (name2 = attrNames[i++]) {
        elem.removeAttribute(name2);
      }
    }
  }
});
boolHook = {
  set: function(elem, value, name2) {
    if (value === false) {
      jQuery.removeAttr(elem, name2);
    } else {
      elem.setAttribute(name2, name2);
    }
    return name2;
  }
};
jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name2) {
  var getter = attrHandle[name2] || jQuery.find.attr;
  attrHandle[name2] = function(elem, name3, isXML) {
    var ret, handle, lowercaseName = name3.toLowerCase();
    if (!isXML) {
      handle = attrHandle[lowercaseName];
      attrHandle[lowercaseName] = ret;
      ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
      attrHandle[lowercaseName] = handle;
    }
    return ret;
  };
});
var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
jQuery.fn.extend({
  prop: function(name2, value) {
    return access(this, jQuery.prop, name2, value, arguments.length > 1);
  },
  removeProp: function(name2) {
    return this.each(function() {
      delete this[jQuery.propFix[name2] || name2];
    });
  }
});
jQuery.extend({
  prop: function(elem, name2, value) {
    var ret, hooks, nType = elem.nodeType;
    if (nType === 3 || nType === 8 || nType === 2) {
      return;
    }
    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
      name2 = jQuery.propFix[name2] || name2;
      hooks = jQuery.propHooks[name2];
    }
    if (value !== void 0) {
      if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
        return ret;
      }
      return elem[name2] = value;
    }
    if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
      return ret;
    }
    return elem[name2];
  },
  propHooks: {
    tabIndex: {
      get: function(elem) {
        var tabindex = jQuery.find.attr(elem, "tabindex");
        if (tabindex) {
          return parseInt(tabindex, 10);
        }
        if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
          return 0;
        }
        return -1;
      }
    }
  },
  propFix: {
    "for": "htmlFor",
    "class": "className"
  }
});
if (!support.optSelected) {
  jQuery.propHooks.selected = {
    get: function(elem) {
      var parent = elem.parentNode;
      if (parent && parent.parentNode) {
        parent.parentNode.selectedIndex;
      }
      return null;
    },
    set: function(elem) {
      var parent = elem.parentNode;
      if (parent) {
        parent.selectedIndex;
        if (parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
      }
    }
  };
}
jQuery.each([
  "tabIndex",
  "readOnly",
  "maxLength",
  "cellSpacing",
  "cellPadding",
  "rowSpan",
  "colSpan",
  "useMap",
  "frameBorder",
  "contentEditable"
], function() {
  jQuery.propFix[this.toLowerCase()] = this;
});
function stripAndCollapse(value) {
  var tokens = value.match(rnothtmlwhite) || [];
  return tokens.join(" ");
}
function getClass(elem) {
  return elem.getAttribute && elem.getAttribute("class") || "";
}
function classesToArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === "string") {
    return value.match(rnothtmlwhite) || [];
  }
  return [];
}
jQuery.fn.extend({
  addClass: function(value) {
    var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
    if (isFunction(value)) {
      return this.each(function(j2) {
        jQuery(this).addClass(value.call(this, j2, getClass(this)));
      });
    }
    classes = classesToArray(value);
    if (classes.length) {
      while (elem = this[i++]) {
        curValue = getClass(elem);
        cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
        if (cur) {
          j = 0;
          while (clazz = classes[j++]) {
            if (cur.indexOf(" " + clazz + " ") < 0) {
              cur += clazz + " ";
            }
          }
          finalValue = stripAndCollapse(cur);
          if (curValue !== finalValue) {
            elem.setAttribute("class", finalValue);
          }
        }
      }
    }
    return this;
  },
  removeClass: function(value) {
    var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
    if (isFunction(value)) {
      return this.each(function(j2) {
        jQuery(this).removeClass(value.call(this, j2, getClass(this)));
      });
    }
    if (!arguments.length) {
      return this.attr("class", "");
    }
    classes = classesToArray(value);
    if (classes.length) {
      while (elem = this[i++]) {
        curValue = getClass(elem);
        cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
        if (cur) {
          j = 0;
          while (clazz = classes[j++]) {
            while (cur.indexOf(" " + clazz + " ") > -1) {
              cur = cur.replace(" " + clazz + " ", " ");
            }
          }
          finalValue = stripAndCollapse(cur);
          if (curValue !== finalValue) {
            elem.setAttribute("class", finalValue);
          }
        }
      }
    }
    return this;
  },
  toggleClass: function(value, stateVal) {
    var type = typeof value, isValidValue = type === "string" || Array.isArray(value);
    if (typeof stateVal === "boolean" && isValidValue) {
      return stateVal ? this.addClass(value) : this.removeClass(value);
    }
    if (isFunction(value)) {
      return this.each(function(i) {
        jQuery(this).toggleClass(
          value.call(this, i, getClass(this), stateVal),
          stateVal
        );
      });
    }
    return this.each(function() {
      var className, i, self2, classNames;
      if (isValidValue) {
        i = 0;
        self2 = jQuery(this);
        classNames = classesToArray(value);
        while (className = classNames[i++]) {
          if (self2.hasClass(className)) {
            self2.removeClass(className);
          } else {
            self2.addClass(className);
          }
        }
      } else if (value === void 0 || type === "boolean") {
        className = getClass(this);
        if (className) {
          dataPriv.set(this, "__className__", className);
        }
        if (this.setAttribute) {
          this.setAttribute(
            "class",
            className || value === false ? "" : dataPriv.get(this, "__className__") || ""
          );
        }
      }
    });
  },
  hasClass: function(selector) {
    var className, elem, i = 0;
    className = " " + selector + " ";
    while (elem = this[i++]) {
      if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
        return true;
      }
    }
    return false;
  }
});
var rreturn = /\r/g;
jQuery.fn.extend({
  val: function(value) {
    var hooks, ret, valueIsFunction, elem = this[0];
    if (!arguments.length) {
      if (elem) {
        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
        if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
          return ret;
        }
        ret = elem.value;
        if (typeof ret === "string") {
          return ret.replace(rreturn, "");
        }
        return ret == null ? "" : ret;
      }
      return;
    }
    valueIsFunction = isFunction(value);
    return this.each(function(i) {
      var val;
      if (this.nodeType !== 1) {
        return;
      }
      if (valueIsFunction) {
        val = value.call(this, i, jQuery(this).val());
      } else {
        val = value;
      }
      if (val == null) {
        val = "";
      } else if (typeof val === "number") {
        val += "";
      } else if (Array.isArray(val)) {
        val = jQuery.map(val, function(value2) {
          return value2 == null ? "" : value2 + "";
        });
      }
      hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
      if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
        this.value = val;
      }
    });
  }
});
jQuery.extend({
  valHooks: {
    option: {
      get: function(elem) {
        var val = jQuery.find.attr(elem, "value");
        return val != null ? val : (
          // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem))
        );
      }
    },
    select: {
      get: function(elem) {
        var value, option, i, options2 = elem.options, index2 = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index2 + 1 : options2.length;
        if (index2 < 0) {
          i = max;
        } else {
          i = one ? index2 : 0;
        }
        for (; i < max; i++) {
          option = options2[i];
          if ((option.selected || i === index2) && // Don't return options that are disabled or in a disabled optgroup
          !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
            value = jQuery(option).val();
            if (one) {
              return value;
            }
            values.push(value);
          }
        }
        return values;
      },
      set: function(elem, value) {
        var optionSet, option, options2 = elem.options, values = jQuery.makeArray(value), i = options2.length;
        while (i--) {
          option = options2[i];
          if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
            optionSet = true;
          }
        }
        if (!optionSet) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  }
});
jQuery.each(["radio", "checkbox"], function() {
  jQuery.valHooks[this] = {
    set: function(elem, value) {
      if (Array.isArray(value)) {
        return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
      }
    }
  };
  if (!support.checkOn) {
    jQuery.valHooks[this].get = function(elem) {
      return elem.getAttribute("value") === null ? "on" : elem.value;
    };
  }
});
support.focusin = "onfocusin" in window;
var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
  e.stopPropagation();
};
jQuery.extend(jQuery.event, {
  trigger: function(event, data, elem, onlyHandlers) {
    var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document$1], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
    cur = lastElement = tmp = elem = elem || document$1;
    if (elem.nodeType === 3 || elem.nodeType === 8) {
      return;
    }
    if (rfocusMorph.test(type + jQuery.event.triggered)) {
      return;
    }
    if (type.indexOf(".") > -1) {
      namespaces = type.split(".");
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf(":") < 0 && "on" + type;
    event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join(".");
    event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
    event.result = void 0;
    if (!event.target) {
      event.target = elem;
    }
    data = data == null ? [event] : jQuery.makeArray(data, [event]);
    special = jQuery.event.special[type] || {};
    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
      return;
    }
    if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
      bubbleType = special.delegateType || type;
      if (!rfocusMorph.test(bubbleType + type)) {
        cur = cur.parentNode;
      }
      for (; cur; cur = cur.parentNode) {
        eventPath.push(cur);
        tmp = cur;
      }
      if (tmp === (elem.ownerDocument || document$1)) {
        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
      }
    }
    i = 0;
    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
      lastElement = cur;
      event.type = i > 1 ? bubbleType : special.bindType || type;
      handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
      if (handle) {
        handle.apply(cur, data);
      }
      handle = ontype && cur[ontype];
      if (handle && handle.apply && acceptData(cur)) {
        event.result = handle.apply(cur, data);
        if (event.result === false) {
          event.preventDefault();
        }
      }
    }
    event.type = type;
    if (!onlyHandlers && !event.isDefaultPrevented()) {
      if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
        if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
          tmp = elem[ontype];
          if (tmp) {
            elem[ontype] = null;
          }
          jQuery.event.triggered = type;
          if (event.isPropagationStopped()) {
            lastElement.addEventListener(type, stopPropagationCallback);
          }
          elem[type]();
          if (event.isPropagationStopped()) {
            lastElement.removeEventListener(type, stopPropagationCallback);
          }
          jQuery.event.triggered = void 0;
          if (tmp) {
            elem[ontype] = tmp;
          }
        }
      }
    }
    return event.result;
  },
  // Piggyback on a donor event to simulate a different one
  // Used only for `focus(in | out)` events
  simulate: function(type, elem, event) {
    var e = jQuery.extend(
      new jQuery.Event(),
      event,
      {
        type,
        isSimulated: true
      }
    );
    jQuery.event.trigger(e, null, elem);
  }
});
jQuery.fn.extend({
  trigger: function(type, data) {
    return this.each(function() {
      jQuery.event.trigger(type, data, this);
    });
  },
  triggerHandler: function(type, data) {
    var elem = this[0];
    if (elem) {
      return jQuery.event.trigger(type, data, elem, true);
    }
  }
});
if (!support.focusin) {
  jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
    var handler = function(event) {
      jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
    };
    jQuery.event.special[fix] = {
      setup: function() {
        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
        if (!attaches) {
          doc.addEventListener(orig, handler, true);
        }
        dataPriv.access(doc, fix, (attaches || 0) + 1);
      },
      teardown: function() {
        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
        if (!attaches) {
          doc.removeEventListener(orig, handler, true);
          dataPriv.remove(doc, fix);
        } else {
          dataPriv.access(doc, fix, attaches);
        }
      }
    };
  });
}
var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
function buildParams(prefix, obj, traditional, add) {
  var name2;
  if (Array.isArray(obj)) {
    jQuery.each(obj, function(i, v) {
      if (traditional || rbracket.test(prefix)) {
        add(prefix, v);
      } else {
        buildParams(
          prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
          v,
          traditional,
          add
        );
      }
    });
  } else if (!traditional && toType(obj) === "object") {
    for (name2 in obj) {
      buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add);
    }
  } else {
    add(prefix, obj);
  }
}
jQuery.param = function(a, traditional) {
  var prefix, s = [], add = function(key, valueOrFunction) {
    var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
  };
  if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
    jQuery.each(a, function() {
      add(this.name, this.value);
    });
  } else {
    for (prefix in a) {
      buildParams(prefix, a[prefix], traditional, add);
    }
  }
  return s.join("&");
};
jQuery.fn.extend({
  serialize: function() {
    return jQuery.param(this.serializeArray());
  },
  serializeArray: function() {
    return this.map(function() {
      var elements = jQuery.prop(this, "elements");
      return elements ? jQuery.makeArray(elements) : this;
    }).filter(function() {
      var type = this.type;
      return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
    }).map(function(i, elem) {
      var val = jQuery(this).val();
      if (val == null) {
        return null;
      }
      if (Array.isArray(val)) {
        return jQuery.map(val, function(val2) {
          return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
        });
      }
      return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
    }).get();
  }
});
jQuery.fn.extend({
  wrapAll: function(html2) {
    var wrap;
    if (this[0]) {
      if (isFunction(html2)) {
        html2 = html2.call(this[0]);
      }
      wrap = jQuery(html2, this[0].ownerDocument).eq(0).clone(true);
      if (this[0].parentNode) {
        wrap.insertBefore(this[0]);
      }
      wrap.map(function() {
        var elem = this;
        while (elem.firstElementChild) {
          elem = elem.firstElementChild;
        }
        return elem;
      }).append(this);
    }
    return this;
  },
  wrapInner: function(html2) {
    if (isFunction(html2)) {
      return this.each(function(i) {
        jQuery(this).wrapInner(html2.call(this, i));
      });
    }
    return this.each(function() {
      var self2 = jQuery(this), contents = self2.contents();
      if (contents.length) {
        contents.wrapAll(html2);
      } else {
        self2.append(html2);
      }
    });
  },
  wrap: function(html2) {
    var htmlIsFunction = isFunction(html2);
    return this.each(function(i) {
      jQuery(this).wrapAll(htmlIsFunction ? html2.call(this, i) : html2);
    });
  },
  unwrap: function(selector) {
    this.parent(selector).not("body").each(function() {
      jQuery(this).replaceWith(this.childNodes);
    });
    return this;
  }
});
jQuery.expr.pseudos.hidden = function(elem) {
  return !jQuery.expr.pseudos.visible(elem);
};
jQuery.expr.pseudos.visible = function(elem) {
  return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
};
support.createHTMLDocument = (function() {
  var body = document$1.implementation.createHTMLDocument("").body;
  body.innerHTML = "<form></form><form></form>";
  return body.childNodes.length === 2;
})();
jQuery.parseHTML = function(data, context, keepScripts) {
  if (typeof data !== "string") {
    return [];
  }
  if (typeof context === "boolean") {
    keepScripts = context;
    context = false;
  }
  var base, parsed, scripts;
  if (!context) {
    if (support.createHTMLDocument) {
      context = document$1.implementation.createHTMLDocument("");
      base = context.createElement("base");
      base.href = document$1.location.href;
      context.head.appendChild(base);
    } else {
      context = document$1;
    }
  }
  parsed = rsingleTag.exec(data);
  scripts = !keepScripts && [];
  if (parsed) {
    return [context.createElement(parsed[1])];
  }
  parsed = buildFragment([data], context, scripts);
  if (scripts && scripts.length) {
    jQuery(scripts).remove();
  }
  return jQuery.merge([], parsed.childNodes);
};
jQuery.offset = {
  setOffset: function(elem, options2, i) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
    if (position === "static") {
      elem.style.position = "relative";
    }
    curOffset = curElem.offset();
    curCSSTop = jQuery.css(elem, "top");
    curCSSLeft = jQuery.css(elem, "left");
    calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
    if (calculatePosition) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;
    } else {
      curTop = parseFloat(curCSSTop) || 0;
      curLeft = parseFloat(curCSSLeft) || 0;
    }
    if (isFunction(options2)) {
      options2 = options2.call(elem, i, jQuery.extend({}, curOffset));
    }
    if (options2.top != null) {
      props.top = options2.top - curOffset.top + curTop;
    }
    if (options2.left != null) {
      props.left = options2.left - curOffset.left + curLeft;
    }
    if ("using" in options2) {
      options2.using.call(elem, props);
    } else {
      curElem.css(props);
    }
  }
};
jQuery.fn.extend({
  // offset() relates an element's border box to the document origin
  offset: function(options2) {
    if (arguments.length) {
      return options2 === void 0 ? this : this.each(function(i) {
        jQuery.offset.setOffset(this, options2, i);
      });
    }
    var rect, win, elem = this[0];
    if (!elem) {
      return;
    }
    if (!elem.getClientRects().length) {
      return { top: 0, left: 0 };
    }
    rect = elem.getBoundingClientRect();
    win = elem.ownerDocument.defaultView;
    return {
      top: rect.top + win.pageYOffset,
      left: rect.left + win.pageXOffset
    };
  },
  // position() relates an element's margin box to its offset parent's padding box
  // This corresponds to the behavior of CSS absolute positioning
  position: function() {
    if (!this[0]) {
      return;
    }
    var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
    if (jQuery.css(elem, "position") === "fixed") {
      offset2 = elem.getBoundingClientRect();
    } else {
      offset2 = this.offset();
      doc = elem.ownerDocument;
      offsetParent = elem.offsetParent || doc.documentElement;
      while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
        offsetParent = offsetParent.parentNode;
      }
      if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
        parentOffset = jQuery(offsetParent).offset();
        parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
      }
    }
    return {
      top: offset2.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
      left: offset2.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
    };
  },
  // This method will return documentElement in the following cases:
  // 1) For the element inside the iframe without offsetParent, this method will return
  //    documentElement of the parent window
  // 2) For the hidden or detached element
  // 3) For body or html element, i.e. in case of the html node - it will return itself
  //
  // but those exceptions were never presented as a real life use-cases
  // and might be considered as more preferable results.
  //
  // This logic, however, is not guaranteed and can change at any point in the future
  offsetParent: function() {
    return this.map(function() {
      var offsetParent = this.offsetParent;
      while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || documentElement;
    });
  }
});
jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
  var top = "pageYOffset" === prop;
  jQuery.fn[method] = function(val) {
    return access(this, function(elem, method2, val2) {
      var win;
      if (isWindow(elem)) {
        win = elem;
      } else if (elem.nodeType === 9) {
        win = elem.defaultView;
      }
      if (val2 === void 0) {
        return win ? win[prop] : elem[method2];
      }
      if (win) {
        win.scrollTo(
          !top ? val2 : win.pageXOffset,
          top ? val2 : win.pageYOffset
        );
      } else {
        elem[method2] = val2;
      }
    }, method, val, arguments.length);
  };
});
jQuery.each(["top", "left"], function(i, prop) {
  jQuery.cssHooks[prop] = addGetHookIf(
    support.pixelPosition,
    function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    }
  );
});
jQuery.each({ Height: "height", Width: "width" }, function(name2, type) {
  jQuery.each(
    { padding: "inner" + name2, content: type, "": "outer" + name2 },
    function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type2, value2) {
          var doc;
          if (isWindow(elem)) {
            return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(
              elem.body["scroll" + name2],
              doc["scroll" + name2],
              elem.body["offset" + name2],
              doc["offset" + name2],
              doc["client" + name2]
            );
          }
          return value2 === void 0 ? (
            // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type2, extra)
          ) : (
            // Set width or height on the element
            jQuery.style(elem, type2, value2, extra)
          );
        }, type, chainable ? margin : void 0, chainable);
      };
    }
  );
});
jQuery.each(
  "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
  function(i, name2) {
    jQuery.fn[name2] = function(data, fn2) {
      return arguments.length > 0 ? this.on(name2, null, data, fn2) : this.trigger(name2);
    };
  }
);
jQuery.fn.extend({
  hover: function(fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }
});
jQuery.fn.extend({
  bind: function(types, data, fn2) {
    return this.on(types, null, data, fn2);
  },
  unbind: function(types, fn2) {
    return this.off(types, null, fn2);
  },
  delegate: function(selector, types, data, fn2) {
    return this.on(types, selector, data, fn2);
  },
  undelegate: function(selector, types, fn2) {
    return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn2);
  }
});
jQuery.proxy = function(fn2, context) {
  var tmp, args, proxy;
  if (typeof context === "string") {
    tmp = fn2[context];
    context = fn2;
    fn2 = tmp;
  }
  if (!isFunction(fn2)) {
    return void 0;
  }
  args = slice.call(arguments, 2);
  proxy = function() {
    return fn2.apply(context || this, args.concat(slice.call(arguments)));
  };
  proxy.guid = fn2.guid = fn2.guid || jQuery.guid++;
  return proxy;
};
jQuery.holdReady = function(hold) {
  if (hold) {
    jQuery.readyWait++;
  } else {
    jQuery.ready(true);
  }
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;
jQuery.now = Date.now;
jQuery.isNumeric = function(obj) {
  var type = jQuery.type(obj);
  return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
  // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
  // subtraction forces infinities to NaN
  !isNaN(obj - parseFloat(obj));
};
const $$1 = jQuery;
function div$1(options2) {
  return create$1("div", options2);
}
function create$1(tag, options2) {
  const elem = document.createElement(tag);
  if (options2) {
    if (options2.class) {
      elem.classList.add(options2.class);
    }
    if (options2.id) {
      elem.id = options2.id;
    }
    if (options2.style) {
      applyStyle$1(elem, options2.style);
    }
  }
  return elem;
}
function hide$1(elem) {
  const cssStyle = getComputedStyle(elem);
  if (cssStyle.display !== "none") {
    elem._initialDisplay = cssStyle.display;
  }
  elem.style.display = "none";
}
function show$1(elem) {
  const currentDisplay = getComputedStyle(elem).display;
  if (currentDisplay === "none") {
    const d = elem._initialDisplay || "block";
    elem.style.display = d;
  }
}
function hideAll$1(selector) {
  document.querySelectorAll(selector).forEach((elem) => {
    hide$1(elem);
  });
}
function empty$1(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function offset$1(elem) {
  if (!elem.getClientRects().length) {
    return { top: 0, left: 0 };
  }
  const rect = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect.top + win.pageYOffset,
    left: rect.left + win.pageXOffset
  };
}
function pageCoordinates$1(e) {
  if (e.type.startsWith("touch")) {
    const touch = e.touches[0];
    return { x: touch.pageX, y: touch.pageY };
  } else {
    return { x: e.pageX, y: e.pageY };
  }
}
const relativeDOMBBox$1 = (parentElement, childElement) => {
  const { x: x_p, y: y_p, width: width_p, height: height_p } = parentElement.getBoundingClientRect();
  const { x: x_c, y: y_c, width: width_c, height: height_c } = childElement.getBoundingClientRect();
  return { x: x_c - x_p, y: y_c - y_p, width: width_c, height: height_c };
};
function applyStyle$1(elem, style) {
  for (let key of Object.keys(style)) {
    elem.style[key] = style[key];
  }
}
function guid$2() {
  return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
}
let getMouseXY$1 = (domElement, { clientX, clientY }) => {
  const { left, top, width, height } = domElement.getBoundingClientRect();
  const x = clientX - left;
  const y = clientY - top;
  return { x, y, xNormalized: x / width, yNormalized: y / height, width, height };
};
function translateMouseCoordinates$1(event, domElement) {
  const { clientX, clientY } = event;
  return getMouseXY$1(domElement, { clientX, clientY });
}
var domUtils$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  applyStyle: applyStyle$1,
  create: create$1,
  div: div$1,
  empty: empty$1,
  guid: guid$2,
  hide: hide$1,
  hideAll: hideAll$1,
  offset: offset$1,
  pageCoordinates: pageCoordinates$1,
  relativeDOMBBox: relativeDOMBBox$1,
  show: show$1,
  translateMouseCoordinates: translateMouseCoordinates$1
});
/*! @license DOMPurify 3.0.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.5/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create$2
} = Object;
let {
  apply,
  construct
} = typeof Reflect !== "undefined" && Reflect;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array, transformCaseFunc) {
  var _transformCaseFunc;
  transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === "string") {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone(object) {
  const newObject = create$2(null);
  for (const [property, value] of entries(object)) {
    newObject[property] = value;
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
const text = freeze(["#text"]);
const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
const IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME
});
const getGlobal = () => typeof window === "undefined" ? null : window;
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  let suffix = null;
  const ATTR_NAME = "data-tt-policy-suffix";
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html2) {
        return html2;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const DOMPurify = (root) => createDOMPurify(root);
  DOMPurify.version = "3.0.5";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  const originalDocument = window2.document;
  const currentScript = originalDocument.currentScript;
  let {
    document: document2
  } = window2;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node: Node2,
    Element,
    NodeFilter,
    NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser: DOMParser2,
    trustedTypes
  } = window2;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  const getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    const template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = "";
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document2;
  const {
    importNode
  } = originalDocument;
  let hooks = {};
  DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: MUSTACHE_EXPR2,
    ERB_EXPR: ERB_EXPR2,
    TMPLIT_EXPR: TMPLIT_EXPR2,
    DATA_ATTR: DATA_ATTR2,
    ARIA_ATTR: ARIA_ATTR2,
    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
    ATTR_WHITESPACE: ATTR_WHITESPACE2
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  let FORBID_TAGS = null;
  let FORBID_ATTR = null;
  let ALLOW_ARIA_ATTR = true;
  let ALLOW_DATA_ATTR = true;
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  let SAFE_FOR_TEMPLATES = false;
  let WHOLE_DOCUMENT = false;
  let SET_CONFIG = false;
  let FORCE_BODY = false;
  let RETURN_DOM = false;
  let RETURN_DOM_FRAGMENT = false;
  let RETURN_TRUSTED_TYPE = false;
  let SANITIZE_DOM = true;
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  let KEEP_CONTENT = true;
  let IN_PLACE = false;
  let USE_PROFILES = {};
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let PARSER_MEDIA_TYPE;
  const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  let transformCaseFunc;
  let CONFIG = null;
  const formElement = document2.createElement("form");
  const isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  const _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || typeof cfg !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = "ALLOWED_NAMESPACES" in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone(DEFAULT_URI_SAFE_ATTRIBUTES),
      // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone(DEFAULT_DATA_URI_TAGS),
      // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS,
      // eslint-disable-line indent
      transformCaseFunc
      // eslint-disable-line indent
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [...text]);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      emptyHTML = trustedTypesPolicy.createHTML("");
    } else {
      if (trustedTypesPolicy === void 0) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
        emptyHTML = trustedTypesPolicy.createHTML("");
      }
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  const HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  const ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  const ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  const _checkValidNamespace = function _checkValidNamespace2(element) {
    let parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: "template"
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    return false;
  };
  const _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      node.remove();
    }
  };
  const _removeAttribute = function _removeAttribute2(name2, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name2),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name2, "");
        } catch (_) {
        }
      }
    }
  };
  const _initDocument = function _initDocument2(dirty) {
    let doc;
    let leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  const _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(
      root.ownerDocument || root,
      root,
      // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  const _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function" || typeof elm.hasChildNodes !== "function");
  };
  const _isNode = function _isNode2(object) {
    return typeof Node2 === "object" ? object instanceof Node2 : object && typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  const _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], (hook) => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  const _sanitizeElements = function _sanitizeElements2(currentNode) {
    let content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    const tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR2, " ");
      content = stringReplace(content, ERB_EXPR2, " ");
      content = stringReplace(content, TMPLIT_EXPR2, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
        // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
      ) ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
    else if (value) {
      return false;
    } else ;
    return true;
  };
  const _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    let attr;
    let value;
    let lcName;
    let l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    const {
      attributes
    } = currentNode;
    if (!attributes) {
      return;
    }
    const hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      const {
        name: name2,
        namespaceURI
      } = attr;
      value = name2 === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name2);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR2, " ");
        value = stringReplace(value, ERB_EXPR2, " ");
        value = stringReplace(value, TMPLIT_EXPR2, " ");
      }
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI) ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML": {
              value = trustedTypesPolicy.createHTML(value);
              break;
            }
            case "TrustedScriptURL": {
              value = trustedTypesPolicy.createScriptURL(value);
              break;
            }
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    let shadowNode;
    const shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let body;
    let importedNode;
    let currentNode;
    let returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString === "function") {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      } else {
        throw typeErrorCreate("toString is not a function");
      }
    }
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    const nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
    }
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR2, " ");
      serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR2, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
function createCheckbox$1(name2, initialState) {
  const container = div$1({ class: "igv-ui-trackgear-popover-check-container" });
  const svg2 = iconMarkup$2("check", true === initialState ? "#444" : "transparent");
  svg2.style.borderColor = "gray";
  svg2.style.borderWidth = "1px";
  svg2.style.borderStyle = "solid";
  container.appendChild(svg2);
  let label = div$1();
  label.textContent = name2;
  container.appendChild(label);
  return container;
}
function createIcon$2(name2, color) {
  return iconMarkup$2(name2, color);
}
function iconMarkup$2(name2, color) {
  color = color || "currentColor";
  let icon = icons$2[name2];
  if (!icon) {
    console.error(`No icon named: ${name2}`);
    icon = icons$2["question"];
  }
  const svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg2.setAttributeNS(null, "viewBox", "0 0 " + icon[0] + " " + icon[1]);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttributeNS(null, "fill", color);
  path.setAttributeNS(null, "d", icon[4]);
  svg2.appendChild(path);
  return svg2;
}
const icons$2 = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
};
var icons$1$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createCheckbox: createCheckbox$1,
  createIcon: createIcon$2
});
function attachDialogCloseHandlerWithParent$1(parent, closeHandler) {
  var container = document.createElement("div");
  parent.appendChild(container);
  container.appendChild(createIcon$2("times"));
  container.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    closeHandler();
  });
}
var uiUtils$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  attachDialogCloseHandlerWithParent: attachDialogCloseHandlerWithParent$1
});
let dragData$1;
function makeDraggable$1(target, handle, constraint) {
  handle.addEventListener("mousedown", dragStart.bind(target));
  function dragStart(event) {
    event.stopPropagation();
    event.preventDefault();
    const dragFunction = drag$1.bind(this);
    const dragEndFunction = dragEnd$1.bind(this);
    const computedStyle = getComputedStyle(this);
    dragData$1 = {
      constraint,
      dragFunction,
      dragEndFunction,
      screenX: event.screenX,
      screenY: event.screenY,
      top: parseInt(computedStyle.top.replace("px", "")),
      left: parseInt(computedStyle.left.replace("px", ""))
    };
    document.addEventListener("mousemove", dragFunction);
    document.addEventListener("mouseup", dragEndFunction);
    document.addEventListener("mouseleave", dragEndFunction);
    document.addEventListener("mouseexit", dragEndFunction);
  }
}
function drag$1(event) {
  if (!dragData$1) {
    console.error("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dx = event.screenX - dragData$1.screenX;
  const dy = event.screenY - dragData$1.screenY;
  const left = dragData$1.left + dx;
  const top = dragData$1.constraint ? Math.max(dragData$1.constraint.minY, dragData$1.top + dy) : dragData$1.top + dy;
  this.style.left = `${left}px`;
  this.style.top = `${top}px`;
}
function dragEnd$1(event) {
  if (!dragData$1) {
    console.error("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dragFunction = dragData$1.dragFunction;
  const dragEndFunction = dragData$1.dragEndFunction;
  document.removeEventListener("mousemove", dragFunction);
  document.removeEventListener("mouseup", dragEndFunction);
  document.removeEventListener("mouseleave", dragEndFunction);
  document.removeEventListener("mouseexit", dragEndFunction);
  dragData$1 = void 0;
}
const httpMessages$1 = {
  "401": "Access unauthorized",
  "403": "Access forbidden",
  "404": "Not found"
};
let AlertDialog$1 = class AlertDialog {
  /**
   * Initialize a new alert dialog
   * @param parent
   * @param alertProps - Optional - properties such as scroll to error
   */
  constructor(parent, alertProps) {
    this.alertProps = Object.assign({
      /** When an alert is presented - focus occur */
      shouldFocus: true,
      /** When focus occur - scroll into that element in the view */
      preventScroll: false
    }, alertProps);
    this.container = div$1({ class: "igv-ui-alert-dialog-container" });
    parent.appendChild(this.container);
    this.container.setAttribute("tabIndex", "-1");
    const header = div$1();
    this.container.appendChild(header);
    this.errorHeadline = div$1();
    header.appendChild(this.errorHeadline);
    this.errorHeadline.textContent = "";
    let bodyContainer = div$1({ class: "igv-ui-alert-dialog-body" });
    this.container.appendChild(bodyContainer);
    this.body = div$1({ class: "igv-ui-alert-dialog-body-copy" });
    bodyContainer.appendChild(this.body);
    let ok_container = div$1();
    this.container.appendChild(ok_container);
    this.ok = div$1();
    ok_container.appendChild(this.ok);
    this.ok.textContent = "OK";
    const okHandler = () => {
      if (typeof this.callback === "function") {
        this.callback("OK");
        this.callback = void 0;
      }
      this.body.innerHTML = "";
      hide$1(this.container);
    };
    this.ok.addEventListener("click", (event) => {
      event.stopPropagation();
      okHandler();
    });
    this.container.addEventListener("keypress", (event) => {
      event.stopPropagation();
      if ("Enter" === event.key) {
        okHandler();
      }
    });
    makeDraggable$1(this.container, header);
    hide$1(this.container);
  }
  present(alert2, callback) {
    this.errorHeadline.textContent = alert2.message ? "ERROR" : "";
    let string = alert2.message || alert2;
    if (httpMessages$1.hasOwnProperty(string)) {
      string = httpMessages$1[string];
    }
    const clean = purify.sanitize(string);
    this.body.innerHTML = clean;
    this.callback = callback;
    show$1(this.container);
    if (this.alertProps.shouldFocus) {
      this.container.focus(
        { preventScroll: this.alertProps.preventScroll }
      );
    }
  }
};
let InputDialog$1 = class InputDialog {
  constructor(parent) {
    this.parent = parent;
    this.container = div$1({ class: "igv-ui-generic-dialog-container" });
    parent.appendChild(this.container);
    const header = div$1({ class: "igv-ui-generic-dialog-header" });
    this.container.appendChild(header);
    this.label = div$1({ class: "igv-ui-generic-dialog-one-liner" });
    this.container.appendChild(this.label);
    this.label.text = "Unlabeled";
    this.input_container = div$1({ class: "igv-ui-generic-dialog-input" });
    this.container.appendChild(this.input_container);
    this.input = document.createElement("input");
    this.input_container.appendChild(this.input);
    const buttons = div$1({ class: "igv-ui-generic-dialog-ok-cancel" });
    this.container.appendChild(buttons);
    this.ok = div$1();
    buttons.appendChild(this.ok);
    this.ok.textContent = "OK";
    this.cancel = div$1();
    buttons.appendChild(this.cancel);
    this.cancel.textContent = "Cancel";
    hide$1(this.container);
    this.input.addEventListener("keyup", (e) => {
      if (13 === e.keyCode) {
        if (typeof this.callback === "function") {
          this.callback(this.input.value);
          this.callback = void 0;
        }
        this.input.value = void 0;
        hide$1(this.container);
      }
    });
    this.ok.addEventListener("click", () => {
      if (typeof this.callback === "function") {
        this.callback(this.input.value);
        this.callback = void 0;
      }
      this.input.value = void 0;
      hide$1(this.container);
    });
    const cancel = () => {
      this.input.value = "";
      hide$1(this.container);
    };
    this.cancel.addEventListener("click", cancel);
    attachDialogCloseHandlerWithParent$1(header, cancel);
    makeDraggable$1(this.container, header);
  }
  get value() {
    return purify.sanitize(this.input.value);
  }
  present(options2, e) {
    this.label.textContent = options2.label;
    this.input.value = options2.value;
    this.callback = options2.callback || options2.click;
    show$1(this.container);
    this.clampLocation(e.clientX, e.clientY);
  }
  clampLocation(clientX, clientY) {
    const { width: w, height: h } = this.container.getBoundingClientRect();
    const wh = window.innerHeight;
    const ww = window.innerWidth;
    const y = Math.min(wh - h, clientY);
    const x = Math.min(ww - w, clientX);
    this.container.style.left = `${x}px`;
    this.container.style.top = `${y}px`;
  }
};
const appleCrayonPalette$1 = {
  licorice: "#000000",
  lead: "#1e1e1e",
  tungsten: "#3a3a3a",
  iron: "#545453",
  steel: "#6e6e6e",
  tin: "#878687",
  nickel: "#888787",
  aluminum: "#a09fa0",
  magnesium: "#b8b8b8",
  silver: "#d0d0d0",
  mercury: "#e8e8e8",
  snow: "#ffffff",
  //
  cayenne: "#891100",
  mocha: "#894800",
  aspargus: "#888501",
  fern: "#458401",
  clover: "#028401",
  moss: "#018448",
  teal: "#008688",
  ocean: "#004a88",
  midnight: "#001888",
  eggplant: "#491a88",
  plum: "#891e88",
  maroon: "#891648",
  //
  maraschino: "#ff2101",
  tangerine: "#ff8802",
  lemon: "#fffa03",
  lime: "#83f902",
  spring: "#05f802",
  seam_foam: "#03f987",
  turquoise: "#00fdff",
  aqua: "#008cff",
  blueberry: "#002eff",
  grape: "#8931ff",
  magenta: "#ff39ff",
  strawberry: "#ff2987",
  //
  salmon: "#ff726e",
  cantaloupe: "#ffce6e",
  banana: "#fffb6d",
  honeydew: "#cefa6e",
  flora: "#68f96e",
  spindrift: "#68fbd0",
  ice: "#68fdff",
  sky: "#6acfff",
  orchid: "#6e76ff",
  lavender: "#d278ff",
  bubblegum: "#ff7aff",
  carnation: "#ff7fd3"
};
let GenericContainer$1 = class GenericContainer {
  constructor({ parent, top, left, width, height, border, closeHandler }) {
    let container = div$1({ class: "igv-ui-generic-container" });
    parent.appendChild(container);
    hide$1(container);
    this.container = container;
    if (top !== void 0) {
      this.container.style.top = `${top}px`;
    }
    if (left !== void 0) {
      this.container.style.left = `${left}px`;
    }
    if (width !== void 0) {
      this.container.style.width = `${width}px`;
    }
    if (height !== void 0) {
      this.container.style.height = `${height}px`;
    }
    if (border) {
      this.container.style.border = border;
    }
    const header = div$1();
    this.container.appendChild(header);
    attachDialogCloseHandlerWithParent$1(header, (e) => {
      hide$1(this.container);
      if (typeof closeHandler === "function") {
        closeHandler(e);
      }
    });
    makeDraggable$1(this.container, header);
  }
  show() {
    show$1(this.container);
  }
  hide() {
    hide$1(this.container);
  }
  dispose() {
    if (this.container.parent) {
      this.container.parent.removeChild(this.container);
    }
  }
};
let ColorPicker$1 = class ColorPicker extends GenericContainer$1 {
  constructor({ parent, top, left, width, height, defaultColors, colorHandler }) {
    super({ parent, top, left, width, height, border: "1px solid gray" });
    createColorSwatchSelector$1(this.container, colorHandler, defaultColors);
  }
};
const createColorSwatchSelector$1 = (container, colorHandler, defaultColors) => {
  const hexColorStrings = Object.values(appleCrayonPalette$1);
  for (let hexColorString of hexColorStrings) {
    const swatch = div$1({ class: "igv-ui-color-swatch" });
    container.appendChild(swatch);
    decorateSwatch$1(swatch, hexColorString, colorHandler);
  }
  if (defaultColors) {
    for (let hexColorString of defaultColors) {
      const swatch = div$1({ class: "igv-ui-color-swatch" });
      container.appendChild(swatch);
      decorateSwatch$1(swatch, hexColorString, colorHandler);
    }
  }
};
const decorateSwatch$1 = (swatch, hexColorString, colorHandler) => {
  swatch.style.backgroundColor = hexColorString;
  swatch.addEventListener("mouseenter", (e) => swatch.style.borderColor = hexColorString);
  swatch.addEventListener("mouseleave", (e) => swatch.style.borderColor = "white");
  swatch.addEventListener("click", (event) => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });
  swatch.addEventListener("touchend", (event) => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });
};
class Popover {
  constructor(parent, title) {
    this.parent = parent;
    this.popover = div$1({ class: "igv-ui-popover" });
    parent.appendChild(this.popover);
    const popoverHeader = div$1();
    this.popover.appendChild(popoverHeader);
    const titleElement = div$1();
    popoverHeader.appendChild(titleElement);
    if (title) {
      titleElement.textContent = title;
    }
    attachDialogCloseHandlerWithParent$1(popoverHeader, () => this.hide());
    makeDraggable$1(this.popover, popoverHeader);
    this.popoverContent = div$1();
    this.popover.appendChild(this.popoverContent);
    this.popover.style.display = "none";
  }
  presentContentWithEvent(e, content) {
    this.popover.style.display = "block";
    this.popoverContent.innerHTML = content;
    present$1(e, this.popover, this.popoverContent);
  }
  presentMenu(e, menuItems) {
    if (0 === menuItems.length) {
      return;
    }
    this.popover.style.display = "block";
    const menuElements = createMenuElements$1(menuItems, this.popover);
    for (let item of menuElements) {
      this.popoverContent.appendChild(item.object);
    }
    present$1(e, this.popover, this.popoverContent);
  }
  hide() {
    this.popover.style.display = "none";
    this.dispose();
  }
  dispose() {
    if (this.popover) {
      this.popover.parentNode.removeChild(this.popover);
    }
    const keys = Object.keys(this);
    for (let key of keys) {
      this[key] = void 0;
    }
  }
}
function present$1(e, popover, popoverContent) {
  const { x, y, width } = translateMouseCoordinates$1(e, popover.parentNode);
  popover.style.top = `${y}px`;
  const { width: w } = popover.getBoundingClientRect();
  const xmax = x + w;
  const delta = xmax - width;
  popover.style.left = `${xmax > width ? x - delta : x}px`;
  popoverContent.style.maxWidth = `${Math.min(w, width)}px`;
}
function createMenuElements$1(itemList, popover) {
  const list = itemList.map(function(item, i) {
    let elem;
    if (typeof item === "string") {
      elem = div$1();
      elem.innerHTML = item;
    } else if (typeof item === "Node") {
      elem = item;
    } else {
      if (typeof item.init === "function") {
        item.init();
      }
      if ("checkbox" === item.type) {
        elem = createCheckbox$1("Show all bases", item.value);
      } else if ("color" === item.type) {
        const colorPicker = new ColorPicker$1({
          parent: popover.parentElement,
          width: 364,
          //defaultColor: 'aqua',
          colorHandler: (color) => item.click(color)
        });
        elem = div$1();
        if (typeof item.label === "string") {
          elem.innerHTML = item.label;
        }
        const clickHandler = (e) => {
          colorPicker.show();
          hide$1(popover);
          e.preventDefault();
          e.stopPropagation();
        };
        elem.addEventListener("click", clickHandler);
        elem.addEventListener("touchend", clickHandler);
        elem.addEventListener("mouseup", function(e) {
          e.preventDefault();
          e.stopPropagation();
        });
      } else {
        elem = div$1();
        if (typeof item.label === "string") {
          elem.innerHTML = item.label;
        }
      }
      if (item.click && "color" !== item.type) {
        let handleClick = function(e) {
          item.click();
          hide$1(popover);
          e.preventDefault();
          e.stopPropagation();
        };
        elem.addEventListener("click", handleClick);
        elem.addEventListener("touchend", handleClick);
        elem.addEventListener("mouseup", function(e) {
          e.preventDefault();
          e.stopPropagation();
        });
      }
    }
    return { object: elem, init: item.init };
  });
  return list;
}
class GenericColorPicker extends GenericContainer$1 {
  constructor({ parent, width }) {
    super({ parent, width, border: "1px solid gray" });
  }
  configure(defaultColors, colorHandlers) {
    this.colorHandlers = colorHandlers;
    this.setActiveColorHandler("color");
    this.createSwatches(defaultColors);
  }
  setActiveColorHandler(option) {
    this.activeColorHandler = this.colorHandlers[option];
  }
  createSwatches(defaultColors) {
    this.container.querySelectorAll(".igv-ui-color-swatch").forEach((swatch) => swatch.remove());
    const hexColorStrings = Object.values(appleCrayonPalette$1);
    for (let hexColorString of hexColorStrings) {
      const swatch = div$1({ class: "igv-ui-color-swatch" });
      this.container.appendChild(swatch);
      this.decorateSwatch(swatch, hexColorString);
    }
    if (defaultColors) {
      for (let hexColorString of defaultColors) {
        const swatch = div$1({ class: "igv-ui-color-swatch" });
        this.container.appendChild(swatch);
        this.decorateSwatch(swatch, hexColorString);
      }
    }
  }
  decorateSwatch(swatch, hexColorString) {
    swatch.style.backgroundColor = hexColorString;
    swatch.addEventListener("mouseenter", () => swatch.style.borderColor = hexColorString);
    swatch.addEventListener("mouseleave", () => swatch.style.borderColor = "white");
    swatch.addEventListener("click", (event) => {
      event.stopPropagation();
      this.activeColorHandler(hexColorString);
    });
    swatch.addEventListener("touchend", (event) => {
      event.stopPropagation();
      this.activeColorHandler(hexColorString);
    });
  }
}
function embedCSS$2() {
  const style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("title", "igv-ui.css");
  style.innerHTML = `.igv-ui-popover {
  cursor: default;
  position: absolute;
  z-index: 2048;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: 1px;
  font-family: "Open Sans", sans-serif;
  font-size: small;
  background-color: white;
}
.igv-ui-popover > div:first-child {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-popover > div:first-child > div:first-child {
  margin-left: 4px;
}
.igv-ui-popover > div:first-child > div:last-child {
  margin-right: 4px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-popover > div:first-child > div:last-child:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-popover > div:last-child {
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 400px;
  max-width: 800px;
  background-color: white;
}
.igv-ui-popover > div:last-child > div {
  user-select: all;
  margin-left: 4px;
  margin-right: 4px;
  min-width: 220px;
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.igv-ui-popover > div:last-child > div > span {
  font-weight: bolder;
}
.igv-ui-popover > div:last-child hr {
  width: 100%;
}

.igv-ui-alert-dialog-container {
  box-sizing: content-box;
  position: absolute;
  z-index: 2048;
  top: 50%;
  left: 50%;
  width: 400px;
  height: 200px;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  outline: none;
  font-family: "Open Sans", sans-serif;
  font-size: 15px;
  font-weight: 400;
  background-color: white;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: space-between;
  align-items: center;
}
.igv-ui-alert-dialog-container > div:first-child {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-alert-dialog-container > div:first-child div:first-child {
  padding-left: 8px;
}
.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body {
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  color: #373737;
  width: 100%;
  height: calc(100% - 24px - 64px);
  overflow-y: scroll;
}
.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body .igv-ui-alert-dialog-body-copy {
  margin: 16px;
  width: auto;
  height: auto;
  overflow-wrap: break-word;
  word-break: break-word;
  background-color: white;
  border: unset;
}
.igv-ui-alert-dialog-container > div:last-child {
  width: 100%;
  margin-bottom: 10px;
  background-color: white;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: center;
  align-items: center;
}
.igv-ui-alert-dialog-container > div:last-child div {
  margin: unset;
  width: 40px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: small;
  font-weight: 400;
  border-color: #2B81AF;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-alert-dialog-container > div:last-child div:hover {
  cursor: pointer;
  border-color: #25597f;
  background-color: #25597f;
}

.igv-ui-color-swatch {
  position: relative;
  box-sizing: content-box;
  display: flex;
  flex-flow: row;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  width: 32px;
  height: 32px;
  border-style: solid;
  border-width: 2px;
  border-color: white;
  border-radius: 4px;
}

.igv-ui-color-swatch:hover {
  border-color: dimgray;
}

.igv-ui-colorpicker-menu-close-button {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 32px;
  margin-top: 4px;
  margin-bottom: 4px;
  padding-right: 8px;
}
.igv-ui-colorpicker-menu-close-button i.fa {
  display: block;
  margin-left: 4px;
  margin-right: 4px;
  color: #5f5f5f;
}
.igv-ui-colorpicker-menu-close-button i.fa:hover,
.igv-ui-colorpicker-menu-close-button i.fa:focus,
.igv-ui-colorpicker-menu-close-button i.fa:active {
  cursor: pointer;
  color: #0f0f0f;
}

.igv-ui-generic-dialog-container {
  box-sizing: content-box;
  position: fixed;
  top: 0;
  left: 0;
  width: 300px;
  height: 200px;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  z-index: 2048;
  background-color: white;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div {
  margin-right: 4px;
  margin-bottom: 2px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-one-liner {
  color: #373737;
  width: 95%;
  height: 24px;
  line-height: 24px;
  text-align: left;
  margin-top: 8px;
  padding-left: 8px;
  overflow-wrap: break-word;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input {
  margin-top: 8px;
  width: 95%;
  height: 24px;
  color: #373737;
  line-height: 24px;
  padding-left: 8px;
  background-color: white;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input div {
  width: 30%;
  height: 100%;
  font-size: 16px;
  text-align: right;
  padding-right: 8px;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {
  display: block;
  height: 100%;
  width: 100%;
  padding-left: 4px;
  font-family: "Open Sans", sans-serif;
  font-weight: 400;
  color: #373737;
  text-align: left;
  outline: none;
  border-style: solid;
  border-width: thin;
  border-color: #7F7F7F;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {
  width: 50%;
  font-size: 16px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input {
  margin-top: 8px;
  width: calc(100% - 16px);
  height: 24px;
  color: #373737;
  line-height: 24px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {
  display: block;
  height: 100%;
  width: 100%;
  padding-left: 4px;
  font-family: "Open Sans", sans-serif;
  font-weight: 400;
  color: #373737;
  text-align: left;
  outline: none;
  border-style: solid;
  border-width: thin;
  border-color: #7F7F7F;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {
  font-size: 16px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel {
  width: 100%;
  height: 28px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div {
  margin-top: 32px;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: 14px;
  font-weight: 400;
  width: 75px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  border-color: transparent;
  border-style: solid;
  border-width: thin;
  border-radius: 2px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child {
  margin-left: 32px;
  margin-right: 0;
  background-color: #5ea4e0;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child {
  margin-left: 0;
  margin-right: 32px;
  background-color: #c4c4c4;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child:hover {
  cursor: pointer;
  background-color: #3b5c7f;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child:hover {
  cursor: pointer;
  background-color: #7f7f7f;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok {
  width: 100%;
  height: 36px;
  margin-top: 32px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div {
  width: 98px;
  height: 36px;
  line-height: 36px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  border-color: white;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div:hover {
  cursor: pointer;
  background-color: #25597f;
}

.igv-ui-generic-container {
  box-sizing: content-box;
  position: absolute;
  z-index: 2048;
  background-color: white;
  cursor: pointer;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-container > div:first-child {
  cursor: move;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  height: 24px;
  width: 100%;
  background-color: #dddddd;
}
.igv-ui-generic-container > div:first-child > div {
  display: block;
  color: #5f5f5f;
  cursor: pointer;
  width: 14px;
  height: 14px;
  margin-right: 8px;
  margin-bottom: 4px;
}

.igv-ui-dialog {
  z-index: 2048;
  position: fixed;
  width: fit-content;
  height: fit-content;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: flex-start;
  background-color: white;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
}
.igv-ui-dialog .igv-ui-dialog-header {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-dialog .igv-ui-dialog-header div {
  margin-right: 4px;
  margin-bottom: 2px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-dialog .igv-ui-dialog-header div:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-dialog .igv-ui-dialog-one-liner {
  width: 95%;
  height: 24px;
  line-height: 24px;
  text-align: left;
  margin: 8px;
  overflow-wrap: break-word;
  background-color: white;
  font-weight: bold;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel {
  width: 100%;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div {
  margin: 16px;
  margin-top: 32px;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: 14px;
  font-weight: 400;
  width: 75px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  border-color: transparent;
  border-style: solid;
  border-width: thin;
  border-radius: 2px;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child {
  background-color: #5ea4e0;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child {
  background-color: #c4c4c4;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child:hover {
  cursor: pointer;
  background-color: #3b5c7f;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child:hover {
  cursor: pointer;
  background-color: #7f7f7f;
}
.igv-ui-dialog .igv-ui-dialog-ok {
  width: 100%;
  height: 36px;
  margin-top: 32px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-dialog .igv-ui-dialog-ok div {
  width: 98px;
  height: 36px;
  line-height: 36px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  border-color: white;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-dialog .igv-ui-dialog-ok div:hover {
  cursor: pointer;
  background-color: #25597f;
}

.igv-ui-panel, .igv-ui-panel-row, .igv-ui-panel-column {
  z-index: 2048;
  background-color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
}

.igv-ui-panel-column {
  display: flex;
  flex-direction: column;
}

.igv-ui-panel-row {
  display: flex;
  flex-direction: row;
}

.igv-ui-textbox {
  background-color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
}

.igv-ui-table {
  background-color: white;
}

.igv-ui-table thead {
  position: sticky;
  top: 0;
}

.igv-ui-table th {
  text-align: left;
}

.igv-ui-table td {
  padding-right: 20px;
}

.igv-ui-table tr:hover {
  background-color: lightblue;
}

/*# sourceMappingURL=igv-ui.css.map */
`;
  document.head.append(style);
}
if (typeof document !== "undefined") {
  let stylesheetExists = function(stylesheetName) {
    for (let ss of document.styleSheets) {
      ss = ss.href ? ss.href.replace(/^.*[\\\/]/, "") : "";
      if (ss === stylesheetName) {
        return true;
      }
    }
    return false;
  };
  if (!stylesheetExists("igv-ui.css")) {
    embedCSS$2();
  }
}
function createCheckbox$2(name2, initialState) {
  const container = domUtils$1.div({ class: "igv-menu-popup-check-container" });
  const div2 = domUtils$1.div();
  container.appendChild(div2);
  const svg2 = icons$1$1.createIcon("check", true === initialState ? "#444" : "transparent");
  div2.appendChild(svg2);
  const label = domUtils$1.div();
  label.innerText = name2;
  container.appendChild(label);
  return container;
}
const MenuUtils$1 = {
  trackMenuItemList: function(trackView) {
    const vizWindowTypes = /* @__PURE__ */ new Set(["alignment", "annotation", "variant", "eqtl", "snp"]);
    const hasVizWindow = trackView.track.config && trackView.track.config.visibilityWindow !== void 0;
    let menuItems = [];
    if (trackView.track.config.type !== "sequence") {
      menuItems.push(trackRenameMenuItem$1(trackView));
      menuItems.push(trackHeightMenuItem(trackView));
    }
    if (this.showColorPicker(trackView.track)) {
      menuItems.push("<hr/>");
      menuItems.push(colorPickerMenuItem$1({ trackView, label: "Set track color", option: "color" }));
      menuItems.push(unsetColorMenuItem$1({ trackView, label: "Unset track color" }));
      if (trackView.track.config.type === "wig" || trackView.track.config.type === "annotation") {
        menuItems.push(colorPickerMenuItem$1({ trackView, label: "Set alt color", option: "altColor" }));
        menuItems.push(unsetAltColorMenuItem({ trackView, label: "Unset alt color" }));
      }
    }
    if (trackView.track.menuItemList) {
      menuItems = menuItems.concat(trackView.track.menuItemList());
    }
    if (hasVizWindow || vizWindowTypes.has(trackView.track.type)) {
      menuItems.push("<hr/>");
      menuItems.push(visibilityWindowMenuItem(trackView));
    }
    if (trackView.track.removable !== false) {
      menuItems.push("<hr/>");
      menuItems.push(trackRemovalMenuItem$1(trackView));
    }
    return menuItems;
  },
  numericDataMenuItems: function(trackView) {
    const menuItems = [];
    menuItems.push("<hr/>");
    const object = $$1("<div>");
    object.text("Set data range");
    const click = () => {
      trackView.browser.dataRangeDialog.configure(trackView);
      trackView.browser.dataRangeDialog.present($$1(trackView.browser.columnContainer));
    };
    menuItems.push({ object, click });
    if (trackView.track.logScale !== void 0) {
      menuItems.push(
        {
          object: $$1(createCheckbox$2("Log scale", trackView.track.logScale)),
          click: () => {
            trackView.track.logScale = !trackView.track.logScale;
            trackView.repaintViews();
          }
        }
      );
    }
    menuItems.push(
      {
        object: $$1(createCheckbox$2("Autoscale", trackView.track.autoscale)),
        click: () => {
          trackView.track.autoscale = !trackView.track.autoscale;
          trackView.updateViews();
        }
      }
    );
    return menuItems;
  },
  trackMenuItemListHelper: function(itemList, menuPopup) {
    var list = [];
    if (itemList.length > 0) {
      list = itemList.map(function(item, i) {
        var $e;
        if (item.name) {
          $e = $$1("<div>");
          $e.text(item.name);
        } else if (item.object) {
          $e = item.object;
        } else if (typeof item.label === "string") {
          $e = $$1("<div>");
          $e.html(item.label);
        } else if (typeof item === "string") {
          if (item.startsWith("<")) {
            $e = $$1(item);
          } else {
            $e = $$1("<div>" + item + "</div>");
          }
        }
        if (0 === i) {
          $e.addClass("igv-track-menu-border-top");
        }
        if (item.click) {
          let handleClick = function(e) {
            item.click(e);
            menuPopup.hide();
            e.preventDefault();
            e.stopPropagation();
          };
          $e.on("click", handleClick);
          $e.on("touchend", function(e) {
            handleClick(e);
          });
          $e.on("mouseup", function(e) {
            e.preventDefault();
            e.stopPropagation();
          });
        }
        return { object: $e, init: item.init || void 0 };
      });
    }
    return list;
  },
  showColorPicker(track) {
    return void 0 === track.type || "bedtype" === track.type || "alignment" === track.type || "annotation" === track.type || "variant" === track.type || "wig" === track.type || "interact" === track.type;
  },
  createMenuItem(label, action) {
    const object = $$1("<div>");
    object.text(label);
    return { object, click: action };
  }
};
function visibilityWindowMenuItem(trackView) {
  const click = (e) => {
    const callback = () => {
      let value = trackView.browser.inputDialog.value;
      value = "" === value || void 0 === value ? -1 : value.trim();
      trackView.track.visibilityWindow = Number.parseInt(value);
      trackView.track.config.visibilityWindow = Number.parseInt(value);
      trackView.updateViews();
    };
    const config = {
      label: "Visibility Window",
      value: trackView.track.visibilityWindow,
      callback
    };
    trackView.browser.inputDialog.present(config, e);
  };
  const object = $$1("<div>");
  object.text("Set visibility window");
  return { object, click };
}
function trackRemovalMenuItem$1(trackView) {
  const object = $$1("<div>");
  object.text("Remove track");
  return { object, click: () => trackView.browser.removeTrack(trackView.track) };
}
function colorPickerMenuItem$1({ trackView, label, option }) {
  const $e = $$1("<div>");
  $e.text(label);
  return {
    object: $e,
    click: () => trackView.presentColorPicker(option)
  };
}
function unsetColorMenuItem$1({ trackView, label }) {
  const $e = $$1("<div>");
  $e.text(label);
  return {
    object: $e,
    click: () => {
      trackView.track.color = void 0;
      trackView.repaintViews();
    }
  };
}
function unsetAltColorMenuItem({ trackView, label }) {
  const $e = $$1("<div>");
  $e.text(label);
  return {
    object: $e,
    click: () => {
      trackView.track.altColor = void 0;
      trackView.repaintViews();
    }
  };
}
function trackRenameMenuItem$1(trackView) {
  const click = (e) => {
    const callback = function() {
      let value = trackView.browser.inputDialog.value;
      value = "" === value || void 0 === value ? "untitled" : value.trim();
      trackView.track.name = value;
    };
    const config = {
      label: "Track Name",
      value: getTrackLabelText(trackView.track) || "unnamed",
      callback
    };
    trackView.browser.inputDialog.present(config, e);
  };
  const object = $$1("<div>");
  object.text("Set track name");
  return { object, click };
}
function trackHeightMenuItem(trackView) {
  const click = (e) => {
    const callback = () => {
      const number = Number(trackView.browser.inputDialog.value, 10);
      if (void 0 !== number) {
        if (trackView.track.minHeight !== void 0 && trackView.track.minHeight > number) {
          trackView.track.minHeight = number;
        }
        if (trackView.track.maxHeight !== void 0 && trackView.track.maxHeight < number) {
          trackView.track.minHeight = number;
        }
        trackView.setTrackHeight(number, true);
        trackView.checkContentHeight();
        trackView.repaintViews();
        trackView.track.autoHeight = false;
      }
    };
    const config = {
      label: "Track Height",
      value: trackView.track.height,
      callback
    };
    trackView.browser.inputDialog.present(config, e);
  };
  const object = $$1("<div>");
  object.text("Set track height");
  return { object, click };
}
function getTrackLabelText(track) {
  var vp, txt;
  vp = track.trackView.viewports[0];
  txt = vp.$trackLabel.text();
  return txt;
}
let DataRangeDialog$1 = class DataRangeDialog {
  constructor(browser, $parent, alert2) {
    this.browser = browser;
    this.$container = $$1("<div>", { class: "igv-generic-dialog-container" });
    $parent.append(this.$container);
    this.$container.offset({ left: 0, top: 0 });
    const $header = $$1("<div>", { class: "igv-generic-dialog-header" });
    this.$container.append($header);
    uiUtils$1.attachDialogCloseHandlerWithParent($header[0], () => {
      this.$minimum_input.val(void 0);
      this.$maximum_input.val(void 0);
      this.$container.offset({ left: 0, top: 0 });
      this.$container.hide();
    });
    this.$minimum = $$1("<div>", { class: "igv-generic-dialog-label-input" });
    this.$container.append(this.$minimum);
    const $mindiv = $$1("<div>");
    $mindiv.text("Minimum");
    this.$minimum.append($mindiv);
    this.$minimum_input = $$1("<input>");
    this.$minimum.append(this.$minimum_input);
    this.$maximum = $$1("<div>", { class: "igv-generic-dialog-label-input" });
    this.$container.append(this.$maximum);
    const $maxdiv = $$1("<div>");
    $maxdiv.text("Maximum");
    this.$maximum.append($maxdiv);
    this.$maximum_input = $$1("<input>");
    this.$maximum.append(this.$maximum_input);
    const $buttons = $$1("<div>", { class: "igv-generic-dialog-ok-cancel" });
    this.$container.append($buttons);
    this.$ok = $$1("<div>");
    $buttons.append(this.$ok);
    this.$ok.text("OK");
    this.$cancel = $$1("<div>");
    $buttons.append(this.$cancel);
    this.$cancel.text("Cancel");
    this.$cancel.on("click", () => {
      this.$minimum_input.val(void 0);
      this.$maximum_input.val(void 0);
      this.$container.offset({ left: 0, top: 0 });
      this.$container.hide();
    });
    makeDraggable$1(this.$container.get(0), $header.get(0));
    this.$container.hide();
  }
  configure(trackView) {
    const dataRange = trackView.dataRange();
    let min;
    let max;
    if (dataRange) {
      min = dataRange.min;
      max = dataRange.max;
    } else {
      min = 0;
      max = 100;
    }
    this.$minimum_input.val(min);
    this.$maximum_input.val(max);
    this.$minimum_input.unbind();
    this.$minimum_input.on("keyup", (e) => {
      if (13 === e.keyCode) {
        this.processResults(trackView);
      }
    });
    this.$maximum_input.unbind();
    this.$maximum_input.on("keyup", (e) => {
      if (13 === e.keyCode) {
        this.processResults(trackView);
      }
    });
    this.$ok.unbind();
    this.$ok.on("click", (e) => {
      this.processResults(trackView);
    });
  }
  processResults(trackView) {
    const min = Number(this.$minimum_input.val());
    const max = Number(this.$maximum_input.val());
    if (isNaN(min) || isNaN(max)) {
      this.browser.alert.present(new Error("Must input numeric values"), void 0);
    } else {
      trackView.setDataRange(min, max);
    }
    this.$minimum_input.val(void 0);
    this.$maximum_input.val(void 0);
    this.$container.offset({ left: 0, top: 0 });
    this.$container.hide();
  }
  present($parent) {
    const offset_top = $parent.offset().top;
    const scroll_top = $$1("body").scrollTop();
    this.$container.offset({ left: $parent.width() - this.$container.width(), top: offset_top + scroll_top });
    this.$container.show();
  }
};
function isString$2(x) {
  return typeof x === "string" || x instanceof String;
}
function numberFormatter$1(rawNumber) {
  var dec = String(rawNumber).split(/[.,]/), sep = ",", decsep = ".";
  return dec[0].split("").reverse().reduce(function(prev, now, i) {
    return i % 3 === 0 ? prev + sep + now : prev + now;
  }).split("").reverse().join("") + (dec[1] ? decsep + dec[1] : "");
}
const splitLines$5 = function(string) {
  return string.split(/\n|\r\n|\r/g);
};
function splitStringRespectingQuotes(string, delim) {
  var tokens = [], len2 = string.length, i, n = 0, quote = false, c;
  if (len2 > 0) {
    tokens[n] = string.charAt(0);
    for (i = 1; i < len2; i++) {
      c = string.charAt(i);
      if (c === '"') {
        quote = !quote;
      } else if (!quote && c === delim) {
        n++;
        tokens[n] = "";
      } else {
        tokens[n] += c;
      }
    }
  }
  return tokens;
}
function stripQuotes$1(str) {
  if (str === void 0) {
    return str;
  }
  if (str.startsWith("'") || str.startsWith('"')) {
    str = str.substring(1);
  }
  if (str.endsWith("'") || str.endsWith('"')) {
    str = str.substring(0, str.length - 1);
  }
  return str;
}
function capitalize(str) {
  return str.length > 0 ? str.charAt(0).toUpperCase() + str.slice(1) : str;
}
function parseLocusString$1(string) {
  const t12 = string.split(":");
  const t22 = t12[1].split("-");
  const range = {
    chr: t12[0],
    start: Number.parseInt(t22[0].replace(/,/g, "")) - 1
  };
  if (t22.length > 1) {
    range.end = Number.parseInt(t22[1].replace(/,/g, ""));
  } else {
    range.end = range.start + 1;
  }
  return range;
}
function getFilename$2(urlOrFile) {
  if (urlOrFile.name !== void 0) {
    return urlOrFile.name;
  } else if (isString$2(urlOrFile)) {
    let index2 = urlOrFile.lastIndexOf("/");
    let filename = index2 < 0 ? urlOrFile : urlOrFile.substr(index2 + 1);
    index2 = filename.indexOf("?");
    if (index2 > 0) {
      filename = filename.substr(0, index2);
    }
    return filename;
  } else {
    throw Error(`Expected File or string, got ${typeof urlOrFile}`);
  }
}
function isFile$1(object) {
  if (!object) {
    return false;
  }
  return typeof object !== "function" && (object instanceof File || object.hasOwnProperty("name") && typeof object.slice === "function" && typeof object.arrayBuffer === "function");
}
function download(filename, data) {
  const element = document.createElement("a");
  element.setAttribute("href", data);
  element.setAttribute("download", filename);
  element.style.display = "none";
  document.body.appendChild(element);
  element.click();
  document.body.removeChild(element);
}
if (typeof process === "object" && typeof window === "undefined") {
  global.atob = function(str) {
    return Buffer.from(str, "base64").toString("binary");
  };
}
function parseUri(str) {
  var o = options, m = o.parser["loose"].exec(str), uri = {}, i = 14;
  while (i--) uri[o.key[i]] = m[i] || "";
  uri[o.q.name] = {};
  uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) {
    if ($1) uri[o.q.name][$1] = $2;
  });
  return uri;
}
const options = {
  key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
  q: {
    name: "queryKey",
    parser: /(?:^|&)([^&=]*)=?([^&]*)/g
  },
  parser: {
    loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
  }
};
async function resolveURL(url) {
  return typeof url === "function" ? url() : url;
}
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
const Z_FIXED$1 = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN$1 = 2;
function zero$1$1(buf) {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH$1$1 = 3;
const MAX_MATCH$1$1 = 258;
const LENGTH_CODES$1$1 = 29;
const LITERALS$1$1 = 256;
const L_CODES$1$1 = LITERALS$1$1 + 1 + LENGTH_CODES$1$1;
const D_CODES$1$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1$1 + 1;
const MAX_BITS$1 = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN$1 = 512;
const static_ltree$1 = new Array((L_CODES$1$1 + 2) * 2);
zero$1$1(static_ltree$1);
const static_dtree$1 = new Array(D_CODES$1$1 * 2);
zero$1$1(static_dtree$1);
const _dist_code$1 = new Array(DIST_CODE_LEN$1);
zero$1$1(_dist_code$1);
const _length_code$1 = new Array(MAX_MATCH$1$1 - MIN_MATCH$1$1 + 1);
zero$1$1(_length_code$1);
const base_length$1 = new Array(LENGTH_CODES$1$1);
zero$1$1(base_length$1);
const base_dist$1 = new Array(D_CODES$1$1);
zero$1$1(base_dist$1);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist) => {
  return dist < 256 ? _dist_code$1[dist] : _dist_code$1[256 + (dist >>> 7)];
};
const put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
const send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
const send_code = (s, c, tree) => {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len2) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len2 > 0);
  return res >>> 1;
};
const bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
const gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n, m;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n = 0; n <= max_code; n++) {
    let len2 = tree[n * 2 + 1];
    if (len2 === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len2]++, len2);
  }
};
const tr_static_init = () => {
  let n;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1$1 - 1; code++) {
    base_length$1[code] = length;
    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code$1[length++] = code;
    }
  }
  _length_code$1[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist$1[code] = dist;
    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code$1[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1$1; code++) {
    base_dist$1[code] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code$1[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree$1[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree$1[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree$1[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree$1[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree$1, L_CODES$1$1 + 1, bl_count);
  for (n = 0; n < D_CODES$1$1; n++) {
    static_dtree$1[n * 2 + 1] = 5;
    static_dtree$1[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree$1, extra_lbits, LITERALS$1$1 + 1, L_CODES$1$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree$1, extra_dbits, 0, D_CODES$1$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
const init_block = (s) => {
  let n;
  for (n = 0; n < L_CODES$1$1; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES$1$1; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES$1; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
const bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
const smaller = (tree, n, m, depth) => {
  const _n2 = n * 2;
  const _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
};
const pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
};
const compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code$1[lc];
        send_code(s, code + LITERALS$1$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length$1[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist$1[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
const build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n, m;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
const scan_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s, tree, max_code) => {
  let n;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n;
  for (n = 0; n <= 31; n++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS$1$1; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
const _tr_stored_block$1 = (s, buf, stored_len, last) => {
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
const _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree$1);
  bi_flush(s);
};
const _tr_flush_block$1 = (s, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree$1, static_dtree$1);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last) {
    bi_windup(s);
  }
};
const _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code$1[lc] + LITERALS$1$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32$1 = (adler, buf, len2, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len2 !== 0) {
    n = len2 > 2e3 ? 2e3 : len2;
    len2 -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1$1 = adler32$1;
const makeTable$1 = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
const crcTable$1 = new Uint32Array(makeTable$1());
const crc32$1 = (crc, buf, len2, pos) => {
  const t = crcTable$1;
  const end = pos + len2;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1$1 = crc32$1;
var messages$1 = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2$1 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2$1;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS$1 = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const GZIP_STATE = 57;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages$1[errorCode];
  return errorCode;
};
const rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
const zero = (buf) => {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
};
const slide_hash = (s) => {
  let n, m;
  let p;
  let wsize = s.w_size;
  n = s.hash_size;
  p = n;
  do {
    m = s.head[--p];
    s.head[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
  n = wsize;
  p = n;
  do {
    m = s.prev[--p];
    s.prev[p] = m >= wsize ? m - wsize : 0;
  } while (--n);
};
let HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s = strm.state;
  let len2 = s.pending;
  if (len2 > strm.avail_out) {
    len2 = strm.avail_out;
  }
  if (len2 === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len2), strm.next_out);
  strm.next_out += len2;
  s.pending_out += len2;
  strm.total_out += len2;
  strm.avail_out -= len2;
  s.pending -= len2;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
const flush_block_only = (s, last) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
const put_byte = (s, b) => {
  s.pending_buf[s.pending++] = b;
};
const putShortMSB = (s, b) => {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
};
const read_buf = (strm, buf, start, size) => {
  let len2 = strm.avail_in;
  if (len2 > size) {
    len2 = size;
  }
  if (len2 === 0) {
    return 0;
  }
  strm.avail_in -= len2;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len2), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1$1(strm.adler, buf, len2, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1$1(strm.adler, buf, len2, start);
  }
  strm.next_in += len2;
  strm.total_in += len2;
  return len2;
};
const longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len2;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len2 = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len2 > best_len) {
      s.match_start = cur_match;
      best_len = len2;
      if (len2 >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
const fill_window = (s) => {
  const _w_size = s.w_size;
  let n, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
const deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len2, left, have, last = 0;
  let used = s.strm.avail_in;
  do {
    len2 = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len2 > left + s.strm.avail_in) {
      len2 = left + s.strm.avail_in;
    }
    if (len2 > have) {
      len2 = have;
    }
    if (len2 < min_block && (len2 === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len2 !== left + s.strm.avail_in)) {
      break;
    }
    last = flush === Z_FINISH$3 && len2 === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last);
    s.pending_buf[s.pending - 4] = len2;
    s.pending_buf[s.pending - 3] = len2 >> 8;
    s.pending_buf[s.pending - 2] = ~len2;
    s.pending_buf[s.pending - 1] = ~len2 >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len2) {
        left = len2;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len2 -= left;
    }
    if (len2) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len2);
      s.strm.next_out += len2;
      s.strm.avail_out -= len2;
      s.strm.total_out += len2;
    }
  } while (last === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len2 = left > have ? have : left;
    last = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len2 === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len2, last);
    s.block_start += len2;
    flush_pending(s.strm);
  }
  return last ? BS_FINISH_STARTED : BS_NEED_MORE;
};
const deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
const deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
const deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1$1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
const deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1$1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has$1 = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign$1 = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has$1(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks$1 = (chunks) => {
  let len2 = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len2 += chunks[i].length;
  }
  const result = new Uint8Array(len2);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common$1 = {
  assign: assign$1,
  flattenChunks: flattenChunks$1
};
let STR_APPLY_UIA_OK$1 = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK$1 = false;
}
const _utf8len$1 = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len$1[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len$1[254] = _utf8len$1[254] = 1;
var string2buf$1 = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
const buf2binstring$1 = (buf, len2) => {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK$1) {
      return String.fromCharCode.apply(null, buf.length === len2 ? buf : buf.subarray(0, len2));
    }
  }
  let result = "";
  for (let i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string$1 = (buf, max) => {
  const len2 = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len$1[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring$1(utf16buf, out);
};
var utf8border$1 = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len$1[buf[pos]] > max ? pos : max;
};
var strings$1 = {
  string2buf: string2buf$1,
  buf2string: buf2string$1,
  utf8border: utf8border$1
};
function ZStream$1() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream$1 = ZStream$1;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2$1;
function Deflate$1(options2) {
  this.options = common$1.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream$1();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages$1[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings$1.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages$1[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings$1.string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common$1.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  const deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages$1[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
var deflateRaw_1$1 = deflateRaw$1;
var deflate_1$1 = {
  deflateRaw: deflateRaw_1$1
};
const BAD$1$1 = 16209;
const TYPE$1$1 = 16191;
var inffast$1 = function inflate_fast2(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len2;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len2 > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output[_out++] = output[from++];
                      if (len2 > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len2 = bits >> 3;
  _in -= len2;
  bits -= len2 << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS$1 = 15;
const ENOUGH_LENS$1$1 = 852;
const ENOUGH_DISTS$1$1 = 592;
const CODES$1$1 = 0;
const LENS$1$1 = 1;
const DISTS$1$1 = 2;
const lbase$1 = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext$1 = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase$1 = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext$1 = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table$1 = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len2 = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let match;
  const count = new Uint16Array(MAXBITS$1 + 1);
  const offs = new Uint16Array(MAXBITS$1 + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS$1; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS$1; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS$1; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len2 = 1; len2 < MAXBITS$1; len2++) {
    offs[len2 + 1] = offs[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1$1) {
    base = extra = work;
    match = 20;
  } else if (type === LENS$1$1) {
    base = lbase$1;
    extra = lext$1;
    match = 257;
  } else {
    base = dbase$1;
    extra = dext$1;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1$1 && used > ENOUGH_LENS$1$1 || type === DISTS$1$1 && used > ENOUGH_DISTS$1$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1$1 && used > ENOUGH_LENS$1$1 || type === DISTS$1$1 && used > ENOUGH_DISTS$1$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees$1 = inflate_table$1;
const CODES$2 = 0;
const LENS$2 = 1;
const DISTS$2 = 2;
const {
  Z_FINISH: Z_FINISH$1$1,
  Z_BLOCK: Z_BLOCK$2,
  Z_TREES: Z_TREES$1,
  Z_OK: Z_OK$1$1,
  Z_STREAM_END: Z_STREAM_END$1$1,
  Z_NEED_DICT: Z_NEED_DICT$1$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1$1,
  Z_BUF_ERROR: Z_BUF_ERROR$2,
  Z_DEFLATED: Z_DEFLATED$3
} = constants$2$1;
const HEAD$1 = 16180;
const FLAGS$1 = 16181;
const TIME$1 = 16182;
const OS$1 = 16183;
const EXLEN$1 = 16184;
const EXTRA$1 = 16185;
const NAME$1 = 16186;
const COMMENT$1 = 16187;
const HCRC$1 = 16188;
const DICTID$1 = 16189;
const DICT$1 = 16190;
const TYPE$2 = 16191;
const TYPEDO$1 = 16192;
const STORED$1 = 16193;
const COPY_$1 = 16194;
const COPY$1 = 16195;
const TABLE$1 = 16196;
const LENLENS$1 = 16197;
const CODELENS$1 = 16198;
const LEN_$1 = 16199;
const LEN$1 = 16200;
const LENEXT$1 = 16201;
const DIST$1 = 16202;
const DISTEXT$1 = 16203;
const MATCH$1 = 16204;
const LIT$1 = 16205;
const CHECK$1 = 16206;
const LENGTH$1 = 16207;
const DONE$1 = 16208;
const BAD$2 = 16209;
const MEM$1 = 16210;
const SYNC$1 = 16211;
const ENOUGH_LENS$2 = 852;
const ENOUGH_DISTS$2 = 592;
const MAX_WBITS$2 = 15;
const DEF_WBITS$1 = MAX_WBITS$2;
const zswap32$1 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState$1() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD$1 || state.mode > SYNC$1) {
    return 1;
  }
  return 0;
};
const inflateResetKeep$1 = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD$1;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$2);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$2);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1$1;
};
const inflateReset$1 = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep$1(strm);
};
const inflateReset2$1 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset$1(strm);
};
const inflateInit2$1 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1$1;
  }
  const state = new InflateState$1();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD$1;
  const ret = inflateReset2$1(strm, windowBits);
  if (ret !== Z_OK$1$1) {
    strm.state = null;
  }
  return ret;
};
const inflateInit$1 = (strm) => {
  return inflateInit2$1(strm, DEF_WBITS$1);
};
let virgin$1 = true;
let lenfix$1, distfix$1;
const fixedtables$1 = (state) => {
  if (virgin$1) {
    lenfix$1 = new Int32Array(512);
    distfix$1 = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees$1(LENS$2, state.lens, 0, 288, lenfix$1, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees$1(DISTS$2, state.lens, 0, 32, distfix$1, 0, state.work, { bits: 5 });
    virgin$1 = false;
  }
  state.lencode = lenfix$1;
  state.lenbits = 9;
  state.distcode = distfix$1;
  state.distbits = 5;
};
const updatewindow$1 = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
const inflate$2$1 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len2;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1$1;
  }
  state = strm.state;
  if (state.mode === TYPE$2) {
    state.mode = TYPEDO$1;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD$1:
          if (state.wrap === 0) {
            state.mode = TYPEDO$1;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS$1;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$2;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state.mode = BAD$2;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          }
          if (len2 > 15 || len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$2;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID$1 : TYPE$2;
          hold = 0;
          bits = 0;
          break;
        case FLAGS$1:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$3) {
            strm.msg = "unknown compression method";
            state.mode = BAD$2;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$2;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME$1;
        /* falls through */
        case TIME$1:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1$1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS$1;
        /* falls through */
        case OS$1:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1$1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN$1;
        /* falls through */
        case EXLEN$1:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1$1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA$1;
        /* falls through */
        case EXTRA$1:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len2
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1$1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$1;
        /* falls through */
        case NAME$1:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1$1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT$1;
        /* falls through */
        case COMMENT$1:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1$1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC$1;
        /* falls through */
        case HCRC$1:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$2;
          break;
        case DICTID$1:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32$1(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT$1;
        /* falls through */
        case DICT$1:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$2;
        /* falls through */
        case TYPE$2:
          if (flush === Z_BLOCK$2 || flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO$1:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK$1;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED$1;
              break;
            case 1:
              fixedtables$1(state);
              state.mode = LEN_$1;
              if (flush === Z_TREES$1) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE$1;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$2;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED$1:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$2;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_$1;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case COPY_$1:
          state.mode = COPY$1;
        /* falls through */
        case COPY$1:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$2;
          break;
        case TABLE$1:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$2;
            break;
          }
          state.have = 0;
          state.mode = LENLENS$1;
        /* falls through */
        case LENLENS$1:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees$1(CODES$2, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$2;
            break;
          }
          state.have = 0;
          state.mode = CODELENS$1;
        /* falls through */
        case CODELENS$1:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$2;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$2;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD$2) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$2;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees$1(LENS$2, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$2;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees$1(DISTS$2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$2;
            break;
          }
          state.mode = LEN_$1;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        /* falls through */
        case LEN_$1:
          state.mode = LEN$1;
        /* falls through */
        case LEN$1:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast$1(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$2) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT$1;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$2;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$2;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT$1;
        /* falls through */
        case LENEXT$1:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST$1;
        /* falls through */
        case DIST$1:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$2;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT$1;
        /* falls through */
        case DISTEXT$1:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$2;
            break;
          }
          state.mode = MATCH$1;
        /* falls through */
        case MATCH$1:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$2;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN$1;
          }
          break;
        case LIT$1:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN$1;
          break;
        case CHECK$1:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1$1(state.check, output, _out, put - _out) : adler32_1$1(state.check, output, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32$1(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH$1;
        /* falls through */
        case LENGTH$1:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$2;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE$1;
        /* falls through */
        case DONE$1:
          ret = Z_STREAM_END$1$1;
          break inf_leave;
        case BAD$2:
          ret = Z_DATA_ERROR$1$1;
          break inf_leave;
        case MEM$1:
          return Z_MEM_ERROR$1$1;
        case SYNC$1:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$2 && (state.mode < CHECK$1 || flush !== Z_FINISH$1$1)) {
    if (updatewindow$1(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1$1(state.check, output, _out, strm.next_out - _out) : adler32_1$1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$2 ? 128 : 0) + (state.mode === LEN_$1 || state.mode === COPY_$1 ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1$1) && ret === Z_OK$1$1) {
    ret = Z_BUF_ERROR$2;
  }
  return ret;
};
const inflateEnd$1 = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1$1;
};
const inflateGetHeader$1 = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1$1;
};
const inflateSetDictionary$1 = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT$1) {
    return Z_STREAM_ERROR$1$1;
  }
  if (state.mode === DICT$1) {
    dictid = 1;
    dictid = adler32_1$1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1$1;
    }
  }
  ret = updatewindow$1(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM$1;
    return Z_MEM_ERROR$1$1;
  }
  state.havedict = 1;
  return Z_OK$1$1;
};
var inflateReset_1$1 = inflateReset$1;
var inflateReset2_1$1 = inflateReset2$1;
var inflateResetKeep_1$1 = inflateResetKeep$1;
var inflateInit_1$1 = inflateInit$1;
var inflateInit2_1$1 = inflateInit2$1;
var inflate_2$1$1 = inflate$2$1;
var inflateEnd_1$1 = inflateEnd$1;
var inflateGetHeader_1$1 = inflateGetHeader$1;
var inflateSetDictionary_1$1 = inflateSetDictionary$1;
var inflateInfo$1 = "pako inflate (from Nodeca project)";
var inflate_1$2$1 = {
  inflateReset: inflateReset_1$1,
  inflateReset2: inflateReset2_1$1,
  inflateResetKeep: inflateResetKeep_1$1,
  inflateInit: inflateInit_1$1,
  inflateInit2: inflateInit2_1$1,
  inflate: inflate_2$1$1,
  inflateEnd: inflateEnd_1$1,
  inflateGetHeader: inflateGetHeader_1$1,
  inflateSetDictionary: inflateSetDictionary_1$1,
  inflateInfo: inflateInfo$1
};
function GZheader$1() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader$1 = GZheader$1;
const toString$2 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$3,
  Z_FINISH: Z_FINISH$4,
  Z_OK: Z_OK$4,
  Z_STREAM_END: Z_STREAM_END$4,
  Z_NEED_DICT: Z_NEED_DICT$2,
  Z_STREAM_ERROR: Z_STREAM_ERROR$3,
  Z_DATA_ERROR: Z_DATA_ERROR$3,
  Z_MEM_ERROR: Z_MEM_ERROR$2
} = constants$2$1;
function Inflate$1$1(options2) {
  this.options = common$1.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream$1();
  this.strm.avail_out = 0;
  let status = inflate_1$2$1.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK$4) {
    throw new Error(messages$1[status]);
  }
  this.header = new gzheader$1();
  inflate_1$2$1.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings$1.string2buf(opt.dictionary);
    } else if (toString$2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2$1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$4) {
        throw new Error(messages$1[status]);
      }
    }
  }
}
Inflate$1$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$4 : Z_NO_FLUSH$3;
  if (toString$2.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2$1.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT$2 && dictionary) {
      status = inflate_1$2$1.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK$4) {
        status = inflate_1$2$1.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$3) {
        status = Z_NEED_DICT$2;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END$4 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2$1.inflateReset(strm);
      status = inflate_1$2$1.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR$3:
      case Z_DATA_ERROR$3:
      case Z_NEED_DICT$2:
      case Z_MEM_ERROR$2:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$4) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings$1.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings$1.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK$4 && last_avail_out === 0) continue;
    if (status === Z_STREAM_END$4) {
      status = inflate_1$2$1.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1$1.prototype.onEnd = function(status) {
  if (status === Z_OK$4) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common$1.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1$1(input, options2) {
  const inflator = new Inflate$1$1(options2);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages$1[inflator.err];
  return inflator.result;
}
function inflateRaw$1$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1$1(input, options2);
}
var inflate_2$2 = inflate$1$1;
var inflateRaw_1$1$1 = inflateRaw$1$1;
var ungzip$1$1 = inflate$1$1;
var inflate_1$1$1 = {
  inflate: inflate_2$2,
  inflateRaw: inflateRaw_1$1$1,
  ungzip: ungzip$1$1
};
const { deflateRaw } = deflate_1$1;
const { inflate: inflate$3, inflateRaw: inflateRaw$2, ungzip: ungzip$2 } = inflate_1$1$1;
var deflateRaw_1 = deflateRaw;
var inflate_1$3 = inflate$3;
var inflateRaw_1 = inflateRaw$2;
var ungzip_1$1 = ungzip$2;
const FEXTRA = 4;
function isgzipped(data) {
  const b = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  return b[0] === 31 && b[1] === 139;
}
function ungzip_blocks(data) {
  const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  const b = ba[3] & FEXTRA;
  if (b !== 0 && ba[12] === 66 && ba[13] === 67) {
    return unbgzf(ba.buffer);
  } else {
    return ungzip_1$1(ba);
  }
}
function unbgzf(data, lim) {
  const oBlockList = [];
  let ptr = 0;
  let totalSize = 0;
  lim = lim || data.byteLength - 18;
  while (ptr < lim) {
    try {
      const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data, ptr, 18);
      const xlen = ba[11] << 8 | ba[10];
      const flg = ba[3];
      const fextra = flg & FEXTRA;
      const si1 = ba[12];
      const si2 = ba[13];
      const slen = ba[15] << 8 | ba[14];
      const bsize = (ba[17] << 8 | ba[16]) + 1;
      const start = 12 + xlen + ptr;
      const bytesLeft = data.byteLength - start;
      const cDataSize = bsize - xlen - 19;
      if (bytesLeft < cDataSize || cDataSize <= 0) break;
      const a = new Uint8Array(data, start, cDataSize);
      const unc = inflateRaw_1(a);
      ptr += cDataSize - 1 + 26;
      totalSize += unc.byteLength;
      oBlockList.push(unc);
    } catch (e) {
      console.error(e);
      break;
    }
  }
  if (oBlockList.length === 1) {
    return oBlockList[0];
  } else {
    const out = new Uint8Array(totalSize);
    let cursor = 0;
    for (let i = 0; i < oBlockList.length; ++i) {
      var b = new Uint8Array(oBlockList[i]);
      arrayCopy(b, 0, out, cursor, b.length);
      cursor += b.length;
    }
    return out;
  }
}
function bgzBlockSize$1(data) {
  const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  const bsize = (ba[17] << 8 | ba[16]) + 1;
  return bsize;
}
const testArray = new Uint8Array(1);
const hasSubarray = typeof testArray.subarray === "function";
function arrayCopy(src, srcOffset, dest, destOffset, count) {
  if (count === 0) {
    return;
  }
  if (!src) {
    throw "Undef src";
  } else if (!dest) {
    throw "Undef dest";
  }
  if (count === src.length) {
    arrayCopy_fast(src, dest, destOffset);
  } else if (hasSubarray) {
    arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset);
  } else if (src.BYTES_PER_ELEMENT === 1 && count > 100) {
    arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);
  } else {
    arrayCopy_slow(src, srcOffset, dest, destOffset, count);
  }
}
function arrayCopy_slow(src, srcOffset, dest, destOffset, count) {
  for (let i = 0; i < count; ++i) {
    dest[destOffset + i] = src[srcOffset + i];
  }
}
function arrayCopy_fast(src, dest, destOffset) {
  dest.set(src, destOffset);
}
function compressString(str) {
  const bytes = new Uint8Array(str.length);
  for (var i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  const compressedBytes = new deflateRaw_1(bytes);
  const compressedString = String.fromCharCode.apply(null, compressedBytes);
  let enc = btoa(compressedString);
  return enc.replace(/\+/g, ".").replace(/\//g, "_").replace(/=/g, "-");
}
function uncompressString(enc) {
  enc = enc.replace(/\./g, "+").replace(/_/g, "/").replace(/-/g, "=");
  const compressedString = atob(enc);
  const compressedBytes = [];
  for (let i = 0; i < compressedString.length; i++) {
    compressedBytes.push(compressedString.charCodeAt(i));
  }
  const bytes = inflateRaw_1(compressedBytes);
  let str = "";
  for (let b of bytes) {
    str += String.fromCharCode(b);
  }
  return str;
}
function decodeDataURI$1(dataURI, gzip) {
  const split = dataURI.split(",");
  const info = split[0].split(":")[1];
  let dataString = split[1];
  if (info.indexOf("base64") >= 0) {
    dataString = atob(dataString);
    const bytes = new Uint8Array(dataString.length);
    for (let i = 0; i < dataString.length; i++) {
      bytes[i] = dataString.charCodeAt(i);
    }
    let plain;
    if (info.indexOf("gzip") > 0) {
      plain = ungzip_1$1(bytes);
    } else {
      plain = bytes;
    }
    return plain;
  } else {
    return decodeURIComponent(dataString);
  }
}
const IGVMath = {
  lerp: (v0, v1, t) => {
    return (1 - t) * v0 + t * v1;
  },
  mean: function(array) {
    var t = 0, n = 0, i;
    for (i = 0; i < array.length; i++) {
      if (!isNaN(array[i])) {
        t += array[i];
        n++;
      }
    }
    return n > 0 ? t / n : 0;
  },
  meanAndStdev: function(array) {
    var v, t = 0, t22 = 0, n = 0, i;
    for (i = 0; i < array.length; i++) {
      v = array[i];
      if (!isNaN(v)) {
        t += v;
        t22 += v * v;
        n++;
      }
    }
    return n > 0 ? { mean: t / n, stdev: Math.sqrt(t22 - t * t / n) } : { mean: 0, stdev: 0 };
  },
  median: function(numbers) {
    var median = 0, numsLen = numbers.length;
    numbers.sort();
    if (numsLen % 2 === 0) {
      median = (numbers[numsLen / 2 - 1] + numbers[numsLen / 2]) / 2;
    } else {
      median = numbers[(numsLen - 1) / 2];
    }
    return median;
  },
  // Fast percentile function for "p" near edges.  This needs profiled for p in middle (e.g. median)
  percentile: function(array, p) {
    if (array.length === 0) return void 0;
    var k = Math.floor(array.length * ((100 - p) / 100));
    if (k === 0) {
      array.sort(function(a, b) {
        return b - a;
      });
      return array[k];
    } else {
      return selectElement(array, k);
    }
  },
  clamp: function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  },
  log2: function(x) {
    return Math.log(x) / Math.LN2;
  }
};
function selectElement(array, k) {
  var heap = new BinaryHeap(), i;
  for (i = 0; i < array.length; i++) {
    var item = array[i];
    if (heap.content.length < k || item > heap.content[0]) {
      if (heap.content.length === k) {
        heap.pop();
      }
      heap.push(item);
    }
  }
  return heap.content[0];
}
function BinaryHeap() {
  this.content = [];
}
BinaryHeap.prototype = {
  push: function(element) {
    this.content.push(element);
    this.bubbleUp(this.content.length - 1);
  },
  pop: function() {
    var result = this.content[0];
    var end = this.content.pop();
    if (this.content.length > 0) {
      this.content[0] = end;
      this.sinkDown(0);
    }
    return result;
  },
  remove: function(node) {
    var length = this.content.length;
    for (var i = 0; i < length; i++) {
      if (this.content[i] !== node) continue;
      var end = this.content.pop();
      if (i === length - 1) break;
      this.content[i] = end;
      this.bubbleUp(i);
      this.sinkDown(i);
      break;
    }
  },
  size: function() {
    return this.content.length;
  },
  bubbleUp: function(n) {
    var element = this.content[n], score = element;
    while (n > 0) {
      var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];
      if (score >= parent)
        break;
      this.content[parentN] = element;
      this.content[n] = parent;
      n = parentN;
    }
  },
  sinkDown: function(n) {
    var length = this.content.length, element = this.content[n], elemScore = element;
    while (true) {
      var child2N = (n + 1) * 2, child1N = child2N - 1;
      var swap2 = null;
      if (child1N < length) {
        var child1 = this.content[child1N], child1Score = child1;
        if (child1Score < elemScore)
          swap2 = child1N;
      }
      if (child2N < length) {
        var child2 = this.content[child2N], child2Score = child2;
        if (child2Score < (swap2 == null ? elemScore : child1Score))
          swap2 = child2N;
      }
      if (swap2 == null) break;
      this.content[n] = this.content[swap2];
      this.content[swap2] = element;
      n = swap2;
    }
  }
};
function _random(min, max) {
  return Math.random() * (max - min) + min;
}
const IGVColor = {
  rgbListFromHSV: () => {
    let s = 1;
    let accumulation = [];
    for (let v = 1; v >= 0.5; v -= 0.1) {
      for (let h = 0; h < 1; h += 1 / 28) {
        const r = "rgb(" + IGVColor.hsvToRgb(h, s, v).join(",") + ")";
        accumulation.push(r);
      }
    }
    accumulation.pop();
    accumulation.push(IGVColor.rgbColor(16, 16, 16));
    return accumulation;
  },
  rgbToHex: function(rgb) {
    rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return rgb && rgb.length === 4 ? "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2) : "";
  },
  hexToRgb: function(hex) {
    var cooked = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (null === cooked) {
      return void 0;
    }
    return "rgb(" + parseInt(cooked[1], 16) + "," + parseInt(cooked[2], 16) + "," + parseInt(cooked[3], 16) + ")";
  },
  /**
   * Converts an HSV color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSV_color_space.
   * Assumes h, s, and v are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   v       The value
   * @return  Array   The RGB representation
   */
  hsvToRgb: function(h, s, v) {
    var r, g, b;
    var i = Math.floor(h * 6);
    var f = h * 6 - i;
    var p = v * (1 - s);
    var q = v * (1 - f * s);
    var t = v * (1 - (1 - f) * s);
    switch (i % 6) {
      case 0:
        r = v, g = t, b = p;
        break;
      case 1:
        r = q, g = v, b = p;
        break;
      case 2:
        r = p, g = v, b = t;
        break;
      case 3:
        r = p, g = q, b = v;
        break;
      case 4:
        r = t, g = p, b = v;
        break;
      case 5:
        r = v, g = p, b = q;
        break;
    }
    return [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
  },
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h, s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   *
   * Credit: https://gist.githubusercontent.com/mjackson/5311256
   *
   * @param   h       The hue
   * @param   s       The saturation
   * @param   l       The lightness
   * @return  Array   The RGB representation
   */
  hslToRgb: function(h, s, l) {
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p = 2 * l - q;
      r = IGVColor.hue2rgb(p, q, h + 1 / 3);
      g = IGVColor.hue2rgb(p, q, h);
      b = IGVColor.hue2rgb(p, q, h - 1 / 3);
    }
    return [r * 255, g * 255, b * 255];
  },
  hue2rgb: (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  },
  rgbaColor: function(r, g, b, a) {
    r = IGVMath.clamp(r, 0, 255);
    g = IGVMath.clamp(g, 0, 255);
    b = IGVMath.clamp(b, 0, 255);
    a = IGVMath.clamp(a, 0, 1);
    return "rgba(" + r + "," + g + "," + b + "," + a + ")";
  },
  rgbColor: function(r, g, b) {
    r = IGVMath.clamp(r, 0, 255);
    g = IGVMath.clamp(g, 0, 255);
    b = IGVMath.clamp(b, 0, 255);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  greyScale: function(value) {
    var grey = IGVMath.clamp(value, 0, 255);
    return "rgb(" + grey + "," + grey + "," + grey + ")";
  },
  randomGrey: function(min, max) {
    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);
    var g = Math.round(_random(min, max)).toString(10);
    return "rgb(" + g + "," + g + "," + g + ")";
  },
  randomRGB: function(min, max) {
    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);
    var r = Math.round(_random(min, max)).toString(10);
    var g = Math.round(_random(min, max)).toString(10);
    var b = Math.round(_random(min, max)).toString(10);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  randomRGBConstantAlpha: function(min, max, alpha) {
    min = IGVMath.clamp(min, 0, 255);
    max = IGVMath.clamp(max, 0, 255);
    var r = Math.round(_random(min, max)).toString(10);
    var g = Math.round(_random(min, max)).toString(10);
    var b = Math.round(_random(min, max)).toString(10);
    return "rgba(" + r + "," + g + "," + b + "," + alpha + ")";
  },
  addAlpha: function(color, alpha) {
    if (color === "0" || color === ".") {
      color = "rgb(0,0,0)";
    } else {
      const c = this.colorNameToHex(color);
      if (c) {
        color = c;
      }
    }
    var isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    if (color.startsWith("rgba")) {
      const idx = color.lastIndexOf(",");
      return color.substring(0, idx + 1) + alpha.toString() + ")";
    }
    if (isHex) {
      color = IGVColor.hexToRgb(color);
    }
    if (color.startsWith("rgb")) {
      return color.replace("rgb", "rgba").replace(")", ", " + alpha + ")");
    } else {
      console.log(color + " is not an rgb style string");
      return color;
    }
  },
  rgbComponents: function(color) {
    if (color === "0" || color === ".") {
      return [0, 0, 0];
    }
    const isHex = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(color);
    if (isHex) {
      color = IGVColor.hexToRgb(color);
    } else {
      if (!color.startsWith("rgb")) {
        const hex = this.colorNameToHex(color);
        color = this.hexToRgb(hex);
      }
    }
    if (color.startsWith("rgb(")) {
      return color.substring(4, color.length - 1).split(",").map((s) => Number.parseInt(s.trim()));
    } else if (color.startsWith("rgba(")) {
      return color.substring(5, color.length - 1).split(",").map((s, i) => {
        s = s.trim();
        return i === 3 ? Number.parseFloat(s) : Number.parseInt(s);
      });
    } else {
      throw Error("Unrecognized color string: color");
    }
  },
  /**
   *
   * @param dest  RGB components as an array
   * @param src  RGB components as an array
   * @param alpha   alpha transparancy in the range 0-1
   * @returns {}
   */
  getCompositeColor: function(dest, src, alpha) {
    var r = Math.floor(alpha * src[0] + (1 - alpha) * dest[0]), g = Math.floor(alpha * src[1] + (1 - alpha) * dest[1]), b = Math.floor(alpha * src[2] + (1 - alpha) * dest[2]);
    return "rgb(" + r + "," + g + "," + b + ")";
  },
  /**
   * Return a color represented by the string.  If the string is not a recognized color format return the
   * string itself.  This function exists for backward compatibility,  createColorStringSafe is preferredz
   * @param str
   */
  createColorString: function(str) {
    const color = this.createColorStringSafe(str);
    return color ? color : str;
  },
  /**
   * If str is a recognized color format return a string encoding the color
   * @param str
   */
  createColorStringSafe: function(str) {
    str = stripQuotes$1(str);
    if (str.startsWith("rgb(") && str.endsWith(")")) {
      return str;
    }
    if (str.startsWith("#") && str.length < 8) {
      return str;
    }
    const hex = this.colorNameToHex(str);
    if (hex) {
      return hex;
    }
    const tokens = str.split(",");
    if (tokens.length === 3 && isColorComponent(tokens[0]) && isColorComponent(tokens[1]) && isColorComponent(tokens[2])) {
      return `rgb(${str})`;
    }
  },
  darkenLighten: function(color, amt) {
    let src;
    let hexColor = this.colorNameToHex(color);
    if (hexColor) {
      src = IGVColor.hexToRgb(hexColor);
    } else {
      src = color.startsWith("rgb(") ? color : IGVColor.hexToRgb(color);
    }
    const components = src.replace(")", "").substring(4).split(",");
    const r = Math.max(0, Math.min(255, Number.parseInt(components[0].trim()) + amt));
    const g = Math.max(0, Math.min(255, Number.parseInt(components[1].trim()) + amt));
    const b = Math.max(0, Math.min(255, Number.parseInt(components[2].trim()) + amt));
    return "rgb(" + r.toString() + "," + g.toString() + "," + b.toString() + ")";
  },
  /**
   * Convert html/css color name to hex value.  Adapted from https://gist.github.com/mxfh/4719348
   * @param colorName
   * @returns {*}
   */
  colorNameToHex: function(colorName) {
    const definedColorNames = {
      "aliceblue": "#f0f8ff",
      "antiquewhite": "#faebd7",
      "aqua": "#00ffff",
      "aquamarine": "#7fffd4",
      "azure": "#f0ffff",
      "beige": "#f5f5dc",
      "bisque": "#ffe4c4",
      "black": "#000000",
      "blanchedalmond": "#ffebcd",
      "blue": "#0000ff",
      "blueviolet": "#8a2be2",
      "brown": "#a52a2a",
      "burlywood": "#deb887",
      "cadetblue": "#5f9ea0",
      "chartreuse": "#7fff00",
      "chocolate": "#d2691e",
      "coral": "#ff7f50",
      "cornflowerblue": "#6495ed",
      "cornsilk": "#fff8dc",
      "crimson": "#dc143c",
      "cyan": "#00ffff",
      "darkblue": "#00008b",
      "darkcyan": "#008b8b",
      "darkgoldenrod": "#b8860b",
      "darkgray": "#a9a9a9",
      "darkgreen": "#006400",
      "darkkhaki": "#bdb76b",
      "darkmagenta": "#8b008b",
      "darkolivegreen": "#556b2f",
      "darkorange": "#ff8c00",
      "darkorchid": "#9932cc",
      "darkred": "#8b0000",
      "darksalmon": "#e9967a",
      "darkseagreen": "#8fbc8f",
      "darkslateblue": "#483d8b",
      "darkslategray": "#2f4f4f",
      "darkturquoise": "#00ced1",
      "darkviolet": "#9400d3",
      "deeppink": "#ff1493",
      "deepskyblue": "#00bfff",
      "dimgray": "#696969",
      "dodgerblue": "#1e90ff",
      "firebrick": "#b22222",
      "floralwhite": "#fffaf0",
      "forestgreen": "#228b22",
      "fuchsia": "#ff00ff",
      "gainsboro": "#dcdcdc",
      "ghostwhite": "#f8f8ff",
      "gold": "#ffd700",
      "goldenrod": "#daa520",
      "gray": "#808080",
      "green": "#008000",
      "greenyellow": "#adff2f",
      "honeydew": "#f0fff0",
      "hotpink": "#ff69b4",
      "indianred ": "#cd5c5c",
      "indigo ": "#4b0082",
      "ivory": "#fffff0",
      "khaki": "#f0e68c",
      "lavender": "#e6e6fa",
      "lavenderblush": "#fff0f5",
      "lawngreen": "#7cfc00",
      "lemonchiffon": "#fffacd",
      "lightblue": "#add8e6",
      "lightcoral": "#f08080",
      "lightcyan": "#e0ffff",
      "lightgoldenrodyellow": "#fafad2",
      "lightgrey": "#d3d3d3",
      "lightgreen": "#90ee90",
      "lightpink": "#ffb6c1",
      "lightsalmon": "#ffa07a",
      "lightseagreen": "#20b2aa",
      "lightskyblue": "#87cefa",
      "lightslategray": "#778899",
      "lightsteelblue": "#b0c4de",
      "lightyellow": "#ffffe0",
      "lime": "#00ff00",
      "limegreen": "#32cd32",
      "linen": "#faf0e6",
      "magenta": "#ff00ff",
      "maroon": "#800000",
      "mediumaquamarine": "#66cdaa",
      "mediumblue": "#0000cd",
      "mediumorchid": "#ba55d3",
      "mediumpurple": "#9370d8",
      "mediumseagreen": "#3cb371",
      "mediumslateblue": "#7b68ee",
      "mediumspringgreen": "#00fa9a",
      "mediumturquoise": "#48d1cc",
      "mediumvioletred": "#c71585",
      "midnightblue": "#191970",
      "mintcream": "#f5fffa",
      "mistyrose": "#ffe4e1",
      "moccasin": "#ffe4b5",
      "navajowhite": "#ffdead",
      "navy": "#000080",
      "oldlace": "#fdf5e6",
      "olive": "#808000",
      "olivedrab": "#6b8e23",
      "orange": "#ffa500",
      "orangered": "#ff4500",
      "orchid": "#da70d6",
      "palegoldenrod": "#eee8aa",
      "palegreen": "#98fb98",
      "paleturquoise": "#afeeee",
      "palevioletred": "#d87093",
      "papayawhip": "#ffefd5",
      "peachpuff": "#ffdab9",
      "peru": "#cd853f",
      "pink": "#ffc0cb",
      "plum": "#dda0dd",
      "powderblue": "#b0e0e6",
      "purple": "#800080",
      "red": "#ff0000",
      "rosybrown": "#bc8f8f",
      "royalblue": "#4169e1",
      "saddlebrown": "#8b4513",
      "salmon": "#fa8072",
      "sandybrown": "#f4a460",
      "seagreen": "#2e8b57",
      "seashell": "#fff5ee",
      "sienna": "#a0522d",
      "silver": "#c0c0c0",
      "skyblue": "#87ceeb",
      "slateblue": "#6a5acd",
      "slategray": "#708090",
      "snow": "#fffafa",
      "springgreen": "#00ff7f",
      "steelblue": "#4682b4",
      "tan": "#d2b48c",
      "teal": "#008080",
      "thistle": "#d8bfd8",
      "tomato": "#ff6347",
      "turquoise": "#40e0d0",
      "violet": "#ee82ee",
      "wheat": "#f5deb3",
      "white": "#ffffff",
      "whitesmoke": "#f5f5f5",
      "yellow": "#ffff00",
      "yellowgreen": "#9acd32",
      "darkgrey": "#a9a9a9",
      "darkslategrey": "#2f4f4f",
      "dimgrey": "#696969",
      "grey": "#808080",
      "lightgray": "#d3d3d3",
      "lightslategrey": "#778899",
      "slategrey": "#708090"
    };
    return definedColorNames[colorName];
  }
};
function isColorComponent(str) {
  const num = Number.parseInt(str);
  return !Number.isNaN(num) && num >= 0 && num <= 255;
}
const DEFAULT_HOST = "googleapis";
class Oauth2 {
  constructor() {
    this.oauthTokens = {};
  }
  setToken(token, host) {
    host = host || DEFAULT_HOST;
    this.oauthTokens[host] = token;
  }
  getToken(host) {
    host = host || DEFAULT_HOST;
    let token;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp(key);
      if (regex.test(host)) {
        token = this.oauthTokens[key];
        break;
      }
    }
    return token;
  }
  removeToken(host) {
    host = host || DEFAULT_HOST;
    for (let key of Object.keys(this.oauthTokens)) {
      const regex = wildcardToRegExp(key);
      if (regex.test(host)) {
        this.oauthTokens[key] = void 0;
      }
    }
  }
  // Special object for google -- legacy support
  // google: {
  //     setToken: function (token) {
  //         oauth.setToken(token);
  //     }
  // }
}
function wildcardToRegExp(s) {
  return new RegExp("^" + s.split(/\*+/).map(regExpEscape).join(".*") + "$");
}
function regExpEscape(s) {
  return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
}
function isGoogleURL$1(url) {
  return url.includes("googleapis") && !url.includes("urlshortener") || isGoogleStorageURL$1(url) || isGoogleDriveURL$1(url);
}
function isGoogleStorageURL$1(url) {
  return url.startsWith("gs://") || url.startsWith("https://www.googleapis.com/storage") || url.startsWith("https://storage.cloud.google.com") || url.startsWith("https://storage.googleapis.com");
}
function isGoogleDriveURL$1(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
}
function translateGoogleCloudURL(gsUrl) {
  let { bucket, object } = parseBucketName(gsUrl);
  object = encode(object);
  const qIdx = gsUrl.indexOf("?");
  const paramString = qIdx > 0 ? gsUrl.substring(qIdx) + "&alt=media" : "?alt=media";
  return `https://storage.googleapis.com/storage/v1/b/${bucket}/o/${object}${paramString}`;
}
function parseBucketName(url) {
  let bucket;
  let object;
  if (url.startsWith("gs://")) {
    const i = url.indexOf("/", 5);
    if (i >= 0) {
      bucket = url.substring(5, i);
      const qIdx = url.indexOf("?");
      object = qIdx < 0 ? url.substring(i + 1) : url.substring(i + 1, qIdx);
    }
  } else if (url.startsWith("https://storage.googleapis.com") || url.startsWith("https://storage.cloud.google.com")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    if (bucketIdx > 0) {
      const objIdx = url.indexOf("/o/", bucketIdx);
      if (objIdx > 0) {
        const queryIdx = url.indexOf("?", objIdx);
        bucket = url.substring(bucketIdx + 6, objIdx);
        object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
      }
    } else {
      const idx1 = url.indexOf("/", 8);
      const idx2 = url.indexOf("/", idx1 + 1);
      const idx3 = url.indexOf("?", idx2);
      if (idx2 > 0) {
        bucket = url.substring(idx1 + 1, idx2);
        object = idx3 < 0 ? url.substring(idx2 + 1) : url.substring(idx2 + 1, idx3);
      }
    }
  } else if (url.startsWith("https://www.googleapis.com/storage/v1/b")) {
    const bucketIdx = url.indexOf("/v1/b/", 8);
    const objIdx = url.indexOf("/o/", bucketIdx);
    if (objIdx > 0) {
      const queryIdx = url.indexOf("?", objIdx);
      bucket = url.substring(bucketIdx + 6, objIdx);
      object = queryIdx > 0 ? url.substring(objIdx + 3, queryIdx) : url.substring(objIdx + 3);
    }
  }
  if (bucket && object) {
    return {
      bucket,
      object
    };
  } else {
    throw Error(`Unrecognized Google Storage URI: ${url}`);
  }
}
function encode(objectName) {
  let result = "";
  objectName.split("").forEach(function(letter) {
    if (encodings$1.has(letter)) {
      result += encodings$1.get(letter);
    } else {
      result += letter;
    }
  });
  return result;
}
const encodings$1 = /* @__PURE__ */ new Map();
encodings$1.set("!", "%21");
encodings$1.set("#", "%23");
encodings$1.set("$", "%24");
encodings$1.set("%", "%25");
encodings$1.set("&", "%26");
encodings$1.set("'", "%27");
encodings$1.set("(", "%28");
encodings$1.set(")", "%29");
encodings$1.set("*", "%2A");
encodings$1.set("+", "%2B");
encodings$1.set(",", "%2C");
encodings$1.set("/", "%2F");
encodings$1.set(":", "%3A");
encodings$1.set(";", "%3B");
encodings$1.set("=", "%3D");
encodings$1.set("?", "%3F");
encodings$1.set("@", "%40");
encodings$1.set("[", "%5B");
encodings$1.set("]", "%5D");
encodings$1.set(" ", "%20");
async function init$1$1(config) {
  if (!google.accounts.oauth2.initTokenClient) {
    throw new Error("Google accounts token client not loaded (https://accounts.google.com/gsi/client)");
  }
  if (isInitialized()) {
    throw new Error("Google client is already initialized");
  }
  const codeClientConfig = {
    client_id: config.client_id || config.clientId,
    scope: config.scope || "https://www.googleapis.com/auth/userinfo.profile",
    state: config.state || "igv",
    error: (err2) => {
      throw new Error(err2.type);
    },
    hint: config.hint,
    // Optional
    hosted_domain: config.hosted_domain
    // Optional
  };
  const tokenClient = google.accounts.oauth2.initTokenClient(codeClientConfig);
  google.igv = {
    tokenClient,
    apiKey: config.apiKey
  };
}
function isInitialized() {
  return window.google && window.google.igv;
}
function getCurrentAccessToken() {
  return isInitialized() && google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt ? google.igv.tokenResponse.access_token : void 0;
}
async function getAccessToken(scope) {
  if (!isInitialized()) {
    throw Error("Google oAuth has not been initialized");
  }
  if (google.igv.tokenResponse && Date.now() < google.igv.tokenExpiresAt && google.accounts.oauth2.hasGrantedAllScopes(google.igv.tokenResponse, scope)) {
    return google.igv.tokenResponse.access_token;
  } else {
    const tokenClient = google.igv.tokenClient;
    return new Promise((resolve, reject) => {
      try {
        tokenClient.callback = (tokenResponse) => {
          if (tokenResponse.error !== void 0) {
            reject(tokenResponse);
          }
          google.igv.tokenResponse = tokenResponse;
          google.igv.tokenExpiresAt = Date.now() + tokenResponse.expires_in * 1e3;
          resolve(tokenResponse.access_token);
        };
        tokenClient.requestAccessToken({ scope });
      } catch (err2) {
        console.log(err2);
      }
    });
  }
}
function getScopeForURL(url) {
  if (isGoogleDriveURL$1(url)) {
    return "https://www.googleapis.com/auth/drive.file";
  } else if (isGoogleStorageURL$1(url)) {
    return "https://www.googleapis.com/auth/devstorage.read_only";
  } else {
    return "https://www.googleapis.com/auth/userinfo.profile";
  }
}
function getApiKey() {
  return google.igv.apiKey;
}
async function getDriveFileInfo(googleDriveURL) {
  const id = getGoogleDriveFileID$1(googleDriveURL);
  let endPoint = "https://www.googleapis.com/drive/v3/files/" + id + "?supportsTeamDrives=true";
  const apiKey2 = getApiKey();
  if (apiKey2) {
    endPoint += "&key=" + apiKey2;
  }
  const response = await fetch(endPoint);
  let json = await response.json();
  if (json.error && json.error.code === 404) {
    let scope = "https://www.googleapis.com/auth/drive.readonly";
    const access_token = await getAccessToken(scope);
    if (access_token) {
      const response2 = await fetch(endPoint, {
        headers: {
          "Authorization": `Bearer ${access_token}`
        }
      });
      json = await response2.json();
      if (json.error) {
        throw Error(json.error);
      }
    } else {
      throw Error(json.error);
    }
  }
  return json;
}
function getDriveDownloadURL$1(link2) {
  var id = getGoogleDriveFileID$1(link2);
  return id ? "https://www.googleapis.com/drive/v3/files/" + id + "?alt=media&supportsTeamDrives=true" : link2;
}
function getGoogleDriveFileID$1(link2) {
  if (link2.includes("/open?id=")) {
    const i1 = link2.indexOf("/open?id=") + 9;
    const i2 = link2.indexOf("&");
    if (i1 > 0 && i2 > i1) {
      return link2.substring(i1, i2);
    } else if (i1 > 0) {
      return link2.substring(i1);
    }
  } else if (link2.includes("/file/d/")) {
    const i1 = link2.indexOf("/file/d/") + 8;
    const i2 = link2.lastIndexOf("/");
    return link2.substring(i1, i2);
  } else if (link2.startsWith("https://www.googleapis.com/drive")) {
    let i1 = link2.indexOf("/files/");
    const i2 = link2.indexOf("?");
    if (i1 > 0) {
      i1 += 7;
      return i2 > 0 ? link2.substring(i1, i2) : link2.substring(i1);
    }
  }
  throw Error("Unknown Google Drive url format: " + link2);
}
class Throttle2 {
  constructor(options2) {
    this.requestsPerSecond = options2.requestsPerSecond || 10;
    this.lastStartTime = 0;
    this.queued = [];
  }
  /**
   * Adds a promise
   * @param {Function} async function to be executed
   * @param {Object} options A set of options.
   * @return {Promise} A promise
   */
  add(asyncFunction, options2) {
    var self2 = this;
    return new Promise(function(resolve, reject) {
      self2.queued.push({
        resolve,
        reject,
        asyncFunction
      });
      self2.dequeue();
    });
  }
  /**
   * Adds all the promises passed as parameters
   * @param {Function} promises An array of functions that return a promise
   * @param {Object} options A set of options.
   * @param {number} options.signal An AbortSignal object that can be used to abort the returned promise
   * @param {number} options.weight A "weight" of each operation resolving by array of promises
   * @return {Promise} A promise that succeeds when all the promises passed as options do
   */
  addAll(promises, options2) {
    var addedPromises = promises.map((function(promise) {
      return this.add(promise, options2);
    }).bind(this));
    return Promise.all(addedPromises);
  }
  /**
   * Dequeues a promise
   * @return {void}
   */
  dequeue() {
    if (this.queued.length > 0) {
      var now = /* @__PURE__ */ new Date(), inc = 1e3 / this.requestsPerSecond + 1, elapsed = now - this.lastStartTime;
      if (elapsed >= inc) {
        this._execute();
      } else {
        setTimeout((function() {
          this.dequeue();
        }).bind(this), inc - elapsed);
      }
    }
  }
  /**
   * Executes the promise
   * @private
   * @return {void}
   */
  async _execute() {
    this.lastStartTime = /* @__PURE__ */ new Date();
    var candidate = this.queued.shift();
    const f = candidate.asyncFunction;
    try {
      const r = await f();
      candidate.resolve(r);
    } catch (e) {
      candidate.reject(e);
    }
  }
}
class IGVXhr2 {
  constructor() {
    this.apiKey = void 0;
    this.googleThrottle = new Throttle2({
      requestsPerSecond: 8
    });
    this.RANGE_WARNING_GIVEN = false;
    this.oauth = new Oauth2();
  }
  setApiKey(key) {
    this.apiKey = key;
  }
  async loadArrayBuffer(url, options2) {
    options2 = options2 || {};
    if (!options2.responseType) {
      options2.responseType = "arraybuffer";
    }
    if (isFile$1(url)) {
      return this._loadFileSlice(url, options2);
    } else {
      return this.load(url, options2);
    }
  }
  /**
   * A wrapper around loadArrayBuffer that inflates gzipped data
   * @param url
   * @param options
   * @returns {Promise<Uint8Array>}
   */
  async loadByteArray(url, options2) {
    const arraybuffer = await this.loadArrayBuffer(url, options2);
    let plain;
    if (isgzipped(arraybuffer)) {
      plain = ungzip_blocks(arraybuffer);
    } else {
      plain = new Uint8Array(arraybuffer);
    }
    return plain;
  }
  async loadJson(url, options2) {
    options2 = options2 || {};
    const method = options2.method || (options2.sendData ? "POST" : "GET");
    if (method === "POST") {
      options2.contentType = "application/json";
    }
    const result = await this.loadString(url, options2);
    if (result) {
      return JSON.parse(result);
    } else {
      return result;
    }
  }
  async loadString(path, options2) {
    options2 = options2 || {};
    if (path instanceof File) {
      return this._loadStringFromFile(path, options2);
    } else {
      return this._loadStringFromUrl(path, options2);
    }
  }
  async load(url, options2) {
    options2 = options2 || {};
    const urlType = typeof url;
    url = await (typeof url === "function" ? url() : url);
    if (isFile$1(url)) {
      return this._loadFileSlice(url, options2);
    } else if (typeof url.startsWith === "function") {
      if (url.startsWith("data:")) {
        const buffer = decodeDataURI$1(url).buffer;
        if (options2.range) {
          const rangeEnd = options2.range.size ? options2.range.start + options2.range.size : buffer.byteLength;
          return buffer.slice(options2.range.start, rangeEnd);
        } else {
          return buffer;
        }
      } else {
        if (url.startsWith("https://drive.google.com")) {
          url = getDriveDownloadURL$1(url);
        }
        if (isGoogleDriveURL$1(url) || url.startsWith("https://www.dropbox.com")) {
          return this.googleThrottle.add(async () => {
            return this._loadURL(url, options2);
          });
        } else {
          return this._loadURL(url, options2);
        }
      }
    } else {
      throw Error(`url must be either a 'File', 'string', 'function', or 'Promise'.  Actual type: ${urlType}`);
    }
  }
  async _loadURL(url, options2) {
    const self2 = this;
    const _url = url;
    url = mapUrl$1(url);
    options2 = options2 || {};
    let oauthToken = options2.oauthToken || this.getOauthToken(url);
    if (oauthToken) {
      oauthToken = await (typeof oauthToken === "function" ? oauthToken() : oauthToken);
    }
    return new Promise(function(resolve, reject) {
      if (isGoogleURL$1(url) && !isGoogleStorageSigned(url)) {
        if (isGoogleStorageURL$1(url)) {
          url = translateGoogleCloudURL(url);
        }
        url = addApiKey(url);
        if (isGoogleDriveURL$1(url)) {
          addTeamDrive(url);
        }
        if (!oauthToken) {
          oauthToken = getCurrentGoogleAccessToken();
        }
      }
      const headers = options2.headers || {};
      if (oauthToken) {
        addOauthHeaders(headers, oauthToken);
      }
      const range = options2.range;
      const xhr = new XMLHttpRequest();
      const sendData = options2.sendData || options2.body;
      const method = options2.method || (sendData ? "POST" : "GET");
      const responseType = options2.responseType;
      const contentType = options2.contentType;
      const mimeType = options2.mimeType;
      xhr.open(method, url);
      if (options2.timeout) {
        xhr.timeout = options2.timeout;
      }
      if (range) {
        let rangeEnd = "";
        if (range.size) {
          rangeEnd = range.start + range.size - 1;
        }
        xhr.setRequestHeader("Range", "bytes=" + range.start + "-" + rangeEnd);
      }
      if (contentType) {
        xhr.setRequestHeader("Content-Type", contentType);
      }
      if (mimeType) {
        xhr.overrideMimeType(mimeType);
      }
      if (responseType) {
        xhr.responseType = responseType;
      }
      if (headers) {
        for (let key of Object.keys(headers)) {
          const value = headers[key];
          xhr.setRequestHeader(key, value);
        }
      }
      if (options2.withCredentials === true) {
        xhr.withCredentials = true;
      }
      xhr.onload = async function(event) {
        if (xhr.status === 0 || xhr.status >= 200 && xhr.status <= 300) {
          if ("HEAD" === options2.method) {
            const headers2 = options2.requestedHeaders || ["content-length"];
            const headerMap = {};
            for (let h of headers2) {
              headerMap[h] = xhr.getResponseHeader(h);
            }
            resolve(headerMap);
          } else {
            if (range && xhr.status !== 206 && range.start !== 0) {
              if (xhr.response.length > 1e5 && !self2.RANGE_WARNING_GIVEN) {
                alert(`Warning: Range header ignored for URL: ${url}.  This can have severe performance impacts.`);
              }
              resolve(xhr.response.slice(range.start, range.start + range.size));
            } else {
              resolve(xhr.response);
            }
          }
        } else if (xhr.status === 416) {
          handleError(Error(`416 Unsatisfiable Range`));
        } else if (isInitialized() && ((xhr.status === 404 || xhr.status === 401 || xhr.status === 403) && isGoogleURL$1(url)) && !options2.retries) {
          tryGoogleAuth();
        } else {
          if (xhr.status === 403) {
            handleError("Access forbidden: " + url);
          } else {
            handleError(xhr.status);
          }
        }
      };
      xhr.onerror = function(event) {
        if (isGoogleURL$1(url) && !options2.retries) {
          tryGoogleAuth();
        } else {
          handleError("Error accessing resource: " + url + " Status: " + xhr.status);
        }
      };
      xhr.ontimeout = function(event) {
        handleError("Timed out");
      };
      xhr.onabort = function(event) {
        console.log("Aborted");
        reject(event);
      };
      try {
        xhr.send(sendData);
      } catch (e) {
        if (isGoogleURL$1(url) && !options2.retries) {
          tryGoogleAuth();
        } else {
          handleError(e);
        }
      }
      function handleError(error) {
        if (reject) {
          reject(error);
        } else {
          throw error;
        }
      }
      async function tryGoogleAuth() {
        try {
          const accessToken = await fetchGoogleAccessToken(_url);
          options2.retries = 1;
          options2.oauthToken = accessToken;
          const response = await self2.load(_url, options2);
          resolve(response);
        } catch (e) {
          if (e.error) {
            const msg = e.error.startsWith("popup_blocked") ? "Google login popup blocked by browser." : e.error;
            alert(msg);
          } else {
            handleError(e);
          }
        }
      }
    });
  }
  async _loadFileSlice(localfile, options2) {
    let blob = options2 && options2.range ? localfile.slice(options2.range.start, options2.range.start + options2.range.size) : localfile;
    const arrayBuffer = await blob.arrayBuffer();
    if ("arraybuffer" === options2.responseType) {
      return arrayBuffer;
    } else {
      return arrayBufferToString(arrayBuffer);
    }
  }
  async _loadStringFromFile(localfile, options2) {
    const blob = options2.range ? localfile.slice(options2.range.start, options2.range.start + options2.range.size) : localfile;
    const arrayBuffer = await blob.arrayBuffer();
    return arrayBufferToString(arrayBuffer);
  }
  async _loadStringFromUrl(url, options2) {
    options2 = options2 || {};
    options2.responseType = "arraybuffer";
    const data = await this.load(url, options2);
    return arrayBufferToString(data);
  }
  /**
   * Explicity set an oAuth token for use with given host.  If host is undefined token is used for google api access*
   * @param token
   * @param host
   */
  setOauthToken(token, host) {
    this.oauth.setToken(token, host);
  }
  /**
   * Return an oauth token for the URL if we have one.  This method does not force sign-in, and the token may
   * or may not be valid.  Sign-in is triggered on request failure.
   * *
   * @param url
   * @returns {*}
   */
  getOauthToken(url) {
    const host = isGoogleURL$1(url) ? void 0 : parseUri(url).host;
    let token = this.oauth.getToken(host);
    if (token) {
      return token;
    } else if (host === void 0) {
      const googleToken = getCurrentGoogleAccessToken();
      if (googleToken && googleToken.expires_at > Date.now()) {
        return googleToken.access_token;
      }
    }
  }
  /**
   * This method should only be called when it is known the server supports HEAD requests.  It is used to recover
   * from 416 errors from out-of-spec WRT range request servers.  Notably Globus.
   * * *
   * @param url
   * @param options
   * @returns {Promise<unknown>}
   */
  async getContentLength(url, options2) {
    options2 = options2 || {};
    options2.method = "HEAD";
    options2.requestedHeaders = ["content-length"];
    const headerMap = await this._loadURL(url, options2);
    const contentLengthString = headerMap["content-length"];
    return contentLengthString ? Number.parseInt(contentLengthString) : 0;
  }
}
function isGoogleStorageSigned(url) {
  return url.indexOf("X-Goog-Signature") > -1;
}
async function fetchGoogleAccessToken(url) {
  if (isInitialized()) {
    const scope = getScopeForURL(url);
    const access_token = await getAccessToken(scope);
    return access_token;
  } else {
    throw Error(
      `Authorization is required, but Google oAuth has not been initalized. Contact your site administrator for assistance.`
    );
  }
}
function getCurrentGoogleAccessToken() {
  if (isInitialized()) {
    const access_token = getCurrentAccessToken();
    return access_token;
  } else {
    return void 0;
  }
}
function addOauthHeaders(headers, acToken) {
  if (acToken) {
    headers["Cache-Control"] = "no-cache";
    headers["Authorization"] = "Bearer " + acToken;
  }
  return headers;
}
function addApiKey(url) {
  let apiKey2 = igvxhr.apiKey;
  if (!apiKey2 && typeof gapi !== "undefined") {
    apiKey2 = gapi.apiKey;
  }
  if (apiKey2 !== void 0 && !url.includes("key=")) {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "key=" + apiKey2;
  }
  return url;
}
function addTeamDrive(url) {
  if (url.includes("supportsTeamDrive")) {
    return url;
  } else {
    const paramSeparator = url.includes("?") ? "&" : "?";
    url = url + paramSeparator + "supportsTeamDrive=true";
  }
}
function mapUrl$1(url) {
  if (url.startsWith("https://www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.startsWith("https://drive.google.com")) {
    return getDriveDownloadURL$1(url);
  } else if (url.includes("//www.broadinstitute.org/igvdata")) {
    return url.replace("//www.broadinstitute.org/igvdata", "//data.broadinstitute.org/igvdata");
  } else if (url.includes("//igvdata.broadinstitute.org")) {
    return url.replace("//igvdata.broadinstitute.org", "//s3.amazonaws.com/igv.broadinstitute.org");
  } else if (url.includes("//igv.genepattern.org")) {
    return url.replace("//igv.genepattern.org", "//igv-genepattern-org.s3.amazonaws.com");
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov/geo")) {
    return url.replace("ftp://", "https://");
  } else {
    return url;
  }
}
function arrayBufferToString(arraybuffer) {
  let plain;
  if (isgzipped(arraybuffer)) {
    plain = ungzip_blocks(arraybuffer);
  } else {
    plain = new Uint8Array(arraybuffer);
  }
  if ("TextDecoder" in getGlobalObject()) {
    return new TextDecoder().decode(plain);
  } else {
    return decodeUTF8(plain);
  }
}
function decodeUTF8(octets) {
  var string = "";
  var i = 0;
  while (i < octets.length) {
    var octet = octets[i];
    var bytesNeeded = 0;
    var codePoint = 0;
    if (octet <= 127) {
      bytesNeeded = 0;
      codePoint = octet & 255;
    } else if (octet <= 223) {
      bytesNeeded = 1;
      codePoint = octet & 31;
    } else if (octet <= 239) {
      bytesNeeded = 2;
      codePoint = octet & 15;
    } else if (octet <= 244) {
      bytesNeeded = 3;
      codePoint = octet & 7;
    }
    if (octets.length - i - bytesNeeded > 0) {
      var k = 0;
      while (k < bytesNeeded) {
        octet = octets[i + k + 1];
        codePoint = codePoint << 6 | octet & 63;
        k += 1;
      }
    } else {
      codePoint = 65533;
      bytesNeeded = octets.length - i;
    }
    string += String.fromCodePoint(codePoint);
    i += bytesNeeded + 1;
  }
  return string;
}
function getGlobalObject() {
  if (typeof self !== "undefined") {
    return self;
  }
  if (typeof global !== "undefined") {
    return global;
  } else {
    return window;
  }
}
const igvxhr = new IGVXhr2();
var BLACK = 1;
var RED = 2;
var NIL = {};
NIL.color = BLACK;
NIL.parent = NIL;
NIL.left = NIL;
NIL.right = NIL;
class IntervalTree {
  constructor() {
    this.root = NIL;
  }
  insert(start, end, value) {
    var interval = new Interval(start, end, value);
    var x = new Node$1(interval);
    this.treeInsert(x);
    x.color = RED;
    while (x !== this.root && x.parent.color === RED) {
      if (x.parent === x.parent.parent.left) {
        let y = x.parent.parent.right;
        if (y.color === RED) {
          x.parent.color = BLACK;
          y.color = BLACK;
          x.parent.parent.color = RED;
          x = x.parent.parent;
        } else {
          if (x === x.parent.right) {
            x = x.parent;
            leftRotate.call(this, x);
          }
          x.parent.color = BLACK;
          x.parent.parent.color = RED;
          rightRotate.call(this, x.parent.parent);
        }
      } else {
        let y = x.parent.parent.left;
        if (y.color === RED) {
          x.parent.color = BLACK;
          y.color = BLACK;
          x.parent.parent.color = RED;
          x = x.parent.parent;
        } else {
          if (x === x.parent.left) {
            x = x.parent;
            rightRotate.call(this, x);
          }
          x.parent.color = BLACK;
          x.parent.parent.color = RED;
          leftRotate.call(this, x.parent.parent);
        }
      }
    }
    this.root.color = BLACK;
  }
  /**
   *
   * @param start - query interval
   * @param end - query interval
   * @returns Array of all intervals overlapping the query region
   */
  findOverlapping(start, end) {
    var searchInterval = new Interval(start, end, 0);
    if (this.root === NIL) return [];
    var intervals = searchAll.call(this, searchInterval, this.root, []);
    if (intervals.length > 1) {
      intervals.sort(function(i1, i2) {
        return i1.low - i2.low;
      });
    }
    return intervals;
  }
  /**
   * Dump info on intervals to console.  For debugging.
   */
  logIntervals() {
    logNode(this.root, 0);
    function logNode(node, indent) {
      var space = "";
      for (var i = 0; i < indent; i++) space += " ";
      console.log(space + node.interval.low + " " + node.interval.high);
      indent += 5;
      if (node.left !== NIL) logNode(node.left, indent);
      if (node.right !== NIL) logNode(node.right, indent);
    }
  }
  mapIntervals(func) {
    applyInterval(this.root);
    function applyInterval(node) {
      func(node.interval);
      if (node.left !== NIL) applyInterval(node.left);
      if (node.right !== NIL) applyInterval(node.right);
    }
  }
  /**
   * Note:  Does not maintain RB constraints,  this is done post insert
   *
   * @param x  a Node
   */
  treeInsert(x) {
    var node = this.root;
    var y = NIL;
    while (node !== NIL) {
      y = node;
      if (x.interval.low <= node.interval.low) {
        node = node.left;
      } else {
        node = node.right;
      }
    }
    x.parent = y;
    if (y === NIL) {
      this.root = x;
      x.left = x.right = NIL;
    } else {
      if (x.interval.low <= y.interval.low) {
        y.left = x;
      } else {
        y.right = x;
      }
    }
    applyUpdate.call(this, x);
  }
}
function searchAll(interval, node, results) {
  if (node.interval.overlaps(interval)) {
    results.push(node.interval);
  }
  if (node.left !== NIL && node.left.max >= interval.low) {
    searchAll.call(this, interval, node.left, results);
  }
  if (node.right !== NIL && node.right.min <= interval.high) {
    searchAll.call(this, interval, node.right, results);
  }
  return results;
}
function leftRotate(x) {
  var y = x.right;
  x.right = y.left;
  if (y.left !== NIL) {
    y.left.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === NIL) {
    this.root = y;
  } else {
    if (x.parent.left === x) {
      x.parent.left = y;
    } else {
      x.parent.right = y;
    }
  }
  y.left = x;
  x.parent = y;
  applyUpdate.call(this, x);
}
function rightRotate(x) {
  var y = x.left;
  x.left = y.right;
  if (y.right !== NIL) {
    y.right.parent = x;
  }
  y.parent = x.parent;
  if (x.parent === NIL) {
    this.root = y;
  } else {
    if (x.parent.right === x) {
      x.parent.right = y;
    } else {
      x.parent.left = y;
    }
  }
  y.right = x;
  x.parent = y;
  applyUpdate.call(this, x);
}
function applyUpdate(node) {
  while (node !== NIL) {
    var nodeMax = node.left.max > node.right.max ? node.left.max : node.right.max;
    var intervalHigh = node.interval.high;
    node.max = nodeMax > intervalHigh ? nodeMax : intervalHigh;
    var nodeMin = node.left.min < node.right.min ? node.left.min : node.right.min;
    var intervalLow = node.interval.low;
    node.min = nodeMin < intervalLow ? nodeMin : intervalLow;
    node = node.parent;
  }
}
class Interval {
  constructor(low, high, value) {
    this.low = low;
    this.high = high;
    this.value = value;
  }
  equals(other) {
    if (!other) {
      return false;
    }
    if (this === other) {
      return true;
    }
    return this.low === other.low && this.high === other.high;
  }
  compareTo(other) {
    if (this.low < other.low)
      return -1;
    if (this.low > other.low)
      return 1;
    if (this.high < other.high)
      return -1;
    if (this.high > other.high)
      return 1;
    return 0;
  }
  /**
   * Returns true if this interval overlaps the other.
   */
  overlaps(other) {
    return this.low <= other.high && other.low <= this.high;
  }
}
function Node$1(interval) {
  this.parent = NIL;
  this.left = NIL;
  this.right = NIL;
  this.interval = interval;
  this.color = RED;
}
class FeatureCache$1 {
  constructor(featureList, genome, range) {
    featureList = featureList || [];
    this.treeMap = this.buildTreeMap(featureList, genome);
    this.range = range;
    this.count = featureList.length;
  }
  containsRange(genomicRange) {
    return this.range === void 0 || this.range.contains(genomicRange.chr, genomicRange.start, genomicRange.end);
  }
  queryFeatures(chr, start, end) {
    const tree = this.treeMap[chr];
    if (!tree) return [];
    const intervals = tree.findOverlapping(start, end);
    if (intervals.length === 0) {
      return [];
    } else {
      const featureList = [];
      const all = this.allFeatures[chr];
      if (all) {
        for (let interval of intervals) {
          const indexRange = interval.value;
          for (let i = indexRange.start; i < indexRange.end; i++) {
            let feature2 = all[i];
            if (feature2.start > end) break;
            else if (feature2.end >= start) {
              featureList.push(feature2);
            }
          }
        }
        featureList.sort(function(a, b) {
          return a.start - b.start;
        });
      }
      return featureList;
    }
  }
  /**
   * Returns all features, unsorted.
   *
   * @returns {Array}
   */
  getAllFeatures() {
    return this.allFeatures;
  }
  buildTreeMap(featureList, genome) {
    const treeMap = {};
    const chromosomes = [];
    this.allFeatures = {};
    if (featureList) {
      for (let feature2 of featureList) {
        let chr = feature2.chr;
        if (genome) {
          chr = genome.getChromosomeName(chr);
        }
        let geneList = this.allFeatures[chr];
        if (!geneList) {
          chromosomes.push(chr);
          geneList = [];
          this.allFeatures[chr] = geneList;
        }
        geneList.push(feature2);
      }
      for (let chr of chromosomes) {
        const chrFeatures = this.allFeatures[chr];
        chrFeatures.sort(function(f1, f2) {
          return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;
        });
        treeMap[chr] = buildIntervalTree$1(chrFeatures);
      }
    }
    return treeMap;
  }
}
function buildIntervalTree$1(featureList) {
  const tree = new IntervalTree();
  const len2 = featureList.length;
  const chunkSize = Math.max(10, Math.round(len2 / 10));
  for (let i = 0; i < len2; i += chunkSize) {
    const e = Math.min(len2, i + chunkSize);
    const subArray = new IndexRange(i, e);
    const iStart = featureList[i].start;
    let iEnd = iStart;
    for (let j = i; j < e; j++) {
      iEnd = Math.max(iEnd, featureList[j].end);
    }
    tree.insert(iStart, iEnd, subArray);
  }
  return tree;
}
class IndexRange {
  constructor(start, end) {
    this.start = start;
    this.end = end;
  }
}
const FeatureUtils = {
  packFeatures: function(features, maxRows, sorted) {
    var start;
    var end;
    if (!features) return;
    maxRows = maxRows || 1e4;
    if (!sorted) {
      features.sort(function(a, b) {
        return a.start - b.start;
      });
    }
    if (features.length === 0) {
      return [];
    } else {
      var bucketList = [], allocatedCount = 0, lastAllocatedCount = 0, nextStart, row, index2, bucket, feature2, gap = 2, bucketStart;
      start = features[0].start;
      end = features[features.length - 1].start;
      bucketStart = Math.max(start, features[0].start);
      nextStart = bucketStart;
      features.forEach(function(alignment) {
        var buckListIndex = Math.max(0, alignment.start - bucketStart);
        if (bucketList[buckListIndex] === void 0) {
          bucketList[buckListIndex] = [];
        }
        bucketList[buckListIndex].push(alignment);
      });
      row = 0;
      while (allocatedCount < features.length && row <= maxRows) {
        while (nextStart <= end) {
          bucket = void 0;
          while (!bucket && nextStart <= end) {
            index2 = nextStart - bucketStart;
            if (bucketList[index2] === void 0) {
              ++nextStart;
            } else {
              bucket = bucketList[index2];
            }
          }
          if (!bucket) {
            break;
          }
          feature2 = bucket.pop();
          if (0 === bucket.length) {
            bucketList[index2] = void 0;
          }
          feature2.row = row;
          nextStart = feature2.end + gap;
          ++allocatedCount;
        }
        row++;
        nextStart = bucketStart;
        if (allocatedCount === lastAllocatedCount) break;
        lastAllocatedCount = allocatedCount;
      }
    }
  },
  /**
   * Find features overlapping the given interval.  It is assumed that all features share the same chromosome.
   *
   * TODO -- significant overlap with FeatureCache, refactor to combine
   *
   * @param featureList
   * @param start
   * @param end
   */
  findOverlapping: function(featureList, start, end) {
    if (!featureList || featureList.length === 0) {
      return [];
    } else {
      const tree = buildIntervalTree(featureList);
      const intervals = tree.findOverlapping(start, end);
      if (intervals.length === 0) {
        return [];
      } else {
        featureList = [];
        intervals.forEach(function(interval) {
          const intervalFeatures = interval.value;
          const len2 = intervalFeatures.length;
          for (let i = 0; i < len2; i++) {
            const feature2 = intervalFeatures[i];
            if (feature2.start > end) break;
            else if (feature2.end > start) {
              featureList.push(feature2);
            }
          }
        });
        featureList.sort(function(a, b) {
          return a.start - b.start;
        });
        return featureList;
      }
    }
  }
};
function buildIntervalTree(featureList) {
  const tree = new IntervalTree();
  const len2 = featureList.length;
  const chunkSize = Math.max(10, Math.round(len2 / 100));
  featureList.sort(function(f1, f2) {
    return f1.start === f2.start ? 0 : f1.start > f2.start ? 1 : -1;
  });
  for (let i = 0; i < len2; i += chunkSize) {
    const e = Math.min(len2, i + chunkSize);
    const subArray = featureList.slice(i, e);
    const iStart = subArray[0].start;
    let iEnd = iStart;
    subArray.forEach(function(feature2) {
      iEnd = Math.max(iEnd, feature2.end);
    });
    tree.insert(iStart, iEnd, subArray);
  }
  return tree;
}
const appleCrayonRGBPalette = {
  cantaloupe: { r: 255, g: 206, b: 110 },
  honeydew: { r: 206, g: 250, b: 110 },
  spindrift: { r: 104, g: 251, b: 208 },
  sky: { r: 106, g: 207, b: 255 },
  lavender: { r: 210, g: 120, b: 255 },
  carnation: { r: 255, g: 127, b: 211 },
  licorice: { r: 0, g: 0, b: 0 },
  snow: { r: 255, g: 255, b: 255 },
  salmon: { r: 255, g: 114, b: 110 },
  banana: { r: 255, g: 251, b: 109 },
  flora: { r: 104, g: 249, b: 110 },
  ice: { r: 104, g: 253, b: 255 },
  orchid: { r: 110, g: 118, b: 255 },
  bubblegum: { r: 255, g: 122, b: 255 },
  lead: { r: 30, g: 30, b: 30 },
  mercury: { r: 232, g: 232, b: 232 },
  tangerine: { r: 255, g: 136, b: 2 },
  lime: { r: 131, g: 249, b: 2 },
  sea_foam: { r: 3, g: 249, b: 135 },
  aqua: { r: 0, g: 140, b: 255 },
  grape: { r: 137, g: 49, b: 255 },
  strawberry: { r: 255, g: 41, b: 135 },
  tungsten: { r: 58, g: 58, b: 58 },
  silver: { r: 208, g: 208, b: 208 },
  maraschino: { r: 255, g: 33, b: 1 },
  lemon: { r: 255, g: 250, b: 3 },
  spring: { r: 5, g: 248, b: 2 },
  turquoise: { r: 0, g: 253, b: 255 },
  blueberry: { r: 0, g: 46, b: 255 },
  magenta: { r: 255, g: 57, b: 255 },
  iron: { r: 84, g: 84, b: 83 },
  magnesium: { r: 184, g: 184, b: 184 },
  mocha: { r: 137, g: 72, b: 0 },
  fern: { r: 69, g: 132, b: 1 },
  moss: { r: 1, g: 132, b: 72 },
  ocean: { r: 0, g: 74, b: 136 },
  eggplant: { r: 73, g: 26, b: 136 },
  maroon: { r: 137, g: 22, b: 72 },
  steel: { r: 110, g: 110, b: 110 },
  aluminum: { r: 160, g: 159, b: 160 },
  cayenne: { r: 137, g: 17, b: 0 },
  aspargus: { r: 136, g: 133, b: 1 },
  clover: { r: 2, g: 132, b: 1 },
  teal: { r: 0, g: 134, b: 136 },
  midnight: { r: 0, g: 24, b: 136 },
  plum: { r: 137, g: 30, b: 136 },
  tin: { r: 135, g: 134, b: 135 },
  nickel: { r: 136, g: 135, b: 135 }
};
function appleCrayonRGB(name2) {
  const { r, g, b } = appleCrayonRGBPalette[name2];
  return `rgb(${r},${g},${b})`;
}
function appleCrayonRGBA(name2, alpha) {
  const { r, g, b } = appleCrayonRGBPalette[name2];
  return `rgba(${r},${g},${b},${alpha})`;
}
const colorPalettes = {
  Set1: [
    "rgb(228,26,28)",
    "rgb(55,126,184)",
    "rgb(77,175,74)",
    "rgb(166,86,40)",
    "rgb(152,78,163)",
    "rgb(255,127,0)",
    "rgb(247,129,191)",
    "rgb(153,153,153)",
    "rgb(255,255,51)"
  ],
  Dark2: [
    "rgb(27,158,119)",
    "rgb(217,95,2)",
    "rgb(117,112,179)",
    "rgb(231,41,138)",
    "rgb(102,166,30)",
    "rgb(230,171,2)",
    "rgb(166,118,29)",
    "rgb(102,102,102)"
  ],
  Set2: [
    "rgb(102, 194,165)",
    "rgb(252,141,98)",
    "rgb(141,160,203)",
    "rgb(231,138,195)",
    "rgb(166,216,84)",
    "rgb(255,217,47)",
    "rgb(229,196,148)",
    "rgb(179,179,179)"
  ],
  Set3: [
    "rgb(141,211,199)",
    "rgb(255,255,179)",
    "rgb(190,186,218)",
    "rgb(251,128,114)",
    "rgb(128,177,211)",
    "rgb(253,180,98)",
    "rgb(179,222,105)",
    "rgb(252,205,229)",
    "rgb(217,217,217)",
    "rgb(188,128,189)",
    "rgb(204,235,197)",
    "rgb(255,237,111)"
  ],
  Pastel1: [
    "rgb(251,180,174)",
    "rgb(179,205,227)",
    "rgb(204,235,197)",
    "rgb(222,203,228)",
    "rgb(254,217,166)",
    "rgb(255,255,204)",
    "rgb(229,216,189)",
    "rgb(253,218,236)"
  ],
  Pastel2: [
    "rgb(173,226,207)",
    "rgb(253,205,172)",
    "rgb(203,213,232)",
    "rgb(244,202,228)",
    "rgb(230,245,201)",
    "rgb(255,242,174)",
    "rgb(243,225,206)"
  ],
  Accent: [
    "rgb(127,201,127)",
    "rgb(190,174,212)",
    "rgb(253,192,134)",
    "rgb(255,255,153)",
    "rgb(56,108,176)",
    "rgb(240,2,127)",
    "rgb(191,91,23)"
  ]
};
class PaletteColorTable {
  constructor(palette) {
    this.colors = colorPalettes[palette];
    if (!Array.isArray(this.colors)) this.colors = [];
    this.colorTable = {};
    this.nextIdx = 0;
    this.colorGenerator = new RandomColorGenerator();
  }
  getColor(key) {
    if (!this.colorTable.hasOwnProperty(key)) {
      if (this.nextIdx < this.colors.length) {
        this.colorTable[key] = this.colors[this.nextIdx];
      } else {
        this.colorTable[key] = this.colorGenerator.get();
      }
      this.nextIdx++;
    }
    return this.colorTable[key];
  }
}
class ColorTable {
  constructor(colors) {
    this.colorTable = colors || {};
    this.nextIdx = 0;
    this.colorGenerator = new RandomColorGenerator();
  }
  getColor(key) {
    if (!this.colorTable.hasOwnProperty(key)) {
      if (this.colorTable.hasOwnProperty("*")) {
        return this.colorTable["*"];
      }
      this.colorTable[key] = this.colorGenerator.get();
    }
    return this.colorTable[key];
  }
}
function RandomColorGenerator() {
  this.hue = Math.random();
  this.goldenRatio = 0.618033988749895;
  this.hexwidth = 2;
}
RandomColorGenerator.prototype.hsvToRgb = function(h, s, v) {
  var h_i = Math.floor(h * 6), f = h * 6 - h_i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), r = 255, g = 255, b = 255;
  switch (h_i) {
    case 0:
      r = v, g = t, b = p;
      break;
    case 1:
      r = q, g = v, b = p;
      break;
    case 2:
      r = p, g = v, b = t;
      break;
    case 3:
      r = p, g = q, b = v;
      break;
    case 4:
      r = t, g = p, b = v;
      break;
    case 5:
      r = v, g = p, b = q;
      break;
  }
  return [Math.floor(r * 256), Math.floor(g * 256), Math.floor(b * 256)];
};
RandomColorGenerator.prototype.padHex = function(str) {
  if (str.length > this.hexwidth) return str;
  return new Array(this.hexwidth - str.length + 1).join("0") + str;
};
RandomColorGenerator.prototype.get = function(saturation, value) {
  this.hue += this.goldenRatio;
  this.hue %= 1;
  if (typeof saturation !== "number") saturation = 0.5;
  if (typeof value !== "number") value = 0.95;
  var rgb = this.hsvToRgb(this.hue, saturation, value);
  return "#" + this.padHex(rgb[0].toString(16)) + this.padHex(rgb[1].toString(16)) + this.padHex(rgb[2].toString(16));
};
function randomRGB$1(min, max) {
  min = IGVMath.clamp(min, 0, 255);
  max = IGVMath.clamp(max, 0, 255);
  const r = Math.round(Math.random() * (max - min) + min).toString(10);
  const g = Math.round(Math.random() * (max - min) + min).toString(10);
  const b = Math.round(Math.random() * (max - min) + min).toString(10);
  return `rgb(${r},${g},${b})`;
}
const IGVGraphics = {
  configureHighDPICanvas: function(ctx2, w, h) {
    const scaleFactor = window.devicePixelRatio;
    ctx2.canvas.style.width = `${w}px`;
    ctx2.canvas.width = Math.floor(scaleFactor * w);
    ctx2.canvas.style.height = `${h}px`;
    ctx2.canvas.height = Math.floor(scaleFactor * h);
    ctx2.scale(scaleFactor, scaleFactor);
  },
  setProperties: function(ctx2, properties) {
    for (var key in properties) {
      if (properties.hasOwnProperty(key)) {
        var value = properties[key];
        ctx2[key] = value;
      }
    }
  },
  strokeLine: function(ctx2, x1, y1, x2, y2, properties) {
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    x2 = Math.floor(x2) + 0.5;
    y2 = Math.floor(y2) + 0.5;
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    ctx2.beginPath();
    ctx2.moveTo(x1, y1);
    ctx2.lineTo(x2, y2);
    ctx2.stroke();
    if (properties) ctx2.restore();
  },
  fillRect: function(ctx2, x, y, w, h, properties) {
    x = Math.round(x);
    y = Math.round(y);
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    ctx2.fillRect(x, y, w, h);
    if (properties) ctx2.restore();
  },
  fillPolygon: function(ctx2, x, y, properties) {
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    doPath(ctx2, x, y);
    ctx2.fill();
    if (properties) ctx2.restore();
  },
  strokePolygon: function(ctx2, x, y, properties) {
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    doPath(ctx2, x, y);
    ctx2.stroke();
    if (properties) ctx2.restore();
  },
  fillText: function(ctx2, text2, x, y, properties, transforms) {
    if (properties || transforms) {
      ctx2.save();
    }
    if (properties) {
      IGVGraphics.setProperties(ctx2, properties);
    }
    if (transforms) {
      ctx2.translate(x, y);
      for (var transform in transforms) {
        var value = transforms[transform];
        if (transform === "translate") {
          ctx2.translate(value["x"], value["y"]);
        }
        if (transform === "rotate") {
          ctx2.rotate(value["angle"] * Math.PI / 180);
        }
      }
      ctx2.fillText(text2, 0, 0);
    } else {
      ctx2.fillText(text2, x, y);
    }
    if (properties || transforms) ctx2.restore();
  },
  strokeText: function(ctx2, text2, x, y, properties, transforms) {
    if (properties || transforms) {
      ctx2.save();
    }
    if (properties) {
      IGVGraphics.setProperties(ctx2, properties);
    }
    if (transforms) {
      ctx2.translate(x, y);
      for (var transform in transforms) {
        var value = transforms[transform];
        if (transform === "translate") {
          ctx2.translate(value["x"], value["y"]);
        }
        if (transform === "rotate") {
          ctx2.rotate(value["angle"] * Math.PI / 180);
        }
      }
      ctx2.strokeText(text2, 0, 0);
    } else {
      ctx2.strokeText(text2, x, y);
    }
    if (properties || transforms) ctx2.restore();
  },
  strokeCircle: function(ctx2, x, y, radius, properties) {
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    ctx2.beginPath();
    ctx2.arc(x, y, radius, 0, 2 * Math.PI);
    ctx2.stroke();
    if (properties) ctx2.restore();
  },
  fillCircle: function(ctx2, x, y, radius, properties) {
    if (properties) {
      ctx2.save();
      IGVGraphics.setProperties(ctx2, properties);
    }
    ctx2.beginPath();
    ctx2.arc(x, y, radius, 0, 2 * Math.PI);
    ctx2.fill();
    if (properties) ctx2.restore();
  },
  drawArrowhead: function(ctx2, x, y, size, lineWidth) {
    ctx2.save();
    if (!size) {
      size = 5;
    }
    if (lineWidth) {
      ctx2.lineWidth = lineWidth;
    }
    ctx2.beginPath();
    ctx2.moveTo(x, y - size / 2);
    ctx2.lineTo(x, y + size / 2);
    ctx2.lineTo(x + size, y);
    ctx2.lineTo(x, y - size / 2);
    ctx2.closePath();
    ctx2.fill();
    ctx2.restore();
  },
  dashedLine: function(ctx2, x1, y1, x2, y2, dashLen, properties = {}) {
    if (dashLen === void 0) dashLen = 2;
    ctx2.setLineDash([dashLen, dashLen]);
    IGVGraphics.strokeLine(ctx2, x1, y1, x2, y2, properties);
    ctx2.setLineDash([]);
  },
  roundRect: function(ctx2, x, y, width, height, radius, fill, stroke) {
    if (typeof stroke == "undefined") {
      stroke = true;
    }
    if (typeof radius === "undefined") {
      radius = 5;
    }
    ctx2.beginPath();
    ctx2.moveTo(x + radius, y);
    ctx2.lineTo(x + width - radius, y);
    ctx2.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx2.lineTo(x + width, y + height - radius);
    ctx2.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx2.lineTo(x + radius, y + height);
    ctx2.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx2.lineTo(x, y + radius);
    ctx2.quadraticCurveTo(x, y, x + radius, y);
    ctx2.closePath();
    if (stroke) {
      ctx2.stroke();
    }
    if (fill) {
      ctx2.fill();
    }
  },
  polygon: function(ctx2, x, y, fill, stroke) {
    if (typeof stroke == "undefined") {
      stroke = true;
    }
    ctx2.beginPath();
    var len2 = x.length;
    ctx2.moveTo(x[0], y[0]);
    for (var i = 1; i < len2; i++) {
      ctx2.lineTo(x[i], y[i]);
    }
    ctx2.closePath();
    if (stroke) {
      ctx2.stroke();
    }
    if (fill) {
      ctx2.fill();
    }
  },
  drawRandomColorVerticalLines: (ctx2) => {
    for (let x = 0; x < ctx2.canvas.width; x++) {
      IGVGraphics.fillRect(ctx2, x, 0, 1, ctx2.canvas.height, { fillStyle: randomRGB$1(100, 250) });
    }
  },
  labelTransformWithContext: (ctx2, exe) => {
    ctx2.translate(exe, 0);
    ctx2.scale(-1, 1);
    ctx2.translate(-exe, 0);
  }
};
function doPath(ctx2, x, y) {
  var i, len2 = x.length;
  for (i = 0; i < len2; i++) {
    x[i] = Math.round(x[i]);
    y[i] = Math.round(y[i]);
  }
  ctx2.beginPath();
  ctx2.moveTo(x[0], y[0]);
  for (i = 1; i < len2; i++) {
    ctx2.lineTo(x[i], y[i]);
  }
  ctx2.closePath();
}
let Alert$2 = class Alert2 {
  constructor(parent) {
    this.dialog = new AlertDialog$1(parent);
  }
  present(alert2, callback) {
    this.dialog.present(alert2, callback);
  }
};
const FileFormats = {
  gwascatalog: {
    fields: [
      "bin",
      "chr",
      "start",
      "end",
      "name",
      "pubMedID",
      "author",
      "pubDate",
      "journal",
      "title",
      "trait",
      "initSample",
      "replSample",
      "region",
      "genes",
      "riskAllele",
      "riskAlFreq",
      "pValue",
      "pValueDesc",
      "orOrBeta",
      "ci95",
      "platform",
      "cnv"
    ]
  },
  wgrna: {
    fields: [
      "bin",
      "chr",
      "start",
      "end",
      "name",
      "score",
      "strand",
      "thickStart",
      "thickEnd",
      "type"
    ]
  },
  cpgislandext: {
    fields: [
      "bin",
      "chr",
      "start",
      "end",
      "name",
      "length",
      "cpgNum",
      "gcNum",
      "perCpg",
      "perGc",
      "obsExp"
    ]
  },
  clinVarMain: {
    fields: [
      "chr1",
      "start",
      "end",
      "name",
      "score",
      "strand",
      "thickStart",
      "thickEnd",
      "reserved",
      "blockCount",
      // Number of blocks
      "blockSizes",
      // Comma separated list of block sizes
      "chromStarts",
      // Start positions relative to chromStart
      "origName",
      // NM_198053.2(CD247):c.462C>T (p.Asp154=)	ClinVar Variation Report
      "clinSign",
      // Likely benign	Clinical significance
      "reviewStatus",
      // 	based on: criteria provided,single submitter	Review Status
      "type",
      // single nucleotide variant	Type of Variant
      "geneId",
      // CD247	Gene Symbol
      "snpId",
      //	181656780	dbSNP ID
      "nsvId",
      //		dbVar ID
      "rcvAcc",
      //	RCV000642347	ClinVar Allele Submission
      "testedInGtr",
      //	N	Genetic Testing Registry
      "phenotypeList",
      //	Immunodeficiency due to defect in cd3-zeta	Phenotypes
      "phenotype",
      //	MedGen:C1857798, OMIM:610163	Phenotype identifiers
      "origin",
      //	germline	Data origin
      "assembly",
      //	GRCh37	Genome assembly
      "cytogenetic",
      //	1q24.2	Cytogenetic status
      "hgvsCod",
      //	NM_198053.2:c.462C>T	Nucleotide HGVS
      "hgvsProt",
      //	NP_932170.1:p.Asp154=	Protein HGVS
      "numSubmit",
      //	1	Number of submitters
      "lastEval",
      //	Dec 19,2017	Last evaluation
      "guidelines",
      //		Guidelines
      "otherIds"
    ]
  }
};
function isSimpleType(value) {
  const simpleTypes = /* @__PURE__ */ new Set(["boolean", "number", "string", "symbol"]);
  const valueType = typeof value;
  return value !== void 0 && (simpleTypes.has(valueType) || value.substring || value.toFixed);
}
function buildOptions$1(config, options2) {
  var defaultOptions = {
    oauthToken: config.oauthToken,
    headers: config.headers,
    withCredentials: config.withCredentials,
    filename: config.filename
  };
  return Object.assign(defaultOptions, options2);
}
const doAutoscale$1 = function(features) {
  var min, max;
  if (features && features.length > 0) {
    min = Number.MAX_VALUE;
    max = -Number.MAX_VALUE;
    for (let f of features) {
      if (!Number.isNaN(f.value)) {
        min = Math.min(min, f.value);
        max = Math.max(max, f.value);
      }
    }
    if (max > 0) min = Math.min(0, min);
    if (max < 0) max = 0;
  } else {
    min = 0;
    max = 100;
  }
  return { min, max };
};
const validateGenomicExtent = function(chromosomeLengthBP, genomicExtent, minimumBP) {
  let ss = genomicExtent.start;
  let ee = genomicExtent.end;
  if (void 0 === ee) {
    ss -= minimumBP / 2;
    ee = ss + minimumBP;
    if (ee > chromosomeLengthBP) {
      ee = chromosomeLengthBP;
      ss = ee - minimumBP;
    } else if (ss < 0) {
      ss = 0;
      ee = minimumBP;
    }
  } else if (ee - ss < minimumBP) {
    const center = (ee + ss) / 2;
    if (center - minimumBP / 2 < 0) {
      ss = 0;
      ee = ss + minimumBP;
    } else if (center + minimumBP / 2 > chromosomeLengthBP) {
      ee = chromosomeLengthBP;
      ss = ee - minimumBP;
    } else {
      ss = center - minimumBP / 2;
      ee = ss + minimumBP;
    }
  }
  genomicExtent.start = Math.ceil(ss);
  genomicExtent.end = Math.floor(ee);
};
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
const isNumber = function(num) {
  if (typeof num === "number") {
    return num - num === 0;
  }
  if (typeof num === "string" && num.trim() !== "") {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};
async function getFilename$1(url) {
  if (isString$2(url) && url.startsWith("https://drive.google.com")) {
    if (getApiKey() === void 0) {
      throw Error("Google drive is referenced, but API key is not defined.  An API key is required for Google Drive access");
    }
    const json = await getDriveFileInfo(url);
    return json.originalFileName || json.name;
  } else {
    return getFilename$2(url);
  }
}
function prettyBasePairNumber(raw) {
  var denom, units, value, floored;
  if (raw > 1e7) {
    denom = 1e6;
    units = " mb";
  } else if (raw > 1e4) {
    denom = 1e3;
    units = " kb";
    value = raw / denom;
    floored = Math.floor(value);
    return numberFormatter$1(floored) + units;
  } else {
    return numberFormatter$1(raw) + " bp";
  }
  value = raw / denom;
  floored = Math.floor(value);
  return floored.toString() + units;
}
function isDataURL(obj) {
  return isString$2(obj) && obj.startsWith("data:");
}
function createColumn(columnContainer, className) {
  const column = domUtils$1.div({ class: className });
  columnContainer.appendChild(column);
}
function insertElementBefore(element, referenceNode) {
  referenceNode.parentNode.insertBefore(element, referenceNode);
}
function insertElementAfter(element, referenceNode) {
  referenceNode.parentNode.insertBefore(element, referenceNode.nextSibling);
}
function isSecureContext() {
  return window.location.protocol === "https:" || window.location.hostname === "localhost";
}
function getElementAbsoluteHeight(element) {
  element = typeof element === "string" ? document.querySelector(element) : element;
  const styles = window.getComputedStyle(element);
  const margin = parseFloat(styles["marginTop"]) + parseFloat(styles["marginBottom"]);
  const height = element.offsetHeight;
  return Math.ceil(margin + height);
}
function decodeBedpe(tokens, header) {
  if (tokens.length < 6) {
    console.log("Skipping line: " + tokens.join(" "));
    return void 0;
  }
  var feature2 = {
    chr1: tokens[0],
    start1: Number.parseInt(tokens[1]),
    end1: Number.parseInt(tokens[2]),
    chr2: tokens[3],
    start2: Number.parseInt(tokens[4]),
    end2: Number.parseInt(tokens[5])
  };
  if (isNaN(feature2.start1) || isNaN(feature2.end1) || isNaN(feature2.start2) || isNaN(feature2.end2)) {
    return void 0;
  }
  if (header && header.hiccups === void 0) {
    header.hiccups = header.columnNames ? isHiccups(header.columnNames) : false;
  }
  const hiccups = header && header.hiccups;
  const stdColumns = hiccups ? 6 : 10;
  if (!hiccups) {
    if (tokens.length > 6 && tokens[6] !== ".") {
      feature2.name = tokens[6];
    }
    if (tokens.length > 7 && tokens[7] !== ".") {
      feature2.score = Number(tokens[7]);
    }
    if (tokens.length > 8 && tokens[8] !== ".") {
      feature2.strand1 = tokens[8];
    }
    if (tokens.length > 9 && tokens[9] !== ".") {
      feature2.strand2 = tokens[9];
    }
  }
  if (header) {
    const colorColumn = header.colorColumn;
    if (colorColumn && colorColumn < tokens.length) {
      feature2.color = IGVColor.createColorString(tokens[colorColumn]);
    }
    const thicknessColumn = header.thicknessColumn;
    if (thicknessColumn && thicknessColumn < tokens.length) {
      feature2.thickness = tokens[thicknessColumn];
    }
    if (tokens.length > stdColumns && header.columnNames && header.columnNames.length === tokens.length) {
      feature2.extras = tokens.slice(stdColumns);
    }
  }
  if (feature2.chr1 === feature2.chr2) {
    feature2.chr = feature2.chr1;
    feature2.start = Math.min(feature2.start1, feature2.start2);
    feature2.end = Math.max(feature2.end1, feature2.end2);
  }
  return feature2;
}
function fixBedPE(features) {
  if (features.length == 0) return;
  const firstFeature = features[0];
  if (firstFeature.score === void 0 && firstFeature.name !== void 0) {
    for (let f of features) {
      if (!(isNumber(f.name) || f.name === ".")) return;
    }
    for (let f of features) {
      f.score = Number(f.name);
      delete f.name;
    }
  }
  const interChrFeatures = features.filter((f) => f.chr1 !== f.chr2);
  for (let f1 of interChrFeatures) {
    const f2 = Object.assign({}, f1);
    f2.dup = true;
    features.push(f2);
    f1.chr = f1.chr1;
    f1.start = f1.start1;
    f1.end = f1.end1;
    f2.chr = f2.chr2;
    f2.start = f2.start2;
    f2.end = f2.end2;
  }
}
function decodeBedpeDomain(tokens, header) {
  if (tokens.length < 8) return void 0;
  return {
    chr: tokens[0],
    start: Number.parseInt(tokens[1]),
    end: Number.parseInt(tokens[2]),
    color: IGVColor.createColorString(tokens[6]),
    value: Number(tokens[7])
  };
}
function isHiccups(columns) {
  return columns && (columns.includes("fdrDonut") || columns.includes("fdr_donut"));
}
const knownFileExtensions = /* @__PURE__ */ new Set([
  "narrowpeak",
  "broadpeak",
  "regionpeak",
  "peaks",
  "bedgraph",
  "wig",
  "gff3",
  "gff",
  "gtf",
  "fusionjuncspan",
  "refflat",
  "seg",
  "aed",
  "bed",
  "vcf",
  "bb",
  "bigbed",
  "biginteract",
  "biggenepred",
  "bignarrowpeak",
  "bw",
  "bigwig",
  "bam",
  "tdf",
  "refgene",
  "genepred",
  "genepredext",
  "bedpe",
  "bp",
  "snp",
  "rmsk",
  "cram",
  "gwas",
  "maf",
  "mut",
  "tsv",
  "hiccups",
  "fasta",
  "fa",
  "fna",
  "pytor"
]);
function getFormat(name2) {
  if (FileFormats && FileFormats[name2]) {
    return expandFormat(FileFormats[name2]);
  } else {
    return void 0;
  }
  function expandFormat(format2) {
    const fields = format2.fields;
    const keys = ["chr", "start", "end"];
    for (let i = 0; i < fields.length; i++) {
      for (let key of keys) {
        if (key === fields[i]) {
          format2[key] = i;
        }
      }
    }
    return format2;
  }
}
function inferFileFormat(fn2) {
  var idx, ext;
  fn2 = fn2.toLowerCase();
  if (fn2.endsWith("refgene.txt.gz") || fn2.endsWith("refgene.txt.bgz") || fn2.endsWith("refgene.txt") || fn2.endsWith("refgene.sorted.txt.gz") || fn2.endsWith("refgene.sorted.txt.bgz")) {
    return "refgene";
  }
  idx = fn2.indexOf("?");
  if (idx > 0) {
    fn2 = fn2.substr(0, idx);
  }
  if (fn2.endsWith(".gz")) {
    fn2 = fn2.substr(0, fn2.length - 3);
  }
  if (fn2.endsWith(".txt") || fn2.endsWith(".tab") || fn2.endsWith(".bgz")) {
    fn2 = fn2.substr(0, fn2.length - 4);
  }
  idx = fn2.lastIndexOf(".");
  ext = idx < 0 ? fn2 : fn2.substr(idx + 1);
  switch (ext) {
    case "bw":
      return "bigwig";
    case "bb":
      return "bigbed";
    case "fasta":
    case "fa":
    case "fna":
      return "fasta";
    default:
      if (knownFileExtensions.has(ext)) {
        return ext;
      } else {
        return void 0;
      }
  }
}
function inferIndexPath(url, extension) {
  if (isString$2(url)) {
    if (url.includes("?")) {
      const idx = url.indexOf("?");
      return url.substring(0, idx) + "." + extension + url.substring(idx);
    } else {
      return url + "." + extension;
    }
  } else {
    return void 0;
  }
}
function inferTrackType(config) {
  translateDeprecatedTypes(config);
  if (config.type) {
    return config.type;
  }
  if (config.format) {
    const format2 = config.format.toLowerCase();
    switch (format2) {
      case "bw":
      case "bigwig":
      case "wig":
      case "bedgraph":
      case "tdf":
        return "wig";
      case "vcf":
        return "variant";
      case "seg":
        return "seg";
      case "mut":
      case "maf":
        return "mut";
      case "bam":
      case "cram":
        return "alignment";
      case "hiccups":
      case "bedpe":
      case "bedpe-loop":
      case "biginteract":
        return "interact";
      case "bp":
        return "arc";
      case "gwas":
        return "gwas";
      case "bed":
      case "bigbed":
      case "bb":
      case "biggenepred":
      case "bignarrowpeak":
        return "bedtype";
      case "fasta":
        return "sequence";
      case "pytor":
        return "cnvpytor";
      default:
        return "annotation";
    }
  }
}
function translateDeprecatedTypes(config) {
  if (config.featureType) {
    config.type = config.type || config.featureType;
    config.featureType = void 0;
  }
  if ("junctions" === config.type) {
    config.type = "junction";
  } else if ("bed" === config.type) {
    config.type = "annotation";
    config.format = config.format || "bed";
  } else if ("annotations" === config.type) {
    config.type = "annotation";
  } else if ("alignments" === config.type) {
    config.type = "alignment";
  } else if ("bam" === config.type) {
    config.type = "alignment";
    config.format = "bam";
  } else if ("vcf" === config.type) {
    config.type = "variant";
    config.format = "vcf";
  } else if ("t2d" === config.type) {
    config.type = "gwas";
  } else if ("FusionJuncSpan" === config.type && !config.format) {
    config.format = "fusionjuncspan";
  } else if ("aed" === config.type) {
    config.type = "annotation";
    config.format = config.format || "aed";
  }
}
async function inferFileFormatFromHeader(config) {
  if (config.url) {
    const firstBytes = await igvxhr.loadString(config.url, buildOptions$1(config, { range: { start: 0, size: 1e3 } }));
    if (firstBytes) {
      const columnNames = firstBytes.split("\n")[0].split("	");
      if (isHiccups(columnNames)) {
        return "hiccups";
      }
    }
  }
  return void 0;
}
function registerFileFormats(name2, fields) {
  FileFormats[name2] = { fields };
}
var TrackUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  knownFileExtensions,
  getFormat,
  inferFileFormat,
  inferFileFormatFromHeader,
  inferTrackType,
  inferIndexPath,
  registerFileFormats
});
const pairs = [
  ["A", "T"],
  ["G", "C"],
  ["Y", "R"],
  ["W", "S"],
  ["K", "M"],
  ["D", "H"],
  ["B", "V"]
];
const complements = /* @__PURE__ */ new Map();
for (let p of pairs) {
  const p1 = p[0];
  const p2 = p[1];
  complements.set(p1, p2);
  complements.set(p2, p1);
  complements.set(p1.toLowerCase(), p2.toLowerCase());
  complements.set(p2.toLowerCase(), p1.toLowerCase());
}
function reverseComplementSequence(sequence) {
  let comp = "";
  let idx = sequence.length;
  while (idx-- > 0) {
    const base = sequence[idx];
    comp += complements.has(base) ? complements.get(base) : base;
  }
  return comp;
}
class Chromosome {
  constructor(name2, order, bpLength) {
    this.name = name2;
    this.order = order;
    this.bpLength = bpLength;
  }
}
const splitLines$4 = splitLines$5;
const reservedProperties$1 = /* @__PURE__ */ new Set(["fastaURL", "indexURL", "cytobandURL", "indexed"]);
class NonIndexedFasta {
  constructor(reference) {
    this.fastaURL = reference.fastaURL;
    this.withCredentials = reference.withCredentials;
    this.chromosomeNames = [];
    this.chromosomes = {};
    this.sequences = /* @__PURE__ */ new Map();
    const config = {};
    for (let key in reference) {
      if (reference.hasOwnProperty(key) && !reservedProperties$1.has(key)) {
        config[key] = reference[key];
      }
    }
    this.config = config;
  }
  async init() {
    return this.loadAll();
  }
  async getSequence(chr, start, end) {
    if (!this.sequences.has(chr)) {
      return void 0;
    }
    let seqSlice = this.sequences.get(chr).find((ss) => ss.contains(start, end));
    if (!seqSlice) {
      seqSlice = this.sequences.get(chr).find((ss) => ss.overlaps(start, end));
      if (!seqSlice) {
        return void 0;
      }
    }
    start -= seqSlice.offset;
    end -= seqSlice.offset;
    let prefix = "";
    if (start < 0) {
      for (let i = start; i < Math.min(end, 0); i++) {
        prefix += "*";
      }
    }
    if (end <= 0) {
      return Promise.resolve(prefix);
    }
    const seq = seqSlice.sequence;
    const seqEnd = Math.min(end, seq.length);
    return prefix + seq.substring(start, seqEnd);
  }
  async loadAll() {
    let data;
    if (isDataURL(this.fastaURL)) {
      let bytes = decodeDataURI$1(this.fastaURL);
      data = "";
      for (let b of bytes) {
        data += String.fromCharCode(b);
      }
    } else {
      data = await igvxhr.load(this.fastaURL, buildOptions$1(this.config));
    }
    const chrNameSet = /* @__PURE__ */ new Set();
    const lines = splitLines$4(data);
    const len2 = lines.length;
    let lineNo = 0;
    let order = 0;
    let nextLine2;
    let current = {};
    while (lineNo < len2) {
      nextLine2 = lines[lineNo++].trim();
      if (nextLine2.startsWith("#") || nextLine2.length === 0) ;
      else if (nextLine2.startsWith(">")) {
        if (current && current.seq) {
          pushChromosome.call(this, current, order++);
        }
        const parts = nextLine2.substr(1).split(/\s+/);
        const nameParts = parts[0].split(":");
        current.chr = nameParts[0];
        current.seq = "";
        current.offset = 0;
        if (nameParts.length > 1 && nameParts[1].indexOf("-") > 0) {
          const locusParts = nameParts[1].split("-");
          if (locusParts.length === 2 && /^[0-9]+$/.test(locusParts[0]) && /^[0-9]+$/.test(locusParts[1])) ;
          const from = Number.parseInt(locusParts[0]);
          const to = Number.parseInt(locusParts[1]);
          if (to > from) {
            current.offset = from - 1;
          }
          if (parts.length > 1 && parts[1].startsWith("@len=")) {
            try {
              current.length = parseInt(parts[1].trim().substring(5));
            } catch (e) {
              current.length = void 0;
              console.error(`Error parsing sequence length for ${nextLine2}`);
            }
          } else {
            current.length = void 0;
          }
        }
      } else {
        current.seq += nextLine2;
      }
      if (current && current.seq) {
        pushChromosome.call(this, current, order);
      }
    }
    function pushChromosome(current2, order2) {
      const length = current2.length || current2.offset + current2.seq.length;
      if (!chrNameSet.has(current2.chr)) {
        this.chromosomeNames.push(current2.chr);
        this.sequences.set(current2.chr, []);
        this.chromosomes[current2.chr] = new Chromosome(current2.chr, order2, length);
        chrNameSet.add(current2.chr);
      } else {
        const c = this.chromosomes[current2.chr];
        c.bpLength = Math.max(c.bpLength, length);
      }
      this.sequences.get(current2.chr).push(new SequenceSlice(current2.offset, current2.seq));
    }
  }
}
class SequenceSlice {
  constructor(offset2, sequence) {
    this.offset = offset2;
    this.sequence = sequence;
  }
  contains(start, end) {
    return this.offset <= start && this.end >= end;
  }
  overlaps(start, end) {
    return this.offset < end && this.end > start;
  }
  get end() {
    return this.offset + this.sequence.length;
  }
}
const GenomicInterval = function(chr, start, end, features) {
  this.chr = chr;
  this.start = start;
  this.end = end;
  this.features = features;
};
GenomicInterval.prototype.contains = function(chr, start, end) {
  return this.chr === chr && this.start <= start && this.end >= end;
};
GenomicInterval.prototype.containsRange = function(range) {
  return this.chr === range.chr && this.start <= range.start && this.end >= range.end;
};
const splitLines$3 = splitLines$5;
const reservedProperties = /* @__PURE__ */ new Set(["fastaURL", "indexURL", "compressedIndexURL", "cytobandURL", "indexed"]);
class FastaSequence {
  constructor(reference) {
    this.file = reference.fastaURL;
    this.indexFile = reference.indexURL || reference.indexFile || this.file + ".fai";
    this.compressedIndexFile = reference.compressedIndexURL || false;
    this.withCredentials = reference.withCredentials;
    this.chromosomeNames = [];
    this.chromosomes = {};
    this.sequences = {};
    this.offsets = {};
    const config = {};
    for (let key in reference) {
      if (reference.hasOwnProperty(key) && !reservedProperties.has(key)) {
        config[key] = reference[key];
      }
    }
    this.config = config;
  }
  async init() {
    return this.getIndex();
  }
  async getSequence(chr, start, end) {
    const hasCachedSquence = this.interval && this.interval.contains(chr, start, end);
    if (!hasCachedSquence) {
      let qstart = start;
      let qend = end;
      if (end - start < 5e4) {
        const w = end - start;
        const center = Math.round(start + w / 2);
        qstart = Math.max(0, center - 25e3);
        qend = center + 25e3;
      }
      const seqBytes = await this.readSequence(chr, qstart, qend);
      this.interval = new GenomicInterval(chr, qstart, qend, seqBytes);
    }
    const offset2 = start - this.interval.start;
    const n = end - start;
    const seq = this.interval.features ? this.interval.features.substr(offset2, n) : null;
    return seq;
  }
  async getIndex() {
    if (this.index) {
      return this.index;
    } else {
      const data = await igvxhr.load(this.indexFile, buildOptions$1(this.config));
      const lines = splitLines$3(data);
      const len2 = lines.length;
      let lineNo = 0;
      let order = 0;
      this.index = {};
      while (lineNo < len2) {
        const tokens = lines[lineNo++].split("	");
        const nTokens = tokens.length;
        if (nTokens === 5) {
          const chr = tokens[0];
          const size = parseInt(tokens[1]);
          const position = parseInt(tokens[2]);
          const basesPerLine = parseInt(tokens[3]);
          const bytesPerLine = parseInt(tokens[4]);
          const indexEntry = {
            size,
            position,
            basesPerLine,
            bytesPerLine
          };
          this.chromosomeNames.push(chr);
          this.index[chr] = indexEntry;
          this.chromosomes[chr] = new Chromosome(chr, order++, size);
        }
      }
      return this.index;
    }
  }
  //Code is losely based on https://github.com/GMOD/bgzf-filehandle
  //Reworked however in orde to work with the igvxhr interface for loading files
  //Additionally, replaced calls to the Long.js interface with standard JS calls for ArrayBuffers and the associated views
  //
  //The compressed index is an array of blocks, with each block being a pair: compressed-position & uncompressed-position (both in bytes)
  async getCompressedIndex() {
    const GZI_NUM_BYTES_OFFSET = 8;
    const GZI_NUM_BYTES_BLOCK = 8;
    if (this.compressedIndex) {
      return this.compressedIndex;
    }
    if (!this.compressedIndexFile) {
      this.compressedIndex = [];
      return this.compressedIndex;
    }
    this.compressedIndex = [];
    const gziData = await igvxhr.loadArrayBuffer(this.compressedIndexFile, buildOptions$1(this.config));
    const givenFileSize = gziData.byteLength;
    if (givenFileSize < GZI_NUM_BYTES_OFFSET) {
      console.log("Cannot parse GZI index file: length (" + givenFileSize + " bytes) is insufficient to determine content of index.");
      return this.compressedIndex;
    }
    const numBlocksBuffer = gziData.slice(0, GZI_NUM_BYTES_OFFSET);
    const numBlocks = Number(new DataView(numBlocksBuffer).getBigUint64(0, true));
    const expectedFileSize = GZI_NUM_BYTES_OFFSET + numBlocks * 2 * GZI_NUM_BYTES_BLOCK;
    if (givenFileSize != expectedFileSize) {
      console.log("Incorrect file size of reference genome index. Expected : " + expectedFileSize + ". Received : " + givenFileSize);
      return this.compressedIndex;
    }
    this.compressedIndex.push([0, 0]);
    for (let blockNumber = 0; blockNumber < numBlocks; blockNumber++) {
      const bufferBlockStart = GZI_NUM_BYTES_OFFSET + blockNumber * 2 * GZI_NUM_BYTES_BLOCK;
      const bufferBlockEnd = GZI_NUM_BYTES_OFFSET + blockNumber * 2 * GZI_NUM_BYTES_BLOCK + 2 * GZI_NUM_BYTES_BLOCK;
      const bufferBlock = gziData.slice(bufferBlockStart, bufferBlockEnd);
      const viewBlock = new DataView(bufferBlock);
      const compressedPosition = Number(viewBlock.getBigUint64(0, true));
      const uncompressedPosition = Number(viewBlock.getBigUint64(GZI_NUM_BYTES_BLOCK, true));
      this.compressedIndex.push([compressedPosition, uncompressedPosition]);
    }
    return this.compressedIndex;
  }
  //The Fasta-index gives a byte-position of the chromosomal sequences within the FASTA file.
  //These locations need to be remapped to the locations within the zipped reference genome, using the GZI index
  //This function provides this functionality by 
  //1) taking the indicated start/stop byte locations within the UNCOMPRESSED FASTA file
  //2) remapping these byte locations to the correct blocks (and associated positions) within the COMPRESSED FASTA file
  //Subsequently, the calling method can then extract the correct blocks from the compressed FASTA files and uncompressed the data
  async getRelevantCompressedBlockNumbers(queryPositionStart, queryPositionEnd) {
    const UNCOMPRESSED_POSITION = 1;
    if (queryPositionStart < 0 || queryPositionEnd < 0 || queryPositionEnd < queryPositionStart) {
      console.log("Incompatible query positions for reference-genome. Start:" + queryPositionStart + " | End:" + queryPositionEnd);
      return [];
    }
    await this.getCompressedIndex();
    let result = [];
    const lowestBlockNumber = 0;
    const highestBlockNumber = this.compressedIndex.length - 1;
    if (this.compressedIndex.length == 0) {
      console.log("Compressed index does not contain any content");
      return [];
    }
    if (queryPositionStart > this.compressedIndex[highestBlockNumber][UNCOMPRESSED_POSITION]) {
      return [highestBlockNumber];
    }
    let searchLow = lowestBlockNumber;
    let searchHigh = highestBlockNumber;
    let searchPosition = Math.floor(this.compressedIndex.length / 2);
    let maxIterations = this.compressedIndex.length + 1;
    let solutionFound = false;
    for (let iteration = 0; iteration < maxIterations; iteration++) {
      const searchUncompressedPosition = this.compressedIndex[searchPosition][UNCOMPRESSED_POSITION];
      const nextSearchUncompressedPosition = searchPosition < this.compressedIndex.length - 1 ? this.compressedIndex[searchPosition + 1][UNCOMPRESSED_POSITION] : Infinity;
      if (searchUncompressedPosition <= queryPositionStart && nextSearchUncompressedPosition > queryPositionStart) {
        solutionFound = true;
        break;
      } else if (searchUncompressedPosition < queryPositionStart) {
        searchLow = searchPosition + 1;
      } else {
        searchHigh = searchPosition - 1;
      }
      searchPosition = Math.ceil((searchHigh - searchLow) / 2) + searchLow;
    }
    if (!solutionFound) {
      console.log("No blocks within compressed index found that correspond with query positions " + queryPositionStart + "," + queryPositionEnd);
      console.log(this.compressedIndex);
      return [];
    }
    result.push(searchPosition);
    for (let blockIndex = searchPosition + 1; blockIndex < this.compressedIndex.length; blockIndex++) {
      result.push(blockIndex);
      const blockUncompressedPosition = this.compressedIndex[blockIndex][UNCOMPRESSED_POSITION];
      if (blockUncompressedPosition >= queryPositionEnd) {
        break;
      }
    }
    const finalRelevantBlock = result[result.length - 1];
    const finalIndexBlock = this.compressedIndex.length - 1;
    if (finalRelevantBlock === finalIndexBlock && this.compressedIndex[finalRelevantBlock][UNCOMPRESSED_POSITION] < queryPositionEnd) {
      result.push(-1);
    }
    return result;
  }
  //Load the content from the blockIndices.
  //This is done on a per-block basis
  //Content of the first block will be trimmed in order to match the expected offset
  async loadAndUncompressBlocks(blockIndices, startByte) {
    const COMPRESSED_POSITION = 0;
    const UNCOMPRESSED_POSITION = 1;
    await this.getCompressedIndex();
    if (blockIndices.length == 0) {
      return "";
    }
    let resultCache = Array(blockIndices.length - 1);
    for (let i = 0; i < blockIndices.length - 1; i++) {
      const currentBlockNumber = blockIndices[i];
      const currentBlockInfo = this.compressedIndex[currentBlockNumber];
      const currentBlockCompressedPosition = currentBlockInfo[COMPRESSED_POSITION];
      const nextBlockNumber = blockIndices[i + 1];
      let compressedBytes = [];
      if (nextBlockNumber != -1) {
        const nextBlockInfo = this.compressedIndex[nextBlockNumber];
        const nextBlockCompressedPosition = nextBlockInfo[COMPRESSED_POSITION];
        const compressedLength = nextBlockCompressedPosition - currentBlockCompressedPosition;
        compressedBytes = await igvxhr.loadArrayBuffer(this.file, buildOptions$1(this.config, {
          range: {
            start: currentBlockCompressedPosition,
            size: compressedLength
          }
        }));
      } else {
        compressedBytes = await igvxhr.loadArrayBuffer(this.file, buildOptions$1(this.config, {
          range: {
            start: currentBlockCompressedPosition
          }
        }));
      }
      const uncompressedBytes = await unbgzf(compressedBytes);
      resultCache[i] = uncompressedBytes;
    }
    let result = "";
    for (let i = 0; i < resultCache.length; i++) {
      for (let j = 0; j < resultCache[i].length; j++) {
        const c = String.fromCharCode(resultCache[i][j]);
        result = result + c;
      }
    }
    const firstBlockInfo = this.compressedIndex[blockIndices[0]];
    const offset2 = startByte - firstBlockInfo[UNCOMPRESSED_POSITION];
    result = result.substring(offset2);
    return result;
  }
  async readSequence(chr, qstart, qend) {
    await this.getIndex();
    await this.getCompressedIndex();
    const idxEntry = this.index[chr];
    if (!idxEntry) {
      console.log("No index entry for chr: " + chr);
      this.interval = new GenomicInterval(chr, qstart, qend, null);
      return null;
    }
    const start = Math.max(0, qstart);
    const end = Math.min(idxEntry.size, qend);
    const bytesPerLine = idxEntry.bytesPerLine;
    const basesPerLine = idxEntry.basesPerLine;
    const position = idxEntry.position;
    const nEndBytes = bytesPerLine - basesPerLine;
    const startLine = Math.floor(start / basesPerLine);
    const endLine = Math.floor(end / basesPerLine);
    const base0 = startLine * basesPerLine;
    const offset2 = start - base0;
    const startByte = position + startLine * bytesPerLine + offset2;
    const base1 = endLine * basesPerLine;
    const offset1 = end - base1;
    const endByte = position + endLine * bytesPerLine + offset1 - 1;
    const byteCount = endByte - startByte + 1;
    if (byteCount <= 0) {
      console.error("No sequence for " + chr + ":" + qstart + "-" + qend);
      return null;
    }
    let allBytes;
    if (!this.compressedIndexFile) {
      allBytes = await igvxhr.load(this.file, buildOptions$1(this.config, {
        range: {
          start: startByte,
          size: byteCount
        }
      }));
    } else {
      let relevantBlockIndices = await this.getRelevantCompressedBlockNumbers(startByte, endByte);
      if (relevantBlockIndices.length === 0) {
        console.log("No blocks in the compressed index that correspond with the requested byte positions (" + startByte + "," + endByte + ")");
        return null;
      }
      allBytes = await this.loadAndUncompressBlocks(relevantBlockIndices, startByte);
    }
    if (!allBytes) {
      return null;
    }
    let nBases, seqBytes = "", srcPos = 0, allBytesLength = allBytes.length;
    if (offset2 > 0) {
      nBases = Math.min(end - start, basesPerLine - offset2);
      seqBytes += allBytes.substr(srcPos, nBases);
      srcPos += nBases + nEndBytes;
    }
    while (srcPos < allBytesLength) {
      nBases = Math.min(basesPerLine, allBytesLength - srcPos);
      seqBytes += allBytes.substr(srcPos, nBases);
      srcPos += nBases + nEndBytes;
    }
    return seqBytes;
  }
}
const splitLines$2 = splitLines$5;
class ChromSizes {
  constructor(url) {
    this.url = url;
    this.chromosomeNames = [];
    this.chromosomes = {};
  }
  async init() {
    return this.loadAll();
  }
  async getSequence(chr, start, end) {
    return void 0;
  }
  async loadAll() {
    let data;
    if (isDataURL(this.url)) {
      let bytes = decodeDataURI$1(this.fastaURL);
      data = "";
      for (let b of bytes) {
        data += String.fromCharCode(b);
      }
    } else {
      data = await igvxhr.load(this.url, {});
    }
    this.chromosomeNames = [];
    this.chromosomes = {};
    const lines = splitLines$2(data);
    let order = 0;
    for (let nextLine2 of lines) {
      const tokens = nextLine2.split("	");
      this.chromosomeNames.push(tokens[0]);
      const chrLength = Number.parseInt(tokens[1]);
      const chromosome = new Chromosome(tokens[0], order++, chrLength);
      this.chromosomes[tokens[0]] = chromosome;
    }
  }
}
async function loadFasta(reference) {
  let fasta;
  if ("chromsizes" === reference.format) {
    fasta = new ChromSizes(reference.fastaURL);
  } else if (isDataURL(reference.fastaURL) || reference.indexed === false) {
    fasta = new NonIndexedFasta(reference);
  } else {
    fasta = new FastaSequence(reference);
  }
  await fasta.init();
  return fasta;
}
const defaultNucleotideColors = {
  "A": "rgb(  0, 200,   0)",
  "C": "rgb(  0,0,200)",
  "T": "rgb(255,0,0)",
  "G": "rgb(209,113,  5)",
  "N": "rgb(80,80,80)"
};
const defaultSequenceTrackOrder = Number.MIN_SAFE_INTEGER;
const translationDict = {
  "TTT": "F",
  "TTC": "F",
  "TTA": "L",
  "TTG": "L",
  "CTT": "L",
  "CTC": "L",
  "CTA": "L",
  "CTG": "L",
  "ATT": "I",
  "ATC": "I",
  "ATA": "I",
  "ATG": "M",
  "GTT": "V",
  "GTC": "V",
  "GTA": "V",
  "GTG": "V",
  "TCT": "S",
  "TCC": "S",
  "TCA": "S",
  "TCG": "S",
  "CCT": "P",
  "CCC": "P",
  "CCA": "P",
  "CCG": "P",
  "ACT": "T",
  "ACC": "T",
  "ACA": "T",
  "ACG": "T",
  "GCT": "A",
  "GCC": "A",
  "GCA": "A",
  "GCG": "A",
  "TAT": "Y",
  "TAC": "Y",
  "TAA": "STOP",
  "TAG": "STOP",
  "CAT": "H",
  "CAC": "H",
  "CAA": "Q",
  "CAG": "Q",
  "AAT": "N",
  "AAC": "N",
  "AAA": "K",
  "AAG": "K",
  "GAT": "D",
  "GAC": "D",
  "GAA": "E",
  "GAG": "E",
  "TGT": "C",
  "TGC": "C",
  "TGA": "STOP",
  "TGG": "W",
  "CGT": "R",
  "CGC": "R",
  "CGA": "R",
  "CGG": "R",
  "AGT": "S",
  "AGC": "S",
  "AGA": "R",
  "AGG": "R",
  "GGT": "G",
  "GGC": "G",
  "GGA": "G",
  "GGG": "G"
};
const complement = {};
const t1 = ["A", "G", "C", "T", "Y", "R", "W", "S", "K", "M", "D", "V", "H", "B", "N", "X"];
const t2 = ["T", "C", "G", "A", "R", "Y", "W", "S", "M", "K", "H", "B", "D", "V", "N", "X"];
for (let i = 0; i < t1.length; i++) {
  complement[t1[i]] = t2[i];
  complement[t1[i].toLowerCase()] = t2[i].toLowerCase();
}
const DEFAULT_HEIGHT = 25;
const TRANSLATED_HEIGHT = 115;
const SEQUENCE_HEIGHT = 15;
const FRAME_HEIGHT = 25;
const FRAME_BORDER = 5;
const BP_PER_PIXEL_THRESHOLD = 1 / 10;
const bppFeatureFetchThreshold = 10;
class SequenceTrack {
  constructor(config, browser) {
    this.config = config;
    this.browser = browser;
    this.type = "sequence";
    this.removable = config.removable === void 0 ? true : config.removable;
    this.name = config.name;
    this.id = config.id;
    this.sequenceType = config.sequenceType || "dna";
    this.disableButtons = false;
    this.order = config.order || defaultSequenceTrackOrder;
    this.ignoreTrackMenu = false;
    this.reversed = config.reversed === true;
    this.frameTranslate = config.frameTranslate === true;
    this.height = this.frameTranslate ? TRANSLATED_HEIGHT : DEFAULT_HEIGHT;
    if (config.url) {
      config.fastaURL = config.url;
    }
    if (!config.fastaURL) {
      this.id = config.id || "sequence";
    }
  }
  menuItemList() {
    return [
      {
        name: this.reversed ? "Forward" : "Reverse",
        click: () => {
          this.reversed = !this.reversed;
          this.trackView.repaintViews();
        }
      },
      {
        name: this.frameTranslate ? "Close Translation" : "Three-frame Translate",
        click: () => {
          this.frameTranslate = !this.frameTranslate;
          if (this.frameTranslate) {
            for (let vp of this.trackView.viewports) {
              vp.setContentHeight(TRANSLATED_HEIGHT);
            }
            this.trackView.setTrackHeight(TRANSLATED_HEIGHT);
          } else {
            for (let vp of this.trackView.viewports) {
              vp.setContentHeight(DEFAULT_HEIGHT);
            }
            this.trackView.setTrackHeight(DEFAULT_HEIGHT);
          }
          this.trackView.repaintViews();
        }
      }
    ];
  }
  contextMenuItemList(clickState) {
    const viewport = clickState.viewport;
    if (viewport.referenceFrame.bpPerPixel <= 1) {
      const pixelWidth = viewport.getWidth();
      const bpWindow = pixelWidth * viewport.referenceFrame.bpPerPixel;
      const chr = viewport.referenceFrame.chr;
      const start = Math.floor(viewport.referenceFrame.start);
      const end = Math.ceil(start + bpWindow);
      const items = [
        {
          label: this.reversed ? "View visible sequence (reversed)..." : "View visible sequence...",
          click: async () => {
            let seq = await this.browser.genome.sequence.getSequence(chr, start, end);
            if (!seq) {
              seq = "Unknown sequence";
            } else if (this.reversed) {
              seq = reverseComplementSequence(seq);
            }
            this.browser.alert.present(seq);
          }
        }
      ];
      if (isSecureContext()) {
        items.push({
          label: "Copy visible sequence",
          click: async () => {
            let seq = await this.browser.genome.sequence.getSequence(chr, start, end);
            if (!seq) {
              seq = "Unknown sequence";
            } else if (this.reversed) {
              seq = reverseComplementSequence(seq);
            }
            try {
              await navigator.clipboard.writeText(seq);
            } catch (e) {
              console.error(e);
              this.browser.alert.present(`error copying sequence to clipboard ${e}`);
            }
          }
        });
      }
      items.push("<hr/>");
      return items;
    } else {
      return void 0;
    }
  }
  translateSequence(seq) {
    const threeFrame = [[], [], []];
    for (let fNum of [0, 1, 2]) {
      let idx = fNum;
      while (seq.length - idx >= 3) {
        let st = seq.slice(idx, idx + 3);
        if (this.reversed) {
          st = st.split("").reverse().join("");
        }
        const aa = translationDict[st.toUpperCase()] || "";
        threeFrame[fNum].push({
          codons: st,
          aminoA: aa
        });
        idx += 3;
      }
    }
    return threeFrame;
  }
  /**
   * Return the source for sequence.  If an explicit fasta url is defined, use it, otherwise fetch sequence
   * from the current genome
   * *
   * @returns {Promise<WrappedFasta|*>}
   */
  async getSequenceSource() {
    if (this.config.fastaURL) {
      if (!this.fasta) {
        this.fasta = new WrappedFasta(this.config, this.browser.genome);
        await this.fasta.init();
      }
      return this.fasta;
    } else {
      return this.browser.genome.sequence;
    }
  }
  async getFeatures(chr, start, end, bpPerPixel) {
    start = Math.floor(start);
    end = Math.floor(end);
    if (bpPerPixel && bpPerPixel > bppFeatureFetchThreshold) {
      return null;
    } else {
      const sequenceSource = await this.getSequenceSource();
      const sequence = await sequenceSource.getSequence(chr, start, end);
      return {
        bpStart: start,
        sequence
      };
    }
  }
  draw(options2) {
    const ctx2 = options2.context;
    if (options2.features) {
      let sequence = options2.features.sequence;
      if (!sequence) {
        return;
      }
      if (this.reversed) {
        sequence = sequence.split("").map(function(cv) {
          return complement[cv];
        }).join("");
      }
      const sequenceBpStart = options2.features.bpStart;
      const bpEnd = 1 + options2.bpStart + options2.pixelWidth * options2.bpPerPixel;
      for (let bp = Math.floor(options2.bpStart); bp <= bpEnd; bp++) {
        const seqIdx = Math.floor(bp - sequenceBpStart);
        if (seqIdx >= 0 && seqIdx < sequence.length) {
          const offsetBP = bp - options2.bpStart;
          const aPixel = offsetBP / options2.bpPerPixel;
          const pixelWidth = 1 / options2.bpPerPixel;
          const baseLetter = sequence[seqIdx];
          const color = this.fillColor(baseLetter.toUpperCase());
          if (options2.bpPerPixel > BP_PER_PIXEL_THRESHOLD) {
            IGVGraphics.fillRect(ctx2, aPixel, FRAME_BORDER, pixelWidth, SEQUENCE_HEIGHT - FRAME_BORDER, { fillStyle: color });
          } else {
            const textPixel = aPixel + 0.5 * (pixelWidth - ctx2.measureText(baseLetter).width);
            if ("y" === options2.axis) {
              ctx2.save();
              IGVGraphics.labelTransformWithContext(ctx2, textPixel);
              IGVGraphics.strokeText(ctx2, baseLetter, textPixel, SEQUENCE_HEIGHT, { strokeStyle: color });
              ctx2.restore();
            } else {
              IGVGraphics.strokeText(ctx2, baseLetter, textPixel, SEQUENCE_HEIGHT, { strokeStyle: color });
            }
          }
        }
      }
      if (this.frameTranslate) {
        let y = SEQUENCE_HEIGHT + 2 * FRAME_BORDER;
        const translatedSequence = this.translateSequence(sequence);
        for (let fNum = 0; fNum < translatedSequence.length; fNum++) {
          const aaSequence = translatedSequence[fNum];
          for (let idx = 0; idx < aaSequence.length; idx++) {
            let color = 0 === idx % 2 ? "rgb(160,160,160)" : "rgb(224,224,224)";
            const cv = aaSequence[idx];
            const bpPos = sequenceBpStart + fNum + idx * 3;
            const bpOffset = bpPos - options2.bpStart;
            const p0 = Math.floor(bpOffset / options2.bpPerPixel);
            const p1 = Math.floor((bpOffset + 3) / options2.bpPerPixel);
            const pc = Math.round((p0 + p1) / 2);
            if (p1 < 0) {
              continue;
            } else if (p0 > options2.pixelWidth) {
              break;
            }
            let aaLabel = cv.aminoA;
            if (cv.aminoA.indexOf("STOP") > -1) {
              color = "rgb(255, 0, 0)";
              aaLabel = "STOP";
            } else if (cv.aminoA === "M") {
              color = "rgb(0, 153, 0)";
              aaLabel = "START";
            }
            IGVGraphics.fillRect(ctx2, p0, y, p1 - p0, FRAME_HEIGHT, { fillStyle: color });
            if (options2.bpPerPixel <= 1 / 10) {
              IGVGraphics.strokeText(ctx2, aaLabel, pc - ctx2.measureText(aaLabel).width / 2, y + 15);
            }
          }
          y += FRAME_HEIGHT + FRAME_BORDER;
        }
      }
    }
  }
  get supportsWholeGenome() {
    return false;
  }
  computePixelHeight(ignore) {
    this.height = this.frameTranslate ? TRANSLATED_HEIGHT : DEFAULT_HEIGHT;
    return this.height;
  }
  fillColor(index2) {
    if (this.color) {
      return this.color;
    } else if ("dna" === this.sequenceType) {
      return defaultNucleotideColors[index2] || "gray";
    } else {
      return "rgb(0, 0, 150)";
    }
  }
  /**
   * Return the current state of the track.  Used to create sessions and bookmarks.
   *
   * @returns {*|{}}
   */
  getState() {
    const config = {
      type: "sequence"
    };
    if (this.order !== defaultSequenceTrackOrder) {
      config.order = this.order;
    }
    if (this.reversed) {
      config.revealed = true;
    }
    return config;
  }
}
class WrappedFasta {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
  }
  async init() {
    this.fasta = await loadFasta(this.config);
    this.chrNameMap = /* @__PURE__ */ new Map();
    for (let name2 of this.fasta.chromosomeNames) {
      this.chrNameMap.set(this.genome.getChromosomeName(name2), name2);
    }
  }
  async getSequence(chr, start, end) {
    const chrName = this.chrNameMap.has(chr) ? this.chrNameMap.get(chr) : chr;
    return this.fasta.getSequence(chrName, start, end);
  }
}
class Viewport {
  constructor(trackView, viewportColumn, referenceFrame, width) {
    this.guid = domUtils$1.guid();
    this.trackView = trackView;
    this.referenceFrame = referenceFrame;
    this.browser = trackView.browser;
    this.$viewport = $$1('<div class="igv-viewport">');
    viewportColumn.appendChild(this.$viewport.get(0));
    if (trackView.track.height) {
      this.$viewport.get(0).style.height = `${trackView.track.height}px`;
    }
    if (trackView.track instanceof SequenceTrack) {
      this.alert = new AlertDialog$1(this.$viewport.get(0));
    }
    this.contentTop = 0;
    this.contentHeight = this.$viewport.height();
    this.$viewport.width(width);
    this.initializationHelper();
  }
  initializationHelper() {
  }
  showMessage(message) {
    if (!this.messageDiv) {
      this.messageDiv = document.createElement("div");
      this.messageDiv.className = "igv-viewport-message";
      this.$viewport.append($$1(this.messageDiv));
    }
    this.messageDiv.textContent = message;
    this.messageDiv.style.display = "inline-block";
  }
  hideMessage(message) {
    if (this.messageDiv)
      this.messageDiv.style.display = "none";
  }
  setTrackLabel(label) {
  }
  startSpinner() {
  }
  stopSpinner() {
  }
  checkZoomIn() {
    return true;
  }
  shift() {
  }
  setTop(contentTop) {
    this.contentTop = contentTop;
    this.$viewport.height();
  }
  async loadFeatures() {
    return void 0;
  }
  clearCache() {
  }
  async repaint() {
  }
  draw(drawConfiguration, features, roiFeatures) {
    console.log("Viewport - draw(drawConfiguration, features, roiFeatures)");
  }
  checkContentHeight(features) {
    let track = this.trackView.track;
    features = features || this.cachedFeatures;
    if ("FILL" === track.displayMode) {
      this.setContentHeight(this.$viewport.height());
    } else if (typeof track.computePixelHeight === "function") {
      if (features && features.length > 0) {
        let requiredContentHeight = track.computePixelHeight(features);
        let currentContentHeight = this.contentHeight;
        if (requiredContentHeight !== currentContentHeight) {
          this.setContentHeight(requiredContentHeight);
        }
      }
    }
  }
  getContentHeight() {
    return this.contentHeight;
  }
  setContentHeight(contentHeight) {
    this.contentHeight = contentHeight;
  }
  isLoading() {
    return false;
  }
  saveSVG() {
  }
  isVisible() {
    return this.$viewport.width();
  }
  setWidth(width) {
    this.$viewport.width(width);
  }
  getWidth() {
    return this.$viewport.width();
  }
  getContentTop() {
    return this.contentTop;
  }
  containsPosition(chr, position) {
    console.log("Viewport - containsPosition(chr, position)");
  }
  addMouseHandlers() {
  }
  removeMouseHandlers() {
  }
  /**
   * Called when the associated track is removed.  Do any needed cleanup here.
   */
  dispose() {
    if (this.popover) {
      this.popover.dispose();
    }
    this.$viewport.get(0).remove();
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
  }
}
/*!!
 *  Canvas 2 Svg v1.0.19
 *  A low level canvas to SVG converter. Uses a mock canvas context to build an SVG document.
 *
 *  Licensed under the MIT license:
 *  http://www.opensource.org/licenses/mit-license.php
 *
 *  Author:
 *  Kerry Liu
 *
 *  Copyright (c) 2014 Gliffy Inc.
 */
function format(str, args) {
  var keys = Object.keys(args), i;
  for (i = 0; i < keys.length; i++) {
    str = str.replace(new RegExp("\\{" + keys[i] + "\\}", "gi"), args[keys[i]]);
  }
  return str;
}
function randomString(holder) {
  var chars, randomstring, i;
  if (!holder) {
    throw new Error("cannot create a random attribute name for an undefined object");
  }
  chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
  randomstring = "";
  do {
    randomstring = "";
    for (i = 0; i < 12; i++) {
      randomstring += chars[Math.floor(Math.random() * chars.length)];
    }
  } while (holder[randomstring]);
  return randomstring;
}
function createNamedToNumberedLookup(items, radix) {
  var i, entity, lookup = {}, base10;
  items = items.split(",");
  radix = radix || 10;
  for (i = 0; i < items.length; i += 2) {
    entity = "&" + items[i + 1] + ";";
    base10 = parseInt(items[i], radix);
    lookup[entity] = "&#" + base10 + ";";
  }
  lookup["\\xa0"] = "&#160;";
  return lookup;
}
function getTextAnchor(textAlign) {
  var mapping = { "left": "start", "right": "end", "center": "middle", "start": "start", "end": "end" };
  return mapping[textAlign] || mapping.start;
}
function getDominantBaseline(textBaseline) {
  var mapping = {
    "alphabetic": "alphabetic",
    "hanging": "hanging",
    "top": "text-before-edge",
    "bottom": "text-after-edge",
    "middle": "central"
  };
  return mapping[textBaseline] || mapping.alphabetic;
}
function normalize(vector) {
  var len2 = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
  return [vector[0] / len2, vector[1] / len2];
}
function intersectRect(rect1, rect2) {
  return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
}
const namedEntities = createNamedToNumberedLookup(
  "50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro",
  32
);
const STYLES = {
  "strokeStyle": {
    svgAttr: "stroke",
    //corresponding svg attribute
    canvas: "#000000",
    //canvas default
    svg: "none",
    //svg default
    apply: "stroke"
    //apply on stroke() or fill()
  },
  "fillStyle": {
    svgAttr: "fill",
    canvas: "#000000",
    svg: null,
    //svg default is black, but we need to special case this to handle canvas stroke without fill
    apply: "fill"
  },
  "lineCap": {
    svgAttr: "stroke-linecap",
    canvas: "butt",
    svg: "butt",
    apply: "stroke"
  },
  "lineJoin": {
    svgAttr: "stroke-linejoin",
    canvas: "miter",
    svg: "miter",
    apply: "stroke"
  },
  "miterLimit": {
    svgAttr: "stroke-miterlimit",
    canvas: 10,
    svg: 4,
    apply: "stroke"
  },
  "lineWidth": {
    svgAttr: "stroke-width",
    canvas: 1,
    svg: 1,
    apply: "stroke"
  },
  "globalAlpha": {
    svgAttr: "opacity",
    canvas: 1,
    svg: 1,
    apply: "fill stroke"
  },
  "font": {
    //font converts to multiple svg attributes, there is custom logic for this
    canvas: "10px sans-serif"
  },
  "shadowColor": {
    canvas: "#000000"
  },
  "shadowOffsetX": {
    canvas: 0
  },
  "shadowOffsetY": {
    canvas: 0
  },
  "shadowBlur": {
    canvas: 0
  },
  "textAlign": {
    canvas: "start"
  },
  "textBaseline": {
    canvas: "alphabetic"
  },
  "lineDash": {
    svgAttr: "stroke-dasharray",
    canvas: [],
    svg: null,
    apply: "stroke"
  }
};
class CanvasGradient {
  constructor(gradientNode, ctx2) {
    this.__root = gradientNode;
    this.__ctx = ctx2;
  }
  /**
   * Adds a color stop to the gradient root
   */
  addColorStop(offset2, color) {
    var stop = this.__ctx.__createElement("stop"), regex, matches;
    stop.setAttribute("offset", offset2);
    if (color && color.indexOf("rgba") !== -1) {
      regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
      matches = regex.exec(color);
      stop.setAttribute("stop-color", format("rgb({r},{g},{b})", { r: matches[1], g: matches[2], b: matches[3] }));
      stop.setAttribute("stop-opacity", matches[4]);
    } else {
      stop.setAttribute("stop-color", color);
    }
    this.__root.appendChild(stop);
  }
}
class CanvasPattern {
  constructor(pattern, ctx2) {
    this.__root = pattern;
    this.__ctx = ctx2;
  }
}
class ctx {
  constructor(config) {
    if (!(this instanceof ctx)) {
      return new ctx(config);
    }
    this.config = config;
    this.width = config.width;
    this.height = config.height;
    this.enableMirroring = config.enableMirroring || false;
    this.canvas = this;
    this.__document = document;
    if (config.ctx) {
      this.__ctx = config.ctx;
    } else {
      this.__canvas = this.__document.createElement("canvas");
      this.__ctx = this.__canvas.getContext("2d");
    }
    this.isSVG = true;
    this.__setDefaultStyles();
    this.__stack = [this.__getStyleState()];
    this.__groupStack = [];
    this.__root = this.__createElement("svg");
    this.__root.setAttribute("width", this.width);
    this.__root.setAttribute("height", this.height);
    this.__root.setAttribute("overflow", "visible");
    if (config.viewbox) {
      const str = config.viewbox.x + " " + config.viewbox.y + " " + config.viewbox.width + " " + config.viewbox.height;
      this.__root.setAttribute("viewBox", str);
      this.viewbox = config.viewbox;
    }
    this.__ids = {};
    this.__defs = this.__createElement("defs");
    this.__root.appendChild(this.__defs);
    this.multiLocusGap = config.multiLocusGap;
    let backdropConfig = {
      id: "svg_output_backdrop",
      width: "100%",
      height: "100%",
      fill: config.backdropColor || "white"
    };
    let backdropRect = this.__createElement("rect", backdropConfig);
    this.__root.appendChild(backdropRect);
    this.__rootGroup = this.__createElement("g", { id: "root-group" });
    this.__root.appendChild(this.__rootGroup);
    this.__currentElement = this.__rootGroup;
  }
  setWidth(width) {
    this.width = width;
    this.__root.setAttribute("width", this.width);
    const str = this.config.viewbox.x + " " + this.config.viewbox.y + " " + width + " " + this.config.viewbox.height;
    this.__root.setAttribute("viewBox", str);
  }
  setHeight(height) {
    this.height = height;
    this.__root.setAttribute("height", this.height);
    const str = this.config.viewbox.x + " " + this.config.viewbox.y + " " + this.config.viewbox.width + " " + height;
    this.__root.setAttribute("viewBox", str);
  }
  /**
   * Creates the specified svg element
   * @private
   */
  __createElement(elementName, properties, resetFill) {
    if (typeof properties === "undefined") {
      properties = {};
    }
    let element = this.__document.createElementNS("http://www.w3.org/2000/svg", elementName);
    if (resetFill) {
      element.setAttribute("fill", "none");
      element.setAttribute("stroke", "none");
    }
    for (let key of Object.keys(properties)) {
      element.setAttribute(key, properties[key]);
    }
    return element;
  }
  /**
   * Applies default canvas styles to the context
   * @private
   */
  __setDefaultStyles() {
    var keys = Object.keys(STYLES), i, key;
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      this[key] = STYLES[key].canvas;
    }
  }
  /**
   * Applies styles on restore
   * @param styleState
   * @private
   */
  __applyStyleState(styleState) {
    var keys = Object.keys(styleState), i, key;
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      this[key] = styleState[key];
    }
  }
  /**
   * Gets the current style state
   * @return {Object}
   * @private
   */
  __getStyleState() {
    var i, styleState = {}, keys = Object.keys(STYLES), key;
    for (i = 0; i < keys.length; i++) {
      key = keys[i];
      styleState[key] = this[key];
    }
    return styleState;
  }
  /**
   * Apples the current styles to the current SVG element. On "ctx.fill" or "ctx.stroke"
   * @param type
   * @private
   */
  __applyStyleToCurrentElement(type) {
    var currentElement = this.__currentElement;
    var currentStyleGroup = this.__currentElementsToStyle;
    if (currentStyleGroup) {
      currentElement.setAttribute(type, "");
      currentElement = currentStyleGroup.element;
      currentStyleGroup.children.forEach(function(node) {
        node.setAttribute(type, "");
      });
    }
    var keys = Object.keys(STYLES), i, style, value, id, regex, matches;
    for (i = 0; i < keys.length; i++) {
      style = STYLES[keys[i]];
      value = this[keys[i]];
      if (style.apply) {
        if (value instanceof CanvasPattern) {
          if (value.__ctx) {
            while (value.__ctx.__defs.childNodes.length) {
              id = value.__ctx.__defs.childNodes[0].getAttribute("id");
              this.__ids[id] = id;
              this.__defs.appendChild(value.__ctx.__defs.childNodes[0]);
            }
          }
          currentElement.setAttribute(style.apply, format("url(#{id})", { id: value.__root.getAttribute("id") }));
        } else if (value instanceof CanvasGradient) {
          currentElement.setAttribute(style.apply, format("url(#{id})", { id: value.__root.getAttribute("id") }));
        } else if (style && style.apply.indexOf(type) !== -1 && style.svg !== value) {
          if ((style.svgAttr === "stroke" || style.svgAttr === "fill") && value && value.indexOf("rgba") !== -1) {
            regex = /rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d?\.?\d*)\s*\)/gi;
            matches = regex.exec(value);
            currentElement.setAttribute(style.svgAttr, format("rgb({r},{g},{b})", {
              r: matches[1],
              g: matches[2],
              b: matches[3]
            }));
            var opacity = matches[4];
            var globalAlpha = this.globalAlpha;
            if (globalAlpha != null) {
              opacity *= globalAlpha;
            }
            currentElement.setAttribute(style.svgAttr + "-opacity", opacity);
          } else {
            var attr = style.svgAttr;
            if (keys[i] === "globalAlpha") {
              attr = type + "-" + style.svgAttr;
              if (currentElement.getAttribute(attr)) {
                continue;
              }
            }
            currentElement.setAttribute(attr, value);
          }
        }
      }
    }
  }
  /**
   * Will return the closest group or svg node. May return the current element.
   * @private
   */
  __closestGroupOrSvg(node) {
    node = node || this.__currentElement;
    if (node.nodeName === "g" || node.nodeName === "svg") {
      return node;
    } else {
      return this.__closestGroupOrSvg(node.parentNode);
    }
  }
  /**
   * Returns the serialized value of the svg so far
   * @param fixNamedEntities - Standalone SVG doesn't support named entities, which document.createTextNode encodes.
   *                           If true, we attempt to find all named entities and encode it as a numeric entity.
   * @return serialized svg
   */
  getSerializedSvg(fixNamedEntities) {
    var serialized = new XMLSerializer().serializeToString(this.__root), keys, i, key, value, regexp;
    if (fixNamedEntities) {
      keys = Object.keys(namedEntities);
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        value = namedEntities[key];
        regexp = new RegExp(key, "gi");
        if (regexp.test(serialized)) {
          serialized = serialized.replace(regexp, value);
        }
      }
    }
    return serialized;
  }
  /**
   * Returns the root svg
   * @return
   */
  getSvg() {
    return this.__root;
  }
  /**
   * Will generate a group tag.
   */
  saveWithTranslationAndClipRect(id, tx, ty, width, height, clipYOffset) {
    const clip_id = `${id}_clip_rect`;
    let clipPath = this.__createElement("clipPath", { id: clip_id });
    this.__defs.appendChild(clipPath);
    const config = {
      x: "0",
      y: clipYOffset.toString(),
      width: width.toString(),
      height: height.toString()
    };
    clipPath.appendChild(this.__createElement("rect", config));
    const group = this.__createElement("g");
    group.setAttribute("transform", format("translate({x},{y})", { x: tx, y: ty }));
    group.setAttribute("clip-path", format("url(#{id})", { id: clip_id }));
    const parent = this.__closestGroupOrSvg();
    parent.appendChild(group);
    this.__groupStack.push(parent);
    this.__currentElement = group;
    this.__stack.push(this.__getStyleState());
  }
  save() {
    var group = this.__createElement("g");
    var parent = this.__closestGroupOrSvg();
    this.__groupStack.push(parent);
    parent.appendChild(group);
    this.__currentElement = group;
    this.__stack.push(this.__getStyleState());
  }
  /**
   * Sets current element to parent, or just root if already root
   */
  restore() {
    this.__currentElement = this.__groupStack.pop();
    this.__currentElementsToStyle = null;
    if (!this.__currentElement) {
      this.__currentElement = this.__root.childNodes[1];
    }
    var state = this.__stack.pop();
    this.__applyStyleState(state);
  }
  /**
   * Helper method to add transform
   * @private
   */
  __addTransform(t) {
    var parent = this.__closestGroupOrSvg();
    if (parent.childNodes.length > 0) {
      if (this.__currentElement.nodeName === "path") {
        if (!this.__currentElementsToStyle) this.__currentElementsToStyle = { element: parent, children: [] };
        this.__currentElementsToStyle.children.push(this.__currentElement);
        this.__applyCurrentDefaultPath();
      }
      var group = this.__createElement("g");
      parent.appendChild(group);
      this.__currentElement = group;
    }
    var transform = this.__currentElement.getAttribute("transform");
    if (transform) {
      transform += " ";
    } else {
      transform = "";
    }
    transform += t;
    this.__currentElement.setAttribute("transform", transform);
  }
  addTrackGroupWithTranslationAndClipRect(id, tx, ty, width, height, clipYOffset) {
    const clip_id = id + "_clip_rect";
    let clipPath = this.__createElement("clipPath", { id: clip_id });
    this.__defs.appendChild(clipPath);
    clipPath.appendChild(this.__createElement("rect", {
      x: "0",
      y: clipYOffset.toString(),
      width: width.toString(),
      height: height.toString()
    }));
    let group = this.__createElement("g");
    this.__rootGroup.appendChild(group);
    group.setAttribute("transform", format("translate({x},{y})", { x: tx, y: ty }));
    group.setAttribute("id", id + "_group");
    group.setAttribute("clip-path", format("url(#{id})", { id: clip_id }));
    this.__currentElement = group;
  }
  /**
   *  scales the current element
   */
  scale(x, y) {
    if (y === void 0) {
      y = x;
    }
    this.__addTransform(format("scale({x},{y})", { x, y }));
  }
  /**
   * rotates the current element
   */
  rotate(angle) {
    var degrees = angle * 180 / Math.PI;
    this.__addTransform(format("rotate({angle},{cx},{cy})", { angle: degrees, cx: 0, cy: 0 }));
  }
  /**
   * translates the current element
   */
  translate(x, y) {
    this.__addTransform(format("translate({x},{y})", { x, y }));
  }
  /**
   * applies a transform to the current element
   */
  transform(a, b, c, d, e, f) {
    this.__addTransform(format("matrix({a},{b},{c},{d},{e},{f})", { a, b, c, d, e, f }));
  }
  /**
   * Create a new Path Element
   */
  beginPath() {
    var path, parent;
    this.__currentDefaultPath = "";
    this.__currentPosition = {};
    path = this.__createElement("path", {}, true);
    parent = this.__closestGroupOrSvg();
    parent.appendChild(path);
    this.__currentElement = path;
  }
  /**
   * Helper function to apply currentDefaultPath to current path element
   * @private
   */
  __applyCurrentDefaultPath() {
    var currentElement = this.__currentElement;
    if (currentElement.nodeName === "path") {
      currentElement.setAttribute("d", this.__currentDefaultPath);
    } else {
      console.error("Attempted to apply path command to node", currentElement.nodeName);
    }
  }
  /**
   * Helper function to add path command
   * @private
   */
  __addPathCommand(command) {
    this.__currentDefaultPath += " ";
    this.__currentDefaultPath += command;
  }
  /**
   * Adds the move command to the current path element,
   * if the currentPathElement is not empty create a new path element
   */
  moveTo(x, y) {
    if (this.__currentElement.nodeName !== "path") {
      this.beginPath();
    }
    this.__currentPosition = { x, y };
    this.__addPathCommand(format("M {x} {y}", { x, y }));
  }
  /**
   * Closes the current path
   */
  closePath() {
    if (this.__currentDefaultPath) {
      this.__addPathCommand("Z");
    }
  }
  /**
   * Adds a line to command
   */
  lineTo(x, y) {
    this.__currentPosition = { x, y };
    if (this.__currentDefaultPath && this.__currentDefaultPath.indexOf("M") > -1) {
      this.__addPathCommand(format("L {x} {y}", { x, y }));
    } else {
      this.__addPathCommand(format("M {x} {y}", { x, y }));
    }
  }
  /**
   * Add a bezier command
   */
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.__currentPosition = { x, y };
    this.__addPathCommand(format(
      "C {cp1x} {cp1y} {cp2x} {cp2y} {x} {y}",
      { cp1x, cp1y, cp2x, cp2y, x, y }
    ));
  }
  /**
   * Adds a quadratic curve to command
   */
  quadraticCurveTo(cpx, cpy, x, y) {
    this.__currentPosition = { x, y };
    this.__addPathCommand(format("Q {cpx} {cpy} {x} {y}", { cpx, cpy, x, y }));
  }
  /**
   * Adds the arcTo to the current path
   *
   * @see http://www.w3.org/TR/2015/WD-2dcontext-20150514/#dom-context-2d-arcto
   */
  arcTo(x1, y1, x2, y2, radius) {
    var x0 = this.__currentPosition && this.__currentPosition.x;
    var y0 = this.__currentPosition && this.__currentPosition.y;
    if (typeof x0 == "undefined" || typeof y0 == "undefined") {
      return;
    }
    if (radius < 0) {
      throw new Error("IndexSizeError: The radius provided (" + radius + ") is negative.");
    }
    if (x0 === x1 && y0 === y1 || x1 === x2 && y1 === y2 || radius === 0) {
      this.lineTo(x1, y1);
      return;
    }
    var unit_vec_p1_p0 = normalize([x0 - x1, y0 - y1]);
    var unit_vec_p1_p2 = normalize([x2 - x1, y2 - y1]);
    if (unit_vec_p1_p0[0] * unit_vec_p1_p2[1] === unit_vec_p1_p0[1] * unit_vec_p1_p2[0]) {
      this.lineTo(x1, y1);
      return;
    }
    var cos = unit_vec_p1_p0[0] * unit_vec_p1_p2[0] + unit_vec_p1_p0[1] * unit_vec_p1_p2[1];
    var theta = Math.acos(Math.abs(cos));
    var unit_vec_p1_origin = normalize([
      unit_vec_p1_p0[0] + unit_vec_p1_p2[0],
      unit_vec_p1_p0[1] + unit_vec_p1_p2[1]
    ]);
    var len_p1_origin = radius / Math.sin(theta / 2);
    var x = x1 + len_p1_origin * unit_vec_p1_origin[0];
    var y = y1 + len_p1_origin * unit_vec_p1_origin[1];
    var unit_vec_origin_start_tangent = [
      -unit_vec_p1_p0[1],
      unit_vec_p1_p0[0]
    ];
    var unit_vec_origin_end_tangent = [
      unit_vec_p1_p2[1],
      -unit_vec_p1_p2[0]
    ];
    var getAngle = function(vector) {
      var x3 = vector[0];
      var y3 = vector[1];
      if (y3 >= 0) {
        return Math.acos(x3);
      } else {
        return -Math.acos(x3);
      }
    };
    var startAngle = getAngle(unit_vec_origin_start_tangent);
    var endAngle = getAngle(unit_vec_origin_end_tangent);
    this.lineTo(
      x + unit_vec_origin_start_tangent[0] * radius,
      y + unit_vec_origin_start_tangent[1] * radius
    );
    this.arc(x, y, radius, startAngle, endAngle);
  }
  /**
   * Sets the stroke property on the current element
   */
  stroke() {
    if (this.__currentElement.nodeName === "path") {
      this.__currentElement.setAttribute("paint-order", "fill stroke markers");
    }
    this.__applyCurrentDefaultPath();
    this.__applyStyleToCurrentElement("stroke");
  }
  /**
   * Sets fill properties on the current element
   */
  fill() {
    if (this.__currentElement.nodeName === "path") {
      this.__currentElement.setAttribute("paint-order", "stroke fill markers");
    }
    this.__applyCurrentDefaultPath();
    this.__applyStyleToCurrentElement("fill");
  }
  /**
   *  Adds a rectangle to the path.
   */
  rect(x, y, width, height) {
    if (this.__currentElement.nodeName !== "path") {
      this.beginPath();
    }
    this.moveTo(x, y);
    this.lineTo(x + width, y);
    this.lineTo(x + width, y + height);
    this.lineTo(x, y + height);
    this.lineTo(x, y);
    this.closePath();
  }
  /**
   * adds a rectangle element
   */
  fillRect(x, y, width, height) {
    if (height < 0) {
      y += height;
      height = -height;
    }
    if (width < 0) {
      x += width;
      width = -width;
    }
    var r2 = {
      x,
      y,
      width,
      height
    };
    if (this.viewbox) {
      if (!intersectRect(this.viewbox, r2)) {
        return;
      }
    }
    var rect, parent;
    rect = this.__createElement("rect", r2, true);
    parent = this.__closestGroupOrSvg();
    parent.appendChild(rect);
    this.__currentElement = rect;
    this.__applyStyleToCurrentElement("fill");
  }
  /**
   * Draws a rectangle with no fill
   * @param x
   * @param y
   * @param width
   * @param height
   */
  strokeRect(x, y, width, height) {
    var rect, parent;
    rect = this.__createElement("rect", {
      x,
      y,
      width,
      height
    }, true);
    parent = this.__closestGroupOrSvg();
    parent.appendChild(rect);
    this.__currentElement = rect;
    this.__applyStyleToCurrentElement("stroke");
  }
  // stroke ellipse
  strokeEllipse(cx, cy, rx, ry, rotation, startAngle, endAngle, isCCW) {
    this.__ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, isCCW, "stroke");
  }
  // fill ellipse
  fillEllipse(cx, cy, rx, ry, rotation, startAngle, endAngle, isCCW) {
    this.__ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, isCCW, "fill");
  }
  // ellipse helper
  __ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, isCCW, style) {
    const config = {
      cx,
      cy,
      rx,
      ry
    };
    const element = this.__createElement("ellipse", config, true);
    const parent = this.__closestGroupOrSvg();
    parent.appendChild(element);
    this.__currentElement = element;
    this.__applyStyleToCurrentElement(style);
  }
  /**
   * Clear entire canvas:
   * 1. save current transforms
   * 2. remove all the childNodes of the root g element
   */
  __clearCanvas() {
    var current = this.__closestGroupOrSvg(), transform = current.getAttribute("transform");
    var rootGroup = this.__root.childNodes[1];
    var childNodes = rootGroup.childNodes;
    for (var i = childNodes.length - 1; i >= 0; i--) {
      if (childNodes[i]) {
        rootGroup.removeChild(childNodes[i]);
      }
    }
    this.__currentElement = rootGroup;
    this.__groupStack = [];
    if (transform) {
      this.__addTransform(transform);
    }
  }
  /**
   * "Clears" a canvas by just drawing a white rectangle in the current group.
   */
  clearRect(x, y, width, height) {
    if (x === 0 && y === 0 && width === this.width && height === this.height) {
      this.__clearCanvas();
      return;
    }
    var rect, parent = this.__closestGroupOrSvg();
    rect = this.__createElement("rect", {
      x,
      y,
      width,
      height,
      fill: "#FFFFFF"
    }, true);
    parent.appendChild(rect);
  }
  /**
   * Adds a linear gradient to a defs tag.
   * Returns a canvas gradient object that has a reference to it's parent def
   */
  createLinearGradient(x1, y1, x2, y2) {
    var grad = this.__createElement("linearGradient", {
      id: randomString(this.__ids),
      x1: x1 + "px",
      x2: x2 + "px",
      y1: y1 + "px",
      y2: y2 + "px",
      "gradientUnits": "userSpaceOnUse"
    }, false);
    this.__defs.appendChild(grad);
    return new CanvasGradient(grad, this);
  }
  /**
   * Adds a radial gradient to a defs tag.
   * Returns a canvas gradient object that has a reference to it's parent def
   */
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    var grad = this.__createElement("radialGradient", {
      id: randomString(this.__ids),
      cx: x1 + "px",
      cy: y1 + "px",
      r: r1 + "px",
      fx: x0 + "px",
      fy: y0 + "px",
      "gradientUnits": "userSpaceOnUse"
    }, false);
    this.__defs.appendChild(grad);
    return new CanvasGradient(grad, this);
  }
  /**
   * Parses the font string and returns svg mapping
   * @private
   */
  __parseFont() {
    var regex = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-,\'\"\sa-z0-9]+?)\s*$/i;
    var fontPart = regex.exec(this.font);
    var data = {
      style: fontPart[1] || "normal",
      size: fontPart[4] || "10px",
      family: fontPart[6] || "sans-serif",
      weight: fontPart[3] || "normal",
      decoration: fontPart[2] || "normal",
      href: null
    };
    if (this.__fontUnderline === "underline") {
      data.decoration = "underline";
    }
    if (this.__fontHref) {
      data.href = this.__fontHref;
    }
    return data;
  }
  /**
   * Helper to link text fragments
   * @param font
   * @param element
   * @return {*}
   * @private
   */
  __wrapTextLink(font, element) {
    if (font.href) {
      var a = this.__createElement("a");
      a.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", font.href);
      a.appendChild(element);
      return a;
    }
    return element;
  }
  /**
   * Fills or strokes text
   * @param text
   * @param x
   * @param y
   * @param action - stroke or fill
   * @private
   */
  __applyText(text2, x, y, action) {
    var font = this.__parseFont(), parent = this.__closestGroupOrSvg(), textElement = this.__createElement("text", {
      "font-family": font.family,
      "font-size": font.size,
      "font-style": font.style,
      "font-weight": font.weight,
      "text-decoration": font.decoration,
      "x": x,
      "y": y,
      "text-anchor": getTextAnchor(this.textAlign),
      "dominant-baseline": getDominantBaseline(this.textBaseline)
    }, true);
    textElement.appendChild(this.__document.createTextNode(text2));
    this.__currentElement = textElement;
    this.__applyStyleToCurrentElement(action);
    parent.appendChild(this.__wrapTextLink(font, textElement));
  }
  /**
   * Creates a text element
   * @param text
   * @param x
   * @param y
   */
  fillText(text2, x, y) {
    this.__applyText(text2, x, y, "fill");
  }
  /**
   * Strokes text
   * @param text
   * @param x
   * @param y
   */
  strokeText(text2, x, y) {
    this.__applyText(text2, x, y, "stroke");
  }
  /**
   * No need to implement this for svg.
   * @param text
   * @return {TextMetrics}
   */
  measureText(text2) {
    this.__ctx.font = this.font;
    return this.__ctx.measureText(text2);
  }
  /**
   *  Arc command!
   */
  arc(x, y, radius, startAngle, endAngle, counterClockwise) {
    if (startAngle === endAngle) {
      return;
    }
    startAngle = startAngle % (2 * Math.PI);
    endAngle = endAngle % (2 * Math.PI);
    if (startAngle === endAngle) {
      endAngle = (endAngle + 2 * Math.PI - 1e-3 * (counterClockwise ? -1 : 1)) % (2 * Math.PI);
    }
    var endX = x + radius * Math.cos(endAngle), endY = y + radius * Math.sin(endAngle), startX = x + radius * Math.cos(startAngle), startY = y + radius * Math.sin(startAngle), sweepFlag = counterClockwise ? 0 : 1, largeArcFlag = 0, diff = endAngle - startAngle;
    if (diff < 0) {
      diff += 2 * Math.PI;
    }
    if (counterClockwise) {
      largeArcFlag = diff > Math.PI ? 0 : 1;
    } else {
      largeArcFlag = diff > Math.PI ? 1 : 0;
    }
    this.lineTo(startX, startY);
    this.__addPathCommand(format(
      "A {rx} {ry} {xAxisRotation} {largeArcFlag} {sweepFlag} {endX} {endY}",
      {
        rx: radius,
        ry: radius,
        xAxisRotation: 0,
        largeArcFlag,
        sweepFlag,
        endX,
        endY
      }
    ));
    this.__currentPosition = { x: endX, y: endY };
  }
  /**
   * The ellipse() method creates an elliptical arc centered at (x, y) with the radii radiusX and radiusY. The path
   * starts at startAngle and ends at endAngle, and travels in the direction given by counterclockwise (defaulting to clockwise).
   */
  // ellipse (x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
  //     // TODO -- implement
  // }
  /**
   * Generates a ClipPath from the clip command.
   */
  clip() {
    var group = this.__closestGroupOrSvg(), clipPath = this.__createElement("clipPath"), id = randomString(this.__ids), newGroup = this.__createElement("g");
    this.__applyCurrentDefaultPath();
    group.removeChild(this.__currentElement);
    clipPath.setAttribute("id", id);
    clipPath.appendChild(this.__currentElement);
    this.__defs.appendChild(clipPath);
    group.setAttribute("clip-path", format("url(#{id})", { id }));
    group.appendChild(newGroup);
    this.__currentElement = newGroup;
  }
  /**
   * Draws a canvas, image or mock context to this canvas.
   * Note that all svg dom manipulation uses node.childNodes rather than node.children for IE support.
   * http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-drawimage
   */
  drawImage() {
    var args = Array.prototype.slice.call(arguments), image = args[0], dx, dy, dw, dh, sx = 0, sy = 0, sw, sh, parent, svg2, defs, group, svgImage, canvas, context, id;
    if (args.length === 3) {
      dx = args[1];
      dy = args[2];
      sw = image.width;
      sh = image.height;
      dw = sw;
      dh = sh;
    } else if (args.length === 5) {
      dx = args[1];
      dy = args[2];
      dw = args[3];
      dh = args[4];
      sw = image.width;
      sh = image.height;
    } else if (args.length === 9) {
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else {
      throw new Error("Invalid number of arguments passed to drawImage: " + arguments.length);
    }
    parent = this.__closestGroupOrSvg();
    this.__currentElement;
    var translateDirective = "translate(" + dx + ", " + dy + ")";
    if (image instanceof ctx) {
      svg2 = image.getSvg().cloneNode(true);
      if (svg2.childNodes && svg2.childNodes.length > 1) {
        defs = svg2.childNodes[0];
        while (defs.childNodes.length) {
          id = defs.childNodes[0].getAttribute("id");
          this.__ids[id] = id;
          this.__defs.appendChild(defs.childNodes[0]);
        }
        group = svg2.childNodes[1];
        if (group) {
          var originTransform = group.getAttribute("transform");
          var transformDirective;
          if (originTransform) {
            transformDirective = originTransform + " " + translateDirective;
          } else {
            transformDirective = translateDirective;
          }
          group.setAttribute("transform", transformDirective);
          parent.appendChild(group);
        }
      }
    } else if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
      svgImage = this.__createElement("image");
      svgImage.setAttribute("width", dw);
      svgImage.setAttribute("height", dh);
      svgImage.setAttribute("preserveAspectRatio", "none");
      if (sx || sy || sw !== image.width || sh !== image.height) {
        canvas = this.__document.createElement("canvas");
        canvas.width = dw;
        canvas.height = dh;
        context = canvas.getContext("2d");
        context.drawImage(image, sx, sy, sw, sh, 0, 0, dw, dh);
        image = canvas;
      }
      svgImage.setAttribute("transform", translateDirective);
      svgImage.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
      );
      parent.appendChild(svgImage);
    }
  }
  /**
   * Generates a pattern tag
   */
  createPattern(image, repetition) {
    let pattern = this.__document.__createElement("pattern");
    let id = randomString(this.__ids);
    let img;
    pattern.setAttribute("id", id);
    pattern.setAttribute("width", image.width);
    pattern.setAttribute("height", image.height);
    if (image.nodeName === "CANVAS" || image.nodeName === "IMG") {
      img = this.__createElement("image");
      img.setAttribute("width", image.width);
      img.setAttribute("height", image.height);
      img.setAttributeNS(
        "http://www.w3.org/1999/xlink",
        "xlink:href",
        image.nodeName === "CANVAS" ? image.toDataURL() : image.getAttribute("src")
      );
      pattern.appendChild(img);
      this.__defs.appendChild(pattern);
    } else if (image instanceof ctx) {
      pattern.appendChild(image.__root.childNodes[1]);
      this.__defs.appendChild(pattern);
    }
    return new CanvasPattern(pattern, this);
  }
  setLineDash(dashArray) {
    if (dashArray && dashArray.length > 0) {
      this.lineDash = dashArray.join(",");
    } else {
      this.lineDash = null;
    }
  }
  /**
   * Not yet implemented
   */
  drawFocusRing() {
  }
  createImageData() {
  }
  getImageData() {
  }
  putImageData() {
  }
  globalCompositeOperation() {
  }
  setTransform() {
  }
}
const Cytoband = function(start, end, name2, typestain) {
  this.start = start;
  this.end = end;
  this.name = name2;
  this.stain = 0;
  if (typestain === "acen") {
    this.type = "c";
  } else {
    this.type = typestain.charAt(1);
    if (this.type === "p") {
      this.stain = parseInt(typestain.substring(4));
    }
  }
};
const _version = "2.15.13";
function version$2() {
  return _version;
}
const DEFAULT_GENOMES_URL = "https://igv.org/genomes/genomes.json";
const BACKUP_GENOMES_URL = "https://s3.amazonaws.com/igv.org.genomes/genomes.json";
const splitLines$1 = splitLines$5;
const GenomeUtils = {
  loadGenome: async function(options2) {
    const cytobandUrl = options2.cytobandURL;
    const aliasURL = options2.aliasURL;
    const sequence = await loadFasta(options2);
    let aliases;
    if (aliasURL) {
      aliases = await loadAliases(aliasURL, sequence.config);
    }
    const genome = new Genome$1(options2, sequence, aliases);
    if (cytobandUrl) {
      genome.cytobands = await loadCytobands(cytobandUrl, sequence.config, genome);
    }
    return genome;
  },
  initializeGenomes: async function(config) {
    if (!GenomeUtils.KNOWN_GENOMES) {
      let processJson = function(jsonArray) {
        jsonArray.forEach(function(json) {
          table[json.id] = json;
        });
        return table;
      };
      const table = {};
      if (config.loadDefaultGenomes !== false) {
        try {
          const url = DEFAULT_GENOMES_URL + `?randomSeed=${Math.random().toString(36)}&version=${version$2()}`;
          const jsonArray = await igvxhr.loadJson(url, { timeout: 5e3 });
          processJson(jsonArray);
        } catch (e) {
          console.error(e);
          try {
            const url = BACKUP_GENOMES_URL + `?randomSeed=${Math.random().toString(36)}&version=${version$2()}`;
            const jsonArray = await igvxhr.loadJson(url, {});
            processJson(jsonArray);
          } catch (e2) {
            console.error(e2);
            console.warn("Errors loading default genome definitions.");
          }
        }
      }
      const genomeList = config.genomeList || config.genomes;
      if (genomeList) {
        if (typeof genomeList === "string") {
          const jsonArray = await igvxhr.loadJson(genomeList, {});
          processJson(jsonArray);
        } else {
          processJson(genomeList);
        }
      }
      GenomeUtils.KNOWN_GENOMES = table;
    }
  },
  isWholeGenomeView: function(chr) {
    return "all" === chr.toLowerCase();
  },
  // Expand a genome id to a reference object, if needed
  expandReference: function(alert2, idOrConfig) {
    if (isString$2(idOrConfig) && idOrConfig.startsWith("{")) {
      try {
        idOrConfig = JSON.parse(idOrConfig);
      } catch (e) {
      }
    }
    let genomeID;
    if (isString$2(idOrConfig)) {
      genomeID = idOrConfig;
    } else if (idOrConfig.genome) {
      genomeID = idOrConfig.genome;
    } else if (idOrConfig.id !== void 0 && idOrConfig.fastaURL === void 0) {
      genomeID = idOrConfig.id;
    }
    if (genomeID) {
      const knownGenomes2 = GenomeUtils.KNOWN_GENOMES;
      const reference = knownGenomes2[genomeID];
      if (!reference) {
        alert2.present(new Error(`Unknown genome id: ${genomeID}`), void 0);
      }
      return reference;
    } else {
      return idOrConfig;
    }
  }
};
let Genome$1 = class Genome {
  constructor(config, sequence, aliases) {
    this.config = config;
    this.id = config.id || generateGenomeID(config);
    this.sequence = sequence;
    this.chromosomeNames = sequence.chromosomeNames;
    this.chromosomes = sequence.chromosomes;
    this.featureDB = /* @__PURE__ */ new Map();
    this.wholeGenomeView = config.wholeGenomeView === void 0 || config.wholeGenomeView;
    if (this.wholeGenomeView && Object.keys(sequence.chromosomes).length > 1) {
      constructWG(this, config);
    } else {
      this.wgChromosomeNames = sequence.chromosomeNames;
    }
    var chrAliasTable = {}, self2 = this;
    chrAliasTable["all"] = "all";
    this.chromosomeNames.forEach(function(name2) {
      var alias = name2.startsWith("chr") ? name2.substring(3) : "chr" + name2;
      chrAliasTable[alias.toLowerCase()] = name2;
      if (name2 === "chrM") chrAliasTable["mt"] = "chrM";
      if (name2 === "MT") chrAliasTable["chrm"] = "MT";
      chrAliasTable[name2.toLowerCase()] = name2;
    });
    if (aliases) {
      aliases.forEach(function(array) {
        var defName, i;
        for (i = 0; i < array.length; i++) {
          if (self2.chromosomes[array[i]]) {
            defName = array[i];
            break;
          }
        }
        if (defName) {
          array.forEach(function(alias) {
            if (alias !== defName) {
              chrAliasTable[alias.toLowerCase()] = defName;
              chrAliasTable[alias] = defName;
            }
          });
        }
      });
    }
    this.chrAliasTable = chrAliasTable;
  }
  showWholeGenomeView() {
    return this.config.wholeGenomeView !== false;
  }
  toJSON() {
    return Object.assign({}, this.config, { tracks: void 0 });
  }
  getInitialLocus() {
  }
  getHomeChromosomeName() {
    if (this.showWholeGenomeView() && this.chromosomes.hasOwnProperty("all")) {
      return "all";
    } else {
      return this.chromosomeNames[0];
    }
  }
  getChromosomeName(str) {
    const chr = str ? this.chrAliasTable[str.toLowerCase()] : str;
    return chr ? chr : str;
  }
  getChromosome(chr) {
    chr = this.getChromosomeName(chr);
    return this.chromosomes[chr];
  }
  getCytobands(chr) {
    return this.cytobands ? this.cytobands[chr] : null;
  }
  getLongestChromosome() {
    var longestChr, chromosomes = this.chromosomes;
    for (let key in chromosomes) {
      if (chromosomes.hasOwnProperty(key)) {
        var chr = chromosomes[key];
        if (longestChr === void 0 || chr.bpLength > longestChr.bpLength) {
          longestChr = chr;
        }
      }
      return longestChr;
    }
  }
  getChromosomes() {
    return this.chromosomes;
  }
  /**
   * Return the genome coordinate in kb for the give chromosome and position.
   * NOTE: This might return undefined if the chr is filtered from whole genome view.
   */
  getGenomeCoordinate(chr, bp) {
    var offset2 = this.getCumulativeOffset(chr);
    if (offset2 === void 0) return void 0;
    return offset2 + bp;
  }
  /**
   * Return the chromosome and coordinate in bp for the given genome coordinate
   */
  getChromosomeCoordinate(genomeCoordinate) {
    if (this.cumulativeOffsets === void 0) {
      this.cumulativeOffsets = computeCumulativeOffsets.call(this);
    }
    let lastChr = void 0;
    let lastCoord = 0;
    for (let name2 of this.wgChromosomeNames) {
      const cumulativeOffset = this.cumulativeOffsets[name2];
      if (cumulativeOffset > genomeCoordinate) {
        const position = genomeCoordinate - lastCoord;
        return { chr: lastChr, position };
      }
      lastChr = name2;
      lastCoord = cumulativeOffset;
    }
    return { chr: this.wgChromosomeNames[this.wgChromosomeNames.length - 1], position: 0 };
  }
  /**
   * Return the offset in genome coordinates (kb) of the start of the given chromosome
   * NOTE:  This might return undefined if the chromosome is filtered from whole genome view.
   */
  getCumulativeOffset(chr) {
    if (this.cumulativeOffsets === void 0) {
      this.cumulativeOffsets = computeCumulativeOffsets2.call(this);
    }
    const queryChr = this.getChromosomeName(chr);
    return this.cumulativeOffsets[queryChr];
    function computeCumulativeOffsets2() {
      let self2 = this;
      let acc = {};
      let offset2 = 0;
      for (let name2 of self2.wgChromosomeNames) {
        acc[name2] = Math.floor(offset2);
        const chromosome = self2.getChromosome(name2);
        offset2 += chromosome.bpLength;
      }
      return acc;
    }
  }
  /**
   * Return the nominal genome length, this is the length of the main chromosomes (no scaffolds, etc).
   */
  getGenomeLength() {
    let self2 = this;
    if (!this.bpLength) {
      let bpLength = 0;
      self2.wgChromosomeNames.forEach(function(cname) {
        let c = self2.chromosomes[cname];
        bpLength += c.bpLength;
      });
      this.bpLength = bpLength;
    }
    return this.bpLength;
  }
  async getSequence(chr, start, end) {
    chr = this.getChromosomeName(chr);
    return this.sequence.getSequence(chr, start, end);
  }
  addFeaturesToDB(featureList, config) {
    const insertFeature = (name2, feature2) => {
      const current = this.featureDB.get(name2);
      if (current) {
        feature2 = feature2.end - feature2.start > current.end - current.start ? feature2 : current;
      }
      this.featureDB.set(name2, feature2);
    };
    for (let feature2 of featureList) {
      if (feature2.name) {
        insertFeature(feature2.name.toUpperCase(), feature2);
      }
      if (feature2.gene && feature2.gene.name) {
        insertFeature(feature2.gene.name.toUpperCase(), feature2);
      }
      if (config.searchableFields) {
        for (let f of config.searchableFields) {
          const value = feature2.getAttributeValue(f);
          if (value) {
            if (value.indexOf(" ") > 0) {
              insertFeature(value.replaceAll(" ", "+").toUpperCase(), feature2);
            } else {
              insertFeature(value.toUpperCase(), feature2);
            }
          }
        }
      }
    }
  }
};
async function loadCytobands(cytobandUrl, config, genome) {
  let data;
  if (isDataURL(cytobandUrl)) {
    const plain = decodeDataURI$1(cytobandUrl);
    data = "";
    const len2 = plain.length;
    for (let i = 0; i < len2; i++) {
      data += String.fromCharCode(plain[i]);
    }
  } else {
    data = await igvxhr.loadString(cytobandUrl, buildOptions$1(config));
  }
  const cytobands = {};
  let lastChr;
  let bands = [];
  const lines = splitLines$1(data);
  for (let line of lines) {
    var tokens = line.split("	");
    var chr = genome.getChromosomeName(tokens[0]);
    if (!lastChr) lastChr = chr;
    if (chr !== lastChr) {
      cytobands[lastChr] = bands;
      bands = [];
      lastChr = chr;
    }
    if (tokens.length === 5) {
      var start = parseInt(tokens[1]);
      var end = parseInt(tokens[2]);
      var name2 = tokens[3];
      var stain = tokens[4];
      bands.push(new Cytoband(start, end, name2, stain));
    }
  }
  return cytobands;
}
function loadAliases(aliasURL, config) {
  return igvxhr.loadString(aliasURL, buildOptions$1(config)).then(function(data) {
    var lines = splitLines$1(data), aliases = [];
    lines.forEach(function(line) {
      if (!line.startsWith("#") && line.length > 0) aliases.push(line.split("	"));
    });
    return aliases;
  });
}
function constructWG(genome, config) {
  let wgChromosomes;
  if (config.chromosomeOrder) {
    if (Array.isArray(config.chromosomeOrder)) {
      genome.wgChromosomeNames = config.chromosomeOrder;
    } else {
      genome.wgChromosomeNames = config.chromosomeOrder.split(",").map((nm) => nm.trim());
    }
    wgChromosomes = genome.wgChromosomeNames.map((nm) => genome.chromosomes[nm]).filter((chr) => chr !== void 0);
  } else {
    const lengths = Object.keys(genome.chromosomes).map((key) => genome.chromosomes[key].bpLength);
    const median = lengths.reduce((a, b) => Math.max(a, b));
    const threshold = median / 50;
    wgChromosomes = Object.values(genome.chromosomes).filter((chr) => chr.bpLength > threshold);
    const numericChromosomes = wgChromosomes.filter((chr) => isDigit2(chr.name.replace("chr", "")));
    const alphaChromosomes = wgChromosomes.filter((chr) => !isDigit2(chr.name.replace("chr", "")));
    numericChromosomes.sort((a, b) => Number.parseInt(a.name.replace("chr", "")) - Number.parseInt(b.name.replace("chr", "")));
    const wgChromosomeNames = numericChromosomes.map((chr) => chr.name);
    for (let chr of alphaChromosomes) {
      wgChromosomeNames.push(chr.name);
    }
    genome.wgChromosomeNames = wgChromosomeNames;
  }
  const l = wgChromosomes.reduce((accumulator, currentValue) => accumulator += currentValue.bpLength, 0);
  genome.chromosomes["all"] = {
    name: "all",
    bpLength: l
  };
  function isDigit2(val) {
    return /^\d+$/.test(val);
  }
}
function generateGenomeID(config) {
  if (config.id !== void 0) {
    return config.id;
  } else if (config.fastaURL && isString$2(config.fastaURL)) {
    return config.fastaURL;
  } else if (config.fastaURL && config.fastaURL.name) {
    return config.fastaURL.name;
  } else {
    return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
  }
}
const NOT_LOADED_MESSAGE = "Error loading track data";
let lastClickTime = 0;
let lastHoverUpdateTime = 0;
let popupTimerID;
class TrackViewport extends Viewport {
  constructor(trackView, viewportColumn, referenceFrame, width) {
    super(trackView, viewportColumn, referenceFrame, width);
  }
  initializationHelper() {
    this.$spinner = $$1("<div>", { class: "igv-loading-spinner-container" });
    this.$viewport.append(this.$spinner);
    this.$spinner.append($$1("<div>"));
    const track = this.trackView.track;
    if ("sequence" !== track.type) {
      this.$zoomInNotice = this.createZoomInNotice(this.$viewport);
    }
    if (track.name && "sequence" !== track.id) {
      this.$trackLabel = $$1('<div class="igv-track-label">');
      this.$viewport.append(this.$trackLabel);
      this.setTrackLabel(track.name);
      if (false === this.browser.trackLabelsVisible) {
        this.$trackLabel.hide();
      }
    }
    this.stopSpinner();
    this.addMouseHandlers();
  }
  setContentHeight(contentHeight) {
    super.setContentHeight(contentHeight);
    if (this.featureCache) this.featureCache.redraw = true;
  }
  setTrackLabel(label) {
    this.$trackLabel.empty();
    this.$trackLabel.html(label);
    const txt = this.$trackLabel.text();
    this.$trackLabel.attr("title", txt);
  }
  startSpinner() {
    this.$spinner.show();
  }
  stopSpinner() {
    if (this.$spinner) {
      this.$spinner.hide();
    }
  }
  /**
   * Test to determine if we are zoomed in far enough to see features. Applicable to tracks with visibility windows.
   *
   * As a side effect the viewports canvas is removed if zoomed out.
   *
   * @returns {boolean} true if we are zoomed in past visibility window, false otherwise
   */
  checkZoomIn() {
    const zoomedOutOfWindow = () => {
      if (this.referenceFrame.chr.toLowerCase() === "all" && !this.trackView.track.supportsWholeGenome) {
        return true;
      } else {
        const visibilityWindow = this.trackView.track.visibilityWindow;
        return visibilityWindow !== void 0 && visibilityWindow > 0 && this.referenceFrame.bpPerPixel * this.$viewport.width() > visibilityWindow;
      }
    };
    if (this.trackView.track && "sequence" === this.trackView.track.type && this.referenceFrame.bpPerPixel > bppFeatureFetchThreshold) {
      $$1(this.canvas).remove();
      this.canvas = void 0;
      return false;
    }
    if (!this.viewIsReady()) {
      return false;
    }
    if (zoomedOutOfWindow()) {
      if (this.canvas) {
        $$1(this.canvas).remove();
        this.canvas = void 0;
      }
      if (this.trackView.track.autoHeight) {
        const minHeight = this.trackView.minHeight || 0;
        this.setContentHeight(minHeight);
      }
      if (this.$zoomInNotice) {
        this.$zoomInNotice.show();
      }
      return false;
    } else {
      if (this.$zoomInNotice) {
        this.$zoomInNotice.hide();
      }
      return true;
    }
  }
  /**
   * Adjust the canvas to the current genomic state.
   */
  shift() {
    const referenceFrame = this.referenceFrame;
    if (this.canvas && this.canvas._data && this.canvas._data.referenceFrame.chr === this.referenceFrame.chr && this.canvas._data.bpPerPixel === referenceFrame.bpPerPixel) {
      const pixelOffset = Math.round((this.canvas._data.bpStart - referenceFrame.start) / referenceFrame.bpPerPixel);
      this.canvas.style.left = pixelOffset + "px";
    }
  }
  /**
   * Set the content top of the current view.  This is triggered by scrolling.   If the current canvas extent is not
   * sufficient to cover the new vertical range repaint.
   *
   * @param contentTop - the "top" property of the virtual content div, 0 unless track is scrolled vertically
   *
   *
   */
  setTop(contentTop) {
    super.setTop(contentTop);
    if (!this.canvas) {
      this.repaint();
    } else {
      const h = this.$viewport.height();
      const vt = contentTop + this.canvas._data.pixelTop;
      const vb = vt + this.canvas._data.pixelHeight;
      if (vt > 0 || vb < h) {
        this.repaint();
      }
    }
    let offset2 = contentTop + this.canvas._data.pixelTop;
    this.canvas.style.top = `${offset2}px`;
  }
  async loadFeatures() {
    const referenceFrame = this.referenceFrame;
    const chr = referenceFrame.chr;
    const chrLength = this.browser.genome.getChromosome(chr).bpLength;
    const pixelWidth = this.$viewport.width();
    const bpWidth = pixelWidth * referenceFrame.bpPerPixel;
    const bpStart = Math.floor(Math.max(0, referenceFrame.start - bpWidth));
    const bpEnd = Math.ceil(Math.min(chrLength, referenceFrame.start + bpWidth + bpWidth));
    if (this.loading && this.loading.start === bpStart && this.loading.end === bpEnd) {
      return void 0;
    }
    this.loading = { start: bpStart, end: bpEnd };
    this.startSpinner();
    try {
      const track = this.trackView.track;
      const features = await this.getFeatures(track, chr, bpStart, bpEnd, referenceFrame.bpPerPixel);
      if (features) {
        let roiFeatures = [];
        if (track.roiSets && track.roiSets.length > 0) {
          for (let roiSet of track.roiSets) {
            const features2 = await roiSet.getFeatures(chr, bpStart, bpEnd, referenceFrame.bpPerPixel);
            roiFeatures.push({ track: roiSet, features: features2 });
          }
        }
        const mr = track && ("wig" === track.type || "merged" === track.type);
        this.featureCache = new FeatureCache(chr, bpStart, bpEnd, referenceFrame.bpPerPixel, features, roiFeatures, mr);
        this.loading = false;
        this.hideMessage();
        this.stopSpinner();
        return this.featureCache;
      }
    } catch (error) {
      if (this.trackView && this.trackView.disposed !== true) {
        this.showMessage(NOT_LOADED_MESSAGE);
        this.browser.alert.present(error);
        console.error(error);
      }
    } finally {
      this.loading = false;
      this.stopSpinner();
    }
  }
  /**
   * Compute the genomic extent and needed pixelWidth to repaint the canvas for the current genomic state.
   * Normally the canvas is size 3X the width of the viewport, however there is no left-right panning for WGV so
   * canvas width is viewport width.
   * @returns {{bpEnd: *, pixelWidth: (*|number), bpStart: number}}
   */
  repaintDimensions() {
    const isWGV = GenomeUtils.isWholeGenomeView(this.referenceFrame.chr);
    const pixelWidth = isWGV ? this.$viewport.width() : 3 * this.$viewport.width();
    const bpPerPixel = this.referenceFrame.bpPerPixel;
    const bpStart = this.referenceFrame.start - (isWGV ? 0 : pixelWidth / 3 * bpPerPixel);
    const bpEnd = this.referenceFrame.end + (isWGV ? 0 : pixelWidth / 3 * bpPerPixel);
    return {
      bpStart,
      bpEnd,
      pixelWidth
    };
  }
  /**
   * Repaint the canvas using the cached features
   *
   */
  repaint() {
    if (void 0 === this.featureCache) {
      return;
    }
    const { features, roiFeatures } = this.featureCache;
    const { bpStart, bpEnd, pixelWidth } = this.repaintDimensions();
    const viewportHeight = this.$viewport.height();
    const contentHeight = this.getContentHeight();
    const maxHeight = roiFeatures ? Math.max(contentHeight, viewportHeight) : contentHeight;
    const pixelHeight = Math.min(maxHeight, 3 * viewportHeight);
    if (0 === pixelWidth || 0 === pixelHeight) {
      if (this.canvas) {
        $$1(this.canvas).remove();
      }
      return;
    }
    const pixelTop = Math.max(0, -this.contentTop - Math.floor(pixelHeight / 3));
    const bpPerPixel = this.referenceFrame.bpPerPixel;
    const pixelXOffset = Math.round((bpStart - this.referenceFrame.start) / bpPerPixel);
    const canvasTop = (this.contentTop || 0) + pixelTop;
    const newCanvas = document.createElement("canvas");
    newCanvas.style.position = "relative";
    newCanvas.style.display = "block";
    newCanvas.style.width = pixelWidth + "px";
    newCanvas.style.height = pixelHeight + "px";
    newCanvas.style.left = pixelXOffset + "px";
    newCanvas.style.top = canvasTop + "px";
    const devicePixelRatio = "FILL" === this.trackView.track.displayMode || this.trackView.track.supportHiDPI !== false ? window.devicePixelRatio : 1;
    newCanvas.width = devicePixelRatio * pixelWidth;
    newCanvas.height = devicePixelRatio * pixelHeight;
    const ctx2 = newCanvas.getContext("2d");
    ctx2.scale(devicePixelRatio, devicePixelRatio);
    ctx2.translate(0, -pixelTop);
    const drawConfiguration = {
      context: ctx2,
      pixelXOffset,
      pixelWidth,
      pixelHeight,
      pixelTop,
      bpStart,
      bpEnd,
      bpPerPixel,
      referenceFrame: this.referenceFrame,
      selection: this.selection,
      viewport: this,
      viewportWidth: this.$viewport.width()
    };
    this.draw(drawConfiguration, features, roiFeatures);
    if (this.canvas) {
      $$1(this.canvas).remove();
    }
    newCanvas._data = drawConfiguration;
    this.canvas = newCanvas;
    this.$viewport.append($$1(newCanvas));
  }
  refresh() {
    if (!(this.canvas && this.featureCache)) return;
    const drawConfiguration = this.canvas._data;
    drawConfiguration.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    const { features, roiFeatures } = this.featureCache;
    this.draw(drawConfiguration, features, roiFeatures);
  }
  /**
   * Draw the associated track.
   *
   * @param drawConfiguration
   * @param features
   * @param roiFeatures
   */
  draw(drawConfiguration, features, roiFeatures) {
    if (features) {
      drawConfiguration.features = features;
      this.trackView.track.draw(drawConfiguration);
    }
    if (roiFeatures && roiFeatures.length > 0) {
      for (let r of roiFeatures) {
        drawConfiguration.features = r.features;
        r.track.draw(drawConfiguration);
      }
    }
  }
  containsPosition(chr, position) {
    if (this.referenceFrame.chr === chr && position >= this.referenceFrame.start) {
      return position <= this.referenceFrame.calculateEnd(this.getWidth());
    } else {
      return false;
    }
  }
  isLoading() {
    return this.loading;
  }
  savePNG() {
    if (!this.canvas) return;
    const canvasMetadata = this.canvas._data;
    const canvasTop = canvasMetadata ? canvasMetadata.pixelTop : 0;
    const devicePixelRatio = window.devicePixelRatio;
    const w = this.$viewport.width() * devicePixelRatio;
    const h = this.$viewport.height() * devicePixelRatio;
    const x = -$$1(this.canvas).position().left * devicePixelRatio;
    const y = (-this.contentTop - canvasTop) * devicePixelRatio;
    const ctx2 = this.canvas.getContext("2d");
    const imageData = ctx2.getImageData(x, y, w, h);
    const exportCanvas = document.createElement("canvas");
    const exportCtx = exportCanvas.getContext("2d");
    exportCanvas.width = imageData.width;
    exportCanvas.height = imageData.height;
    exportCtx.putImageData(imageData, 0, 0);
    const filename = (this.$trackLabel.text() ? this.$trackLabel.text() : "image") + ".png";
    const data = exportCanvas.toDataURL("image/png");
    download(filename, data);
  }
  saveSVG() {
    const marginTop = 32;
    const marginLeft = 32;
    let { width, height } = this.browser.columnContainer.getBoundingClientRect();
    const h_render = 8e3;
    const config = {
      width,
      height: h_render,
      backdropColor: "white",
      multiLocusGap: 0,
      viewbox: {
        x: 0,
        y: 0,
        width,
        height: h_render
      }
    };
    const context = new ctx(config);
    const delta = {
      deltaX: marginLeft,
      deltaY: marginTop
    };
    this.renderViewportToSVG(context, delta);
    context.setHeight(height);
    const str = (this.trackView.track.name || this.trackView.track.id).replace(/\W/g, "");
    const index2 = this.browser.referenceFrameList.indexOf(this.referenceFrame);
    const svg2 = context.getSerializedSvg(true);
    const data = URL.createObjectURL(new Blob([svg2], { type: "application/octet-stream" }));
    const id = `${str}_referenceFrame_${index2}_guid_${domUtils$1.guid()}`;
    download(`${id}.svg`, data);
  }
  // called by trackView.renderSVGContext() when rendering
  // entire browser as SVG
  renderViewportToSVG(context, { deltaX, deltaY }) {
    if (this.$zoomInNotice && this.$zoomInNotice.is(":visible")) {
      return;
    }
    const { width, height } = this.$viewport.get(0).getBoundingClientRect();
    const str = (this.trackView.track.name || this.trackView.track.id).replace(/\W/g, "");
    const index2 = this.browser.referenceFrameList.indexOf(this.referenceFrame);
    const id = `${str}_referenceFrame_${index2}_guid_${domUtils$1.guid()}`;
    this.drawSVGWithContext(context, width, height, id, deltaX, deltaY + this.contentTop, -this.contentTop);
  }
  renderSVGContext(context, { deltaX, deltaY }) {
    this.renderViewportToSVG(context, { deltaX, deltaY });
    if (this.$zoomInNotice && this.$zoomInNotice.is(":visible")) {
      return;
    }
    if (this.$trackLabel && true === this.browser.trackLabelsVisible) {
      const { x, y, width, height } = domUtils$1.relativeDOMBBox(this.$viewport.get(0), this.$trackLabel.get(0));
      this.renderTrackLabelSVG(context, deltaX + x, deltaY + y, width, height);
    }
  }
  // render track label element called from renderSVGContext()
  renderTrackLabelSVG(context, tx, ty, width, height) {
    const str = (this.trackView.track.name || this.trackView.track.id).replace(/\W/g, "");
    const id = `${str}_track_label_guid_${domUtils$1.guid()}`;
    context.saveWithTranslationAndClipRect(id, tx, ty, width, height, 0);
    context.fillStyle = "white";
    context.fillRect(0, 0, width, height);
    context.font = "12px Arial";
    context.fillStyle = "rgb(68, 68, 68)";
    const { width: stringWidth } = context.measureText(this.$trackLabel.text());
    const dx = 0.25 * (width - stringWidth);
    const dy = 0.7 * (height - 12);
    context.fillText(this.$trackLabel.text(), dx, height - dy);
    context.strokeStyle = "rgb(68, 68, 68)";
    context.strokeRect(0, 0, width, height);
    context.restore();
  }
  // called by renderSVGContext()
  drawSVGWithContext(context, width, height, id, x, y, yClipOffset) {
    context.saveWithTranslationAndClipRect(id, x, y, width, height, yClipOffset);
    let { start, bpPerPixel } = this.referenceFrame;
    const config = {
      context,
      viewport: this,
      referenceFrame: this.referenceFrame,
      top: yClipOffset,
      pixelTop: yClipOffset,
      pixelWidth: width,
      pixelHeight: height,
      bpStart: start,
      bpEnd: start + width * bpPerPixel,
      bpPerPixel,
      viewportWidth: width,
      selection: this.selection
    };
    const features = this.featureCache ? this.featureCache.features : void 0;
    const roiFeatures = this.featureCache ? this.featureCache.roiFeatures : void 0;
    this.draw(config, features, roiFeatures);
    context.restore();
  }
  get cachedFeatures() {
    return this.featureCache ? this.featureCache.features : [];
  }
  clearCache() {
    this.featureCache = void 0;
    if (this.canvas) this.canvas._data = void 0;
  }
  async getFeatures(track, chr, start, end, bpPerPixel) {
    if (this.featureCache && this.featureCache.containsRange(chr, start, end, bpPerPixel)) {
      return this.featureCache.features;
    } else if (typeof track.getFeatures === "function") {
      const features = await track.getFeatures(chr, start, end, bpPerPixel, this);
      this.checkContentHeight(features);
      return features;
    } else {
      return void 0;
    }
  }
  needsRepaint() {
    if (!this.canvas) return true;
    const data = this.canvas._data;
    return !data || this.referenceFrame.start < data.bpStart || this.referenceFrame.end > data.bpEnd || this.referenceFrame.chr !== data.referenceFrame.chr || this.referenceFrame.bpPerPixel != data.bpPerPixel;
  }
  needsReload() {
    if (!this.featureCache) return true;
    const { chr, bpPerPixel } = this.referenceFrame;
    const { bpStart, bpEnd } = this.repaintDimensions();
    return !this.featureCache.containsRange(chr, bpStart, bpEnd, bpPerPixel);
  }
  createZoomInNotice($parent) {
    const $container = $$1("<div>", { class: "igv-zoom-in-notice-container" });
    $parent.append($container);
    const $e = $$1("<div>");
    $container.append($e);
    $e.text("Zoom in to see features");
    $container.hide();
    return $container;
  }
  viewIsReady() {
    return this.browser && this.browser.referenceFrameList && this.referenceFrame;
  }
  addMouseHandlers() {
    const viewport = this.$viewport.get(0);
    this.addViewportContextMenuHandler(viewport);
    const md = (event) => {
      this.enableClick = true;
      this.browser.mouseDownOnViewport(event, this);
      domUtils$1.pageCoordinates(event);
    };
    viewport.addEventListener("mousedown", md);
    viewport.addEventListener("touchstart", md);
    const mu = (event) => {
      if (this.browser.dragObject || this.browser.isScrolling) {
        this.browser.cancelTrackPan();
        this.enableClick = false;
      } else {
        this.browser.cancelTrackPan();
        this.browser.endTrackDrag();
      }
    };
    viewport.addEventListener("mouseup", mu);
    viewport.addEventListener("touchend", mu);
    if (typeof this.trackView.track.hoverText === "function") {
      viewport.addEventListener("mousemove", ((event) => {
        if (event.buttons === 0 && Date.now() - lastHoverUpdateTime > 100) {
          lastHoverUpdateTime = Date.now();
          const clickState = this.createClickState(event);
          if (clickState) {
            const tooltip = this.trackView.track.hoverText(clickState);
            if (tooltip) {
              this.$viewport[0].setAttribute("title", tooltip);
            } else {
              this.$viewport[0].removeAttribute("title");
            }
          }
        }
      }));
    }
    this.addViewportClickHandler(this.$viewport.get(0));
    if (this.trackView.track.name && "sequence" !== this.trackView.track.config.type) {
      this.addTrackLabelClickHandler(this.$trackLabel.get(0));
    }
  }
  addViewportContextMenuHandler(viewport) {
    viewport.addEventListener("contextmenu", (event) => {
      if (this.browser.dragObject) {
        return false;
      }
      const clickState = this.createClickState(event);
      if (void 0 === clickState) {
        return false;
      }
      event.preventDefault();
      let menuItems = [];
      if (typeof this.trackView.track.contextMenuItemList === "function") {
        const trackMenuItems = this.trackView.track.contextMenuItemList(clickState);
        if (trackMenuItems) {
          menuItems = trackMenuItems;
        }
      }
      if (menuItems.length > 0) {
        menuItems.push({ label: $$1("<HR>") });
      }
      menuItems.push({ label: "Save Image (PNG)", click: () => this.savePNG() });
      menuItems.push({ label: "Save Image (SVG)", click: () => this.saveSVG() });
      this.browser.menuPopup.presentTrackContextMenu(event, menuItems);
    });
  }
  addViewportClickHandler(viewport) {
    viewport.addEventListener("click", (event) => {
      if (this.enableClick && this.canvas) {
        if (3 === event.which || event.ctrlKey) {
          return;
        }
        $$1(".igv-popover").hide();
        if (this.browser.dragObject || this.browser.isScrolling) {
          return;
        }
        event.preventDefault();
        const mouseX = domUtils$1.translateMouseCoordinates(event, this.$viewport.get(0)).x;
        const mouseXCanvas = domUtils$1.translateMouseCoordinates(event, this.canvas).x;
        const referenceFrame = this.referenceFrame;
        const xBP = Math.floor(referenceFrame.start + referenceFrame.toBP(mouseXCanvas));
        const time = Date.now();
        if (time - lastClickTime < this.browser.constants.doubleClickDelay) {
          if (popupTimerID) {
            window.clearTimeout(popupTimerID);
            popupTimerID = void 0;
          }
          const centerBP = Math.round(referenceFrame.start + referenceFrame.toBP(mouseX));
          let string;
          if ("all" === this.referenceFrame.chr.toLowerCase()) {
            const chr = this.browser.genome.getChromosomeCoordinate(centerBP).chr;
            if (1 === this.browser.referenceFrameList.length) {
              string = chr;
            } else {
              const loci = this.browser.referenceFrameList.map(({ locusSearchString }) => locusSearchString);
              const index2 = this.browser.referenceFrameList.indexOf(this.referenceFrame);
              loci[index2] = chr;
              string = loci.join(" ");
            }
            this.browser.search(string);
          } else {
            this.browser.zoomWithScaleFactor(0.5, centerBP, this.referenceFrame);
          }
        } else {
          if (event.shiftKey && typeof this.trackView.track.shiftClick === "function") {
            this.trackView.track.shiftClick(xBP, event);
          } else if (typeof this.trackView.track.popupData === "function") {
            popupTimerID = setTimeout(
              () => {
                const content = this.getPopupContent(event);
                if (content) {
                  if (this.popover) this.popover.dispose();
                  this.popover = new Popover(this.browser.columnContainer);
                  this.popover.presentContentWithEvent(event, content);
                }
                window.clearTimeout(popupTimerID);
                popupTimerID = void 0;
              },
              this.browser.constants.doubleClickDelay
            );
          }
        }
        lastClickTime = time;
      }
    });
  }
  addTrackLabelClickHandler(trackLabel) {
    trackLabel.addEventListener("click", (event) => {
      event.stopPropagation();
      const { track } = this.trackView;
      let str;
      if (typeof track.description === "function") {
        str = track.description();
      } else if (track.description) {
        str = `<div>${track.description}</div>`;
      }
      if (str) {
        if (this.popover) {
          this.popover.dispose();
        }
        this.popover = new Popover(this.browser.columnContainer, track.name || "");
        this.popover.presentContentWithEvent(event, str);
      }
    });
  }
  createClickState(event) {
    if (!this.canvas) return;
    const referenceFrame = this.referenceFrame;
    const viewportCoords = domUtils$1.translateMouseCoordinates(event, this.$viewport.get(0));
    const canvasCoords = domUtils$1.translateMouseCoordinates(event, this.canvas);
    const genomicLocation = referenceFrame.start + referenceFrame.toBP(viewportCoords.x);
    return {
      event,
      viewport: this,
      referenceFrame,
      genomicLocation,
      y: viewportCoords.y - this.contentTop,
      canvasX: canvasCoords.x,
      canvasY: canvasCoords.y
    };
  }
  getPopupContent(event) {
    const clickState = this.createClickState(event);
    if (void 0 === clickState) {
      return;
    }
    let track = this.trackView.track;
    const dataList = track.popupData(clickState);
    const popupClickHandlerResult = this.browser.fireEvent("trackclick", [track, dataList]);
    let content;
    if (void 0 === popupClickHandlerResult || true === popupClickHandlerResult) {
      if (dataList && dataList.length > 0) {
        content = formatPopoverText(dataList);
      }
    } else if (typeof popupClickHandlerResult === "string") {
      content = popupClickHandlerResult;
    }
    return content;
  }
}
function formatPopoverText(nameValues) {
  const rows = nameValues.map((nameValue) => {
    if (nameValue.name) {
      const str = `<span>${nameValue.name}</span>&nbsp&nbsp&nbsp${nameValue.value}`;
      return `<div title="${nameValue.value}">${str}</div>`;
    } else if ("<hr>" === nameValue) {
      return nameValue;
    } else if (nameValue.html) {
      return nameValue.html;
    } else {
      return `<div title="${nameValue}">${nameValue}</div>`;
    }
  });
  return rows.join("");
}
class FeatureCache {
  constructor(chr, tileStart, tileEnd, bpPerPixel, features, roiFeatures, multiresolution) {
    this.chr = chr;
    this.bpStart = tileStart;
    this.bpEnd = tileEnd;
    this.bpPerPixel = bpPerPixel;
    this.features = features;
    this.roiFeatures = roiFeatures;
    this.multiresolution = multiresolution;
  }
  containsRange(chr, start, end, bpPerPixel) {
    const r = this.multiresolution ? this.bpPerPixel / bpPerPixel : 1;
    return start >= this.bpStart && end <= this.bpEnd && chr === this.chr && r > 0.5 && r < 2;
  }
  overlapsRange(chr, start, end) {
    return this.chr === chr && end >= this.bpStart && start <= this.bpEnd;
  }
}
function decodeInteract(tokens, header) {
  if (tokens.length < 6) {
    console.log("Skipping line: " + tokens.join(" "));
    return void 0;
  }
  var feature2 = {
    chr: tokens[0],
    start: tokens[1],
    end: tokens[2],
    chr1: tokens[8],
    start1: Number.parseInt(tokens[9]),
    end1: Number.parseInt(tokens[10]),
    chr2: tokens[13],
    start2: Number.parseInt(tokens[14]),
    end2: Number.parseInt(tokens[15]),
    name: tokens[3],
    score: Number(tokens[4]),
    value: Number(tokens[5]),
    color: tokens[7] === "." ? void 0 : tokens[7] === "0" ? "rgb(0,0,0)" : tokens[7]
  };
  return feature2;
}
const transcriptTypes = /* @__PURE__ */ new Set([
  "transcript",
  "primary_transcript",
  "processed_transcript",
  "mRNA",
  "mrna",
  "lnc_RNA",
  "miRNA",
  "ncRNA",
  "rRNA",
  "scRNA",
  "snRNA",
  "snoRNA",
  "tRNA"
]);
const cdsTypes = /* @__PURE__ */ new Set(["CDS", "cds"]);
const codonTypes = /* @__PURE__ */ new Set(["start_codon", "stop_codon"]);
const utrTypes = /* @__PURE__ */ new Set(["5UTR", "3UTR", "UTR", "five_prime_UTR", "three_prime_UTR", "3'-UTR", "5'-UTR"]);
const exonTypes = /* @__PURE__ */ new Set(["exon", "coding-exon"]);
const transcriptPartTypes = /* @__PURE__ */ new Set();
for (let cltn of [cdsTypes, codonTypes, utrTypes, exonTypes]) {
  for (let t of cltn) {
    transcriptPartTypes.add(t);
  }
}
function isExon(type) {
  return exonTypes.has(type);
}
function isIntron(type) {
  return type.includes("intron");
}
function isCoding(type) {
  return cdsTypes.has(type) || codonTypes.has(type);
}
function isUTR(type) {
  return utrTypes.has(type);
}
function isTranscript(type) {
  return transcriptTypes.has(type) || type.endsWith("RNA") || type.endsWith("transcript");
}
function isTranscriptPart(type) {
  return transcriptPartTypes.has(type) || type.endsWith("RNA") || isIntron(type);
}
const filterPopupProperties = /* @__PURE__ */ new Set(["id", "parent", "name"]);
class GFFFeature {
  constructor(properties) {
    Object.assign(this, properties);
  }
  popupData(genomicLocation) {
    const pd = this.geneObject ? this.geneObject.popupData() : [];
    if (this.geneObject) {
      pd.push("<hr/>");
    }
    if (this.name) {
      pd.push({ name: "Name", value: this.name });
    }
    pd.push({ name: "Type", value: this.type });
    pd.push({ name: "Source", value: this.source });
    if (this.score !== void 0) {
      pd.push({ name: "Score", value: this.score });
    }
    if (this.attributeString) {
      const atts = parseAttributeString(this.attributeString, this.delim);
      for (let [key, value] of atts) {
        if (value !== void 0 && value.length > 0 && !filterPopupProperties.has(key.toLowerCase())) {
          pd.push({ name: key + ":", value });
        }
      }
    }
    pd.push({
      name: "Location",
      value: `${this.chr}:${numberFormatter$1(this.start + 1)}-${numberFormatter$1(this.end)}`
    });
    return pd;
  }
  getAttributeValue(attributeName) {
    if (this.hasOwnProperty(attributeName)) {
      return this[attributeName];
    } else {
      if (!this._attributeCache) {
        this._attributeCache = /* @__PURE__ */ new Map();
      }
      if (this._attributeCache.has(attributeName)) {
        return this._attributeCache.get(attributeName);
      } else {
        const atts = parseAttributeString(this.attributeString, this.delim);
        let v;
        for (let [key, value] of atts) {
          if (key === attributeName) {
            v = value;
            break;
          }
        }
        this._attributeCache.set(attributeName, v);
        return v;
      }
    }
  }
}
class GFFTranscript extends GFFFeature {
  constructor(feature2) {
    super(feature2);
    this.exons = [];
    this.parts = [];
  }
  addExon(feature2) {
    this.exons.push(feature2);
    this.start = Math.min(this.start, feature2.start);
    this.end = Math.max(this.end, feature2.end);
  }
  addPart(feature2) {
    this.parts.push(feature2);
  }
  assembleParts() {
    if (this.parts.length === 0) return;
    this.parts.sort(function(a, b) {
      return a.start - b.start;
    });
    let lastStart = this.parts[0].start;
    let lastEnd = this.parts[0].end;
    for (let i = 1; i < this.parts.length; i++) {
      const part = this.parts[i];
      if (isIntron(part.type)) {
        continue;
      }
      if (part.start <= lastEnd) {
        lastEnd = Math.max(lastEnd, part.end);
      } else {
        let exon2 = this.findExonContaining({ start: lastStart, end: lastEnd });
        if (!exon2) {
          this.exons.push({ start: lastStart, end: lastEnd, psuedo: true });
        }
        lastStart = part.start;
        lastEnd = part.end;
      }
    }
    let exon = this.findExonContaining({ start: lastStart, end: lastEnd });
    if (!exon) {
      this.exons.push({ start: lastStart, end: lastEnd, psuedo: true });
      this.start = Math.min(this.start, lastStart);
      this.end = Math.max(this.end, lastEnd);
    }
    for (let part of this.parts) {
      const type = part.type;
      if (isCoding(type)) {
        this.addCDS(part);
      } else if (isUTR(type)) {
        this.addUTR(part);
      }
    }
  }
  findExonContaining({ start, end }) {
    for (let exon of this.exons) {
      if (exon.end >= end && exon.start <= start) {
        return exon;
      }
    }
    return void 0;
  }
  addCDS(cds2) {
    let exon;
    const exons = this.exons;
    for (let e of exons) {
      if (e.start <= cds2.start && e.end >= cds2.end) {
        exon = e;
        break;
      }
    }
    if (exon) {
      exon.cdStart = exon.cdStart ? Math.min(cds2.start, exon.cdStart) : cds2.start;
      exon.cdEnd = exon.cdEnd ? Math.max(cds2.end, exon.cdEnd) : cds2.end;
    } else {
      console.error("No exon found spanning " + cds2.start + "-" + cds2.end);
    }
    this.cdStart = this.cdStart ? Math.min(cds2.start, this.cdStart) : cds2.start;
    this.cdEnd = this.cdEnd ? Math.max(cds2.end, this.cdEnd) : cds2.end;
  }
  addUTR(utr) {
    let exon;
    const exons = this.exons;
    for (let i = 0; i < exons.length; i++) {
      if (exons[i].start <= utr.start && exons[i].end >= utr.end) {
        exon = exons[i];
        break;
      }
    }
    if (exon) {
      if (utr.start === exon.start && utr.end === exon.end) {
        exon.utr = true;
      } else {
        if (utr.end < exon.end) {
          exon.cdStart = utr.end;
        }
        if (utr.start > exon.start) {
          exon.cdEnd = utr.start;
        }
      }
    } else {
      console.error("No exon found spanning " + cds.start + "-" + cds.end);
    }
  }
  finish() {
    this.assembleParts();
    var cdStart = this.cdStart;
    var cdEnd = this.cdEnd;
    this.exons.sort(function(a, b) {
      return a.start - b.start;
    });
    if (cdStart) {
      this.exons.forEach(function(exon) {
        if (exon.end < cdStart || exon.start > cdEnd) exon.utr = true;
      });
    }
  }
  popupData(genomicLocation) {
    const pd = super.popupData(genomicLocation);
    for (let exon of this.exons) {
      if (exon.pseudo) continue;
      if (genomicLocation >= exon.start && genomicLocation < exon.end && typeof exon.popupData === "function") {
        pd.push("<hr/>");
        const exonData = exon.popupData(genomicLocation);
        for (let att of exonData) {
          pd.push(att);
        }
      }
    }
    for (let part of this.parts) {
      if (genomicLocation >= part.start && genomicLocation < part.end && typeof part.popupData === "function") {
        pd.push("<hr/>");
        const partData = part.popupData(genomicLocation);
        for (let att of partData) {
          pd.push(att);
        }
      }
    }
    return pd;
  }
}
function decode(tokens, header) {
  const format2 = header.format;
  if (tokens.length < 9) {
    return void 0;
  }
  const delim = "gff3" === format2 ? "=" : " ";
  return new GFFFeature({
    source: decodeGFFAttribute(tokens[1]),
    type: tokens[2],
    chr: tokens[0],
    start: parseInt(tokens[3]) - 1,
    end: parseInt(tokens[4]),
    score: "." === tokens[5] ? void 0 : Number(tokens[5]),
    strand: tokens[6],
    phase: "." === tokens[7] ? 0 : parseInt(tokens[7]),
    attributeString: tokens[8],
    delim
  });
}
function decodeGFF3(tokens, header) {
  const feature2 = decode(tokens, header);
  if (!feature2) {
    return;
  }
  const attributes = parseAttributeString(feature2.attributeString, feature2.delim);
  for (let [key, value] of attributes) {
    const keyLower = key.toLowerCase();
    if ("color" === keyLower || "colour" === keyLower) {
      feature2.color = IGVColor.createColorString(value);
    } else if (key === "ID") {
      feature2.id = value;
    } else if (key === "Parent") {
      feature2.parent = value;
    }
  }
  return feature2;
}
function decodeGTF(tokens, header) {
  const feature2 = decode(tokens, header);
  if (!feature2) {
    return;
  }
  const attributes = parseAttributeString(feature2.attributeString, feature2.delim);
  let idField;
  let parentField;
  switch (feature2.type) {
    case "gene":
      idField = "gene_id";
      break;
    case "transcript":
      idField = "transcript_id";
      parentField = "gene_id";
      break;
    default:
      parentField = "transcript_id";
  }
  for (let [key, value] of attributes) {
    const keyLower = key.toLowerCase();
    if ("color" === keyLower || "colour" === keyLower) {
      feature2.color = IGVColor.createColorString(value);
    } else if (key === idField) {
      feature2.id = value;
    } else if (key === parentField) {
      feature2.parent = value;
    }
  }
  return feature2;
}
function parseAttributeString(attributeString, keyValueDelim, relaxed = false) {
  var attributes = [];
  for (let kv of attributeString.split(";")) {
    kv = kv.trim();
    const idx = kv.indexOf(keyValueDelim);
    if (idx > 0 && idx < kv.length - 1) {
      const key = stripQuotes(decodeGFFAttribute(kv.substring(0, idx).trim(), relaxed));
      let value = stripQuotes(decodeGFFAttribute(kv.substring(idx + 1).trim(), relaxed));
      attributes.push([key, value]);
    }
  }
  return attributes;
}
function stripQuotes(value) {
  if (value.startsWith('"') && value.endsWith('"')) {
    value = value.substr(1, value.length - 2);
  }
  return value;
}
const encodings$2 = /* @__PURE__ */ new Map([
  ["%09", "	"],
  ["%0A", "\n"],
  ["%0D", "\r"],
  ["%25", "%"],
  ["%3B", ";"],
  ["%3D", "="],
  ["%26", "&"],
  ["%2C", ","]
]);
function decodeGFFAttribute(str, relaxed = false) {
  if (!str.includes("%")) {
    return str;
  }
  if (relaxed) {
    return decodeURIComponent(str);
  }
  let decoded = "";
  for (let i = 0; i < str.length; i++) {
    if (str.charCodeAt(i) === 37 && i < str.length - 2) {
      const key = str.substring(i, i + 3);
      if (encodings$2.has(key)) {
        decoded += encodings$2.get(key);
      } else {
        decoded += key;
      }
      i += 2;
    } else {
      decoded += str.charAt(i);
    }
  }
  return decoded;
}
class DecodeError {
  constructor(message) {
    this.message = message;
  }
}
function decodeBed(tokens, header) {
  if (tokens.length < 3) return void 0;
  header && header.gffTags;
  const chr = tokens[0];
  const start = parseInt(tokens[1]);
  const end = tokens.length > 2 ? parseInt(tokens[2]) : start + 1;
  if (isNaN(start) || isNaN(end)) {
    return new DecodeError(`Unparsable bed record.`);
  }
  const feature2 = new UCSCBedFeature({ chr, start, end, score: 1e3 });
  try {
    if (tokens.length > 3) {
      if (tokens[3].indexOf(";") > 0 && tokens[3].indexOf("=") > 0) {
        const attributeKVs = parseAttributeString(tokens[3], "=", true);
        feature2.attributes = {};
        for (let kv of attributeKVs) {
          feature2.attributes[kv[0]] = kv[1];
          if (header.nameField != void 0 && kv[0] === header.nameField) {
            feature2.name = kv[1];
          }
        }
      }
      if (!feature2.name) {
        feature2.name = tokens[3] === "." ? "" : tokens[3];
      }
    }
    if (tokens.length > 4) {
      feature2.score = tokens[4] === "." ? 0 : Number(tokens[4]);
      if (isNaN(feature2.score)) {
        return feature2;
      }
    }
    if (tokens.length > 5) {
      feature2.strand = tokens[5];
      if (!(feature2.strand === "." || feature2.strand === "+" || feature2.strand === "-")) {
        return feature2;
      }
    }
    if (tokens.length > 6) {
      feature2.cdStart = parseInt(tokens[6]);
      if (isNaN(feature2.cdStart)) {
        return feature2;
      }
    }
    if (tokens.length > 7) {
      feature2.cdEnd = parseInt(tokens[7]);
      if (isNaN(feature2.cdEnd)) {
        return feature2;
      }
    }
    if (tokens.length > 8) {
      if (tokens[8] !== "." && tokens[8] !== "0")
        feature2.color = IGVColor.createColorString(tokens[8]);
    }
    if (tokens.length > 11) {
      const exonCount = parseInt(tokens[9]);
      if (exonCount > 1e3) {
        return feature2;
      }
      const exonSizes = tokens[10].replace(/,$/, "").split(",");
      const exonStarts = tokens[11].replace(/,$/, "").split(",");
      if (!(exonSizes.length === exonStarts.length && exonCount === exonSizes.length)) {
        return feature2;
      }
      const exons = [];
      for (let i = 0; i < exonCount; i++) {
        const eStart = start + parseInt(exonStarts[i]);
        const eEnd = eStart + parseInt(exonSizes[i]);
        exons.push({ start: eStart, end: eEnd });
      }
      if (exons.length > 0) {
        findUTRs$1(exons, feature2.cdStart, feature2.cdEnd);
        feature2.exons = exons;
      }
    }
    if (header) {
      let thicknessColumn = header.thicknessColumn;
      let colorColumn = header.colorColumn;
      if (colorColumn && colorColumn < tokens.length) {
        feature2.color = IGVColor.createColorString(tokens[colorColumn]);
      }
      if (thicknessColumn && thicknessColumn < tokens.length) {
        feature2.thickness = tokens[thicknessColumn];
      }
    }
  } catch (e) {
  }
  return feature2;
}
function decodeRepeatMasker(tokens, header) {
  if (tokens.length <= 15) return void 0;
  const feature2 = {
    swScore: Number.parseInt(tokens[1]),
    milliDiv: Number.parseInt(tokens[2]),
    milliDel: Number.parseInt(tokens[3]),
    milliIns: Number.parseInt(tokens[4]),
    chr: tokens[5],
    start: Number.parseInt(tokens[6]),
    end: Number.parseInt(tokens[7]),
    //genoLeft: tokens[8],
    strand: tokens[9],
    repName: tokens[10],
    repClass: tokens[11],
    repFamily: tokens[12],
    repStart: Number.parseInt(tokens[13]),
    repEnd: Number.parseInt(tokens[14]),
    repLeft: Number.parseInt(tokens[15])
  };
  return feature2;
}
function decodeGenePred(tokens, header) {
  var shift = header.shift === void 0 ? 0 : 1;
  if (tokens.length <= 9 + shift) return void 0;
  const cdStart = parseInt(tokens[5 + shift]);
  const cdEnd = parseInt(tokens[6 + shift]);
  var feature2 = {
    name: tokens[0 + shift],
    chr: tokens[1 + shift],
    strand: tokens[2 + shift],
    start: parseInt(tokens[3 + shift]),
    end: parseInt(tokens[4 + shift]),
    cdStart,
    cdEnd,
    id: tokens[0 + shift]
  };
  const exons = decodeExons(parseInt(tokens[7 + shift]), tokens[8 + shift], tokens[9 + shift]);
  findUTRs$1(exons, cdStart, cdEnd);
  feature2.exons = exons;
  return feature2;
}
function decodeGenePredExt(tokens, header) {
  var shift = header.shift === void 0 ? 0 : 1;
  if (tokens.length <= 11 + shift) return void 0;
  const cdStart = parseInt(tokens[5 + shift]);
  const cdEnd = parseInt(tokens[6 + shift]);
  const feature2 = {
    name: tokens[11 + shift],
    chr: tokens[1 + shift],
    strand: tokens[2 + shift],
    start: parseInt(tokens[3 + shift]),
    end: parseInt(tokens[4 + shift]),
    cdStart,
    cdEnd,
    id: tokens[0 + shift]
  };
  const exons = decodeExons(parseInt(tokens[7 + shift]), tokens[8 + shift], tokens[9 + shift]);
  findUTRs$1(exons, cdStart, cdEnd);
  feature2.exons = exons;
  return feature2;
}
function decodeReflat(tokens, header) {
  var shift = header.shift === void 0 ? 0 : 1;
  if (tokens.length <= 10 + shift) return void 0;
  const cdStart = parseInt(tokens[6 + shift]);
  const cdEnd = parseInt(tokens[7 + shift]);
  var feature2 = {
    name: tokens[0 + shift],
    id: tokens[1 + shift],
    chr: tokens[2 + shift],
    strand: tokens[3 + shift],
    start: parseInt(tokens[4 + shift]),
    end: parseInt(tokens[5 + shift]),
    cdStart,
    cdEnd
  };
  const exons = decodeExons(parseInt(tokens[8 + shift]), tokens[9 + shift], tokens[10 + shift]);
  findUTRs$1(exons, cdStart, cdEnd);
  feature2.exons = exons;
  return feature2;
}
function decodePSL(tokens, header) {
  if (tokens.length < 21) return void 0;
  const chr = tokens[13];
  const start = parseInt(tokens[15]);
  const end = parseInt(tokens[16]);
  const strand = tokens[8].charAt(0);
  const exonCount = parseInt(tokens[17]);
  const exons = [];
  const exonStarts = tokens[20].replace(/,$/, "").split(",");
  const exonSizes = tokens[18].replace(/,$/, "").split(",");
  for (let i = 0; i < exonCount; i++) {
    const start2 = parseInt(exonStarts[i]);
    const end2 = start2 + parseInt(exonSizes[i]);
    exons.push({ start: start2, end: end2 });
  }
  return new PSLFeature({ chr, start, end, strand, exons, tokens });
}
function decodeExons(exonCountToken, exonStartsToken, exonEndsToken) {
  const exonCount = parseInt(exonCountToken);
  const exonStarts = exonStartsToken.replace(/,$/, "").split(",");
  const exonEnds = exonEndsToken.replace(/,$/, "").split(",");
  const exons = [];
  for (let i = 0; i < exonCount; i++) {
    const start = parseInt(exonStarts[i]);
    const end = parseInt(exonEnds[i]);
    exons.push({ start, end });
  }
  return exons;
}
function findUTRs$1(exons, cdStart, cdEnd) {
  for (let exon of exons) {
    const end = exon.end;
    const start = exon.start;
    if (end < cdStart || start > cdEnd) {
      exon.utr = true;
    } else {
      if (cdStart >= start && cdStart <= end) {
        exon.cdStart = cdStart;
      }
      if (cdEnd >= start && cdEnd <= end) {
        exon.cdEnd = cdEnd;
      }
    }
  }
}
function decodePeak(tokens, header) {
  var tokenCount, chr, start, end, strand, name2, score, qValue, signal, pValue;
  tokenCount = tokens.length;
  if (tokenCount < 9) {
    return void 0;
  }
  chr = tokens[0];
  start = parseInt(tokens[1]);
  end = parseInt(tokens[2]);
  name2 = tokens[3];
  score = Number(tokens[4]);
  strand = tokens[5].trim();
  signal = Number(tokens[6]);
  pValue = Number(tokens[7]);
  qValue = Number(tokens[8]);
  if (score === 0) score = signal;
  return {
    chr,
    start,
    end,
    name: name2,
    score,
    strand,
    signal,
    pValue,
    qValue
  };
}
function decodeBedGraph(tokens, header) {
  var chr, start, end, value;
  if (tokens.length <= 3) return void 0;
  chr = tokens[0];
  start = parseInt(tokens[1]);
  end = parseInt(tokens[2]);
  value = Number(tokens[3]);
  const feature2 = { chr, start, end, value };
  if (header) {
    let colorColumn = header.colorColumn;
    if (colorColumn && colorColumn < tokens.length) {
      feature2.color = IGVColor.createColorString(tokens[colorColumn]);
    }
  }
  return feature2;
}
function decodeWig(tokens, header) {
  const wig = header.wig;
  if (wig && wig.format === "fixedStep") {
    const ss = wig.index * wig.step + wig.start;
    const ee = ss + wig.span;
    const value = Number(tokens[0]);
    ++wig.index;
    return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value };
  } else if (wig && wig.format === "variableStep") {
    if (tokens.length < 2) return null;
    const ss = parseInt(tokens[0], 10) - 1;
    const ee = ss + wig.span;
    const value = Number(tokens[1]);
    return isNaN(value) ? null : { chr: wig.chrom, start: ss, end: ee, value };
  } else {
    return decodeBedGraph(tokens);
  }
}
function decodeSNP(tokens, header) {
  if (tokens.length < 6) return void 0;
  const autoSql = [
    "bin",
    "chr",
    "start",
    "end",
    "name",
    "score",
    "strand",
    "refNCBI",
    "refUCSC",
    "observed",
    "molType",
    "class",
    "valid",
    "avHet",
    "avHetSE",
    "func",
    "locType",
    "weight",
    "exceptions",
    "submitterCount",
    "submitters",
    "alleleFreqCount",
    "alleles",
    "alleleNs",
    "alleleFreqs",
    "bitfields"
  ];
  const feature2 = {
    chr: tokens[1],
    start: Number.parseInt(tokens[2]),
    end: Number.parseInt(tokens[3]),
    name: tokens[4],
    score: Number.parseInt(tokens[5])
  };
  const n = Math.min(tokens.length, autoSql.length);
  for (let i = 6; i < n; i++) {
    feature2[autoSql[i]] = tokens[i];
  }
  return feature2;
}
class UCSCBedFeature {
  constructor(properties) {
    Object.assign(this, properties);
  }
  getAttributeValue(attributeName) {
    if (this.hasOwnProperty(attributeName)) {
      return this[attributeName];
    } else if (this.attributes) {
      return this.attributes[attributeName];
    }
  }
}
class PSLFeature {
  constructor(properties) {
    Object.assign(this, properties);
  }
  get score() {
    const tokens = this.tokens;
    const match = parseInt(tokens[0]);
    const repMatch = parseInt(tokens[2]);
    const misMatch = parseInt(tokens[1]);
    const qGapCount = parseInt(tokens[4]);
    const tGapCount = parseInt(tokens[6]);
    const qSize = parseInt(tokens[10]);
    return Math.floor(1e3 * (match + repMatch - misMatch - qGapCount - tGapCount) / qSize);
  }
  get matches() {
    return this.tokens[0];
  }
  get misMatches() {
    return this.tokens[1];
  }
  get repMatches() {
    return this.tokens[2];
  }
  get nCount() {
    return this.tokens[3];
  }
  get qNumInsert() {
    return this.tokens[4];
  }
  get qBaseInsert() {
    return this.tokens[5];
  }
  get tNumInsert() {
    return this.tokens[6];
  }
  get tBaseInsert() {
    return this.tokens[7];
  }
  popupData() {
    return [
      { name: "chr", value: this.chr },
      { name: "start", value: this.start + 1 },
      { name: "end", value: this.end },
      { name: "strand", value: this.strand },
      { name: "score", value: this.score },
      { name: "match", value: this.matches },
      { name: "mis-match", value: this.misMatches },
      { name: "rep. match", value: this.repMatches },
      { name: "N's", value: this.nCount },
      { name: "Q gap count", value: this.qNumInsert },
      { name: "Q gap bases", value: this.qBaseInsert },
      { name: "T gap count", value: this.tNumInsert },
      { name: "T gap bases", value: this.tBaseInsert }
    ];
  }
}
function decodeFusionJuncSpan(tokens, header) {
  if (tokens.length < 7) return void 0;
  var chr = tokens[0];
  var fusion_name = tokens[1];
  var junction_left = parseInt(tokens[2]);
  var junction_right = parseInt(tokens[3]);
  var num_junction_reads = parseInt(tokens[4]);
  var num_spanning_frags = parseInt(tokens[5]);
  var spanning_frag_coords_text = tokens[6];
  var feature2 = {
    chr,
    name: fusion_name,
    junction_left,
    junction_right,
    num_junction_reads,
    num_spanning_frags,
    spanning_frag_coords: [],
    start: -1,
    end: -1
  };
  var min_coord = junction_left;
  var max_coord = junction_right;
  if (num_spanning_frags > 0) {
    var coord_pairs = spanning_frag_coords_text.split(",");
    for (var i = 0; i < coord_pairs.length; i++) {
      var split_coords = coord_pairs[i].split("-");
      var span_left = split_coords[0];
      var span_right = split_coords[1];
      if (span_left < min_coord) {
        min_coord = span_left;
      }
      if (span_right > max_coord) {
        max_coord = span_right;
      }
      feature2.spanning_frag_coords.push({ left: span_left, right: span_right });
    }
  }
  feature2.start = min_coord;
  feature2.end = max_coord;
  return feature2;
}
function decodeGtexGWAS(tokens, header) {
  const tokenCount = tokens.length;
  if (tokenCount < 7) {
    return null;
  }
  const feature2 = {
    chr: tokens[0],
    start: parseInt(tokens[1]) - 1,
    end: parseInt(tokens[2]),
    "Strongest SNP-risk allele": tokens[3],
    "Disease/Phenotype": tokens[4],
    "P-value": tokens[5],
    "Odds ratio or beta": tokens[6]
  };
  if (tokens.length > 6) {
    feature2["PUBMEDID"] = `<a target = "blank" href = "https://www.ncbi.nlm.nih.gov/pubmed/${tokens[7]}">${tokens[7]}</a>`;
  }
  return feature2;
}
function decodeCustom(tokens, header) {
  const format2 = header.customFormat;
  if (tokens.length < format2.fields.length) return void 0;
  const coords = format2.coords || 0;
  const chr = tokens[format2.chr];
  const start = parseInt(tokens[format2.start]) - coords;
  const end = format2.end !== void 0 ? parseInt(tokens[format2.end]) : start + 1;
  const feature2 = { chr, start, end };
  if (format2.fields) {
    format2.fields.forEach(function(field, index2) {
      if (index2 !== format2.chr && index2 !== format2.start && index2 !== format2.end) {
        feature2[field] = tokens[index2];
      }
    });
  }
  return feature2;
}
function decodeGcnv(tokens, header) {
  const columnNames = header.columnNames;
  if (!columnNames) {
    throw Error("Sample names are not defined.   Missing column headers?");
  }
  const sampleCount = columnNames.length - 3;
  const chr = tokens[0];
  const start = parseInt(tokens[1]);
  const end = parseInt(tokens[2]);
  const values = tokens.slice(3).map(Number);
  if (values.length == sampleCount) {
    return {
      chr,
      start,
      end,
      values
    };
  } else {
    console.warn(`${chr}:${start}-${end} row contains ${values.length} sample columns instead of the expected ${sampleCount} columns. Skipping...`);
    return void 0;
  }
}
class FeatureParser {
  constructor(config) {
    this.config = config;
    this.header = {};
    if (config.nameField) {
      this.header.nameField = config.nameField;
    }
    this.skipRows = 0;
    if (config.decode) {
      this.decode = config.decode;
      this.delimiter = config.delimiter || "	";
    } else if (config.format) {
      this.header.format = config.format.toLowerCase();
      this.setDecoder(this.header.format);
    }
    if (!this.delimiter) {
      this.delimiter = "	";
    }
  }
  /**
   * Parse metadata from the file.   A variety of conventions are in use to supply metadata about file contents
   * through header lines (e.g. 'track') and # directives. This method unifies metadata as properties of a
   * 'header' object.
   *
   * @param data
   * @returns {{}}
   */
  async parseHeader(dataWrapper) {
    let header = this.header;
    let columnNames;
    let line;
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      if (line.startsWith("track") || line.startsWith("#track")) {
        let h = parseTrackLine$1(line);
        Object.assign(header, h);
      } else if (line.startsWith("browser")) ;
      else if (line.startsWith("#columns")) {
        let h = parseColumnsDirective$1(line);
        Object.assign(header, h);
      } else if (line.startsWith("##gff-version 3")) {
        header.format = "gff3";
      } else if (line.startsWith("#gffTags")) {
        header.gffTags = true;
      } else if (line.startsWith("fixedStep") || line.startsWith("variableStep")) {
        break;
      } else if (line.startsWith("#")) {
        const tokens = line.split(this.delimiter || "	");
        if (tokens.length > 1) {
          columnNames = tokens;
        }
      } else {
        this.setDecoder(header.format);
        const tokens = line.split(this.delimiter || "	");
        try {
          const tmpHeader = Object.assign({ columnNames }, header);
          if (this.decode(tokens, tmpHeader)) {
            break;
          } else {
            if (tokens.length > 1) {
              columnNames = tokens;
            }
          }
        } catch (e) {
          if (tokens.length > 1) {
            columnNames = tokens;
          }
        }
      }
    }
    if (columnNames) {
      header.columnNames = columnNames;
      for (let n = 0; n < columnNames.length; n++) {
        if (columnNames[n] === "color" || columnNames[n] === "colour") {
          header.colorColumn = n;
        } else if (columnNames[n] === "thickness") {
          header.thicknessColumn = n;
        }
      }
    }
    this.header = header;
    return header;
  }
  async parseFeatures(dataWrapper) {
    const allFeatures = [];
    const decode2 = this.decode;
    const format2 = this.header.format;
    const delimiter = this.delimiter || "	";
    let i = 0;
    let errorCount = 0;
    let line;
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      i++;
      if (i <= this.skipRows) continue;
      if (!line || line.startsWith("track") || line.startsWith("#") || line.startsWith("browser")) {
        continue;
      } else if (format2 === "wig" && line.startsWith("fixedStep")) {
        this.header.wig = parseFixedStep(line);
        continue;
      } else if (format2 === "wig" && line.startsWith("variableStep")) {
        this.header.wig = parseVariableStep(line);
        continue;
      }
      const tokens = line.split(delimiter);
      if (tokens.length < 1) {
        continue;
      }
      const feature2 = decode2(tokens, this.header);
      if (feature2 instanceof DecodeError) {
        errorCount++;
        if (errorCount > 0) {
          console.error(`Error parsing line '${line}': ${feature2.message}`);
        }
        continue;
      }
      if (feature2) {
        allFeatures.push(feature2);
      }
    }
    if (decode2 === decodeBedpe) {
      fixBedPE(allFeatures);
    }
    return allFeatures;
  }
  setDecoder(format2) {
    switch (format2) {
      case "narrowpeak":
      case "broadpeak":
      case "regionpeak":
      case "peaks":
        this.decode = decodePeak;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "bedgraph":
        this.decode = decodeBedGraph;
        this.delimiter = /\s+/;
        break;
      case "wig":
        this.decode = decodeWig;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "gff3":
      case "gff":
        this.decode = decodeGFF3;
        this.delimiter = "	";
        break;
      case "gtf":
        this.decode = decodeGTF;
        this.delimiter = "	";
        break;
      case "fusionjuncspan":
        this.decode = decodeFusionJuncSpan;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "gtexgwas":
        this.skipRows = 1;
        this.decode = decodeGtexGWAS;
        this.delimiter = "	";
        break;
      case "refflat":
        this.decode = decodeReflat;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "genepred":
        this.decode = decodeGenePred;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "genepredext":
        this.decode = decodeGenePredExt;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "ensgene":
        this.decode = decodeGenePred;
        this.header.shift = 1;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "refgene":
        this.decode = decodeGenePredExt;
        this.delimiter = this.config.delimiter || /\s+/;
        this.header.shift = 1;
        break;
      case "bed":
        this.decode = decodeBed;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "bedpe":
      case "hiccups":
        this.decode = decodeBedpe;
        this.delimiter = this.config.delimiter || "	";
        break;
      case "bedpe-domain":
        this.decode = decodeBedpeDomain;
        this.headerLine = true;
        this.delimiter = this.config.delimiter || "	";
        break;
      case "bedpe-loop":
        this.decode = decodeBedpe;
        this.delimiter = this.config.delimiter || "	";
        this.header = { colorColumn: 7 };
        break;
      case "interact":
        this.decode = decodeInteract;
        this.delimiter = this.config.delimiter || /\s+/;
        break;
      case "snp":
        this.decode = decodeSNP;
        this.delimiter = "	";
        break;
      case "rmsk":
        this.decode = decodeRepeatMasker;
        this.delimiter = "	";
        break;
      case "gcnv":
        this.decode = decodeGcnv;
        this.delimiter = "	";
        break;
      default:
        const customFormat = getFormat(format2);
        if (customFormat !== void 0) {
          this.decode = decodeCustom;
          this.header.customFormat = customFormat;
          this.delimiter = customFormat.delimiter || "	";
        } else {
          this.decode = decodeBed;
          this.delimiter = this.config.delimiter || /\s+/;
        }
    }
  }
}
function parseTrackLine$1(line) {
  const properties = {};
  const tokens = line.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g);
  let curr;
  const tmp = [];
  for (let tk of tokens) {
    if (!tk || tk.trim().length === 0) continue;
    if (tk.endsWith("=")) {
      curr = tk;
    } else if (curr) {
      tmp.push(curr + tk);
      curr = void 0;
    } else {
      tmp.push(tk);
    }
  }
  for (let str of tmp) {
    if (!str) return;
    var kv = str.split("=", 2);
    if (kv.length === 2) {
      const key = kv[0].trim();
      const value = kv[1].trim();
      if (properties.hasOwnProperty(key)) {
        let currentValue = properties[key];
        if (Array.isArray(currentValue)) {
          currentValue.push(value);
        } else {
          properties[key] = [currentValue, value];
        }
      } else {
        properties[key] = value;
      }
    }
  }
  if ("interact" == properties["type"]) {
    properties["format"] = "interact";
  } else if ("gcnv" === properties["type"]) {
    properties["format"] = "gcnv";
  }
  return properties;
}
function parseColumnsDirective$1(line) {
  let properties = {};
  let t12 = line.split(/\s+/);
  if (t12.length === 2) {
    let t22 = t12[1].split(";");
    t22.forEach(function(keyValue) {
      let t = keyValue.split("=");
      if (t[0] === "color") {
        properties.colorColumn = Number.parseInt(t[1]) - 1;
      } else if (t[0] === "thickness") {
        properties.thicknessColumn = Number.parseInt(t[1]) - 1;
      }
    });
  }
  return properties;
}
function parseFixedStep(line) {
  const tokens = line.split(/\s+/);
  const chrom = tokens[1].split("=")[1];
  const start = parseInt(tokens[2].split("=")[1], 10) - 1;
  const step = parseInt(tokens[3].split("=")[1], 10);
  const span = tokens.length > 4 ? parseInt(tokens[4].split("=")[1], 10) : 1;
  return { format: "fixedStep", chrom, start, step, span, index: 0 };
}
function parseVariableStep(line) {
  const tokens = line.split(/\s+/);
  const chrom = tokens[1].split("=")[1];
  const span = tokens.length > 2 ? parseInt(tokens[2].split("=")[1], 10) : 1;
  return { format: "variableStep", chrom, span };
}
const fixColor = (colorString) => {
  if (isString$2(colorString)) {
    return colorString.indexOf(",") > 0 && !(colorString.startsWith("rgb(") || colorString.startsWith("rgba(")) ? `rgb(${colorString})` : colorString;
  } else {
    return colorString;
  }
};
class TrackBase {
  static defaults = {
    height: 50,
    autoHeight: false,
    visibilityWindow: void 0,
    // Identifies property that should be copied from config
    color: void 0,
    // Identifies property that should be copied from config
    altColor: void 0,
    // Identifies property that should be copied from config
    supportHiDPI: true
  };
  constructor(config, browser) {
    this.browser = browser;
    this.init(config);
  }
  /**
   * Initialize track properties from the config object.  This method is typically overriden in subclasses, which
   * will call this implementation as super.init(config).
   *
   * @param config
   */
  init(config) {
    this.config = config;
    if (config.displayMode) {
      config.displayMode = config.displayMode.toUpperCase();
    }
    const defaults = Object.assign({}, TrackBase.defaults);
    if (this.constructor.defaults) {
      for (let key of Object.keys(this.constructor.defaults)) {
        defaults[key] = this.constructor.defaults[key];
      }
    }
    for (let key of Object.keys(defaults)) {
      this[key] = config.hasOwnProperty(key) ? config[key] : defaults[key];
      if (key === "color" || key === "altColor") {
        this[key] = fixColor(this[key]);
      }
    }
    if (config.name || config.label) {
      this.name = config.name || config.label;
    } else if (isFile$1(config.url)) {
      this.name = config.url.name;
    } else if (isString$2(config.url) && !config.url.startsWith("data:")) {
      this.name = getFilename$2(config.url);
    }
    this.url = config.url;
    if (this.config.type) this.type = this.config.type;
    this.id = this.config.id === void 0 ? this.name : this.config.id;
    this.order = config.order;
    this.autoscaleGroup = config.autoscaleGroup;
    this.removable = config.removable === void 0 ? true : config.removable;
    this.minHeight = config.minHeight || Math.min(25, this.height);
    this.maxHeight = config.maxHeight || Math.max(1e3, this.height);
    if (config.onclick) {
      this.onclick = config.onclick;
      config.onclick = void 0;
    }
    if (config.description) {
      if (typeof config.description === "function") {
        this.description = config.description;
      } else {
        this.description = () => config.description;
      }
    }
    if (config.hoverTextFields) {
      this.hoverText = hoverText.bind(this);
    } else if (typeof this.config.hoverText === "function") {
      this.hoverText = this.config.hoverText;
    }
  }
  get name() {
    return this._name;
  }
  set name(name2) {
    this._name = name2;
    if (this.trackView) {
      this.trackView.setTrackLabelName(name2);
    }
  }
  /**
   * Update track properties from the config object.
   *
   * @param config
   */
  updateConfig(config) {
    this.init(config);
  }
  clearCachedFeatures() {
    if (this.trackView) {
      this.trackView.clearCachedFeatures();
    }
  }
  updateViews() {
    if (this.trackView) {
      this.trackView.updateViews();
    }
  }
  /**
   * Used to create session object for bookmarking, sharing.  Only simple property values (string, number, boolean)
   * are saved.
   */
  getState() {
    const jsonable = (v) => !(v === void 0 || typeof v === "function" || v instanceof File || v instanceof Promise);
    const state = {};
    for (let key of Object.keys(this.config)) {
      if (!key.startsWith("_") && jsonable(this.config[key])) {
        state[key] = this.config[key];
      }
    }
    for (let key of Object.keys(state)) {
      if (key.startsWith("_")) continue;
      const value = this[key];
      if (value && (isSimpleType(value) || typeof value === "boolean" || key === "metadata")) {
        state[key] = value;
      }
    }
    const defs = TrackBase.defaults;
    if (this.constructor.defaults) {
      for (let key of Object.keys(this.constructor.defaults)) {
        defs[key] = this.constructor.defaults[key];
      }
    }
    for (let key of Object.keys(defs)) {
      if (void 0 !== this[key] && defs[key] !== this[key]) {
        state[key] = this[key];
      }
    }
    if (!this.autoscale && this.dataRange) {
      state.min = this.dataRange.min;
      state.max = this.dataRange.max;
    }
    return state;
  }
  get supportsWholeGenome() {
    return this.config.supportsWholeGenome === true;
  }
  /**
   * Does the track support sample names.  Current sample aware tracks include VCF (with genotypes), MUT, MAF, and SEG
   * @returns {boolean}
   */
  hasSamples() {
    return false;
  }
  getGenomeId() {
    return this.browser.genome ? this.browser.genome.id : void 0;
  }
  /**
   * Set certain track properties, usually from a "track" line.  Not all UCSC properties are supported.
   *
   * Track configuration settings have precendence over track line properties, so if both are present ignore the
   * track line.
   *
   * @param properties
   */
  setTrackProperties(properties) {
    if (this.disposed) return;
    const tracklineConfg = {};
    let tokens;
    for (let key of Object.keys(properties)) {
      switch (key.toLowerCase()) {
        case "usescore":
          tracklineConfg.useScore = properties[key] === 1 || properties[key] === "1" || properties[key] === "on" || properties[key] === true;
          break;
        case "visibility":
          switch (properties[key]) {
            case "2":
            case "3":
            case "pack":
            case "full":
              tracklineConfg.displayMode = "EXPANDED";
              break;
            case "4":
            case "squish":
              tracklineConfg.displayMode = "SQUISHED";
              break;
            case "1":
            case "dense":
              tracklineConfg.displayMode = "COLLAPSED";
          }
          break;
        case "color":
        case "altcolor":
          tracklineConfg[key] = properties[key].startsWith("rgb(") ? properties[key] : "rgb(" + properties[key] + ")";
          break;
        case "featurevisiblitywindow":
        case "visibilitywindow":
          tracklineConfg.visibilityWindow = Number.parseInt(properties[key]);
          break;
        case "maxheightpixels":
          tokens = properties[key].split(":");
          if (tokens.length === 3) {
            tracklineConfg.minHeight = Number.parseInt(tokens[2]);
            tracklineConfg.height = Number.parseInt(tokens[1]);
            tracklineConfg.maxHeight = Number.parseInt(tokens[0]);
          }
          break;
        case "viewlimits":
          if (!this.config.autoscale) {
            tokens = properties[key].split(":");
            let min = 0;
            let max;
            if (tokens.length == 1) {
              max = Number(tokens[0]);
            } else if (tokens.length == 2) {
              min = Number(tokens[0]);
              max = Number(tokens[1]);
            }
            tracklineConfg.autoscale = false;
            tracklineConfg.dataRange = { min, max };
            this.viewLimitMin = min;
            this.viewLimitMax = max;
          }
        case "name":
          tracklineConfg[key] = properties[key];
          break;
        case "url":
          tracklineConfg["infoURL"] = properties[key];
          break;
        case "type":
          const v = properties[key];
          if (UCSCTypeMappings.has(v)) {
            tracklineConfg[key] = UCSCTypeMappings.get(v);
          } else {
            tracklineConfg[key] = v;
          }
          break;
        case "graphtype":
          tracklineConfg["graphType"] = properties[key];
          break;
        default:
          tracklineConfg[key] = properties[key];
      }
    }
    for (let key of Object.keys(tracklineConfg)) {
      if (!this.config.hasOwnProperty(key) || key === "name" && this.config._derivedName) {
        let value = tracklineConfg[key];
        if ("true" === value) value = true;
        if ("false" === value) value = false;
        this[key] = value;
        if (key === "height" && this.trackView) {
          try {
            const h = Number.parseInt(value);
            this.trackView.setTrackHeight(h);
          } catch (e) {
            console.error(e);
          }
        }
      }
    }
  }
  /**
   * Return the features clicked over.  Default implementation assumes an array of features and only considers
   * the genomic location.   Overriden by most subclasses.
   *
   * @param clickState
   * @param features
   * @returns {[]|*[]}
   */
  clickedFeatures(clickState) {
    const features = clickState.viewport.cachedFeatures;
    if (!features || !Array.isArray(features) || features.length === 0) {
      return [];
    }
    const genomicLocation = clickState.genomicLocation;
    const tolerance = clickState.referenceFrame.bpPerPixel > 0.2 ? 3 * clickState.referenceFrame.bpPerPixel : 0.2;
    const ss = genomicLocation - tolerance;
    const ee = genomicLocation + tolerance;
    return FeatureUtils.findOverlapping(features, ss, ee);
  }
  /**
   * Default popup text function -- just extracts string and number properties in random order.
   * @param feature
   * @returns {Array}
   */
  extractPopupData(feature2, genomeId) {
    const filteredProperties = /* @__PURE__ */ new Set(["row", "color", "chr", "start", "end", "cdStart", "cdEnd", "strand", "alpha"]);
    const data = [];
    let alleles, alleleFreqs;
    for (let property in feature2) {
      if (feature2.hasOwnProperty(property) && !filteredProperties.has(property) && isSimpleType(feature2[property])) {
        let value = feature2[property];
        data.push({ name: capitalize(property), value });
        if (property === "alleles") {
          alleles = feature2[property];
        } else if (property === "alleleFreqs") {
          alleleFreqs = feature2[property];
        }
      }
    }
    if (alleles && alleleFreqs) {
      if (alleles.endsWith(",")) {
        alleles = alleles.substr(0, alleles.length - 1);
      }
      if (alleleFreqs.endsWith(",")) {
        alleleFreqs = alleleFreqs.substr(0, alleleFreqs.length - 1);
      }
      let a = alleles.split(",");
      let af = alleleFreqs.split(",");
      if (af.length > 1) {
        let b = [];
        for (let i = 0; i < af.length; i++) {
          b.push({ a: a[i], af: Number(af[i]) });
        }
        b.sort(function(x, y) {
          return x.af - y.af;
        });
        let ref = b[b.length - 1].a;
        if (ref.length === 1) {
          for (let i = b.length - 2; i >= 0; i--) {
            let alt = b[i].a;
            if (alt.length === 1) {
              if (!genomeId) genomeId = this.getGenomeId();
              const cravatLink = TrackBase.getCravatLink(feature2.chr, feature2.start + 1, ref, alt, genomeId);
              console.log(cravatLink);
              if (cravatLink) {
                data.push("<hr/>");
                data.push({ html: cravatLink });
                data.push("<hr/>");
              }
            }
          }
        }
      }
    }
    if (feature2.attributes) {
      for (let key of Object.keys(feature2.attributes)) {
        data.push({ name: key, value: feature2.attributes[key] });
      }
    }
    let posString = `${feature2.chr}:${numberFormatter$1(feature2.start + 1)}-${numberFormatter$1(feature2.end)}`;
    if (feature2.strand) {
      posString += ` (${feature2.strand})`;
    }
    data.push({ name: "Location", value: posString });
    return data;
  }
  /**
   * Default track description -- displayed on click of track label.  This can be overriden in the track
   * configuration, or in subclasses.
   */
  description() {
    const wrapKeyValue = (k, v) => `<div class="igv-track-label-popup-shim"><b>${k}: </b>${v}</div>`;
    let str = '<div class="igv-track-label-popup">';
    if (this.url) {
      if (isFile$1(this.url)) {
        str += wrapKeyValue("Filename", this.url.name);
      } else {
        str += wrapKeyValue("URL", this.url);
      }
    } else {
      str = this.name;
    }
    if (this.config) {
      if (this.config.metadata) {
        for (let key of Object.keys(this.config.metadata)) {
          const value = this.config.metadata[key];
          str += wrapKeyValue(key, value);
        }
      }
      for (let key of Object.keys(this.config)) {
        if (key.startsWith("_")) continue;
        let first = key.substr(0, 1);
        if (first !== first.toLowerCase()) {
          const value = this.config[key];
          if (value && isSimpleType(value)) {
            str += wrapKeyValue(key, value);
          }
        }
      }
    }
    str += "</div>";
    return str;
  }
  /**
   * Return color for a specific feature of this track.  This default implementation is overriden by subclasses*
   * @param f
   * @returns {*|string|string}
   */
  getColorForFeature(f) {
    return typeof this.color === "function" ? this.color(feature) : this.color;
  }
  /**
   * Track has been permanently removed.  Release resources and other cleanup
   */
  dispose() {
    this.disposed = true;
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
  }
  static getCravatLink(chr, position, ref, alt, genomeID) {
    if ("hg38" === genomeID || "GRCh38" === genomeID) {
      const cravatChr = chr.startsWith("chr") ? chr : "chr" + chr;
      return `<a target="_blank" href="https://run.opencravat.org/result/nocache/variant.html?chrom=${cravatChr}&pos=${position}&ref_base=${ref}&alt_base=${alt}"><b>Cravat ${ref}->${alt}</b></a>`;
    } else {
      return void 0;
    }
  }
}
function hoverText(clickState) {
  if (!this.hoverTextFields) return;
  const features = this.clickedFeatures(clickState);
  if (features && features.length > 0) {
    let str = "";
    for (let i = 0; i < features.length; i++) {
      if (i === 10) {
        str += "; ...";
        break;
      }
      if (!features[i]) continue;
      const f = features[i]._f || features[i];
      if (str.length > 0) str += "\n";
      str = "";
      for (let field of this.hoverTextFields) {
        if (str.length > 0) str += "\n";
        if (f.hasOwnProperty(field)) {
          str += f[field];
        } else if (typeof f.getAttribute === "function") {
          str += f.getAttribute(field);
        }
      }
    }
    return str;
  }
}
const UCSCTypeMappings = /* @__PURE__ */ new Map([
  ["wiggle_0", "wig"],
  ["bed", "bed"],
  ["bigBed", "bigBed"],
  ["bigWig", "bigWig"]
]);
class SegParser {
  constructor(type) {
    this.type = type || "seg";
    switch (this.type) {
      case "mut":
        this.sampleColumn = 3;
        this.chrColumn = 0;
        this.startColumn = 1;
        this.endColumn = 2;
        this.dataColumn = 4;
        break;
      case "maf":
        this.sampleColumn = 15;
        this.chrColumn = 4;
        this.startColumn = 5;
        this.endColumn = 6;
        this.dataColumn = 8;
        break;
      default:
        this.sampleColumn = 0;
        this.chrColumn = 1;
        this.startColumn = 2;
        this.endColumn = 3;
    }
  }
  async parseHeader(dataWrapper) {
    let line;
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      if (line.startsWith("#")) ;
      else {
        const tokens = line.split("	");
        this.header = { headings: tokens };
        break;
      }
    }
    return this.header;
  }
  async parseFeatures(dataWrapper) {
    const allFeatures = [];
    let extraHeaders;
    if (!this.header) {
      this.header = await this.parseHeader(dataWrapper);
    }
    if ("seg" === this.type) {
      this.dataColumn = this.header.headings.length - 1;
    }
    if (this.header.headings.length > 5) {
      extraHeaders = this.extractExtraColumns(this.header.headings);
    }
    const valueColumnName = this.header.headings[this.dataColumn];
    let line;
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      const tokens = line.split("	");
      const value = "seg" === this.type ? Number(tokens[this.dataColumn]) : tokens[this.dataColumn];
      if (tokens.length > this.dataColumn) {
        const feature2 = new SegFeature({
          sample: tokens[this.sampleColumn],
          chr: tokens[this.chrColumn],
          start: parseInt(tokens[this.startColumn]) - 1,
          end: parseInt(tokens[this.endColumn]),
          value,
          valueColumnName
        });
        if (extraHeaders) {
          const extraValues = this.extractExtraColumns(tokens);
          feature2.setAttributes({ names: extraHeaders, values: extraValues });
        }
        allFeatures.push(feature2);
      }
    }
    return allFeatures;
  }
  extractExtraColumns(tokens) {
    const extras = [];
    for (let i = 0; i < tokens.length; i++) {
      if (i !== this.chrColumn && i !== this.startColumn && i !== this.endColumn && i !== this.sampleColumn) {
        extras.push(tokens[i]);
      }
    }
    return extras;
  }
}
class SegFeature {
  constructor({ sample, chr, start, end, value, valueColumnName }) {
    this.sample = sample;
    this.chr = chr;
    this.start = start;
    this.end = end;
    this.value = value;
    this.valueColumnName = valueColumnName;
  }
  setAttributes({ names, values }) {
    this.attributeNames = names;
    this.attributeValues = values;
  }
  getAttribute(name2) {
    if (this.attributeNames) {
      const idx = this.attributeNames.indexOf(name2);
      if (idx >= 0) {
        return this.attributeValues[idx];
      }
    }
    return void 0;
  }
  popupData(type, genomeID) {
    const filteredProperties = /* @__PURE__ */ new Set([
      "chr",
      "start",
      "end",
      "sample",
      "value",
      "row",
      "color",
      "sampleKey",
      "uniqueSampleKey",
      "sampleId",
      "chromosome",
      "uniquePatientKey"
    ]);
    const locationString = this.chr + ":" + numberFormatter$1(this.start + 1) + "-" + numberFormatter$1(this.end);
    const pd = [
      { name: "Sample", value: this.sample },
      { name: "Location", value: locationString },
      { name: this.valueColumnName ? capitalize(this.valueColumnName) : "Value", value: this.value }
    ];
    if ("mut" === type && "hg38" === genomeID) {
      const l = this.extractCravatLink(genomeID);
      if (l) {
        pd.push("<hr/>");
        pd.push({ html: l });
        pd.push("<hr/>");
      }
    }
    if (this.attributeNames && this.attributeNames.length > 0) {
      for (let i = 0; i < this.attributeNames.length; i++) {
        if (!filteredProperties.has(this.attributeNames[i]) & this.valueColumnName !== this.attributeNames[i]) {
          pd.push({ name: capitalize(this.attributeNames[i]), value: this.attributeValues[i] });
        }
      }
    }
    return pd;
  }
  extractCravatLink(genomeId) {
    let ref, alt;
    if (this.attributeNames && this.attributeNames.length > 0) {
      for (let i = 0; i < this.attributeNames.length; i++) {
        if (!ref && "Reference_Allele" === this.attributeNames[i]) {
          ref = this.attributeValues[i];
        }
        if (!alt && this.attributeNames[i].startsWith("Tumor_Seq_Allele") && this.attributeValues[i] !== ref) {
          alt = this.attributeValues[i];
        }
        if (ref && alt) {
          return TrackBase.getCravatLink(this.chr, this.start + 1, ref, alt, genomeId);
        }
      }
    }
  }
}
function createVCFVariant(tokens) {
  const variant = new Variant();
  variant.chr = tokens[0];
  variant.pos = parseInt(tokens[1]);
  variant.names = tokens[2];
  variant.referenceBases = tokens[3];
  variant.alternateBases = tokens[4];
  variant.quality = tokens[5];
  variant.filter = tokens[6];
  variant.info = {};
  const infoStr = tokens[7];
  if (infoStr) {
    for (let elem of infoStr.split(";")) {
      var element = elem.split("=");
      variant.info[element[0]] = element[1];
    }
  }
  variant.init();
  return variant;
}
function createGAVariant(json) {
  var variant = new Variant();
  variant.chr = json.referenceName;
  variant.start = parseInt(json.start);
  variant.end = parseInt(json.end);
  variant.pos = variant.start + 1;
  variant.names = arrayToString(json.names, "; ");
  variant.referenceBases = json.referenceBases;
  variant.alternateBases = arrayToString(json.alternateBases);
  variant.quality = json.quality;
  variant.filter = arrayToString(json.filter);
  variant.info = {};
  if (json.info) {
    Object.keys(json.info).forEach(function(key) {
      var value, valueArray = json.info[key];
      if (Array.isArray(valueArray)) {
        value = valueArray.join(",");
      } else {
        value = valueArray;
      }
      variant.info[key] = value;
    });
  }
  variant.calls = {};
  var id;
  if (json.calls) {
    json.calls.forEach(function(call) {
      id = call.callSetId;
      variant.calls[id] = call;
    });
  }
  init(variant);
  return variant;
}
class Variant {
  init() {
    const ref = this.referenceBases;
    const altBases = this.alternateBases;
    if (this.info) {
      if (this.info["VT"]) {
        this.type = this.info["VT"];
      } else if (this.info["SVTYPE"]) {
        this.type = "SV";
      } else if (this.info["PERIOD"]) {
        this.type = "STR";
      }
    }
    if (this.type === void 0) {
      this.type = determineType(ref, altBases);
    }
    if (this.type === "NONVARIANT") {
      this.heterozygosity = 0;
    }
    if (this.info["END"]) {
      this.start = this.pos - 1;
      if (this.info["CHR2"] && this.info["CHR2"] !== this.chr) {
        this.end = this.start + 1;
      } else {
        this.end = Number.parseInt(this.info["END"]);
      }
    } else {
      if (this.type === "NONVARIANT") {
        this.start = this.pos - 1;
        this.end = this.start + ref.length;
      } else {
        const altTokens = altBases.split(",").filter((token) => token.length > 0);
        this.alleles = [];
        this.start = void 0;
        this.end = void 0;
        for (let alt of altTokens) {
          this.alleles.push(alt);
          if ("SV" !== this.type && isKnownAlt(alt)) {
            let altLength = alt.length;
            let lengthOnRef = ref.length;
            const lmin = Math.min(altLength, lengthOnRef);
            let s = 0;
            while (s < lmin && ref.charCodeAt(s) === alt.charCodeAt(s)) {
              s++;
              altLength--;
              lengthOnRef--;
            }
            while (altLength > 0 && lengthOnRef > 0) {
              const altIdx = s + altLength - 1;
              const refIdx = s + lengthOnRef - 1;
              if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                altLength--;
                lengthOnRef--;
              } else {
                break;
              }
            }
            while (altLength > 0 && lengthOnRef > 0) {
              const altIdx = s;
              const refIdx = s;
              if (alt.charCodeAt(altIdx) === ref.charCodeAt(refIdx)) {
                s++;
                altLength--;
                lengthOnRef--;
              } else {
                break;
              }
            }
            const alleleStart = this.pos + s - 1;
            const alleleEnd = alleleStart + lengthOnRef;
            this.start = this.start === void 0 ? alleleStart : Math.min(this.start, alleleStart);
            this.end = this.end === void 0 ? alleleEnd : Math.max(this.end, alleleEnd);
          }
        }
        if (this.start === void 0) {
          this.start = this.pos - 1;
          this.end = this.pos;
        }
      }
    }
  }
  popupData(genomicLocation, genomeId) {
    const posString = `${numberFormatter$1(this.pos)}`;
    const locString = this.start === this.end ? `${numberFormatter$1(this.start)} | ${numberFormatter$1(this.start + 1)}` : `${numberFormatter$1(this.start + 1)}-${numberFormatter$1(this.end)}`;
    const fields = [
      { name: "Chr", value: this.chr },
      { name: "Pos", value: posString },
      { name: "Loc", value: locString },
      { name: "ID", value: this.names ? this.names : "" },
      { name: "Ref", value: this.referenceBases },
      { name: "Alt", value: this.alternateBases.replace("<", "&lt;") },
      { name: "Qual", value: this.quality },
      { name: "Filter", value: this.filter }
    ];
    if ("SNP" === this.type) {
      let ref = this.referenceBases;
      if (ref.length === 1) {
        let altArray = this.alternateBases.split(",");
        for (let alt of altArray) {
          if (alt.length === 1) {
            let l = TrackBase.getCravatLink(this.chr, this.pos, ref, alt, genomeId);
            if (l) {
              fields.push("<hr/>");
              fields.push({ html: l });
            }
          }
        }
      }
    }
    if (this.hasOwnProperty("heterozygosity")) {
      fields.push({ name: "Heterozygosity", value: this.heterozygosity });
    }
    if (this.info) {
      fields.push({ html: '<hr style="border-top: dotted 1px;border-color: #c9c3ba" />' });
      for (let key of Object.keys(this.info)) {
        fields.push({ name: key, value: arrayToString(decodeURIComponent(this.info[key])) });
      }
    }
    return fields;
  }
  getInfo(tag) {
    return this.info ? this.info[tag] : void 0;
  }
  isRefBlock() {
    return "NONVARIANT" === this.type;
  }
}
const knownAltBases = new Set(["A", "C", "T", "G"].map((c) => c.charCodeAt(0)));
function isKnownAlt(alt) {
  for (let i = 0; i < alt.length; i++) {
    if (!knownAltBases.has(alt.charCodeAt(i))) {
      return false;
    }
  }
  return true;
}
function determineType(ref, altAlleles) {
  const refLength = ref.length;
  if (altAlleles === void 0) {
    return "UNKNOWN";
  } else if (altAlleles.trim().length === 0 || altAlleles === "<NON_REF>" || altAlleles === "<*>" || altAlleles === ".") {
    return "NONVARIANT";
  } else {
    const alleles = altAlleles.split(",");
    const types = alleles.map(function(a) {
      if (refLength === 1 && a.length === 1) {
        return "SNP";
      } else {
        return "<NON_REF>" === a ? "NONVARIANT" : "OTHER";
      }
    });
    let type = types[0];
    for (let t of types) {
      if (t !== type) {
        return "MIXED";
      }
    }
    return type;
  }
}
function arrayToString(value, delim) {
  if (delim === void 0) delim = ",";
  if (!Array.isArray(value)) {
    return value;
  }
  return value.join(delim);
}
class VcfParser {
  construtor() {
  }
  async parseHeader(dataWrapper, genome) {
    const header = {};
    header.chrAliasTable = /* @__PURE__ */ new Map();
    let line = await dataWrapper.nextLine();
    if (line.startsWith("##fileformat")) {
      header.version = line.substr(13);
    } else {
      throw new Error("Invalid VCF file: missing fileformat line");
    }
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      if (line.startsWith("#")) {
        let id;
        const values = {};
        if (line.startsWith("##")) {
          if (line.startsWith("##INFO") || line.startsWith("##FILTER") || line.startsWith("##FORMAT")) {
            const ltIdx = line.indexOf("<");
            const gtIdx = line.lastIndexOf(">");
            if (!(ltIdx > 2 && gtIdx > 0)) {
              console.log("Malformed VCF header line: " + line);
              continue;
            }
            const type = line.substring(2, ltIdx - 1);
            if (!header[type]) header[type] = {};
            const tokens = splitStringRespectingQuotes(line.substring(ltIdx + 1, gtIdx - 1), ",");
            for (let token of tokens) {
              var kv = token.split("=");
              if (kv.length > 1) {
                if (kv[0] === "ID") {
                  id = kv[1];
                } else {
                  values[kv[0]] = kv[1];
                }
              }
            }
            if (id) {
              header[type][id] = values;
            }
          } else if (line.startsWith("##contig") && genome) {
            const idx1 = line.indexOf("<ID=");
            let idx2 = line.indexOf(",", idx1);
            if (idx2 == -1) {
              idx2 = line.indexOf(">", idx1);
            }
            const chr = line.substring(idx1 + 4, idx2);
            const canonicalChromosome = genome.getChromosomeName(chr);
            header.chrAliasTable.set(canonicalChromosome, chr);
          } else ;
        } else if (line.startsWith("#CHROM")) {
          const tokens = line.split("	");
          if (tokens.length > 8) {
            header.callSets = [];
            for (let j = 9; j < tokens.length; j++) {
              header.callSets.push({ id: j, name: tokens[j] });
            }
          }
        }
      } else {
        break;
      }
    }
    this.header = header;
    return header;
  }
  /**
   * Parse data as a collection of Variant objects.
   *
   * @param data
   * @returns {Array}
   */
  async parseFeatures(dataWrapper) {
    const allFeatures = [];
    const callSets = this.header.callSets;
    const nExpectedColumns = 8 + (callSets ? callSets.length + 1 : 0);
    let line;
    while ((line = await dataWrapper.nextLine()) !== void 0) {
      if (line && !line.startsWith("#")) {
        const tokens = line.split("	");
        if (tokens.length === nExpectedColumns) {
          const variant = createVCFVariant(tokens);
          variant.header = this.header;
          allFeatures.push(variant);
          if (tokens.length > 9) {
            const callFields = extractCallFields(tokens[8].split(":"));
            variant.calls = {};
            for (let index2 = 9; index2 < tokens.length; index2++) {
              const token = tokens[index2];
              const callSet = callSets[index2 - 9];
              const call = {
                callSetName: callSet.name,
                info: {}
              };
              variant.calls[callSet.id] = call;
              token.split(":").forEach(function(callToken, idx) {
                switch (idx) {
                  case callFields.genotypeIndex:
                    call.genotype = [];
                    callToken.split(/[\|\/]/).forEach(function(s) {
                      call.genotype.push("." === s ? s : parseInt(s));
                    });
                    break;
                  default:
                    call.info[callFields.fields[idx]] = callToken;
                }
              });
            }
          }
          if (variant.info && variant.info.CHR2 && variant.info.END) {
            allFeatures.push(svComplement(variant));
          }
        }
      }
    }
    return allFeatures;
  }
}
function extractCallFields(tokens) {
  const callFields = {
    genotypeIndex: -1,
    fields: tokens
  };
  for (let i = 0; i < tokens.length; i++) {
    if ("GT" === tokens[i]) {
      callFields.genotypeIndex = i;
    }
  }
  return callFields;
}
function svComplement(v) {
  const chr2 = v.info.CHR2;
  const pos2 = Number.parseInt(v.info.END);
  return {
    chr: chr2,
    start: pos2 - 1,
    end: pos2,
    _f: v
  };
}
class GWASParser {
  constructor(config) {
    this.config = config;
    if (config.columns) {
      if (config.columns.chromosome === void 0 || config.columns.position === void 0 || config.columns.value === void 0) {
        throw Error("columns property must define chrCol, posCol, and valueCol");
      }
      this.posCol = config.columns.position - 1;
      this.chrCol = config.columns.chromosome - 1;
      this.valueCol = config.columns.value - 1;
    } else {
      this.posCol = 2;
      this.chrCol = 1;
      this.valueCol = 3;
    }
  }
  async parseHeader(dataWrapper) {
    const headerLine = await dataWrapper.nextLine();
    return this.parseHeaderLine(headerLine);
  }
  parseHeaderLine(headerLine) {
    this.columns = headerLine.split(/\t/);
    if (!this.config.columns) {
      for (let i = 0; i < this.columns.length; i++) {
        const c = this.columns[i].toLowerCase();
        switch (c) {
          case "chr":
          case "chromosome":
          case "chr_id":
            this.chrCol = i;
            break;
          case "bp":
          case "pos":
          case "position":
          case "chr_pos":
            this.posCol = i;
            break;
          case "p":
          case "pval":
          case "pvalue":
          case "p-value":
          case "p.value":
            this.valueCol = i;
            break;
        }
      }
    }
    return this.columns;
  }
  async parseFeatures(dataWrapper) {
    const allFeatures = [];
    const headerLine = dataWrapper.nextLine();
    if (!this.columns) {
      this.parseHeaderLine(headerLine);
    }
    let line;
    while ((line = dataWrapper.nextLine()) !== void 0) {
      const tokens = line.split(/\t/);
      if (tokens.length === this.columns.length) {
        const chr = tokens[this.chrCol];
        const start = parseInt(tokens[this.posCol]) - 1;
        const end = start + 1;
        const value = Number(tokens[this.valueCol]);
        allFeatures.push(new GWASFeature({
          chr,
          start,
          end,
          value,
          line,
          columns: this.columns
        }));
      }
    }
    return allFeatures;
  }
}
class GWASFeature {
  constructor({ chr, start, end, value, line, columns }) {
    this.chr = chr;
    this.start = start;
    this.end = end;
    this.value = value;
    this.line = line;
    this.columns = columns;
  }
  popupData() {
    const tokens = this.line.split(/\t/);
    return this.columns.map(function(c, index2) {
      return { name: c, value: tokens[index2] };
    });
  }
  getAttribute(attrName) {
    const tokens = this.line.split(/\t/);
    for (let i = 0; i < this.columns.length; i++) {
      if (this.columns[i] === attrName) {
        return tokens[i];
      }
    }
    return void 0;
  }
}
var aedRegexpNoNamespace = new RegExp("([^:]*)\\(([^)]*)\\)");
var aedRegexpNamespace = new RegExp("([^:]*):([^(]*)\\(([^)]*)\\)");
class AEDParser {
  constructor(config) {
    const decode2 = config ? config.decode : void 0;
    this.nameField = config ? config.nameField : void 0;
    this.skipRows = 0;
    if (decode2) {
      this.decode = decode2;
    } else {
      this.decode = decodeAed;
    }
    this.delimiter = "	";
  }
  async parseHeader(dataWrapper) {
    let line;
    let header;
    while (line = await dataWrapper.nextLine()) {
      if (line.startsWith("track") || line.startsWith("#") || line.startsWith("browser")) {
        if (line.startsWith("track") || line.startsWith("#track")) {
          let h = parseTrackLine(line);
          if (header) {
            Object.assign(header, h);
          } else {
            header = h;
          }
        } else if (line.startsWith("#columns")) {
          let h = parseColumnsDirective(line);
          if (header) {
            Object.assign(header, h);
          } else {
            header = h;
          }
        } else if (line.startsWith("##gff-version 3")) {
          this.format = "gff3";
          if (!header) header = {};
          header["format"] = "gff3";
        }
      } else {
        break;
      }
    }
    this.header = header;
    return header;
  }
  async parseFeatures(dataWrapper) {
    const allFeatures = [];
    const decode2 = this.decode;
    const delimiter = this.delimiter || "	";
    let i = 0;
    let line;
    let wig;
    while ((line = dataWrapper.nextLine()) !== void 0) {
      i++;
      if (i <= this.skipRows || line.startsWith("track") || line.startsWith("#") || line.startsWith("browser")) {
        continue;
      }
      let tokens = readTokensAed();
      if (tokens.length < 1) {
        continue;
      }
      if (!this.aed) {
        this.aed = parseAedHeaderRow(tokens);
        continue;
      }
      const feature2 = decode2.call(this, tokens, wig);
      if (feature2) {
        allFeatures.push(feature2);
      }
    }
    return allFeatures;
    function readTokensAed() {
      var tokens = [], token = "", quotedString = false, n, c;
      while (line || line === "") {
        for (n = 0; n < line.length; n++) {
          c = line.charAt(n);
          if (c === delimiter) {
            if (!quotedString) {
              tokens.push(token);
              token = "";
            } else {
              token += c;
            }
          } else if (c === '"') {
            if (n + 1 < line.length && line.charAt(n + 1) === '"') {
              if (quotedString) {
                token += '"';
              }
              n++;
            } else {
              quotedString = !quotedString;
            }
          } else {
            token += c;
          }
        }
        if (quotedString) {
          token += "\n";
          line = nextLine();
        } else {
          break;
        }
      }
      tokens.push(token);
      return tokens;
    }
  }
}
function parseAedToken(value) {
  var match = aedRegexpNamespace.exec(value);
  if (match) {
    return {
      namespace: match[1],
      name: match[2],
      type: match[3]
    };
  }
  match = aedRegexpNoNamespace.exec(value);
  if (match) {
    return {
      namespace: "?",
      name: match[1],
      type: match[2]
    };
  } else {
    throw new Error("Error parsing the header row of AED file - column not in ns:name(ns:type) format");
  }
}
function parseAedHeaderRow(tokens) {
  var aed, k, token, aedToken;
  aed = {
    columns: [
      // Information about the namespace, name and type of each column
      // Example entry:
      // { namespace: 'bio', name: 'start', type: 'aed:Integer' }
    ],
    metadata: {
      // Metadata about the entire AED file
      // Example:
      // {
      //    aed: {
      //       application: { value: "CHaS Browser 3.3.0.139 (r10838)", type: "aed:String" },
      //       created: { value: "2018-01-02T10:20:30.123+01:00", type: "aed:DateTime" },
      //       modified: { value: "2018-03-04T11:22:33.456+01:00", type: "aed:DateTime" },
      //    }
      //    affx: {
      //       ucscGenomeVersion: { value: "hg19", type: "aed:String" }
      //    },
      //    namespace: {
      //       omim: { value: "http://affymetrix.com/ontology/www.ncbi.nlm.nih.gov/omim/", type: "aed:URI" },
      //       affx: { value: "http://affymetrix.com/ontology/", type: "aed:URI" },
      //       refseq: { value: "http://affymetrix.com/ontology/www.ncbi.nlm.nih.gov/RefSeq/", type: "aed:URI" }
      //    }
      // }
    }
  };
  for (k = 0; k < tokens.length; k++) {
    token = tokens[k];
    aedToken = parseAedToken(token);
    aed.columns.push(aedToken);
  }
  return aed;
}
function parseTrackLine(line) {
  const properties = {};
  const tokens = line.split(/(?:")([^"]+)(?:")|([^\s"]+)(?=\s+|$)/g);
  let curr;
  const tmp = [];
  for (let tk of tokens) {
    if (!tk || tk.trim().length === 0) continue;
    if (tk.endsWith("=") > 0) {
      curr = tk;
    } else if (curr) {
      tmp.push(curr + tk);
      curr = void 0;
    } else {
      tmp.push(tk);
    }
  }
  for (let str of tmp) {
    if (!str) return;
    var kv = str.split("=", 2);
    if (kv.length === 2) {
      const key = kv[0].trim();
      const value = kv[1].trim();
      properties[key] = value;
    }
  }
  return properties;
}
function parseColumnsDirective(line) {
  let properties = {};
  let t12 = line.split(/\s+/);
  if (t12.length === 2) {
    let t22 = t12[1].split(";");
    t22.forEach(function(keyValue) {
      let t = keyValue.split("=");
      if (t[0] === "color") {
        properties.colorColumn = Number.parseInt(t[1]) - 1;
      } else if (t[0] === "thickness") {
        properties.thicknessColumn = Number.parseInt(t[1]) - 1;
      }
    });
  }
  return properties;
}
function AedFeature(aed, allColumns) {
  var token, aedColumn, aedColumns = aed.columns;
  this.aed = aed;
  this.allColumns = allColumns;
  this.chr = null;
  this.start = null;
  this.end = null;
  this.score = 1e3;
  this.strand = ".";
  this.cdStart = null;
  this.cdEnd = null;
  this.name = null;
  this.color = null;
  for (let i = 0; i < allColumns.length; i++) {
    token = allColumns[i];
    if (!token) {
      continue;
    }
    aedColumn = aedColumns[i];
    if (aedColumn.type === "aed:Integer") {
      token = parseInt(token);
    }
    var arr2 = [];
    if (aedColumn.namespace.length > 0) {
      for (let j = 0; j < aedColumn.namespace.length; j++) {
        arr2.push(aedColumn.namespace.charCodeAt(j));
      }
    }
    if (aedColumn.namespace.trim() === "bio") {
      if (aedColumn.name === "sequence") {
        this.chr = token;
      } else if (aedColumn.name === "start") {
        this.start = token;
      } else if (aedColumn.name === "end") {
        this.end = token;
      } else if (aedColumn.name === "cdsMin") {
        this.cdStart = token;
      } else if (aedColumn.name === "cdsMax") {
        this.cdEnd = token;
      } else if (aedColumn.name === "strand") {
        this.strand = token;
      }
    } else if (aedColumn.namespace === "aed") {
      if (aedColumn.name === "name") {
        this.name = token;
      }
    } else if (aedColumn.namespace === "style") {
      if (aedColumn.name === "color") {
        this.color = IGVColor.createColorString(token);
      }
    }
  }
}
AedFeature.prototype.popupData = function() {
  var data = [], aed = this.aed;
  for (var i = 0; i < this.allColumns.length; i++) {
    var featureValue = this.allColumns[i];
    var name2 = aed.columns[i].name;
    if (name2 !== "sequence" && name2 !== "color") {
      if (featureValue) {
        data.push({ name: name2, value: featureValue });
      }
    }
  }
  return data;
};
function decodeAed(tokens, ignore) {
  var name2, value, token, nonEmptyTokens = 0, aedColumns = this.aed.columns, aedColumn, aedKey, i;
  if (tokens.length !== aedColumns.length) {
    console.log("Corrupted AED file row: " + tokens.join(","));
    return void 0;
  }
  for (i = 0; i < tokens.length; i++) {
    aedColumn = aedColumns[i];
    token = tokens[i];
    if (token !== "") {
      nonEmptyTokens++;
    }
    if (aedColumn.name === "name" && aedColumn.namespace === "aed") {
      name2 = token;
    } else if (aedColumn.name === "value" && aedColumn.namespace === "aed") {
      value = token;
    }
  }
  if (nonEmptyTokens === 2 && name2 && value) {
    aedKey = parseAedToken(name2);
    if (!this.aed.metadata[aedKey.namespace]) {
      this.aed.metadata[aedKey.namespace] = {};
    }
    if (!this.aed.metadata[aedKey.namespace][aedKey.name]) {
      this.aed.metadata[aedKey.namespace][aedKey.name] = {
        type: aedKey.type,
        value
      };
    }
    return void 0;
  }
  var feature2 = new AedFeature(this.aed, tokens);
  if (!feature2.chr || !feature2.start && feature2.start !== 0 || !feature2.end) {
    console.log("Cannot parse feature: " + tokens.join(","));
    return void 0;
  }
  return feature2;
}
let BinaryParser$1 = class BinaryParser {
  constructor(dataView, littleEndian) {
    this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
    this.position = 0;
    this.view = dataView;
    this.length = dataView.byteLength;
  }
  available() {
    return this.length - this.position;
  }
  remLength() {
    return this.length - this.position;
  }
  hasNext() {
    return this.position < this.length - 1;
  }
  getByte() {
    var retValue = this.view.getUint8(this.position, this.littleEndian);
    this.position++;
    return retValue;
  }
  getShort() {
    var retValue = this.view.getInt16(this.position, this.littleEndian);
    this.position += 2;
    return retValue;
  }
  getUShort() {
    var retValue = this.view.getUint16(this.position, this.littleEndian);
    this.position += 2;
    return retValue;
  }
  getInt() {
    var retValue = this.view.getInt32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;
  }
  getUInt() {
    var retValue = this.view.getUint32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;
  }
  getLong() {
    var b = [];
    b[0] = this.view.getUint8(this.position);
    b[1] = this.view.getUint8(this.position + 1);
    b[2] = this.view.getUint8(this.position + 2);
    b[3] = this.view.getUint8(this.position + 3);
    b[4] = this.view.getUint8(this.position + 4);
    b[5] = this.view.getUint8(this.position + 5);
    b[6] = this.view.getUint8(this.position + 6);
    b[7] = this.view.getUint8(this.position + 7);
    var value = 0;
    if (this.littleEndian) {
      for (let i = b.length - 1; i >= 0; i--) {
        value = value * 256 + b[i];
      }
    } else {
      for (let i = 0; i < b.length; i++) {
        value = value * 256 + b[i];
      }
    }
    this.position += 8;
    return value;
  }
  getString(len2) {
    var s = "";
    var c;
    while ((c = this.view.getUint8(this.position++)) !== 0) {
      s += String.fromCharCode(c);
      if (len2 && s.length === len2) break;
    }
    return s;
  }
  getFixedLengthString(len2) {
    var s = "";
    var i;
    var c;
    for (i = 0; i < len2; i++) {
      c = this.view.getUint8(this.position++);
      if (c > 0) {
        s += String.fromCharCode(c);
      }
    }
    return s;
  }
  getFixedLengthTrimmedString(len2) {
    var s = "";
    var i;
    var c;
    for (i = 0; i < len2; i++) {
      c = this.view.getUint8(this.position++);
      if (c > 32) {
        s += String.fromCharCode(c);
      }
    }
    return s;
  }
  getFloat() {
    var retValue = this.view.getFloat32(this.position, this.littleEndian);
    this.position += 4;
    return retValue;
  }
  getDouble() {
    var retValue = this.view.getFloat64(this.position, this.littleEndian);
    this.position += 8;
    return retValue;
  }
  skip(n) {
    this.position += n;
    return this.position;
  }
  /**
   * Return a BGZip (bam and tabix) virtual pointer
   * TODO -- why isn't 8th byte used ?
   * @returns {*}
   */
  getVPointer() {
    var position = this.position, offset2 = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position), byte6 = (this.view.getUint8(position + 6) & 255) * 4294967296, byte5 = (this.view.getUint8(position + 5) & 255) * 16777216, byte4 = (this.view.getUint8(position + 4) & 255) * 65536, byte3 = (this.view.getUint8(position + 3) & 255) * 256, byte2 = this.view.getUint8(position + 2) & 255, block = byte6 + byte5 + byte4 + byte3 + byte2;
    this.position += 8;
    return new VPointer$1(block, offset2);
  }
};
let VPointer$1 = class VPointer {
  constructor(block, offset2) {
    this.block = block;
    this.offset = offset2;
  }
  isLessThan(vp) {
    return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;
  }
  isGreaterThan(vp) {
    return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;
  }
  isEqualTo(vp) {
    return this.block === vp.block && this.offset === vp.offset;
  }
  print() {
    return "" + this.block + ":" + this.offset;
  }
};
function optimizeChunks(chunks, lowest) {
  if (chunks.length === 0) return chunks;
  chunks.sort(function(c0, c1) {
    const dif = c0.minv.block - c1.minv.block;
    if (dif !== 0) {
      return dif;
    } else {
      return c0.minv.offset - c1.minv.offset;
    }
  });
  if (chunks.length <= 1) {
    return chunks;
  }
  if (lowest) {
    chunks = chunks.filter((c) => c.maxv.isGreaterThan(lowest));
  }
  const mergedChunks = [];
  let lastChunk;
  for (let chunk of chunks) {
    if (!lastChunk) {
      mergedChunks.push(chunk);
      lastChunk = chunk;
    } else {
      if (canMerge(lastChunk, chunk)) {
        if (chunk.maxv.isGreaterThan(lastChunk.maxv)) {
          lastChunk.maxv = chunk.maxv;
        }
      } else {
        mergedChunks.push(chunk);
        lastChunk = chunk;
      }
    }
  }
  return mergedChunks;
}
function canMerge(chunk1, chunk2) {
  chunk2.minv.block - chunk1.maxv.block;
  const sizeEstimate = chunk1.maxv.block - chunk1.minv.block;
  return sizeEstimate < 5e6;
}
const CSI1_MAGIC$1 = 21582659;
const CSI2_MAGIC$1 = 38359875;
async function parseCsiIndex(arrayBuffer, genome) {
  const idx = new CSIIndex();
  idx.parse(arrayBuffer, genome);
  return idx;
}
class CSIIndex {
  constructor(tabix) {
    this.tabix = true;
  }
  parse(arrayBuffer, genome) {
    const parser = new BinaryParser$1(new DataView(arrayBuffer));
    const magic = parser.getInt();
    if (magic !== CSI1_MAGIC$1) {
      if (magic === CSI2_MAGIC$1) {
        throw Error("CSI version 2 is not supported.  Please enter an issue at https://github.com/igvteam/igv.js");
      } else {
        throw Error("Not a CSI index");
      }
    }
    this.indices = [];
    this.blockMin = Number.MAX_SAFE_INTEGER;
    this.lastBlockPosition = [];
    this.sequenceIndexMap = {};
    this.minShift = parser.getInt();
    this.depth = parser.getInt();
    const lAux = parser.getInt();
    const seqNames = [];
    let bmax = 0;
    if (lAux >= 28) {
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      parser.getInt();
      const l_nm = parser.getInt();
      const nameEndPos = parser.position + l_nm;
      let i = 0;
      while (parser.position < nameEndPos) {
        let seq_name = parser.getString();
        if (genome) {
          seq_name = genome.getChromosomeName(seq_name);
        }
        this.sequenceIndexMap[seq_name] = i;
        seqNames[i] = seq_name;
        i++;
      }
    }
    const MAX_BIN = this.bin_limit() + 1;
    const nref = parser.getInt();
    for (let ref = 0; ref < nref; ref++) {
      const binIndex = [];
      const loffset = [];
      const nbin = parser.getInt();
      for (let b = 0; b < nbin; b++) {
        const binNumber = parser.getInt();
        loffset[binNumber] = parser.getVPointer();
        if (binNumber > MAX_BIN) {
          parser.getInt();
          parser.getVPointer();
          parser.getVPointer();
          parser.getLong();
          parser.getLong();
        } else {
          binIndex[binNumber] = [];
          const nchnk = parser.getInt();
          for (let i = 0; i < nchnk; i++) {
            const cs = parser.getVPointer();
            const ce = parser.getVPointer();
            if (cs && ce) {
              if (cs.block < this.blockMin) {
                this.blockMin = cs.block;
              }
              if (ce.block > bmax) {
                bmax = ce.block;
              }
              binIndex[binNumber].push([cs, ce]);
            }
          }
        }
      }
      if (nbin > 0) {
        this.indices[ref] = {
          binIndex,
          loffset
        };
      }
    }
    this.lastBlockPosition = bmax;
  }
  get chromosomeNames() {
    return Object.keys(this.sequenceIndexMap);
  }
  /**
   * Fetch blocks for a particular genomic range.  This method is public so it can be unit-tested.
   *
   * @param refId  the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   * @param return an array of {minv: {filePointer, offset}, {maxv: {filePointer, offset}}
   */
  chunksForRange(refId, min, max) {
    const ba = this.indices[refId];
    if (!ba) {
      return [];
    } else {
      const overlappingBins = this.reg2bins(min, max);
      if (overlappingBins.length == 0) return [];
      const chunks = [];
      for (let binRange of overlappingBins) {
        for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
          if (ba.binIndex[bin]) {
            const binChunks = ba.binIndex[bin];
            for (let c of binChunks) {
              const cs = c[0];
              const ce = c[1];
              chunks.push({ minv: cs, maxv: ce, bin });
            }
          }
        }
      }
      const lowestOffset = ba.loffset[overlappingBins[0]];
      return optimizeChunks(chunks, lowestOffset);
    }
  }
  // reg2bins implementation adapted from GMOD/tabix-js  https://github.com/GMOD/tabix-js/blob/master/src/csi.ts
  reg2bins(beg, end) {
    beg -= 1;
    if (beg < 1) beg = 1;
    if (end > 2 ** 34) end = 2 ** 34;
    end -= 1;
    let l = 0;
    let t = 0;
    let s = this.minShift + this.depth * 3;
    const bins = [];
    for (; l <= this.depth; s -= 3, t += 1 << l * 3, l += 1) {
      const b = t + (beg >> s);
      const e = t + (end >> s);
      bins.push([b, e]);
    }
    return bins;
  }
  bin_limit() {
    return ((1 << (this.depth + 1) * 3) - 1) / 7;
  }
}
const BAI_MAGIC$1 = 21578050;
const TABIX_MAGIC$1 = 21578324;
async function parseBamIndex(arrayBuffer, genome) {
  const index2 = new BamIndex();
  await index2.parse(arrayBuffer, false, genome);
  return index2;
}
async function parseTabixIndex(arrayBuffer, genome) {
  const index2 = new BamIndex();
  await index2.parse(arrayBuffer, true, genome);
  return index2;
}
class BamIndex {
  constructor() {
  }
  async parse(arrayBuffer, tabix, genome) {
    const indices = [];
    let blockMin = Number.MAX_SAFE_INTEGER;
    let blockMax = 0;
    const parser = new BinaryParser$1(new DataView(arrayBuffer));
    const magic = parser.getInt();
    const sequenceIndexMap = {};
    if (magic === BAI_MAGIC$1 || tabix && magic === TABIX_MAGIC$1) {
      const nref = parser.getInt();
      if (tabix) {
        parser.getInt();
        parser.getInt();
        parser.getInt();
        parser.getInt();
        parser.getInt();
        parser.getInt();
        parser.getInt();
        for (let i = 0; i < nref; i++) {
          let seq_name = parser.getString();
          if (genome) {
            seq_name = genome.getChromosomeName(seq_name);
          }
          sequenceIndexMap[seq_name] = i;
        }
      }
      for (let ref = 0; ref < nref; ref++) {
        const binIndex = {};
        const linearIndex = [];
        const nbin = parser.getInt();
        for (let b = 0; b < nbin; b++) {
          const binNumber = parser.getInt();
          if (binNumber === 37450) {
            parser.getInt();
            parser.getVPointer();
            parser.getVPointer();
            parser.getLong();
            parser.getLong();
          } else {
            binIndex[binNumber] = [];
            const nchnk = parser.getInt();
            for (let i = 0; i < nchnk; i++) {
              const cs = parser.getVPointer();
              const ce = parser.getVPointer();
              if (cs && ce) {
                if (cs.block < blockMin) {
                  blockMin = cs.block;
                }
                if (ce.block > blockMax) {
                  blockMax = ce.block;
                }
                binIndex[binNumber].push([cs, ce]);
              }
            }
          }
        }
        const nintv = parser.getInt();
        for (let i = 0; i < nintv; i++) {
          const cs = parser.getVPointer();
          linearIndex.push(cs);
        }
        if (nbin > 0) {
          indices[ref] = {
            binIndex,
            linearIndex
          };
        }
      }
      this.firstBlockPosition = blockMin;
      this.lastBlockPosition = blockMax;
      this.indices = indices;
      this.sequenceIndexMap = sequenceIndexMap;
      this.tabix = tabix;
    } else {
      throw new Error(indexURL + " is not a " + (tabix ? "tabix" : "bai") + " file");
    }
  }
  get chromosomeNames() {
    return Object.keys(this.sequenceIndexMap);
  }
  /**
   * Fetch chunks for a particular genomic range.  This method is public so it can be unit-tested.
   *
   * @param refId  the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   * @param return an array of objects representing chunks (file spans) {minv: {block, offset}, {maxv: {block, offset}}
   */
  chunksForRange(refId, min, max) {
    const bam = this;
    const ba = bam.indices[refId];
    if (!ba) {
      return [];
    } else {
      const overlappingBins = reg2bins(min, max);
      const chunks = [];
      for (let binRange of overlappingBins) {
        for (let bin = binRange[0]; bin <= binRange[1]; bin++) {
          if (ba.binIndex[bin]) {
            const binChunks = ba.binIndex[bin];
            for (let c of binChunks) {
              const cs = c[0];
              const ce = c[1];
              chunks.push({ minv: cs, maxv: ce });
            }
          }
        }
      }
      const nintv = ba.linearIndex.length;
      let lowest;
      const minLin = Math.min(min >> 14, nintv - 1);
      const maxLin = Math.min(max >> 14, nintv - 1);
      for (let i = minLin; i <= maxLin; i++) {
        const vp = ba.linearIndex[i];
        if (vp) {
          lowest = vp;
          break;
        }
      }
      return optimizeChunks(chunks, lowest);
    }
  }
}
function reg2bins(beg, end) {
  const list = [];
  if (end >= 1 << 29) end = 1 << 29;
  --end;
  list.push([0, 0]);
  list.push([1 + (beg >> 26), 1 + (end >> 26)]);
  list.push([9 + (beg >> 23), 9 + (end >> 23)]);
  list.push([73 + (beg >> 20), 73 + (end >> 20)]);
  list.push([585 + (beg >> 17), 585 + (end >> 17)]);
  list.push([4681 + (beg >> 14), 4681 + (end >> 14)]);
  return list;
}
async function parseTribbleIndex(arrayBuffer, genome) {
  const index2 = new TribbleIndex();
  index2.parse(arrayBuffer, genome);
  return index2;
}
class TribbleIndex {
  constructor() {
  }
  async parse(arrayBuffer, genome) {
    let blockMax = 0;
    this.chrIndex = {};
    this.lastBlockPosition = [];
    const parser = new BinaryParser$1(new DataView(arrayBuffer));
    readHeader(parser);
    let nChrs = parser.getInt();
    while (nChrs-- > 0) {
      let chr = parser.getString();
      if (genome) chr = genome.getChromosomeName(chr);
      const binWidth = parser.getInt();
      const nBins = parser.getInt();
      const longestFeature = parser.getInt();
      parser.getInt() > 0;
      parser.getInt();
      let pos = parser.getLong();
      const blocks = [];
      for (let binNumber = 0; binNumber < nBins; binNumber++) {
        const nextPos = parser.getLong();
        blocks.push({ min: pos, max: nextPos });
        pos = nextPos;
        if (nextPos > blockMax) {
          blockMax = nextPos;
        }
      }
      this.chrIndex[chr] = { chr, blocks, longestFeature, binWidth };
    }
    this.lastBlockPosition = blockMax;
    function readHeader(parser2) {
      parser2.getInt();
      parser2.getInt();
      const version2 = parser2.getInt();
      parser2.getString();
      parser2.getLong();
      parser2.getLong();
      parser2.getString();
      parser2.getInt();
      if (version2 >= 3) {
        let nProperties = parser2.getInt();
        while (nProperties-- > 0) {
          parser2.getString();
          parser2.getString();
        }
      }
    }
  }
  get chromosomeNames() {
    return Object.keys(this.chrIndex);
  }
  /**
   * Fetch blocks for a particular genomic range.
   *
   * @param queryChr the sequence dictionary index of the chromosome
   * @param min  genomic start position
   * @param max  genomic end position
   */
  chunksForRange(queryChr, min, max) {
    const chrIdx = this.chrIndex[queryChr];
    if (chrIdx) {
      const blocks = chrIdx.blocks;
      const longestFeature = chrIdx.longestFeature;
      const binWidth = chrIdx.binWidth;
      const adjustedPosition = Math.max(min - longestFeature, 0);
      const startBinNumber = Math.floor(adjustedPosition / binWidth);
      if (startBinNumber >= blocks.length)
        return [];
      else {
        const endBinNumber = Math.min(Math.floor((max - 1) / binWidth), blocks.length - 1);
        const startPos = blocks[startBinNumber].min;
        const endPos = blocks[endBinNumber].max;
        const size = endPos - startPos;
        if (size === 0) {
          return [];
        } else {
          const mergedBlock = { minv: { block: startPos, offset: 0 }, maxv: { block: endPos, offset: 0 } };
          return [mergedBlock];
        }
      }
    } else {
      return void 0;
    }
  }
}
const CSI1_MAGIC = 21582659;
const CSI2_MAGIC = 38359875;
const BAI_MAGIC = 21578050;
const TABIX_MAGIC = 21578324;
const TRIBBLE_MAGIC = 1480870228;
async function loadIndex(indexURL2, config, genome) {
  let arrayBuffer = await igvxhr.loadArrayBuffer(indexURL2, buildOptions$1(config));
  let dv = new DataView(arrayBuffer);
  if (dv.getUint8(0) === 31 && dv.getUint8(1) === 139) {
    const inflate2 = unbgzf(arrayBuffer);
    arrayBuffer = inflate2.buffer;
    dv = new DataView(arrayBuffer);
  }
  const magic = dv.getInt32(0, true);
  switch (magic) {
    case BAI_MAGIC:
      return parseBamIndex(arrayBuffer, genome);
    case TABIX_MAGIC:
      return parseTabixIndex(arrayBuffer, genome);
    case CSI1_MAGIC:
      return parseCsiIndex(arrayBuffer, genome);
    case TRIBBLE_MAGIC:
      return parseTribbleIndex(arrayBuffer, genome);
    case CSI2_MAGIC:
      throw Error("CSI version 2 is not supported.");
    default:
      throw Error(`Unrecognized index type: ${indexURL2}`);
  }
}
function getDataWrapper(data) {
  if (typeof data == "string" || data instanceof String) {
    return new StringDataWrapper(data);
  } else {
    return new ByteArrayDataWrapper(data);
  }
}
class StringDataWrapper {
  constructor(string) {
    this.data = string;
    this.ptr = 0;
  }
  nextLine() {
    var start = this.ptr, idx = this.data.indexOf("\n", start), data = this.data;
    if (idx > 0) {
      this.ptr = idx + 1;
      if (idx > start && data.charAt(idx - 1) === "\r") {
        return data.substring(start, idx - 1);
      }
      return data.substring(start, idx);
    } else {
      var length = data.length;
      this.ptr = length;
      return start >= length ? void 0 : data.substring(start);
    }
  }
}
class ByteArrayDataWrapper {
  constructor(array) {
    this.data = array;
    this.length = this.data.length;
    this.ptr = 0;
  }
  nextLine() {
    var c, result;
    result = "";
    if (this.ptr >= this.length) return void 0;
    for (var i = this.ptr; i < this.length; i++) {
      c = String.fromCharCode(this.data[i]);
      if (c === "\r") continue;
      if (c === "\n") break;
      result = result + c;
    }
    this.ptr = i + 1;
    return result;
  }
}
class BGZLineReader {
  constructor(config) {
    this.config = config;
    this.filePtr = 0;
    this.bufferPtr = 0;
    this.buffer;
  }
  async nextLine() {
    let result = void 0;
    try {
      while (true) {
        const length = this.buffer ? this.buffer.length : 0;
        while (this.bufferPtr < length) {
          const c = String.fromCharCode(this.buffer[this.bufferPtr++]);
          if (c === "\r") continue;
          if (c === "\n") {
            return result;
          }
          result = result ? result + c : c;
        }
        if (this.eof) {
          return result;
        } else {
          await this.readNextBlock();
        }
      }
    } catch (e) {
      console.warn(e);
      this.eof = true;
      return result;
    }
  }
  async readNextBlock() {
    const bsizeOptions = buildOptions$1(this.config, {
      range: {
        start: this.filePtr,
        size: 26
      }
    });
    const abuffer = await igvxhr.loadArrayBuffer(this.config.url, bsizeOptions);
    const bufferSize = bgzBlockSize$1(abuffer);
    if (bufferSize === 0) {
      this.eof = true;
      this.buffer = void 0;
    } else {
      const options2 = buildOptions$1(this.config, { range: { start: this.filePtr, size: bufferSize } });
      const data = await igvxhr.loadArrayBuffer(this.config.url, options2);
      if (data.byteLength < bufferSize) {
        this.eof = true;
      }
      this.buffer = unbgzf(data);
      if (this.buffer.byteLength == 0) {
        this.eof = true;
      }
      this.bufferPtr = 0;
      this.filePtr += data.byteLength;
    }
  }
}
function concatenateArrayBuffers(arrayBuffers) {
  if (arrayBuffers.length === 1) {
    return arrayBuffers[0];
  }
  let len2 = 0;
  for (const b of arrayBuffers) {
    len2 += b.byteLength;
  }
  const c = new Uint8Array(len2);
  let offset2 = 0;
  for (const b of arrayBuffers) {
    c.set(new Uint8Array(b), offset2);
    offset2 += b.byteLength;
  }
  return c.buffer;
}
const bgzBlockSize = (data) => {
  const ba = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
  const bsize = (ba[17] << 8 | ba[16]) + 1;
  return bsize;
};
class BGZBlockLoader {
  constructor(config) {
    this.config = config;
    this.cacheBlocks = false != config.cacheBlocks;
    this.cache = void 0;
  }
  /**
   * Return inflated data from startBlock through endBlock as an UInt8Array
   *
   * @param minv minimum virtual pointer  {block, offset}
   * @param maxv maximum virtual pointer  {block, offset}
   * @returns {Promise<Uint8Array>}
   */
  async getData(minv, maxv) {
    const startBlock = minv.block;
    const endBlock = maxv.block;
    const skipEnd = maxv.offset === 0;
    const blocks = await this.getInflatedBlocks(startBlock, endBlock, skipEnd);
    if (blocks.length === 1) {
      return blocks[0];
    }
    let len2 = 0;
    for (const b of blocks) {
      len2 += b.byteLength;
    }
    const c = new Uint8Array(len2);
    let offset2 = 0;
    for (const b of blocks) {
      c.set(b, offset2);
      offset2 += b.byteLength;
    }
    return c;
  }
  /**
   * Return the inflated data for the specified blocks as an array of Uint8Arrays.  This method is public so
   * it can be unit tested. *
   * @param startBlock
   * @param endBlock
   * @returns {Promise<*[Uint8Array]>}
   */
  async getInflatedBlocks(startBlock, endBlock, skipEnd) {
    if (!this.cacheBlocks) {
      const buffer = await this.loadBLockData(startBlock, endBlock, { skipEnd });
      return inflateBlocks(buffer);
    } else {
      const c = this.cache;
      if (c && c.startBlock <= startBlock && (c.endBlock >= endBlock || skipEnd && c.nextEndBlock === endBlock)) {
        const startOffset = startBlock - c.startBlock;
        const endOffset = endBlock - c.startBlock;
        return inflateBlocks(c.buffer, startOffset, endOffset);
      } else {
        let buffer;
        if (!c || (c.startBlock > endBlock || c.endBlock < startBlock)) {
          buffer = await this.loadBLockData(startBlock, endBlock, { skipEnd });
        } else {
          const arrayBuffers = [];
          if (startBlock < c.startBlock) {
            const startBuffer = await this.loadBLockData(startBlock, c.startBlock, { skipEnd: true });
            arrayBuffers.push(startBuffer);
          }
          let cachedBuffer;
          if (startBlock <= c.startBlock && endBlock >= c.endBlock) {
            cachedBuffer = c.buffer;
          } else {
            const start = Math.max(0, startBlock - c.startBlock);
            let end;
            if (endBlock >= c.endBlock) {
              end = c.buffer.byteLength;
            } else {
              const boundaries = findBlockBoundaries(c.buffer);
              for (let i = 0; i < boundaries.length - 1; i++) {
                if (c.startBlock + boundaries[i] === endBlock) {
                  end = boundaries[i + 1];
                  break;
                }
              }
            }
            cachedBuffer = c.buffer.slice(start, end);
          }
          arrayBuffers.push(cachedBuffer);
          if (endBlock > c.endBlock) {
            const endBuffer = await this.loadBLockData(c.endBlock, endBlock, { skipStart: true, skipEnd });
            arrayBuffers.push(endBuffer);
          }
          buffer = concatenateArrayBuffers(arrayBuffers);
        }
        let nextEndBlock = endBlock;
        if (skipEnd) {
          const boundaries = findBlockBoundaries(buffer);
          endBlock = boundaries[boundaries.length - 1];
        }
        this.cache = { startBlock, endBlock, nextEndBlock, buffer };
        return inflateBlocks(buffer);
      }
    }
  }
  async loadBLockData(startBlock, endBlock, options2) {
    const config = this.config;
    const skipStart = options2 && options2.skipStart;
    const skipEnd = options2 && options2.skipEnd;
    let lastBlockSize = 0;
    if (!skipEnd) {
      const bsizeOptions = buildOptions$1(config, { range: { start: endBlock, size: 26 } });
      const abuffer = await igvxhr.loadArrayBuffer(config.url, bsizeOptions);
      lastBlockSize = bgzBlockSize(abuffer);
    }
    if (skipStart) {
      const bsizeOptions = buildOptions$1(config, { range: { start: startBlock, size: 26 } });
      const abuffer = await igvxhr.loadArrayBuffer(config.url, bsizeOptions);
      startBlock += bgzBlockSize(abuffer);
    }
    const loadOptions = buildOptions$1(config, {
      range: {
        start: startBlock,
        size: endBlock + lastBlockSize - startBlock
      }
    });
    return igvxhr.loadArrayBuffer(config.url, loadOptions);
  }
}
function findBlockBoundaries(arrayBuffer) {
  const byteLengh = arrayBuffer.byteLength;
  let offset2 = 0;
  const blockBoundaries = [0];
  while (offset2 < byteLengh) {
    const ba = new Uint8Array(arrayBuffer, offset2);
    const bsize = (ba[17] << 8 | ba[16]) + 1;
    offset2 += bsize;
    if (offset2 < byteLengh) {
      blockBoundaries.push(offset2);
    }
  }
  return blockBoundaries;
}
function inflateBlocks(data, startBlock, endBlock) {
  startBlock = startBlock || 0;
  const oBlockList = [];
  let ptr = startBlock;
  const lim = data.byteLength - 18;
  while (ptr < lim) {
    try {
      const header = new Uint8Array(data, ptr, 18);
      const xlen = header[11] << 8 | header[10];
      const bsize = header[17] << 8 | header[16];
      const start = 12 + xlen + ptr;
      const bytesLeft = data.byteLength - start;
      const cDataSize = bsize - xlen - 18;
      if (bytesLeft < cDataSize || cDataSize <= 0) {
        break;
      }
      const cdata = new Uint8Array(data, start, cDataSize);
      const unc = inflateRaw_1(cdata);
      oBlockList.push(unc);
      if (endBlock === ptr) {
        break;
      } else {
        ptr += bsize + 1;
      }
    } catch (e) {
      console.error(e);
      break;
    }
  }
  return oBlockList;
}
class FeatureFileReader {
  constructor(config, genome) {
    var uriParts;
    this.config = config || {};
    this.genome = genome;
    this.indexURL = config.indexURL;
    this.indexed = config.indexed || this.indexURL !== void 0;
    this.queryable = this.indexed;
    if (isFile$1(this.config.url)) {
      this.filename = this.config.url.name;
    } else if (isDataURL(this.config.url)) {
      this.indexed = false;
      this.dataURI = config.url;
    } else {
      uriParts = parseUri(this.config.url);
      this.filename = config.filename || uriParts.file;
    }
    this.parser = this.getParser(this.config);
    if (this.config.format === "vcf" && !this.config.indexURL) {
      console.warn("Warning: index file not specified.  The entire vcf file will be loaded.");
    }
  }
  async defaultVisibilityWindow() {
    if (this.config.indexURL) {
      const index2 = await this.getIndex();
      if (index2 && index2.lastBlockPosition) {
        let gl = 0;
        const s = 1e4;
        for (let c of index2.chromosomeNames) {
          const chromosome = this.genome.getChromosome(c);
          if (chromosome) {
            gl += chromosome.bpLength;
          }
        }
        return Math.round(gl / index2.lastBlockPosition * s);
      }
    }
  }
  /**
   * Return a promise to load features for the genomic interval
   * @param chr
   * @param start
   * @param end
   */
  async readFeatures(chr, start, end) {
    const index2 = await this.getIndex();
    if (index2) {
      this.indexed = true;
      return this.loadFeaturesWithIndex(chr, start, end);
    } else if (this.dataURI) {
      this.indexed = false;
      return this.loadFeaturesFromDataURI();
    } else {
      this.indexed = false;
      return this.loadFeaturesNoIndex();
    }
  }
  async readHeader() {
    if (this.dataURI) {
      await this.loadFeaturesFromDataURI(this.dataURI);
      return this.header;
    } else {
      if (this.config.indexURL) {
        const index2 = await this.getIndex();
        if (!index2) {
          throw new Error("Unable to load index: " + this.config.indexURL);
        }
        let dataWrapper;
        if (index2.tabix) {
          this._blockLoader = new BGZBlockLoader(this.config);
          dataWrapper = new BGZLineReader(this.config);
        } else {
          const maxSize = Object.values(index2.chrIndex).flatMap((chr) => chr.blocks).map((block) => block.max).reduce((previous, current) => Math.min(previous, current), Number.MAX_SAFE_INTEGER);
          const options2 = buildOptions$1(this.config, { bgz: index2.tabix, range: { start: 0, size: maxSize } });
          const data = await igvxhr.loadString(this.config.url, options2);
          dataWrapper = getDataWrapper(data);
        }
        this.header = await this.parser.parseHeader(dataWrapper);
        return this.header;
      } else {
        const options2 = buildOptions$1(this.config);
        const data = await igvxhr.loadString(this.config.url, options2);
        let dataWrapper = getDataWrapper(data);
        this.header = await this.parser.parseHeader(dataWrapper);
        dataWrapper = getDataWrapper(data);
        this.features = await this.parser.parseFeatures(dataWrapper);
        return this.header;
      }
    }
  }
  getParser(config) {
    switch (config.format) {
      case "vcf":
        return new VcfParser(config);
      case "seg":
        return new SegParser("seg");
      case "mut":
        return new SegParser("mut");
      case "maf":
        return new SegParser("maf");
      case "gwas":
        return new GWASParser(config);
      case "aed":
        return new AEDParser(config);
      default:
        return new FeatureParser(config);
    }
  }
  async loadFeaturesNoIndex() {
    if (this.features) {
      const tmp = this.features;
      delete this.features;
      return tmp;
    } else {
      const options2 = buildOptions$1(this.config);
      const data = await igvxhr.loadString(this.config.url, options2);
      if (!this.header) {
        const dataWrapper2 = getDataWrapper(data);
        this.header = await this.parser.parseHeader(dataWrapper2);
      }
      const dataWrapper = getDataWrapper(data);
      const features = await this.parser.parseFeatures(dataWrapper);
      return features;
    }
  }
  async loadFeaturesWithIndex(chr, start, end) {
    if (!this.dataURI && !this.header) {
      await this.readHeader();
    }
    const config = this.config;
    const parser = this.parser;
    const tabix = this.index.tabix;
    const refId = tabix ? this.index.sequenceIndexMap[chr] : chr;
    if (refId === void 0) {
      return [];
    }
    const genome = this.genome;
    const chunks = this.index.chunksForRange(refId, start, end);
    if (!chunks || chunks.length === 0) {
      return [];
    } else {
      const allFeatures = [];
      for (let chunk of chunks) {
        let inflated;
        if (tabix) {
          inflated = await this._blockLoader.getData(chunk.minv, chunk.maxv);
        } else {
          const options2 = buildOptions$1(config, {
            range: {
              start: chunk.minv.block,
              size: chunk.maxv.block - chunk.minv.block + 1
            }
          });
          inflated = await igvxhr.loadString(config.url, options2);
        }
        const slicedData = chunk.minv.offset ? inflated.slice(chunk.minv.offset) : inflated;
        const dataWrapper = getDataWrapper(slicedData);
        let slicedFeatures = await parser.parseFeatures(dataWrapper);
        slicedFeatures = slicedFeatures.filter((f) => f._f === void 0);
        let inInterval = false;
        for (let i = 0; i < slicedFeatures.length; i++) {
          const f = slicedFeatures[i];
          const canonicalChromosome = genome ? genome.getChromosomeName(f.chr) : f.chr;
          if (canonicalChromosome !== chr) {
            if (allFeatures.length === 0) {
              continue;
            } else {
              break;
            }
          }
          if (f.start > end) {
            allFeatures.push(f);
            break;
          }
          if (f.end >= start && f.start <= end) {
            if (!inInterval) {
              inInterval = true;
              if (i > 0) {
                allFeatures.push(slicedFeatures[i - 1]);
              }
            }
            allFeatures.push(f);
          }
        }
      }
      allFeatures.sort(function(a, b) {
        return a.start - b.start;
      });
      return allFeatures;
    }
  }
  async getIndex() {
    if (this.index) {
      return this.index;
    } else if (this.config.indexURL) {
      this.index = await this.loadIndex();
      return this.index;
    }
  }
  /**
   * Return a Promise for the async loaded index
   */
  async loadIndex() {
    const indexURL2 = this.config.indexURL;
    return loadIndex(indexURL2, this.config, this.genome);
  }
  async loadFeaturesFromDataURI() {
    if (this.features) {
      const tmp = this.features;
      delete this.features;
      return tmp;
    } else {
      const plain = decodeDataURI$1(this.dataURI);
      let dataWrapper = getDataWrapper(plain);
      this.header = await this.parser.parseHeader(dataWrapper);
      if (this.header instanceof String && this.header.startsWith("##gff-version 3")) {
        this.format = "gff3";
      }
      dataWrapper = getDataWrapper(plain);
      this.features = await this.parser.parseFeatures(dataWrapper);
      return this.features;
    }
  }
}
const isString$1 = isString$2;
class CustomServiceReader {
  constructor(config) {
    this.config = config;
  }
  async readFeatures(chr, start, end) {
    let url;
    if (typeof this.config.url === "function") {
      url = this.config.url({ chr, start, end });
    } else {
      url = this.config.url.replace("$CHR", chr).replace("$START", start).replace("$END", end);
    }
    let config = Object.assign({}, this.config);
    if (this.config.body !== void 0) {
      if (typeof this.config.body === "function") {
        config.body = this.config.body({ chr, start, end });
      } else {
        config.body = this.config.body.replace("$CHR", chr).replace("$START", start).replace("$END", end);
      }
    }
    let features;
    const data = await igvxhr.load(url, config);
    if (data) {
      if (typeof this.config.parser === "function") {
        features = this.config.parser(data);
      } else if (isString$1(data)) {
        features = JSON.parse(data);
      } else {
        features = data;
      }
    }
    if (this.config.mappings) {
      let mappingKeys = Object.keys(this.config.mappings);
      for (let f of features) {
        for (let key of mappingKeys) {
          f[key] = f[this.config.mappings[key]];
        }
      }
    }
    return features;
  }
}
const UCSCServiceReader = function(config, genome) {
  this.config = config;
  this.genome = genome;
  this.expandQueryInterval = false;
};
UCSCServiceReader.prototype.readFeatures = function(chr, start, end) {
  const s = Math.max(0, Math.floor(start));
  let e = Math.ceil(end);
  if (this.genome) {
    const c = this.genome.getChromosome(chr);
    if (c && e > c.bpLength) {
      e = c.bpLength;
    }
  }
  const url = this.config.url + "?db=" + this.config.db + "&table=" + this.config.tableName + "&chr=" + chr + "&start=" + s + "&end=" + e;
  return igvxhr.loadJson(url, this.config).then(function(data) {
    if (data) {
      data.forEach(function(sample) {
        if (sample.hasOwnProperty("exonStarts") && sample.hasOwnProperty("exonEnds") && sample.hasOwnProperty("exonCount") && sample.hasOwnProperty("cdsStart") && sample.hasOwnProperty("cdsEnd")) {
          addExons(sample);
        }
      });
      return data;
    } else {
      return null;
    }
  });
};
function addExons(sample) {
  var exonCount, exonStarts, exonEnds, exons, eStart, eEnd;
  exonCount = sample["exonCount"];
  exonStarts = sample["exonStarts"].split(",");
  exonEnds = sample["exonEnds"].split(",");
  exons = [];
  for (var i = 0; i < exonCount; i++) {
    eStart = parseInt(exonStarts[i]);
    eEnd = parseInt(exonEnds[i]);
    var exon = { start: eStart, end: eEnd };
    if (sample.cdsStart > eEnd || sample.cdsEnd < sample.cdsStart) exon.utr = true;
    if (sample.cdsStart >= eStart && sample.cdsStart <= eEnd) exon.cdStart = sample.cdsStart;
    if (sample.cdsEnd >= eStart && sample.cdsEnd <= eEnd) exon.cdEnd = sample.cdsEnd;
    exons.push(exon);
  }
  sample.exons = exons;
}
const gffNameFields = ["Name", "gene_name", "gene", "gene_id", "alias", "locus", "name"];
class GFFHelper {
  constructor(options2) {
    this.format = options2.format;
    this.nameField = options2.nameField;
    this.filterTypes = options2.filterTypes === void 0 ? /* @__PURE__ */ new Set(["chromosome"]) : new Set(options2.filterTypes);
  }
  combineFeatures(features, genomicInterval) {
    let combinedFeatures;
    const filterTypes = this.filterTypes;
    features = features.filter((f) => filterTypes === void 0 || !filterTypes.has(f.type));
    if ("gff3" === this.format) {
      const tmp = this.combineFeaturesById(features);
      combinedFeatures = this.combineFeaturesByType(tmp);
    } else {
      combinedFeatures = this.combineFeaturesByType(features);
    }
    combinedFeatures.sort(function(a, b) {
      return a.start - b.start;
    });
    this.numberExons(combinedFeatures, genomicInterval);
    this.nameFeatures(combinedFeatures);
    return combinedFeatures;
  }
  /**
   * Combine multiple non-transcript model features with the same ID on the same chromosome into a single feature.
   * Features that are part of the transcript model (e.g. exon, mRNA, etc) are combined later.
   *
   * @param features
   * @returns {[]}
   */
  combineFeaturesById(features) {
    const chrIdMap = /* @__PURE__ */ new Map();
    const combinedFeatures = [];
    for (let f of features) {
      if (isTranscriptPart(f.type) || isTranscript(f.type) || !f.id) {
        combinedFeatures.push(f);
      } else {
        let idMap = chrIdMap.get(f.chr);
        if (!idMap) {
          idMap = /* @__PURE__ */ new Map();
          chrIdMap.set(f.chr, idMap);
        }
        let featureArray = idMap.get(f.id);
        if (featureArray) {
          featureArray.push(f);
        } else {
          idMap.set(f.id, [f]);
        }
      }
    }
    for (let idMap of chrIdMap.values()) {
      for (let featureArray of idMap.values()) {
        if (featureArray.length > 1) {
          const cf = featureArray[0];
          cf.exons = [];
          for (let f of featureArray) {
            cf.start = Math.min(cf.start, f.start);
            cf.end = Math.max(cf.end, f.end);
            cf.exons.push({
              start: f.start,
              end: f.end
            });
          }
          combinedFeatures.push(cf);
        } else {
          combinedFeatures.push(featureArray[0]);
        }
      }
    }
    return combinedFeatures;
  }
  combineFeaturesByType(features) {
    const genes = features.filter((f) => "gene" === f.type || f.type.endsWith("_gene"));
    const geneMap = /* @__PURE__ */ Object.create(null);
    for (let g of genes) {
      geneMap[g.id] = g;
    }
    const transcripts = /* @__PURE__ */ Object.create(null);
    const combinedFeatures = [];
    const consumedFeatures = /* @__PURE__ */ new Set();
    const filterTypes = this.filterTypes;
    features = features.filter((f) => filterTypes === void 0 || !filterTypes.has(f.type));
    for (let f of features) {
      if (f.type === "biological_region") {
        console.log();
      }
      if (isTranscript(f.type)) {
        const transcriptId = f.id;
        if (void 0 !== transcriptId) {
          const gffTranscript = new GFFTranscript(f);
          transcripts[transcriptId] = gffTranscript;
          combinedFeatures.push(gffTranscript);
          consumedFeatures.add(f);
          const g = geneMap[f.parent];
          if (g) {
            gffTranscript.geneObject = g;
            consumedFeatures.add(g);
          }
        }
      }
    }
    for (let f of features) {
      if (isTranscriptPart(f.type)) {
        const parents = getParents(f);
        if (parents) {
          for (let id of parents) {
            let transcript = transcripts[id];
            if (!transcript && this.format === "gtf") {
              const psuedoTranscript = Object.assign({}, f);
              psuedoTranscript.type = "transcript";
              transcript = new GFFTranscript(psuedoTranscript);
              transcripts[id] = transcript;
              combinedFeatures.push(transcript);
            }
            if (transcript !== void 0) {
              if (isExon(f.type)) {
                if (parents.length > 1) {
                  const e2 = new GFFFeature(f);
                  transcript.addExon(e2);
                } else {
                  transcript.addExon(f);
                }
              } else {
                transcript.addPart(f);
              }
              consumedFeatures.add(f);
            }
          }
        }
      }
    }
    combinedFeatures.forEach(function(f) {
      if (typeof f.finish === "function") {
        f.finish();
      }
    });
    const others = features.filter((f) => !consumedFeatures.has(f));
    for (let f of others) {
      combinedFeatures.push(f);
    }
    return combinedFeatures;
    function getParents(f) {
      if (f.parent && f.parent.trim() !== "") {
        return f.parent.trim().split(",");
      } else {
        return null;
      }
    }
  }
  numberExons(features, genomicInterval) {
    for (let f of features) {
      if (f.exons && (!genomicInterval || f.end <= genomicInterval.end && f.start > genomicInterval.start)) {
        for (let i = 0; i < f.exons.length; i++) {
          const exon = f.exons[i];
          exon.number = f.strand === "-" ? f.exons.length - i : i + 1;
        }
      }
    }
  }
  nameFeatures(features) {
    for (let f of features) {
      if (f.attributeString) {
        const delim = "gff3" === this.format ? "=" : " ";
        const attributes = parseAttributeString(f.attributeString, delim);
        const attributesMap = new Map(attributes);
        if (this.nameField) {
          f.name = attributesMap.get(this.nameField);
        } else {
          for (let nameField of gffNameFields) {
            if (attributesMap.has(nameField)) {
              f.name = attributesMap.get(nameField);
              break;
            }
          }
        }
      }
    }
  }
}
const GtexReader = function(config) {
  this.config = config;
  this.url = config.url;
  this.tissueId = config.tissueSiteDetailId;
  this.indexed = true;
  this.datasetId = config.datasetId || "gtex_v8";
};
GtexReader.prototype.readFeatures = async function(chr, bpStart, bpEnd) {
  let self2 = this, queryChr = chr.startsWith("chr") ? chr : "chr" + chr, queryStart = Math.floor(bpStart), queryEnd = Math.ceil(bpEnd), datasetId = this.datasetId, queryURL = this.url + "?chromosome=" + queryChr + "&start=" + queryStart + "&end=" + queryEnd + "&tissueSiteDetailId=" + this.tissueId + "&datasetId=" + datasetId;
  const json = await igvxhr.loadJson(queryURL, {
    withCredentials: self2.config.withCredentials
  });
  if (json && json.singleTissueEqtl) {
    json.singleTissueEqtl.forEach(function(eqtl) {
      eqtl.chr = eqtl.chromosome;
      eqtl.position = eqtl.pos;
      eqtl.start = eqtl.pos - 1;
      eqtl.end = eqtl.start + 1;
      eqtl.snp = eqtl.snpId;
      eqtl.geneName = eqtl.geneSymbol;
      eqtl.geneId = eqtl.gencodeId;
    });
    return json.singleTissueEqtl;
  } else {
    return void 0;
  }
};
const ImmVarReader = function(config) {
  this.config = config;
  this.url = config.url;
  this.cellConditionId = config.cellConditionId;
  this.valueThreshold = config.valueThreshold ? config.valueThreshold : 0.05;
};
ImmVarReader.prototype.readFeatures = function(queryChr, queryStart, queryEnd) {
  var self2 = this, queryURL = this.url + "?chromosome=" + queryChr + "&start=" + queryStart + "&end=" + queryEnd + "&cell_condition_id=" + this.cellConditionId;
  return new Promise(function(fulfill, reject) {
    igvxhr.loadJson(queryURL, {
      withCredentials: self2.config.withCredentials
    }).then(function(json) {
      if (json) {
        json.eqtls.forEach(function(eqtl) {
          eqtl.chr = eqtl.chromosome;
          eqtl.start = eqtl.position;
          eqtl.end = eqtl.position + 1;
        });
        fulfill(json.eqtls);
      } else {
        fulfill(null);
      }
    }).catch(function(error) {
      reject(error);
    });
  });
};
const apiKey = igvxhr.apiKey;
function ga4ghGet(options2) {
  var url = options2.url + "/" + options2.entity + "/" + options2.entityId;
  options2.headers = ga4ghHeaders();
  return igvxhr.loadJson(url, options2);
}
function ga4ghSearch(options2) {
  return new Promise(function(fulfill, reject) {
    var results = options2.results ? options2.results : [], url = options2.url, body = options2.body, decode2 = options2.decode, paramSeparator = "?", fields = options2.fields;
    if (apiKey) {
      url = url + paramSeparator + "key=" + apiKey;
      paramSeparator = "&";
    }
    if (fields) {
      url = url + paramSeparator + "fields=" + fields;
    }
    return loadChunk();
    function loadChunk(pageToken) {
      if (pageToken) {
        body.pageToken = pageToken;
      } else {
        if (body.pageToken !== void 0) delete body.pageToken;
      }
      var sendData = JSON.stringify(body);
      igvxhr.loadJson(url, {
        sendData,
        contentType: "application/json",
        headers: ga4ghHeaders()
        //    oauthToken: ga4ghToken()
      }).then(function(json) {
        var nextPageToken, tmp;
        if (json) {
          tmp = decode2 ? decode2(json) : json;
          if (tmp) {
            tmp.forEach(function(a) {
              {
                results.push(a);
              }
            });
          }
          nextPageToken = json["nextPageToken"];
          if (nextPageToken) {
            loadChunk(nextPageToken);
          } else {
            fulfill(results);
          }
        } else {
          fulfill(results);
        }
      }).catch(function(error) {
        reject(error);
      });
    }
  });
}
function ga4ghHeaders() {
  return {
    "Cache-Control": "no-cache"
  };
}
const Ga4ghVariantReader = function(config, genome) {
  this.config = config;
  this.genome = genome;
  this.url = config.url;
  this.variantSetId = config.variantSetId;
  this.callSetIds = config.callSetIds;
  this.includeCalls = config.includeCalls === void 0 ? true : config.includeCalls;
};
Ga4ghVariantReader.prototype.readHeader = function() {
  var self2 = this;
  if (self2.header) {
    return Promise.resolve(self2.header);
  } else {
    self2.header = {};
    if (self2.includeCalls === false) {
      return Promise.resolve(self2.header);
    } else {
      var readURL = self2.url + "/callsets/search";
      return ga4ghSearch({
        url: readURL,
        fields: "nextPageToken,callSets(id,name)",
        body: {
          "variantSetIds": Array.isArray(self2.variantSetId) ? self2.variantSetId : [self2.variantSetId],
          "pageSize": "10000"
        },
        decode: function(json) {
          if (self2.callSetIds) {
            var callSets = [], csIdSet = /* @__PURE__ */ new Set();
            self2.callSetIds.forEach(function(csid) {
              csIdSet.add(csid);
            });
            json.callSets.forEach(function(cs) {
              if (csIdSet.has(cs.id)) {
                callSets.push(cs);
              }
            });
            return callSets;
          } else {
            return json.callSets;
          }
        }
      }).then(function(callSets) {
        self2.header.callSets = callSets;
        return self2.header;
      });
    }
  }
};
Ga4ghVariantReader.prototype.readFeatures = function(chr, bpStart, bpEnd) {
  const self2 = this;
  const genome = this.genome;
  return self2.readHeader().then(function(header) {
    return getChrAliasTable();
  }).then(function(chrAliasTable) {
    var queryChr = chrAliasTable.hasOwnProperty(chr) ? chrAliasTable[chr] : chr, readURL = self2.url + "/variants/search";
    return ga4ghSearch({
      url: readURL,
      fields: self2.includeCalls ? void 0 : "nextPageToken,variants(id,variantSetId,names,referenceName,start,end,referenceBases,alternateBases,quality,filter,info)",
      body: {
        "variantSetIds": Array.isArray(self2.variantSetId) ? self2.variantSetId : [self2.variantSetId],
        "callSetIds": self2.callSetIds ? self2.callSetIds : void 0,
        "referenceName": queryChr,
        "start": bpStart.toString(),
        "end": bpEnd.toString(),
        "pageSize": "10000"
      },
      decode: function(json) {
        var v;
        var variants = [];
        json.variants.forEach(function(json2) {
          v = createGAVariant(json2);
          if (!v.isRefBlock()) {
            variants.push(v);
          }
        });
        return variants;
      }
    });
  });
  function getChrAliasTable() {
    return new Promise(function(fulfill, reject) {
      if (self2.chrAliasTable) {
        fulfill(self2.chrAliasTable);
      } else {
        self2.readMetadata().then(function(json) {
          self2.metadata = json.metadata;
          self2.chrAliasTable = {};
          if (json.referenceBounds && genome) {
            json.referenceBounds.forEach(function(rb) {
              var refName = rb.referenceName, alias = genome.getChromosomeName(refName);
              self2.chrAliasTable[alias] = refName;
            });
          }
          fulfill(self2.chrAliasTable);
        });
      }
    });
  }
};
Ga4ghVariantReader.prototype.readMetadata = function() {
  return ga4ghGet({
    url: this.url,
    entity: "variantsets",
    entityId: this.variantSetId
  });
};
class CivicReader {
  constructor(config) {
    this.config = config;
  }
  async readFeatures(chr, start, end) {
    const json = await igvxhr.loadJson(this.config.url + "/variants/?count=50000");
    const records = json.records;
    const features = [];
    for (let record of records) {
      if (record.coordinates) {
        record.id;
        const coordinates = record.coordinates;
        if (coordinates.chromosome) {
          features.push(
            new CivicVariant(
              coordinates.chromosome,
              coordinates.start - 1,
              // UCSC 0 convention
              coordinates.stop,
              record
            )
          );
        }
        if (coordinates.chromosome2) {
          features.push(
            new CivicVariant(
              coordinates.chromosome2,
              coordinates.start2 - 1,
              // UCSC 0 convention
              coordinates.stop2,
              record
            )
          );
        }
      }
    }
    return features;
  }
}
class CivicVariant {
  constructor(chr, start, end, record) {
    this.chr = chr;
    this.start = start;
    this.end = end;
    this.id = record.id;
    this.entrezName = record.entrez_name;
    this.name = record.name;
    this.actionabilityScore = record.civic_actionability_score;
    if (record.coordinates.reference_bases) {
      this.refBases = record.coordinates.reference_bases;
    }
    if (record.coordinates.variant_bases) {
      this.altBases = record.coordinates.variant_bases;
    }
    if (record.variant_types) {
      this.variant_types = record.variant_types;
    }
    this.locationString = this.chr + ":" + numberFormatter$1(this.start + 1) + "-" + numberFormatter$1(this.end);
    if (this.actionabilityScore !== void 0) {
      let alpha;
      if (this.actionabilityScore <= 10) {
        alpha = 0.2;
      } else {
        const v = Math.min(30, this.actionabilityScore);
        alpha = 0.2 + 0.8 * Math.log10((v - 10) / 2);
      }
      this.alpha = alpha;
    }
  }
  popupData() {
    const link2 = createLink("CIViC", "https://civicdb.org/links/variants/" + this.id);
    this.refBases !== this.altBases && this.refBases && this.refBases.length === 1 && this.altBases && this.altBases.length === 1;
    const pd = [link2];
    pd.push({
      name: "Entrez",
      value: createLink(this.entrezName, "https://ghr.nlm.nih.gov/gene/" + this.entrezName)
    });
    pd.push({ name: "Name", value: this.name });
    if (this.variant_types && this.variant_types.length > 0) {
      const name2 = this.variant_types.length === 1 ? "Type" : "Types";
      let typeString;
      for (let vt of this.variant_types) {
        if (!typeString) typeString = vt.display_name;
        else typeString += ", " + vt.display_name;
      }
      pd.push({ name: name2, value: typeString });
    }
    pd.push({ name: "Actionability", value: this.actionabilityScore });
    pd.push({ name: "Location", value: this.locationString });
    return pd;
    function createLink(text2, href) {
      return "<a target='_blank' href='" + href + "'>" + text2 + "</a>";
    }
  }
}
class HtsgetReader {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.format = config.format ? config.format.toUpperCase() : "BAM";
    if (!(this.format === "BAM" || this.format === "VCF")) {
      throw Error(`htsget format ${config.format} is not supported`);
    }
  }
  async readHeaderData() {
    const url = `${getUrl(this.config)}?class=header&format=${this.format}`;
    const ticket = await igvxhr.loadJson(url, buildOptions$1(this.config));
    return await this.loadUrls(ticket.htsget.urls);
  }
  async readData(chr, start, end) {
    const url = `${getUrl(this.config)}?format=${this.format}&referenceName=${chr}&start=${Math.floor(start)}&end=${Math.ceil(end)}`;
    const ticket = await igvxhr.loadJson(url, buildOptions$1(this.config));
    return this.loadUrls(ticket.htsget.urls);
  }
  async loadUrls(urls) {
    const promiseArray = [];
    for (let urlData of urls) {
      if (urlData.url.startsWith("data:")) {
        promiseArray.push(Promise.resolve(dataUriToBytes(urlData.url)));
      } else {
        const options2 = buildOptions$1(this.config || {});
        if (urlData.headers) {
          options2.headers = Object.assign(options2.headers || {}, urlData.headers);
        }
        promiseArray.push(igvxhr.loadArrayBuffer(urlData.url, options2));
      }
    }
    const arrayBuffers = await Promise.all(promiseArray);
    return concatArrays(arrayBuffers);
  }
  static async inferFormat(config) {
    try {
      const url = getUrl(config);
      const headerURL = `${url}${url.includes("?") ? "&" : "?"}class=header`;
      const ticket = await igvxhr.loadJson(headerURL, buildOptions$1(config));
      if (ticket.htsget) {
        const format2 = ticket.htsget.format;
        if (!(format2 === "BAM" || format2 === "VCF")) {
          throw Error(`htsget format ${format2} is not supported`);
        }
        config.format = format2.toLowerCase();
        config.sourceType = "htsget";
        if (!config.name) {
          config.name = await getFilename$1(config.url);
        }
      }
    } catch (e) {
    }
  }
}
function getUrl(config) {
  if (config.url && config.endpoint && config.id) {
    return config.url + config.endpoint + config.id;
  } else if (config.endpoint && config.id) {
    return config.endpoint + config.id;
  } else if (config.url) {
    if (config.url.startsWith("htsget://")) {
      return config.url.replace("htsget://", "https://");
    } else {
      return config.url;
    }
  } else {
    throw Error("Must specify either 'url', or 'endpoint' and 'id");
  }
}
function concatArrays(arrayBuffers) {
  let len2 = 0;
  for (let a of arrayBuffers) {
    len2 += a.byteLength;
  }
  let offset2 = 0;
  const newArray = new Uint8Array(len2);
  for (let buf of arrayBuffers) {
    const a = new Uint8Array(buf);
    newArray.set(a, offset2);
    offset2 += a.length;
  }
  return newArray;
}
function dataUriToBytes(dataUri) {
  const split = dataUri.split(",");
  const info = split[0].split(":")[1];
  let dataString = split[1];
  if (info.indexOf("base64") >= 0) {
    dataString = atob(dataString);
  } else {
    dataString = decodeURI(dataString);
  }
  const bytes = new Uint8Array(dataString.length);
  for (var i = 0; i < dataString.length; i++) {
    bytes[i] = dataString.charCodeAt(i);
  }
  return bytes;
}
class HtsgetVariantReader extends HtsgetReader {
  constructor(config, genome) {
    super(config, genome);
    this.parser = new VcfParser();
  }
  async readHeader() {
    if (!this.header) {
      const data = await this.readHeaderData();
      const dataWrapper = getDataWrapper(data);
      this.header = await this.parser.parseHeader(dataWrapper, this.genome);
      this.chrAliasTable = this.header.chrAliasTable;
    }
    return this.header;
  }
  async readFeatures(chr, start, end) {
    if (this.config.format && this.config.format.toUpperCase() !== "VCF") {
      throw Error(`htsget format ${this.config.format} is not supported`);
    }
    if (!this.chrAliasTable) {
      await this.readHeader();
    }
    let queryChr = this.chrAliasTable.has(chr) ? this.chrAliasTable.get(chr) : chr;
    const data = await this.readData(queryChr, start, end);
    const dataWrapper = getDataWrapper(data);
    return this.parser.parseFeatures(dataWrapper);
  }
}
function pack(featureList, maxRows) {
  maxRows = maxRows || Number.MAX_SAFE_INTEGER;
  const rows = [];
  featureList.sort(function(a, b) {
    return a.start - b.start;
  });
  rows.push(-1e3);
  for (let feature2 of featureList) {
    let r = 0;
    const len2 = Math.min(rows.length, maxRows);
    for (r = 0; r < len2; r++) {
      if (feature2.start >= rows[r]) {
        feature2.row = r;
        rows[r] = feature2.end;
        break;
      }
    }
    feature2.row = r;
    rows[r] = feature2.end;
  }
}
const DEFAULT_MAX_WG_COUNT$1 = 1e4;
function computeWGFeatures(allFeatures, genome, maxWGCount) {
  const max = maxWGCount || DEFAULT_MAX_WG_COUNT$1;
  const makeWGFeature = (f) => {
    const wg = Object.assign({}, f);
    wg.chr = "all";
    wg.start = genome.getGenomeCoordinate(f.chr, f.start);
    wg.end = genome.getGenomeCoordinate(f.chr, f.end);
    wg._f = f;
    if (wg["exons"]) delete wg["exons"];
    return wg;
  };
  const wgChromosomeNames = new Set(genome.wgChromosomeNames);
  const wgFeatures = [];
  let count = 0;
  for (let c of genome.wgChromosomeNames) {
    if (Array.isArray(allFeatures)) {
      const featureDict = {};
      for (let f of allFeatures) {
        const chr = genome.getChromosomeName(f.chr);
        if (!featureDict.hasOwnProperty(chr)) {
          featureDict[chr] = [];
        }
        featureDict[chr].push(f);
      }
      allFeatures = featureDict;
    }
    const features = allFeatures[c];
    if (features) {
      for (let f of features) {
        let queryChr = genome.getChromosomeName(f.chr);
        if (wgChromosomeNames.has(queryChr)) {
          if (wgFeatures.length < max) {
            wgFeatures.push(makeWGFeature(f));
          } else {
            const samplingProb = max / (count + 1);
            if (Math.random() < samplingProb) {
              const idx = Math.floor(Math.random() * (max - 1));
              wgFeatures[idx] = makeWGFeature(f);
            }
          }
        }
        count++;
      }
    }
  }
  wgFeatures.sort(function(a, b) {
    return a.start - b.start;
  });
  return wgFeatures;
}
function packFeatures(features, maxRows) {
  maxRows = maxRows || 1e3;
  if (features == null || features.length === 0) {
    return;
  }
  const chrFeatureMap = {};
  const chrs = [];
  for (let feature2 of features) {
    const chr = feature2.chr;
    let flist = chrFeatureMap[chr];
    if (!flist) {
      flist = [];
      chrFeatureMap[chr] = flist;
      chrs.push(chr);
    }
    flist.push(feature2);
  }
  for (let chr of chrs) {
    pack(chrFeatureMap[chr], maxRows);
  }
}
const DEFAULT_MAX_WG_COUNT = 1e4;
class TextFeatureSource {
  constructor(config, genome) {
    this.config = config || {};
    this.genome = genome;
    this.sourceType = config.sourceType === void 0 ? "file" : config.sourceType;
    this.maxWGCount = config.maxWGCount || DEFAULT_MAX_WG_COUNT;
    const queryableFormats = /* @__PURE__ */ new Set(["bigwig", "bw", "bigbed", "bb", "biginteract", "biggenepred", "bignarrowpeak", "tdf"]);
    this.queryable = config.indexURL || config.queryable === true;
    if (config.reader) {
      this.reader = config.reader;
      this.queryable = config.queryable !== false;
    } else if (config.sourceType === "ga4gh") {
      this.reader = new Ga4ghVariantReader(config, genome);
      this.queryable = true;
    } else if (config.sourceType === "immvar") {
      this.reader = new ImmVarReader(config);
      this.queryable = true;
    } else if (config.type === "eqtl" && config.sourceType === "gtex-ws") {
      this.reader = new GtexReader(config);
      this.queryable = true;
    } else if ("htsget" === config.sourceType) {
      this.reader = new HtsgetVariantReader(config, genome);
      this.queryable = true;
    } else if (config.sourceType === "ucscservice") {
      this.reader = new UCSCServiceReader(config.source);
      this.queryable = true;
    } else if (config.sourceType === "custom") {
      this.reader = new CustomServiceReader(config.source);
      this.queryable = false !== config.source.queryable;
    } else if ("civic-ws" === config.sourceType) {
      this.reader = new CivicReader(config);
      this.queryable = false;
    } else {
      this.reader = new FeatureFileReader(config, genome);
      if (config.queryable !== void 0) {
        this.queryable = config.queryable;
      } else if (queryableFormats.has(config.format) || this.reader.indexed) {
        this.queryable = true;
      } else ;
    }
    this.searchable = config.searchable === true || config.searchableFields || config.searchable !== false && !this.queryable;
  }
  async defaultVisibilityWindow() {
    if (this.reader && typeof this.reader.defaultVisibilityWindow === "function") {
      return this.reader.defaultVisibilityWindow();
    }
  }
  async trackType() {
    const header = await this.getHeader();
    if (header) {
      return header.type;
    } else {
      return void 0;
    }
  }
  async getHeader() {
    if (!this.header) {
      if (this.reader && typeof this.reader.readHeader === "function") {
        const header = await this.reader.readHeader();
        if (header) {
          this.header = header;
          if (header.format) {
            this.config.format = header.format;
          }
        } else {
          this.header = {};
        }
      } else {
        this.header = {};
      }
    }
    return this.header;
  }
  /**
   * Required function for all data source objects.  Fetches features for the
   * range requested.
   *
   * This function is quite complex due to the variety of reader types backing it, some indexed, some queryable,
   * some not.
   *
   * @param chr
   * @param start
   * @param end
   * @param bpPerPixel
   */
  async getFeatures({ chr, start, end, bpPerPixel, visibilityWindow }) {
    const genome = this.genome;
    const queryChr = genome ? genome.getChromosomeName(chr) : chr;
    const isWholeGenome = "all" === queryChr.toLowerCase();
    if (isWholeGenome && !this.wgFeatures && this.supportsWholeGenome() || this.config.disableCache || !this.featureCache || !this.featureCache.containsRange(new GenomicInterval(queryChr, start, end))) {
      await this.loadFeatures(queryChr, start, end, visibilityWindow);
    }
    if (isWholeGenome) {
      if (!this.wgFeatures) {
        if (this.supportsWholeGenome()) {
          this.wgFeatures = computeWGFeatures(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount);
        } else {
          this.wgFeatures = [];
        }
      }
      return this.wgFeatures;
    } else {
      return this.featureCache.queryFeatures(queryChr, start, end);
    }
  }
  supportsWholeGenome() {
    return !this.queryable;
  }
  // TODO -- experimental, will only work for non-indexed sources
  getAllFeatures() {
    if (this.queryable || !this.featureCache) {
      return [];
    } else {
      return this.featureCache.getAllFeatures();
    }
  }
  async loadFeatures(queryChr, start, end, visibilityWindow) {
    const reader = this.reader;
    let intervalStart = start;
    let intervalEnd = end;
    if ((!visibilityWindow || visibilityWindow <= 0) && this.config.expandQuery !== false) {
      const chromosome = this.genome ? this.genome.getChromosome(queryChr) : void 0;
      intervalStart = 0;
      intervalEnd = Math.max(chromosome ? chromosome.bpLength : Number.MAX_SAFE_INTEGER, end);
    } else if (visibilityWindow > end - start && this.config.expandQuery !== false) {
      const expansionWindow = Math.min(4.1 * (end - start), visibilityWindow);
      intervalStart = Math.max(0, (start + end) / 2 - expansionWindow);
      intervalEnd = start + expansionWindow;
    }
    let features = await reader.readFeatures(queryChr, intervalStart, intervalEnd);
    if (this.queryable === void 0) {
      this.queryable = reader.indexed;
    }
    const genomicInterval = this.queryable ? new GenomicInterval(queryChr, intervalStart, intervalEnd) : void 0;
    if (features) {
      if (this.config.assembleGFF !== false && ("gtf" === this.config.format || "gff3" === this.config.format || "gff" === this.config.format)) {
        features = new GFFHelper(this.config).combineFeatures(features, genomicInterval);
      }
      if (this.config.format !== "wig" && this.config.type !== "junctions") {
        const maxRows = this.config.maxRows || Number.MAX_SAFE_INTEGER;
        packFeatures(features, maxRows);
      }
      this.featureCache = new FeatureCache$1(features, this.genome, genomicInterval);
      if (this.searchable) {
        this.genome.addFeaturesToDB(features, this.config);
      }
    } else {
      this.featureCache = new FeatureCache$1([], genomicInterval);
    }
  }
}
class BufferedReader {
  constructor(config, contentLength, bufferSize) {
    this.path = config.url;
    this.bufferSize = bufferSize ? bufferSize : 512e3;
    this.range = { start: -1, size: -1 };
    this.config = config;
  }
  /**
   *
   * @param requestedRange - byte rangeas {start, size}
   * @param fulfill - function to receive result
   * @param asUint8 - optional flag to return result as an UInt8Array
   */
  async dataViewForRange(requestedRange, asUint8, retries = 0) {
    try {
      const hasData = this.data && this.range.start <= requestedRange.start && this.range.start + this.range.size >= requestedRange.start + requestedRange.size;
      if (!hasData) {
        let bufferSize;
        if (requestedRange.size) {
          bufferSize = Math.max(this.bufferSize, requestedRange.size);
        } else {
          bufferSize = this.bufferSize;
        }
        if (this.contentLength) {
          bufferSize = Math.min(bufferSize, this.contentLength - requestedRange.start);
        }
        const loadRange = { start: requestedRange.start, size: bufferSize };
        const arrayBuffer = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, { range: loadRange }));
        this.data = arrayBuffer;
        this.range = loadRange;
      }
      const len2 = this.data.byteLength;
      const bufferStart = requestedRange.start - this.range.start;
      return asUint8 ? new Uint8Array(this.data, bufferStart, len2 - bufferStart) : new DataView(this.data, bufferStart, len2 - bufferStart);
    } catch (e) {
      if (retries === 0 && e.message && e.message.startsWith("416")) {
        try {
          this.contentLength = await igvxhr.getContentLength(this.path, buildOptions$1(this.config));
          return this.dataViewForRange(requestedRange, asUint8, ++retries);
        } catch (e1) {
          console.error(e1);
        }
        throw e;
      }
    }
  }
}
function getDecoder(definedFieldCount, fieldCount, autoSql, format2) {
  if ("biginteract" === format2 || (autoSql && "chromatinInteract" === autoSql.table || "interact" === autoSql.table)) {
    return decodeInteract2;
  } else {
    const standardFieldCount = definedFieldCount - 3;
    return function(feature2, tokens) {
      if (standardFieldCount > 0) {
        feature2.name = tokens[0];
      }
      if (standardFieldCount > 1) {
        feature2.score = Number(tokens[1]);
      }
      if (standardFieldCount > 2) {
        feature2.strand = tokens[2];
      }
      if (standardFieldCount > 3) {
        feature2.cdStart = parseInt(tokens[3]);
      }
      if (standardFieldCount > 4) {
        feature2.cdEnd = parseInt(tokens[4]);
      }
      if (standardFieldCount > 5) {
        if (tokens[5] !== "." && tokens[5] !== "0" && tokens[5] !== "-1") {
          const c = IGVColor.createColorString(tokens[5]);
          feature2.color = c.startsWith("rgb") ? c : void 0;
        }
      }
      if (standardFieldCount > 8) {
        const exonCount = parseInt(tokens[6]);
        const exonSizes = tokens[7].split(",");
        const exonStarts = tokens[8].split(",");
        const exons = [];
        for (let i = 0; i < exonCount; i++) {
          const eStart = feature2.start + parseInt(exonStarts[i]);
          const eEnd = eStart + parseInt(exonSizes[i]);
          exons.push({ start: eStart, end: eEnd });
        }
        findUTRs(exons, feature2.cdStart, feature2.cdEnd);
        feature2.exons = exons;
      }
      if (autoSql) {
        const extraStart = definedFieldCount;
        for (let i = extraStart; i < fieldCount; i++) {
          if (i < autoSql.fields.length) {
            const name2 = autoSql.fields[i].name;
            const value = tokens[i - 3];
            feature2[name2] = value;
          }
        }
      }
    };
  }
  function decodeInteract2(feature2, tokens) {
    feature2.chr1 = tokens[5];
    feature2.start1 = Number.parseInt(tokens[6]);
    feature2.end1 = Number.parseInt(tokens[7]);
    feature2.chr2 = tokens[10];
    feature2.start2 = Number.parseInt(tokens[11]);
    feature2.end2 = Number.parseInt(tokens[12]);
    feature2.name = tokens[0];
    feature2.score = Number(tokens[1]);
    feature2.value = Number(tokens[2]);
    feature2.color = tokens[4] === "." ? void 0 : tokens[4] === "0" ? "rgb(0,0,0)" : tokens[4];
    return feature2;
  }
}
function findUTRs(exons, cdStart, cdEnd) {
  for (let exon of exons) {
    const end = exon.end;
    const start = exon.start;
    if (end < cdStart || start > cdEnd) {
      exon.utr = true;
    } else {
      if (cdStart >= start && cdStart <= end) {
        exon.cdStart = cdStart;
      }
      if (cdEnd >= start && cdEnd <= end) {
        exon.cdEnd = cdEnd;
      }
    }
  }
}
function scoreShade(score, color) {
  const alpha = Math.min(1, 0.11 + 0.89 * (score / 779));
  return alpha.toString();
}
function parseAutoSQL(str) {
  let table;
  const fields = [];
  let startDecoding = false;
  const lines = str.trim().split(/\s*[\r\n]+\s*/g);
  for (let line of lines) {
    if (line.startsWith("table")) {
      table = line.split(/\s+/)[1].trim();
    } else if (line.startsWith("(")) {
      startDecoding = true;
    } else if (line.startsWith(")")) ;
    else if (startDecoding) {
      if (line.length > 0) {
        const idx = line.indexOf(";");
        const tokens = line.substr(0, idx).split(/\s+/);
        const description = line.substr(idx + 1).replace(/"/g, "").trim();
        fields.push({
          type: tokens[0],
          name: tokens[1],
          description
        });
      }
    }
  }
  return {
    table,
    fields
  };
}
let BIGWIG_MAGIC_LTH = 2291137574;
let BIGWIG_MAGIC_HTL = 654085990;
let BIGBED_MAGIC_LTH = 2273964779;
let BIGBED_MAGIC_HTL = 3958540679;
let BBFILE_HEADER_SIZE = 64;
let RPTREE_HEADER_SIZE = 48;
let RPTREE_NODE_LEAF_ITEM_SIZE = 32;
let RPTREE_NODE_CHILD_ITEM_SIZE = 24;
let BUFFER_SIZE = 512e3;
class BWReader {
  constructor(config, genome) {
    this.path = config.url;
    this.format = config.format || "bigwig";
    this.genome = genome;
    this.rpTreeCache = {};
    this.config = config;
    this.loader = isDataURL(this.path) ? new DataBuffer(this.path) : igvxhr;
  }
  async readWGFeatures(bpPerPixel, windowFunction) {
    await this.loadHeader();
    const chrIdx1 = 0;
    const chrIdx2 = this.chromTree.idToChrom.length - 1;
    const chr1 = this.chromTree.idToChrom[chrIdx1];
    const chr2 = this.chromTree.idToChrom[chrIdx2];
    return this.readFeatures(chr1, 0, chr2, Number.MAX_VALUE, bpPerPixel, windowFunction);
  }
  async readFeatures(chr1, bpStart, chr2, bpEnd, bpPerPixel, windowFunction) {
    await this.loadHeader();
    const chrIdx1 = this.chromTree.chromToID[chr1];
    const chrIdx2 = this.chromTree.chromToID[chr2];
    if (chrIdx1 === void 0 || chrIdx2 === void 0) {
      return [];
    }
    let treeOffset;
    let decodeFunction;
    if (this.type === "bigwig") {
      const zoomLevelHeaders = await this.getZoomHeaders();
      let zoomLevelHeader = bpPerPixel ? zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) : void 0;
      if (zoomLevelHeader) {
        treeOffset = zoomLevelHeader.indexOffset;
        decodeFunction = decodeZoomData;
      } else {
        treeOffset = this.header.fullIndexOffset;
        decodeFunction = decodeWigData;
      }
    } else {
      treeOffset = this.header.fullIndexOffset;
      decodeFunction = getBedDataDecoder.call(this);
    }
    const rpTree = await this.loadRPTree(treeOffset);
    const leafItems = await rpTree.findLeafItemsOverlapping(chrIdx1, bpStart, chrIdx2, bpEnd);
    if (!leafItems || leafItems.length === 0) {
      return [];
    } else {
      let start = Number.MAX_VALUE;
      let end = 0;
      for (let item of leafItems) {
        start = Math.min(start, item.dataOffset);
        end = Math.max(end, item.dataOffset + item.dataSize);
      }
      const size = end - start;
      const arrayBuffer = await this.loader.loadArrayBuffer(this.config.url, buildOptions$1(this.config, {
        range: {
          start,
          size
        }
      }));
      const allFeatures = [];
      for (let item of leafItems) {
        const uint8Array = new Uint8Array(arrayBuffer, item.dataOffset - start, item.dataSize);
        let plain;
        const isCompressed = this.header.uncompressBuffSize > 0;
        if (isCompressed) {
          plain = inflate_1$3(uint8Array);
        } else {
          plain = uint8Array;
        }
        decodeFunction.call(this, new DataView(plain.buffer), chrIdx1, bpStart, chrIdx2, bpEnd, allFeatures, this.chromTree.idToChrom, windowFunction);
      }
      allFeatures.sort(function(a, b) {
        return a.start - b.start;
      });
      return allFeatures;
    }
  }
  async getZoomHeaders() {
    if (this.zoomLevelHeaders) {
      return this.zoomLevelHeaders;
    } else {
      await this.loadHeader();
      return this.zoomLevelHeaders;
    }
  }
  async loadHeader() {
    if (this.header) {
      return this.header;
    } else {
      let data = await this.loader.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: 0,
          size: BBFILE_HEADER_SIZE
        }
      }));
      let header;
      this.littleEndian = true;
      let binaryParser = new BinaryParser$1(new DataView(data));
      let magic = binaryParser.getUInt();
      if (magic === BIGWIG_MAGIC_LTH) {
        this.type = "bigwig";
      } else if (magic === BIGBED_MAGIC_LTH) {
        this.type = "bigbed";
      } else {
        this.littleEndian = false;
        binaryParser.littleEndian = false;
        binaryParser.position = 0;
        let magic2 = binaryParser.getUInt();
        if (magic2 === BIGWIG_MAGIC_HTL) {
          this.type = "bigwig";
        } else if (magic2 === BIGBED_MAGIC_HTL) {
          this.type = "bigbed";
        } else ;
      }
      header = {
        bwVersion: binaryParser.getUShort(),
        nZoomLevels: binaryParser.getUShort(),
        chromTreeOffset: binaryParser.getLong(),
        fullDataOffset: binaryParser.getLong(),
        fullIndexOffset: binaryParser.getLong(),
        fieldCount: binaryParser.getUShort(),
        definedFieldCount: binaryParser.getUShort(),
        autoSqlOffset: binaryParser.getLong(),
        totalSummaryOffset: binaryParser.getLong(),
        uncompressBuffSize: binaryParser.getInt(),
        extensionOffset: binaryParser.getLong()
      };
      const startOffset = BBFILE_HEADER_SIZE;
      let range = { start: startOffset, size: header.fullDataOffset - startOffset + 5 };
      data = await this.loader.loadArrayBuffer(this.path, buildOptions$1(this.config, { range }));
      const nZooms = header.nZoomLevels;
      binaryParser = new BinaryParser$1(new DataView(data));
      this.zoomLevelHeaders = [];
      this.firstZoomDataOffset = Number.MAX_SAFE_INTEGER;
      for (let i = 1; i <= nZooms; i++) {
        const zoomNumber = nZooms - i;
        const zlh = new ZoomLevelHeader(zoomNumber, binaryParser);
        this.firstZoomDataOffset = Math.min(zlh.dataOffset, this.firstZoomDataOffset);
        this.zoomLevelHeaders[zoomNumber] = zlh;
      }
      if (header.autoSqlOffset > 0) {
        binaryParser.position = header.autoSqlOffset - startOffset;
        const autoSqlString = binaryParser.getString();
        if (autoSqlString) {
          this.autoSql = parseAutoSQL(autoSqlString);
        }
      }
      if (header.totalSummaryOffset > 0) {
        binaryParser.position = header.totalSummaryOffset - startOffset;
        this.totalSummary = new BWTotalSummary(binaryParser);
      }
      if (header.chromTreeOffset > 0) {
        binaryParser.position = header.chromTreeOffset - startOffset;
        this.chromTree = new BPTree(binaryParser, startOffset, this.genome);
      } else {
        throw "BigWig chromosome tree offset <= 0";
      }
      binaryParser.position = header.fullDataOffset - startOffset;
      header.dataCount = binaryParser.getInt();
      this.setDefaultVisibilityWindow(header);
      this.header = header;
      return this.header;
    }
  }
  async loadRPTree(offset2) {
    let rpTree = this.rpTreeCache[offset2];
    if (rpTree) {
      return rpTree;
    } else {
      rpTree = new RPTree(offset2, this.config, this.littleEndian, this.loader);
      await rpTree.load();
      this.rpTreeCache[offset2] = rpTree;
      return rpTree;
    }
  }
  async getType() {
    await this.loadHeader();
    return this.type;
  }
  async getTrackType() {
    await this.loadHeader();
    if (this.type === "bigwig") {
      return "wig";
    } else {
      return this.autoSql && this.autoSql.table === "chromatinInteract" ? "interact" : "annotation";
    }
  }
  setDefaultVisibilityWindow(header) {
    if (this.type === "bigwig") {
      this.visibilityWindow = -1;
    } else {
      let genomeSize = this.genome ? this.genome.getGenomeLength() : 3088286401;
      this.visibilityWindow = header.dataCount < 1e3 ? -1 : 1e3 * (genomeSize / header.dataCount);
    }
  }
}
class ZoomLevelHeader {
  constructor(index2, byteBuffer) {
    this.index = index2;
    this.reductionLevel = byteBuffer.getInt();
    this.reserved = byteBuffer.getInt();
    this.dataOffset = byteBuffer.getLong();
    this.indexOffset = byteBuffer.getLong();
  }
}
class RPTree {
  constructor(fileOffset, config, littleEndian, loader) {
    this.config = config;
    this.loader = loader;
    this.fileOffset = fileOffset;
    this.path = config.url;
    this.littleEndian = littleEndian;
  }
  async load() {
    const rootNodeOffset = this.fileOffset + RPTREE_HEADER_SIZE;
    const bufferedReader = isDataURL(this.path) ? this.loader : new BufferedReader(this.config, BUFFER_SIZE);
    this.rootNode = await this.readNode(rootNodeOffset, bufferedReader);
    return this;
  }
  async readNode(filePosition, bufferedReader) {
    let dataView = await bufferedReader.dataViewForRange({ start: filePosition, size: 4 }, false);
    let binaryParser = new BinaryParser$1(dataView, this.littleEndian);
    const type = binaryParser.getByte();
    const isLeaf = type === 1;
    binaryParser.getByte();
    const count = binaryParser.getUShort();
    filePosition += 4;
    let bytesRequired = count * (isLeaf ? RPTREE_NODE_LEAF_ITEM_SIZE : RPTREE_NODE_CHILD_ITEM_SIZE);
    let range2 = { start: filePosition, size: bytesRequired };
    dataView = await bufferedReader.dataViewForRange(range2, false);
    const items = new Array(count);
    binaryParser = new BinaryParser$1(dataView);
    if (isLeaf) {
      for (let i = 0; i < count; i++) {
        let item = {
          isLeaf: true,
          startChrom: binaryParser.getInt(),
          startBase: binaryParser.getInt(),
          endChrom: binaryParser.getInt(),
          endBase: binaryParser.getInt(),
          dataOffset: binaryParser.getLong(),
          dataSize: binaryParser.getLong()
        };
        items[i] = item;
      }
      return new RPTreeNode(items);
    } else {
      for (let i = 0; i < count; i++) {
        let item = {
          isLeaf: false,
          startChrom: binaryParser.getInt(),
          startBase: binaryParser.getInt(),
          endChrom: binaryParser.getInt(),
          endBase: binaryParser.getInt(),
          childOffset: binaryParser.getLong()
        };
        items[i] = item;
      }
      return new RPTreeNode(items);
    }
  }
  async findLeafItemsOverlapping(chrIdx1, startBase, chrIdx2, endBase) {
    let self2 = this;
    return new Promise(function(fulfill, reject) {
      let leafItems = [], processing = /* @__PURE__ */ new Set(), bufferedReader = isDataURL(self2.path) ? self2.loader : new BufferedReader(self2.config, BUFFER_SIZE);
      processing.add(0);
      findLeafItems(self2.rootNode, 0);
      function findLeafItems(node, nodeId) {
        if (overlaps(node, chrIdx1, startBase, chrIdx2, endBase)) {
          let items = node.items;
          items.forEach(function(item) {
            if (overlaps(item, chrIdx1, startBase, chrIdx2, endBase)) {
              if (item.isLeaf) {
                leafItems.push(item);
              } else {
                if (item.childNode) {
                  findLeafItems(item.childNode);
                } else {
                  processing.add(item.childOffset);
                  self2.readNode(item.childOffset, bufferedReader).then(function(node2) {
                    item.childNode = node2;
                    findLeafItems(node2, item.childOffset);
                  }).catch(reject);
                }
              }
            }
          });
        }
        if (nodeId !== void 0) processing.delete(nodeId);
        if (processing.size === 0) {
          fulfill(leafItems);
        }
      }
    });
  }
}
class RPTreeNode {
  constructor(items) {
    this.items = items;
    let minChromId = Number.MAX_SAFE_INTEGER, maxChromId = 0, minStartBase = Number.MAX_SAFE_INTEGER, maxEndBase = 0, i, item;
    for (i = 0; i < items.length; i++) {
      item = items[i];
      minChromId = Math.min(minChromId, item.startChrom);
      maxChromId = Math.max(maxChromId, item.endChrom);
      minStartBase = Math.min(minStartBase, item.startBase);
      maxEndBase = Math.max(maxEndBase, item.endBase);
    }
    this.startChrom = minChromId;
    this.endChrom = maxChromId;
    this.startBase = minStartBase;
    this.endBase = maxEndBase;
  }
}
class BPTree {
  constructor(binaryParser, startOffset, genome) {
    let magic = binaryParser.getInt();
    let blockSize = binaryParser.getInt();
    let keySize = binaryParser.getInt();
    let valSize = binaryParser.getInt();
    let itemCount = binaryParser.getLong();
    let reserved = binaryParser.getLong();
    let chromToId = {};
    let idToChrom = [];
    this.header = {
      magic,
      blockSize,
      keySize,
      valSize,
      itemCount,
      reserved
    };
    this.chromToID = chromToId;
    this.idToChrom = idToChrom;
    readTreeNode(binaryParser, -1);
    function readTreeNode(byteBuffer, offset2) {
      if (offset2 >= 0) byteBuffer.position = offset2;
      let type = byteBuffer.getByte();
      byteBuffer.getByte();
      let count = byteBuffer.getUShort(), i, key, chromId, childOffset, bufferOffset, currOffset;
      if (type === 1) {
        for (i = 0; i < count; i++) {
          key = byteBuffer.getFixedLengthTrimmedString(keySize);
          chromId = byteBuffer.getInt();
          byteBuffer.getInt();
          if (genome) key = genome.getChromosomeName(key);
          chromToId[key] = chromId;
          idToChrom[chromId] = key;
        }
      } else {
        for (i = 0; i < count; i++) {
          key = byteBuffer.getFixedLengthTrimmedString(keySize);
          childOffset = byteBuffer.getLong();
          bufferOffset = childOffset - startOffset;
          currOffset = byteBuffer.position;
          readTreeNode(byteBuffer, bufferOffset);
          byteBuffer.position = currOffset;
        }
      }
    }
  }
}
function overlaps(item, chrIdx1, startBase, chrIdx2, endBase) {
  if (!item) {
    console.log("null item for " + chrIdx1 + " " + startBase + " " + endBase);
    return false;
  }
  return (chrIdx2 > item.startChrom || chrIdx2 === item.startChrom && endBase >= item.startBase) && (chrIdx1 < item.endChrom || chrIdx1 === item.endChrom && startBase <= item.endBase);
}
class BWTotalSummary {
  constructor(byteBuffer) {
    if (byteBuffer) {
      this.basesCovered = byteBuffer.getLong();
      this.minVal = byteBuffer.getDouble();
      this.maxVal = byteBuffer.getDouble();
      this.sumData = byteBuffer.getDouble();
      this.sumSquares = byteBuffer.getDouble();
      computeStats.call(this);
    } else {
      this.basesCovered = 0;
      this.minVal = 0;
      this.maxVal = 0;
      this.sumData = 0;
      this.sumSquares = 0;
      this.mean = 0;
      this.stddev = 0;
    }
  }
}
function computeStats() {
  let n = this.basesCovered;
  if (n > 0) {
    this.mean = this.sumData / n;
    this.stddev = Math.sqrt(this.sumSquares / (n - 1));
    let min = this.minVal < 0 ? this.mean - 2 * this.stddev : 0, max = this.maxVal > 0 ? this.mean + 2 * this.stddev : 0;
    this.defaultRange = {
      min,
      max
    };
  }
}
function zoomLevelForScale$1(bpPerPixel, zoomLevelHeaders) {
  let level;
  for (let i = 0; i < zoomLevelHeaders.length; i++) {
    const zl = zoomLevelHeaders[i];
    if (zl.reductionLevel < bpPerPixel) {
      level = zl;
      break;
    }
  }
  return level;
}
function decodeWigData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {
  const binaryParser = new BinaryParser$1(data);
  const chromId = binaryParser.getInt();
  const blockStart = binaryParser.getInt();
  let chromStart = blockStart;
  let chromEnd = binaryParser.getInt();
  const itemStep = binaryParser.getInt();
  const itemSpan = binaryParser.getInt();
  const type = binaryParser.getByte();
  binaryParser.getByte();
  let itemCount = binaryParser.getUShort();
  if (chromId >= chrIdx1 && chromId <= chrIdx2) {
    let idx = 0;
    while (itemCount-- > 0) {
      let value;
      switch (type) {
        case 1:
          chromStart = binaryParser.getInt();
          chromEnd = binaryParser.getInt();
          value = binaryParser.getFloat();
          break;
        case 2:
          chromStart = binaryParser.getInt();
          value = binaryParser.getFloat();
          chromEnd = chromStart + itemSpan;
          break;
        case 3:
          value = binaryParser.getFloat();
          chromStart = blockStart + idx * itemStep;
          chromEnd = chromStart + itemSpan;
          idx++;
          break;
      }
      if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;
      else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;
      if (Number.isFinite(value)) {
        const chr = chrDict[chromId];
        featureArray.push({ chr, start: chromStart, end: chromEnd, value });
      }
    }
  }
}
function getBedDataDecoder() {
  const minSize = 3 * 4 + 1;
  const decoder = getDecoder(this.header.definedFieldCount, this.header.fieldCount, this.autoSql, this.format);
  return function(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict) {
    const binaryParser = new BinaryParser$1(data);
    while (binaryParser.remLength() >= minSize) {
      const chromId = binaryParser.getInt();
      const chr = chrDict[chromId];
      const chromStart = binaryParser.getInt();
      const chromEnd = binaryParser.getInt();
      const rest = binaryParser.getString();
      if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;
      else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;
      if (chromEnd > 0) {
        const feature2 = { chr, start: chromStart, end: chromEnd };
        featureArray.push(feature2);
        const tokens = rest.split("	");
        decoder(feature2, tokens);
      }
    }
  };
}
function decodeZoomData(data, chrIdx1, bpStart, chrIdx2, bpEnd, featureArray, chrDict, windowFunction) {
  const binaryParser = new BinaryParser$1(data);
  const minSize = 8 * 4;
  while (binaryParser.remLength() >= minSize) {
    const chromId = binaryParser.getInt();
    const chr = chrDict[chromId];
    const chromStart = binaryParser.getInt();
    const chromEnd = binaryParser.getInt();
    const validCount = binaryParser.getInt();
    const minVal = binaryParser.getFloat();
    const maxVal = binaryParser.getFloat();
    const sumData = binaryParser.getFloat();
    binaryParser.getFloat();
    let value;
    switch (windowFunction) {
      case "min":
        value = minVal;
        break;
      case "max":
        value = maxVal;
        break;
      default:
        value = validCount === 0 ? 0 : sumData / validCount;
    }
    if (chromId < chrIdx1 || chromId === chrIdx1 && chromEnd < bpStart) continue;
    else if (chromId > chrIdx2 || chromId === chrIdx2 && chromStart >= bpEnd) break;
    if (Number.isFinite(value)) {
      featureArray.push({ chr, start: chromStart, end: chromEnd, value });
    }
  }
}
class DataBuffer {
  constructor(dataURI) {
    this.data = decodeDataURI$1(dataURI).buffer;
  }
  /**
   * igvxhr interface
   * @param ignore
   * @param options
   * @returns {any}
   */
  loadArrayBuffer(ignore, options2) {
    const range = options2.range;
    return range ? this.data.slice(range.start, range.start + range.size) : this.data;
  }
  /**
   * BufferedReader interface
   *
   * @param requestedRange - byte rangeas {start, size}
   * @param fulfill - function to receive result
   * @param asUint8 - optional flag to return result as an UInt8Array
   */
  async dataViewForRange(requestedRange, asUint8) {
    const len2 = Math.min(this.data.byteLength - requestedRange.start, requestedRange.size);
    return asUint8 ? new Uint8Array(this.data, requestedRange.start, len2) : new DataView(this.data, requestedRange.start, len2);
  }
}
class BWSource {
  constructor(config, genome) {
    this.reader = new BWReader(config, genome);
    this.genome = genome;
    this.format = config.format || "bigwig";
    this.wgValues = {};
    this.queryable = true;
  }
  async getFeatures({ chr, start, end, bpPerPixel, windowFunction }) {
    const isBigWig = this.reader.type === "bigwig";
    const features = chr.toLowerCase() === "all" ? isBigWig ? await this.getWGValues(windowFunction) : [] : await this.reader.readFeatures(chr, start, chr, end, bpPerPixel, windowFunction);
    if (!isBigWig) {
      pack(features);
    }
    return features;
  }
  async getHeader() {
    return this.reader.loadHeader();
  }
  getDefaultRange() {
    if (this.reader.totalSummary !== void 0) {
      return this.reader.totalSummary.defaultRange;
    } else {
      return void 0;
    }
  }
  async defaultVisibilityWindow() {
    return this.reader.defaultVisibilityWindow;
  }
  async getWGValues(windowFunction) {
    const nominalScreenWidth = 1e3;
    const genome = this.genome;
    if (this.wgValues[windowFunction]) {
      return this.wgValues[windowFunction];
    } else {
      const bpPerPixel = genome.getGenomeLength() / nominalScreenWidth;
      const features = await this.reader.readWGFeatures(bpPerPixel, windowFunction);
      let wgValues = [];
      for (let f of features) {
        const chr = f.chr;
        const offset2 = genome.getCumulativeOffset(chr);
        const wgFeature = Object.assign({}, f);
        wgFeature.chr = "all";
        wgFeature.start = offset2 + f.start;
        wgFeature.end = offset2 + f.end;
        wgValues.push(wgFeature);
      }
      this.wgValues[windowFunction] = wgValues;
      return wgValues;
    }
  }
  supportsWholeGenome() {
    return this.reader.type === "bigwig";
  }
  async trackType() {
    return this.reader.getTrackType();
  }
}
const GZIP_FLAG = 1;
class TDFReader {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.path = config.url;
    this.groupCache = {};
    this.datasetCache = {};
  }
  async readHeader() {
    if (this.magic !== void 0) {
      return this;
    }
    let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, { range: { start: 0, size: 64e3 } }));
    let binaryParser = new BinaryParser$1(new DataView(data));
    this.magic = binaryParser.getInt();
    this.version = binaryParser.getInt();
    this.indexPos = binaryParser.getLong();
    this.indexSize = binaryParser.getInt();
    binaryParser.getInt();
    if (this.version >= 2) {
      let nWindowFunctions = binaryParser.getInt();
      this.windowFunctions = [];
      while (nWindowFunctions-- > 0) {
        this.windowFunctions.push(binaryParser.getString());
      }
    }
    this.trackType = binaryParser.getString();
    this.trackLine = binaryParser.getString();
    let nTracks = binaryParser.getInt();
    this.trackNames = [];
    while (nTracks-- > 0) {
      this.trackNames.push(binaryParser.getString());
    }
    this.genomeID = binaryParser.getString();
    this.flags = binaryParser.getInt();
    this.compressed = (this.flags & GZIP_FLAG) !== 0;
    data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: this.indexPos,
        size: this.indexSize
      }
    }));
    binaryParser = new BinaryParser$1(new DataView(data));
    this.datasetIndex = {};
    let nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      const name2 = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.datasetIndex[name2] = { position: pos, size };
    }
    this.groupIndex = {};
    nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      const name2 = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.groupIndex[name2] = { position: pos, size };
    }
    return this;
  }
  async readDataset(chr, windowFunction, zoom) {
    const key = chr + "_" + windowFunction + "_" + zoom;
    if (this.datasetCache[key]) {
      return this.datasetCache[key];
    } else {
      await this.readHeader();
      const wf = this.version < 2 ? "" : "/" + windowFunction;
      const zoomString = chr.toLowerCase() === "all" || zoom === void 0 ? "0" : zoom.toString();
      let dsName;
      if (windowFunction === "raw") {
        dsName = "/" + chr + "/raw";
      } else {
        dsName = "/" + chr + "/z" + zoomString + wf;
      }
      const indexEntry = this.datasetIndex[dsName];
      if (indexEntry === void 0) {
        return void 0;
      }
      const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: indexEntry.position,
          size: indexEntry.size
        }
      }));
      if (!data) {
        return void 0;
      }
      const binaryParser = new BinaryParser$1(new DataView(data));
      let nAttributes = binaryParser.getInt();
      const attributes = {};
      while (nAttributes-- > 0) {
        attributes[binaryParser.getString()] = binaryParser.getString();
      }
      const dataType = binaryParser.getString();
      const tileWidth = binaryParser.getFloat();
      let nTiles = binaryParser.getInt();
      const tiles = [];
      while (nTiles-- > 0) {
        tiles.push({ position: binaryParser.getLong(), size: binaryParser.getInt() });
      }
      const dataset = {
        name: dsName,
        attributes,
        dataType,
        tileWidth,
        tiles
      };
      this.datasetCache[key] = dataset;
      return dataset;
    }
  }
  async readRootGroup() {
    const genome = this.genome;
    const rootGroup = this.groupCache["/"];
    if (rootGroup) {
      return rootGroup;
    } else {
      const group = await this.readGroup("/");
      const names = group["chromosomes"];
      const maxZoomString = group["maxZoom"];
      if (maxZoomString) {
        this.maxZoom = Number(maxZoomString);
      }
      const totalCountString = group["totalCount"];
      if (totalCountString) {
        group.totalCount = Number(totalCountString);
      }
      const chrAliasTable = {};
      if (names) {
        names.split(",").forEach(function(chr) {
          const canonicalName = genome.getChromosomeName(chr);
          chrAliasTable[canonicalName] = chr;
        });
      }
      this.chrAliasTable = chrAliasTable;
      this.groupCache["/"] = group;
      return group;
    }
  }
  async readGroup(name2) {
    const group = this.groupCache[name2];
    if (group) {
      return group;
    } else {
      await this.readHeader();
      const indexEntry = this.groupIndex[name2];
      if (indexEntry === void 0) {
        return void 0;
      }
      const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
        range: {
          start: indexEntry.position,
          size: indexEntry.size
        }
      }));
      if (!data) {
        return void 0;
      }
      const binaryParser = new BinaryParser$1(new DataView(data));
      const group2 = { name: name2 };
      let nAttributes = binaryParser.getInt();
      while (nAttributes-- > 0) {
        const key = binaryParser.getString();
        const value = binaryParser.getString();
        group2[key] = value;
      }
      this.groupCache[name2] = group2;
      return group2;
    }
  }
  async readTiles(tileIndeces, nTracks) {
    tileIndeces.sort(function(a, b) {
      return a.position - b.position;
    });
    tileIndeces = tileIndeces.filter(function(idx) {
      return idx.size > 0;
    });
    if (tileIndeces.length === 0) {
      return Promise.resolve([]);
    }
    const firstEntry = tileIndeces[0];
    const lastEntry = tileIndeces[tileIndeces.length - 1];
    const position = firstEntry.position;
    const size = lastEntry.position + lastEntry.size - position;
    const data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: position,
        size
      }
    }));
    const tiles = [];
    for (let indexEntry of tileIndeces) {
      const start = indexEntry.position - position;
      const size2 = indexEntry.size;
      if (size2 > 0) {
        let tileData;
        if (this.compressed) {
          const plain = inflate_1$3(data.slice(start, start + size2));
          tileData = plain.buffer;
        } else {
          tileData = data.slice(start, start + size2);
        }
        const binaryParser = new BinaryParser$1(new DataView(tileData));
        const type = binaryParser.getString();
        let tile;
        switch (type) {
          case "fixedStep":
            tile = createFixedStep(binaryParser, nTracks);
            break;
          case "variableStep":
            tile = createVariableStep(binaryParser, nTracks);
            break;
          case "bed":
          case "bedWithName":
            tile = createBed(binaryParser, nTracks, type);
            break;
          default:
            throw "Unknown tile type: " + type;
        }
        tiles.push(tile);
      }
    }
    return tiles;
  }
  async readTile(indexEntry, nTracks) {
    let data = await igvxhr.loadArrayBuffer(this.path, buildOptions$1(this.config, {
      range: {
        start: indexEntry.position,
        size: indexEntry.size
      }
    }));
    if (this.compressed) {
      const plain = inflate_1$3(data);
      data = plain.buffer;
    }
    const binaryParser = new BinaryParser$1(new DataView(data));
    const type = binaryParser.getString();
    switch (type) {
      case "fixedStep":
        return createFixedStep(binaryParser, nTracks);
      case "variableStep":
        return createVariableStep(binaryParser, nTracks);
      case "bed":
      case "bedWithName":
        return createBed(binaryParser, nTracks, type);
      default:
        throw "Unknown tile type: " + type;
    }
  }
}
function createFixedStep(binaryParser, nTracks) {
  const nPositions = binaryParser.getInt();
  const start = binaryParser.getInt();
  const span = binaryParser.getFloat();
  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    let np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }
  return {
    type: "fixedStep",
    start,
    span,
    data,
    nTracks,
    nPositions
  };
}
function createVariableStep(binaryParser, nTracks) {
  const tileStart = binaryParser.getInt();
  const span = binaryParser.getFloat();
  const nPositions = binaryParser.getInt();
  const start = [];
  let np = nPositions;
  while (np-- > 0) {
    start.push(binaryParser.getInt());
  }
  binaryParser.getInt();
  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }
  return {
    type: "variableStep",
    tileStart,
    span,
    start,
    data,
    nTracks,
    nPositions
  };
}
function createBed(binaryParser, nTracks, type) {
  const nPositions = binaryParser.getInt();
  let n = nPositions;
  const start = [];
  while (n-- > 0) {
    start.push(binaryParser.getInt());
  }
  n = nPositions;
  const end = [];
  while (n-- > 0) {
    end.push(binaryParser.getInt());
  }
  binaryParser.getInt();
  const data = [];
  let nt = nTracks;
  while (nt-- > 0) {
    let np = nPositions;
    const dtrack = [];
    while (np-- > 0) {
      dtrack.push(binaryParser.getFloat());
    }
    data.push(dtrack);
  }
  if (type === "bedWithName") {
    n = nPositions;
    const name2 = [];
    while (n-- > 0) {
      name2.push(binaryParser.getString());
    }
  }
  return {
    type,
    start,
    end,
    data,
    nTracks,
    nPositions
  };
}
class TDFSource {
  constructor(config, genome) {
    this.genome = genome;
    this.windowFunction = config.windowFunction || "mean";
    this.reader = new TDFReader(config, genome);
    this.queryable = true;
  }
  async getFeatures({ chr, start, end, bpPerPixel }) {
    if (chr.toLowerCase() === "all") {
      const wgFeatures = [];
      const genome = this.genome;
      const chrNames = this.genome.wgChromosomeNames;
      if (chrNames) {
        for (let c of genome.wgChromosomeNames) {
          const len2 = genome.getChromosome(c).bpLength;
          bpPerPixel = len2 / 1e3;
          const chrFeatures = await this._getFeatures(c, 0, len2, bpPerPixel);
          if (chrFeatures) {
            for (let f of chrFeatures) {
              const wg = Object.assign({}, f);
              wg.chr = "all";
              wg.start = genome.getGenomeCoordinate(f.chr, f.start);
              wg.end = genome.getGenomeCoordinate(f.chr, f.end);
              wg._f = f;
              wgFeatures.push(wg);
            }
          }
        }
      }
      return wgFeatures;
    } else {
      return this._getFeatures(chr, start, end, bpPerPixel);
    }
  }
  async _getFeatures(chr, start, end, bpPerPixel) {
    const genomicInterval = new GenomicInterval(chr, start, end);
    const genome = this.genome;
    if (!this.rootGroup) {
      this.rootGroup = await this.reader.readRootGroup();
      if (!this.normalizationFactor) {
        const totalCount = this.rootGroup.totalCount;
        if (totalCount) {
          this.normalizationFactor = 1e6 / totalCount;
        }
      }
    }
    genomicInterval.bpPerPixel = bpPerPixel;
    const zoom = zoomLevelForScale(chr, bpPerPixel, genome);
    let queryChr = this.reader.chrAliasTable[chr];
    let maxZoom = this.reader.maxZoom;
    if (queryChr === void 0) queryChr = chr;
    if (maxZoom === void 0) maxZoom = -1;
    const wf = zoom > maxZoom ? "raw" : this.windowFunction;
    const dataset = await this.reader.readDataset(queryChr, wf, zoom);
    if (dataset == null) {
      return [];
    }
    const tileWidth = dataset.tileWidth;
    const startTile = Math.floor(start / tileWidth);
    const endTile = Math.floor(end / tileWidth);
    const NTRACKS = 1;
    const tiles = await this.reader.readTiles(dataset.tiles.slice(startTile, endTile + 1), NTRACKS);
    const features = [];
    for (let tile of tiles) {
      switch (tile.type) {
        case "bed":
          decodeBedTile(tile, chr, start, end, bpPerPixel, features);
          break;
        case "variableStep":
          decodeVaryTile(tile, chr, start, end, bpPerPixel, features);
          break;
        case "fixedStep":
          decodeFixedTile(tile, chr, start, end, bpPerPixel, features);
          break;
        default:
          throw "Unknown tile type: " + tile.type;
      }
    }
    features.sort(function(a, b) {
      return a.start - b.start;
    });
    return features;
  }
  get supportsWholeGenome() {
    return true;
  }
}
function decodeBedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
  const nPositions = tile.nPositions;
  const starts = tile.start;
  const ends = tile.end;
  const data = tile.data[0];
  for (let i = 0; i < nPositions; i++) {
    const s = starts[i];
    const e = ends[i];
    if (e < bpStart) continue;
    if (s > bpEnd) break;
    features.push({
      chr,
      start: s,
      end: e,
      value: data[i]
    });
  }
}
function decodeVaryTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
  const nPositions = tile.nPositions;
  const starts = tile.start;
  const span = tile.span;
  const data = tile.data[0];
  for (let i = 0; i < nPositions; i++) {
    const s = starts[i];
    const e = s + span;
    if (e < bpStart) continue;
    if (s > bpEnd) break;
    features.push({
      chr,
      start: s,
      end: e,
      value: data[i]
    });
  }
}
function decodeFixedTile(tile, chr, bpStart, bpEnd, bpPerPixel, features) {
  const nPositions = tile.nPositions;
  let s = tile.start;
  const span = tile.span;
  const data = tile.data[0];
  for (let i = 0; i < nPositions; i++) {
    const e = s + span;
    if (s > bpEnd) break;
    if (e >= bpStart) {
      if (!Number.isNaN(data[i])) {
        features.push({
          chr,
          start: s,
          end: e,
          value: data[i]
        });
      }
    }
    s = e;
  }
}
var log2 = Math.log(2);
function zoomLevelForScale(chr, bpPerPixel, genome) {
  var chrSize = genome.getChromosome(chr).bpLength;
  return Math.ceil(Math.log(Math.max(0, chrSize / (bpPerPixel * 700))) / log2);
}
class StaticFeatureSource {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.queryable = false;
    this.searchable = config.searchable !== false;
    this.updateFeatures(config.features);
  }
  updateFeatures(features) {
    features = fixFeatures(features, this.genome);
    packFeatures(features);
    if (this.config.mappings) {
      mapProperties(features, this.config.mappings);
    }
    this.featureCache = new FeatureCache$1(features, this.genome);
    if (this.searchable || this.config.searchableFields) {
      this.genome.addFeaturesToDB(features, this.config);
    }
  }
  /**
   * Required function for all data source objects.  Fetches features for the
   * range requested.
   *
   * This function is complex due to the variety of reader types backing it, some indexed, some queryable,
   * some not.
   *
   * @param chr
   * @param start
   * @param end
   * @param bpPerPixel
   */
  async getFeatures({ chr, start, end, bpPerPixel, visibilityWindow }) {
    const genome = this.genome;
    const queryChr = genome ? genome.getChromosomeName(chr) : chr;
    const isWholeGenome = "all" === queryChr.toLowerCase();
    if (isWholeGenome) {
      return computeWGFeatures(this.featureCache.getAllFeatures(), this.genome, this.maxWGCount);
    } else {
      return this.featureCache.queryFeatures(queryChr, start, end);
    }
  }
  //
  // supportsWholeGenome() {
  //    return true
  // }
  getAllFeatures() {
    return this.featureCache.getAllFeatures();
  }
  supportsWholeGenome() {
    return true;
  }
}
function fixFeatures(features, genome) {
  if (genome) {
    for (let feature2 of features) {
      feature2.chr = genome.getChromosomeName(feature2.chr);
    }
  }
  return features;
}
function mapProperties(features, mappings) {
  let mappingKeys = Object.keys(mappings);
  features.forEach(function(f) {
    mappingKeys.forEach(function(key) {
      f[key] = f[mappings[key]];
    });
  });
}
const bbFormats = /* @__PURE__ */ new Set(["bigwig", "bw", "bigbed", "bb", "biginteract", "biggenepred", "bignarrowpeak"]);
function FeatureSource(config, genome) {
  const format2 = config.format ? config.format.toLowerCase() : void 0;
  if (config.features) {
    return new StaticFeatureSource(config, genome);
  } else if (bbFormats.has(format2)) {
    return new BWSource(config, genome);
  } else if ("tdf" === format2) {
    return new TDFSource(config, genome);
  } else {
    return new TextFeatureSource(config, genome);
  }
}
const appleCrayonColorName = "nickel";
const ROI_DEFAULT_ALPHA = 2 / 16;
const ROI_DEFAULT_COLOR = appleCrayonRGBA(appleCrayonColorName, ROI_DEFAULT_ALPHA);
const ROI_DEFAULT_HEADER_COLOR = "rgb(190,190,190)";
const ROI_USER_HEADER_DEFINED_COLOR = "rgba(155,185,129)";
const ROI_USER_DEFINED_COLOR = ROI_DEFAULT_COLOR;
class ROISet {
  constructor(config, genome) {
    this.url = config.url;
    if (config.name) {
      this.name = config.name;
    } else if (config.url && isFile$1(config.url)) {
      this.name = config.url.name;
    } else if (config.url && isString$2(config.url) && !config.url.startsWith("data:")) {
      this.name = getFilename$2(config.url);
    }
    this.isUserDefined = config.isUserDefined;
    if (config.features) {
      this.featureSource = new DynamicFeatureSource(config.features, genome);
    } else {
      if (config.format) {
        config.format = config.format.toLowerCase();
      } else {
        const filename = getFilename$2(config.url);
        config.format = inferFileFormat(filename);
      }
      this.featureSource = config.featureSource || FeatureSource(config, genome);
    }
    if (true === this.isUserDefined) {
      this.color = config.color || ROI_USER_DEFINED_COLOR;
      this.headerColor = ROI_USER_HEADER_DEFINED_COLOR;
    } else {
      this.color = config.color || ROI_DEFAULT_COLOR;
      this.headerColor = ROI_DEFAULT_HEADER_COLOR;
    }
  }
  async getFeatures(chr, start, end) {
    return this.featureSource.getFeatures({ chr, start, end });
  }
  async getAllFeatures() {
    return typeof this.featureSource.getAllFeatures === "function" ? await this.featureSource.getAllFeatures() : {};
  }
  addFeature(feature2) {
    if (this.isUserDefined) {
      this.featureSource.addFeature(feature2);
    } else {
      console.error("Attempt to add ROI to non user-defined set");
    }
  }
  removeFeature(feature2) {
    if (this.isUserDefined) {
      this.featureSource.removeFeature(feature2);
    } else {
      console.error("Attempt to remove ROI from non user-defined set");
    }
  }
  toJSON() {
    if (this.url) {
      return { name: this.name, color: this.color, url: this.url, isUserDefined: this.isUserDefined };
    } else {
      const featureMap = this.featureSource.getAllFeatures();
      const features = [];
      for (let chr of Object.keys(featureMap)) {
        for (let f of featureMap[chr]) {
          features.push(f);
        }
      }
      return { name: this.name, color: this.color, features, isUserDefined: this.isUserDefined };
    }
  }
  dispose() {
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
  }
}
const SCREEN_COORDS_WIDTH_THRESHOLD = 3;
function screenCoordinates(regionStartBP, regionEndBP, bpStart, bpp) {
  let xStart = Math.round((regionStartBP - bpStart) / bpp);
  const xEnd = Math.round((regionEndBP - bpStart) / bpp);
  let width = xEnd - xStart;
  if (width < SCREEN_COORDS_WIDTH_THRESHOLD) {
    width = SCREEN_COORDS_WIDTH_THRESHOLD;
    xStart -= 1;
  }
  return { x: xStart, width };
}
class DynamicFeatureSource {
  constructor(features, genome) {
    this.featureMap = {};
    this.genome = genome;
    for (let feature2 of features) {
      const chrKey = genome ? genome.getChromosomeName(feature2.chr) : feature2.chr;
      let featureList = this.featureMap[chrKey];
      if (!featureList) {
        featureList = [];
        this.featureMap[chrKey] = featureList;
      }
      featureList.push(feature2);
    }
    for (let key of Object.keys(this.featureMap)) {
      this.featureMap[key].sort((a, b) => a.start - b.start);
    }
  }
  getFeatures({ chr, start, end }) {
    if (chr.toLowerCase() === "all") {
      return computeWGFeatures(this.featureMap, this.genome);
    } else {
      const featureList = this.featureMap[chr];
      return featureList ? featureList.filter((feature2) => feature2.end > start && feature2.start < end) : [];
    }
  }
  getAllFeatures() {
    return this.featureMap;
  }
  supportsWholeGenome() {
    return true;
  }
  addFeature(feature2) {
    let featureList = this.featureMap[feature2.chr];
    if (!featureList) {
      featureList = [];
      this.featureMap[feature2.chr] = featureList;
    }
    featureList.push(feature2);
    featureList.sort((a, b) => a.start - b.start);
  }
  removeFeature({ chr, start, end }) {
    if (this.featureMap[chr]) {
      const match = `${chr}-${start}-${end}`;
      this.featureMap[chr] = this.featureMap[chr].filter((feature2) => match !== `${feature2.chr}-${feature2.start}-${feature2.end}`);
    }
  }
}
const RULER_SWEEPER_COLOR = "rgba(68, 134, 247, 0.25)";
class RulerSweeper {
  constructor(rulerViewport, column, browser, referenceFrame) {
    this.rulerViewport = rulerViewport;
    this.rulerSweeper = domUtils$1.div({ class: "igv-ruler-sweeper" });
    column.appendChild(this.rulerSweeper);
    this.browser = browser;
    this.referenceFrame = referenceFrame;
    this.isMouseHandlers = void 0;
    this.addBrowserObserver();
  }
  addBrowserObserver() {
    const observerHandler = () => {
      if (this.referenceFrame) {
        GenomeUtils.isWholeGenomeView(this.referenceFrame.chr) ? this.removeMouseHandlers() : this.addMouseHandlers();
      }
    };
    this.boundObserverHandler = observerHandler.bind(this);
    this.browser.on("locuschange", this.boundObserverHandler);
  }
  removeBrowserObserver() {
    this.browser.off("locuschange", this.boundObserverHandler);
  }
  addMouseHandlers() {
    if (true === this.isMouseHandlers) {
      return;
    }
    const threshold = 1;
    let isMouseDown;
    let isMouseIn;
    let mouseDownX;
    let left;
    let width;
    let dx;
    this.boundContentMouseDownHandler = contentMouseDownHandler.bind(this);
    this.rulerViewport.contentDiv.addEventListener("mousedown", this.boundContentMouseDownHandler);
    function contentMouseDownHandler(event) {
      isMouseDown = true;
      isMouseIn = true;
      const { x } = domUtils$1.translateMouseCoordinates(event, this.rulerViewport.contentDiv);
      left = mouseDownX = x;
      width = threshold;
      this.rulerSweeper.style.display = "block";
      this.rulerSweeper.style.backgroundColor = true === event.shiftKey ? ROI_USER_DEFINED_COLOR : RULER_SWEEPER_COLOR;
      this.rulerSweeper.style.left = `${left}px`;
      this.rulerSweeper.style.width = `${width}px`;
    }
    this.boundDocumentMouseMoveHandler = documentMouseMoveHandler.bind(this);
    document.addEventListener("mousemove", this.boundDocumentMouseMoveHandler);
    function documentMouseMoveHandler(event) {
      let mouseCurrentX;
      if (isMouseDown && isMouseIn) {
        const { x } = domUtils$1.translateMouseCoordinates(event, this.rulerViewport.contentDiv);
        mouseCurrentX = Math.max(Math.min(x, this.rulerViewport.contentDiv.clientWidth), 0);
        dx = mouseCurrentX - mouseDownX;
        width = Math.abs(dx);
        this.rulerSweeper.style.width = `${width}px`;
        if (dx < 0) {
          left = mouseDownX + dx;
          this.rulerSweeper.style.left = `${left}px`;
        }
      }
    }
    this.boundDocumentMouseUpHandler = documentMouseUpHandler.bind(this);
    document.addEventListener("mouseup", this.boundDocumentMouseUpHandler);
    function documentMouseUpHandler(event) {
      let genomicExtent;
      if (true === isMouseDown && true === isMouseIn) {
        isMouseDown = isMouseIn = void 0;
        this.rulerSweeper.style.display = "none";
        if (width > threshold) {
          genomicExtent = {
            start: Math.floor(this.referenceFrame.calculateEnd(left)),
            end: Math.floor(this.referenceFrame.calculateEnd(left + width))
          };
          const shiftKeyPressed = event.shiftKey;
          if (true === shiftKeyPressed) {
            this.browser.roiManager.updateUserDefinedROISet(Object.assign({ chr: this.referenceFrame.chr }, genomicExtent));
          } else {
            validateGenomicExtent(this.browser.genome.getChromosome(this.referenceFrame.chr).bpLength, genomicExtent, this.browser.minimumBases());
            updateReferenceFrame(this.referenceFrame, genomicExtent, this.rulerViewport.contentDiv.clientWidth);
            this.browser.updateViews(this.referenceFrame);
          }
        }
      }
    }
    this.isMouseHandlers = true;
  }
  removeMouseHandlers() {
    this.rulerViewport.contentDiv.removeEventListener("mousedown", this.boundContentMouseDownHandler);
    document.removeEventListener("mousemove", this.boundDocumentMouseMoveHandler);
    document.removeEventListener("mouseup", this.boundDocumentMouseUpHandler);
    this.isMouseHandlers = false;
  }
  dispose() {
    this.removeBrowserObserver();
    this.removeMouseHandlers();
    this.rulerSweeper.remove();
  }
}
function updateReferenceFrame(referenceFrame, genomicExtent, pixelWidth) {
  referenceFrame.start = Math.round(genomicExtent.start);
  referenceFrame.end = Math.round(genomicExtent.end);
  referenceFrame.bpPerPixel = (referenceFrame.end - referenceFrame.start) / pixelWidth;
}
class PairedAlignment {
  constructor(firstAlignment) {
    this.paired = true;
    this.firstAlignment = firstAlignment;
    this.chr = firstAlignment.chr;
    this.readName = firstAlignment.readName;
    if (firstAlignment.start < firstAlignment.mate.position) {
      this.start = firstAlignment.start;
      this.scStart = firstAlignment.scStart;
      this.connectingStart = firstAlignment.start + firstAlignment.lengthOnRef;
      this.connectingEnd = firstAlignment.mate.position;
    } else {
      this.start = firstAlignment.mate.position;
      this.scStart = this.start;
      this.connectingStart = firstAlignment.mate.position;
      this.connectingEnd = firstAlignment.start;
    }
    this.end = Math.max(firstAlignment.mate.position, firstAlignment.start + firstAlignment.lengthOnRef);
    this.lengthOnRef = this.end - this.start;
    let scEnd = Math.max(this.end, firstAlignment.scStart + firstAlignment.scLengthOnRef);
    this.scLengthOnRef = scEnd - this.scStart;
  }
  setSecondAlignment(secondAlignment) {
    this.secondAlignment = secondAlignment;
    const firstAlignment = this.firstAlignment;
    if (secondAlignment.start > firstAlignment.start) {
      this.connectingEnd = secondAlignment.start;
    } else {
      this.connectingStart = secondAlignment.start + secondAlignment.lengthOnRef;
    }
    this.start = Math.min(firstAlignment.start, secondAlignment.start);
    this.end = Math.max(firstAlignment.start + firstAlignment.lengthOnRef, secondAlignment.start + secondAlignment.lengthOnRef);
    this.lengthOnRef = this.end - this.start;
    this.scStart = Math.min(firstAlignment.scStart, secondAlignment.scStart);
    const scEnd = Math.max(firstAlignment.scStart + firstAlignment.scLengthOnRef, secondAlignment.scStart + secondAlignment.scLengthOnRef);
    this.scLengthOnRef = scEnd - this.scStart;
  }
  containsLocation(genomicLocation, showSoftClips) {
    const s = showSoftClips ? this.scStart : this.start;
    const l = showSoftClips ? this.scLengthOnRef : this.lengthOnRef;
    return genomicLocation >= s && genomicLocation <= s + l;
  }
  alignmentContaining(genomicLocation, showSoftClips) {
    if (this.firstAlignment.containsLocation(genomicLocation, showSoftClips)) {
      return this.firstAlignment;
    } else if (this.secondAlignment && this.secondAlignment.containsLocation(genomicLocation, showSoftClips)) {
      return this.secondAlignment;
    } else {
      return void 0;
    }
  }
  popupData(genomicLocation) {
    let nameValues = this.firstAlignment.popupData(genomicLocation);
    if (this.secondAlignment) {
      nameValues.push("-------------------------------");
      nameValues = nameValues.concat(this.secondAlignment.popupData(genomicLocation));
    }
    return nameValues;
  }
  isPaired() {
    return true;
  }
  isMateMapped() {
    return true;
  }
  isProperPair() {
    return this.firstAlignment.isProperPair();
  }
  get fragmentLength() {
    return Math.abs(this.firstAlignment.fragmentLength);
  }
  firstOfPairStrand() {
    if (this.firstAlignment.isFirstOfPair()) {
      return this.firstAlignment.strand;
    } else if (this.secondAlignment && this.secondAlignment.isFirstOfPair()) {
      return this.secondAlignment.strand;
    } else {
      return this.firstAlignment.mate.strand;
    }
  }
  hasTag(str) {
    return this.firstAlignment.hasTag(str) || this.secondAlignment && this.secondAlignment.hasTag(str);
  }
}
class BamAlignmentRow {
  constructor() {
    this.alignments = [];
    this.score = void 0;
  }
  findAlignment(genomicLocation) {
    const alignmentContains = (a, genomicLocation2) => {
      return genomicLocation2 >= a.start && genomicLocation2 < a.start + a.lengthOnRef;
    };
    let centerAlignment;
    for (let i = 0; i < this.alignments.length; i++) {
      const a = this.alignments[i];
      if (genomicLocation >= a.start && genomicLocation < a.start + a.lengthOnRef) {
        if (a.paired) {
          if (a.firstAlignment && alignmentContains(a.firstAlignment, genomicLocation)) {
            centerAlignment = a.firstAlignment;
          } else if (a.secondAlignment && alignmentContains(a.secondAlignment, genomicLocation)) {
            centerAlignment = a.secondAlignment;
          }
        } else {
          centerAlignment = a;
        }
        break;
      }
    }
    return centerAlignment;
  }
  getSortValue({ position, option, tag }, alignmentContainer) {
    if (!option) option = "BASE";
    const alignment = this.findAlignment(position);
    if (void 0 === alignment) {
      return Number.MAX_VALUE;
    }
    switch (option) {
      case "NUCLEOTIDE":
      case "BASE": {
        return calculateBaseScore(alignment, alignmentContainer, position);
      }
      case "STRAND":
        return alignment.strand ? 1 : -1;
      case "START":
        return alignment.start;
      case "TAG": {
        return alignment.tags()[tag];
      }
      case "READ_NAME":
        return alignment.readName;
      case "INSERT_SIZE":
        return -Math.abs(alignment.fragmentLength);
      case "GAP_SIZE":
        return -alignment.gapSizeAt(position);
      case "MATE_CHR":
        return alignment.mate;
      case "MQ":
        return alignment.mq === void 0 ? Number.MAX_VALUE : -alignment.mq;
      case "ALIGNED_READ_LENGTH":
        return -alignment.lengthOnRef;
      default:
        return Number.MAX_VALUE;
    }
    function calculateBaseScore(alignment2, alignmentContainer2, genomicLocation) {
      let reference;
      const idx = Math.floor(genomicLocation) - alignmentContainer2.start;
      if (idx < alignmentContainer2.sequence.length) {
        reference = alignmentContainer2.sequence.charAt(idx);
      }
      if (!reference) {
        return 0;
      }
      const base = alignment2.readBaseAt(genomicLocation);
      const quality = alignment2.readBaseQualityAt(genomicLocation);
      const coverageMap = alignmentContainer2.coverageMap;
      const coverageMapIndex = Math.floor(genomicLocation - coverageMap.bpStart);
      const coverage = coverageMap.coverage[coverageMapIndex];
      let baseScore = 0;
      if (alignment2.insertions) {
        for (let ins of alignment2.insertions) {
          if (ins.start === genomicLocation) {
            baseScore = -coverage.ins;
          }
        }
      }
      if (!base) {
        const delCount = coverage.del;
        if (delCount > 0) {
          baseScore -= delCount;
        } else if (baseScore === 0) {
          baseScore = 1;
        }
      } else {
        reference = reference.toUpperCase();
        if ("N" === base && baseScore === 0) {
          baseScore = 2;
        } else if ((reference === base || "=" === base) && baseScore === 0) {
          baseScore = 4 - quality / 1e3;
        } else if ("X" === base || reference !== base) {
          const count = coverage["pos" + base] + coverage["neg" + base];
          baseScore -= count + quality / 1e3;
        }
      }
      return baseScore;
    }
  }
}
const alignmentSpace = 2;
function canBePaired(alignment) {
  return alignment.isPaired() && alignment.mate && alignment.isMateMapped() && alignment.chr === alignment.mate.chr && (alignment.isFirstOfPair() || alignment.isSecondOfPair()) && !(alignment.isSecondary() || alignment.isSupplementary());
}
function pairAlignments(rows) {
  const pairCache = {};
  const result = [];
  for (let row of rows) {
    for (let alignment of row.alignments) {
      if (canBePaired(alignment)) {
        let pairedAlignment = pairCache[alignment.readName];
        if (pairedAlignment) {
          pairedAlignment.setSecondAlignment(alignment);
          pairCache[alignment.readName] = void 0;
        } else {
          pairedAlignment = new PairedAlignment(alignment);
          pairCache[alignment.readName] = pairedAlignment;
          result.push(pairedAlignment);
        }
      } else {
        result.push(alignment);
      }
    }
  }
  return result;
}
function unpairAlignments(rows) {
  const result = [];
  for (let row of rows) {
    for (let alignment of row.alignments) {
      if (alignment instanceof PairedAlignment) {
        if (alignment.firstAlignment) result.push(alignment.firstAlignment);
        if (alignment.secondAlignment) result.push(alignment.secondAlignment);
      } else {
        result.push(alignment);
      }
    }
  }
  return result;
}
function packAlignmentRows(alignments, start, end, showSoftClips) {
  if (!alignments) {
    return void 0;
  } else if (alignments.length === 0) {
    return [];
  } else {
    alignments.sort(function(a, b) {
      return showSoftClips ? a.scStart - b.scStart : a.start - b.start;
    });
    const packedAlignmentRows = [];
    let alignmentRow;
    let nextStart = 0;
    let nextIDX = 0;
    const allocated = /* @__PURE__ */ new Set();
    const startNewRow = () => {
      alignmentRow = new BamAlignmentRow();
      packedAlignmentRows.push(alignmentRow);
      nextStart = 0;
      nextIDX = 0;
      allocated.clear();
    };
    startNewRow();
    while (alignments.length > 0) {
      if (nextIDX >= 0 && nextIDX < alignments.length) {
        const alignment = alignments[nextIDX];
        allocated.add(alignment);
        alignmentRow.alignments.push(alignment);
        nextStart = showSoftClips ? alignment.scStart + alignment.scLengthOnRef + alignmentSpace : alignment.start + alignment.lengthOnRef + alignmentSpace;
        nextIDX = binarySearch$1(alignments, (a) => (showSoftClips ? a.scStart : a.start) > nextStart, nextIDX);
      } else {
        alignments = alignments.filter((a) => !allocated.has(a));
        startNewRow();
      }
    }
    return packedAlignmentRows;
  }
}
function binarySearch$1(array, pred, min) {
  let lo = min - 1, hi = array.length;
  while (1 + lo < hi) {
    const mi = lo + (hi - lo >> 1);
    if (pred(array[mi])) {
      hi = mi;
    } else {
      lo = mi;
    }
  }
  return hi;
}
class AlignmentContainer {
  //            this.config.samplingWindowSize, this.config.samplingDepth,
  //             this.config.pairsSupported, this.config.alleleFreqThreshold)
  constructor(chr, start, end, { samplingWindowSize, samplingDepth, pairsSupported, alleleFreqThreshold }) {
    this.chr = chr;
    this.start = Math.floor(start);
    this.end = Math.ceil(end);
    this.length = end - start;
    this.alleleFreqThreshold = alleleFreqThreshold === void 0 ? 0.2 : alleleFreqThreshold;
    this.coverageMap = new CoverageMap(chr, start, end, this.alleleFreqThreshold);
    this.alignments = [];
    this.downsampledIntervals = [];
    this.samplingWindowSize = samplingWindowSize === void 0 ? 100 : samplingWindowSize;
    this.samplingDepth = samplingDepth === void 0 ? 1e3 : samplingDepth;
    this.pairsSupported = pairsSupported === void 0 ? true : pairsSupported;
    this.paired = false;
    this.pairsCache = {};
    this.downsampledReads = /* @__PURE__ */ new Set();
    this.currentBucket = new DownsampleBucket(this.start, this.start + this.samplingWindowSize, this);
    this.filter = function filter(alignment) {
      return alignment.isMapped() && !alignment.isFailsVendorQualityCheck();
    };
  }
  push(alignment) {
    if (this.filter(alignment) === false) return;
    this.coverageMap.incCounts(alignment);
    if (this.pairsSupported && this.downsampledReads.has(alignment.readName)) {
      return;
    }
    if (alignment.start >= this.currentBucket.end) {
      this.finishBucket();
      this.currentBucket = new DownsampleBucket(alignment.start, alignment.start + this.samplingWindowSize, this);
    }
    this.currentBucket.addAlignment(alignment);
  }
  forEach(callback) {
    this.alignments.forEach(callback);
  }
  finish() {
    if (this.currentBucket !== void 0) {
      this.finishBucket();
    }
    this.alignments.sort(function(a, b) {
      return a.start - b.start;
    });
    this.pairsCache = void 0;
    this.downsampledReads = void 0;
  }
  contains(chr, start, end) {
    return this.chr === chr && this.start <= start && this.end >= end;
  }
  hasDownsampledIntervals() {
    return this.downsampledIntervals && this.downsampledIntervals.length > 0;
  }
  finishBucket() {
    this.alignments = this.alignments.concat(this.currentBucket.alignments);
    if (this.currentBucket.downsampledCount > 0) {
      this.downsampledIntervals.push(new DownsampledInterval(
        this.currentBucket.start,
        this.currentBucket.end,
        this.currentBucket.downsampledCount
      ));
    }
    this.paired = this.paired || this.currentBucket.paired;
  }
  setViewAsPairs(bool) {
    let alignments;
    if (bool) {
      alignments = pairAlignments(this.packedAlignmentRows);
    } else {
      alignments = unpairAlignments(this.packedAlignmentRows);
    }
    this.packedAlignmentRows = packAlignmentRows(alignments, this.start, this.end);
  }
  setShowSoftClips(bool) {
    const alignments = this.allAlignments();
    this.packedAlignmentRows = packAlignmentRows(alignments, this.start, this.end, bool);
  }
  repack(bpPerPixel, showSoftClips) {
    const alignments = this.allAlignments();
    this.packedAlignmentRows = packAlignmentRows(alignments, this.start, this.end, showSoftClips);
  }
  allAlignments() {
    const alignments = [];
    for (let row of this.packedAlignmentRows) {
      for (let alignment of row.alignments) {
        alignments.push(alignment);
      }
    }
    return alignments;
  }
  getMax(start, end) {
    return this.coverageMap.getMax(start, end);
  }
  sortRows(options2) {
    const newRows = [];
    const undefinedRow = [];
    for (let row of this.packedAlignmentRows) {
      const alignment = row.findAlignment(options2.position);
      if (void 0 !== alignment) {
        newRows.push(row);
      } else {
        undefinedRow.push(row);
      }
    }
    newRows.sort((rowA, rowB) => {
      const direction = options2.direction;
      const rowAValue = rowA.getSortValue(options2, this);
      const rowBValue = rowB.getSortValue(options2, this);
      if (rowBValue === void 0 && rowBValue !== void 0) return 1;
      else if (rowAValue !== void 0 && rowBValue === void 0) return -1;
      const i = rowAValue > rowBValue ? 1 : rowAValue < rowBValue ? -1 : 0;
      return true === direction ? i : -i;
    });
    for (let row of undefinedRow) {
      newRows.push(row);
    }
    this.packedAlignmentRows = newRows;
  }
}
class DownsampleBucket {
  constructor(start, end, alignmentContainer) {
    this.start = start;
    this.end = end;
    this.alignments = [];
    this.downsampledCount = 0;
    this.samplingDepth = alignmentContainer.samplingDepth;
    this.pairsSupported = alignmentContainer.pairsSupported;
    this.downsampledReads = alignmentContainer.downsampledReads;
    this.pairsCache = alignmentContainer.pairsCache;
  }
  addAlignment(alignment) {
    var idx, replacedAlignment, pairedAlignment;
    if (this.pairsSupported && canBePaired(alignment)) {
      pairedAlignment = this.pairsCache[alignment.readName];
      if (pairedAlignment) {
        pairedAlignment.setSecondAlignment(alignment);
        this.pairsCache[alignment.readName] = void 0;
        return;
      }
    }
    if (this.alignments.length < this.samplingDepth) {
      if (this.pairsSupported && canBePaired(alignment)) {
        pairedAlignment = new PairedAlignment(alignment);
        this.paired = true;
        this.pairsCache[alignment.readName] = pairedAlignment;
        this.alignments.push(pairedAlignment);
      } else {
        this.alignments.push(alignment);
      }
    } else {
      idx = Math.floor(Math.random() * (this.samplingDepth + this.downsampledCount - 1));
      if (idx < this.samplingDepth) {
        replacedAlignment = this.alignments[idx];
        if (this.pairsSupported && canBePaired(alignment)) {
          if (this.pairsCache[replacedAlignment.readName] !== void 0) {
            this.pairsCache[replacedAlignment.readName] = void 0;
          }
          pairedAlignment = new PairedAlignment(alignment);
          this.paired = true;
          this.pairsCache[alignment.readName] = pairedAlignment;
          this.alignments[idx] = pairedAlignment;
        } else {
          this.alignments[idx] = alignment;
        }
        this.downsampledReads.add(replacedAlignment.readName);
      } else {
        this.downsampledReads.add(alignment.readName);
      }
      this.downsampledCount++;
    }
  }
}
class CoverageMap {
  constructor(chr, start, end, alleleFreqThreshold) {
    this.chr = chr;
    this.bpStart = start;
    this.length = end - start;
    this.coverage = new Array(this.length);
    this.maximum = 0;
    this.threshold = alleleFreqThreshold;
    this.qualityWeight = true;
  }
  /**
   * Return the maximum coverage value between start and end.  This is used for autoscaling.
   * @param start
   * @param end
   */
  getMax(start, end) {
    let max = 0;
    const len2 = this.coverage.length;
    for (let i = 0; i < len2; i++) {
      const pos = this.bpStart + i;
      if (pos > end) break;
      const cov = this.coverage[i];
      if (pos >= start && cov) {
        max = Math.max(max, cov.total);
      }
    }
    return max;
  }
  incCounts(alignment) {
    var self2 = this;
    if (alignment.blocks === void 0) {
      incBlockCount(alignment);
    } else {
      alignment.blocks.forEach(function(block) {
        incBlockCount(block);
      });
    }
    if (alignment.gaps) {
      for (let del of alignment.gaps) {
        if (del.type === "D") {
          const offset2 = del.start - self2.bpStart;
          for (let i = offset2; i < offset2 + del.len; i++) {
            if (i < 0) continue;
            if (!this.coverage[i]) {
              this.coverage[i] = new Coverage(self2.threshold);
            }
            this.coverage[i].del++;
          }
        }
      }
    }
    if (alignment.insertions) {
      for (let del of alignment.insertions) {
        const i = del.start - this.bpStart;
        if (i < 0) continue;
        if (!this.coverage[i]) {
          this.coverage[i] = new Coverage(self2.threshold);
        }
        this.coverage[i].ins++;
      }
    }
    function incBlockCount(block) {
      if ("S" === block.type) return;
      const seq = alignment.seq;
      const qual = alignment.qual;
      const seqOffset = block.seqOffset;
      for (let i = block.start - self2.bpStart, j = 0; j < block.len; i++, j++) {
        if (!self2.coverage[i]) {
          self2.coverage[i] = new Coverage(self2.threshold);
        }
        const base = seq == void 0 ? "N" : seq.charAt(seqOffset + j);
        const key = alignment.strand ? "pos" + base : "neg" + base;
        const q = qual && seqOffset + j < qual.length ? qual[seqOffset + j] : 30;
        self2.coverage[i][key] += 1;
        self2.coverage[i]["qual" + base] += q;
        self2.coverage[i].total += 1;
        self2.coverage[i].qual += q;
        self2.maximum = Math.max(self2.coverage[i].total, self2.maximum);
      }
    }
  }
}
class Coverage {
  constructor(alleleThreshold) {
    this.qualityWeight = true;
    this.posA = 0;
    this.negA = 0;
    this.posT = 0;
    this.negT = 0;
    this.posC = 0;
    this.negC = 0;
    this.posG = 0;
    this.negG = 0;
    this.posN = 0;
    this.negN = 0;
    this.pos = 0;
    this.neg = 0;
    this.qualA = 0;
    this.qualT = 0;
    this.qualC = 0;
    this.qualG = 0;
    this.qualN = 0;
    this.qual = 0;
    this.total = 0;
    this.del = 0;
    this.ins = 0;
    this.threshold = alleleThreshold;
  }
  hoverText() {
    const pos = this.posA + this.posT + this.posC + this.posG + this.posN;
    const neg = this.negA + this.negT + this.negC + this.negG + this.negN;
    return `${this.total} (${pos}+, ${neg}-)`;
  }
  isMismatch(refBase) {
    const threshold = this.threshold * (this.qualityWeight && this.qual ? this.qual : this.total);
    let mismatchQualitySum = 0;
    for (let base of ["A", "T", "C", "G"]) {
      if (base !== refBase) {
        mismatchQualitySum += this.qualityWeight && this.qual ? this["qual" + base] : this["pos" + base] + this["neg" + base];
      }
    }
    return mismatchQualitySum >= threshold;
  }
}
class DownsampledInterval {
  constructor(start, end, counts) {
    this.start = start;
    this.end = end;
    this.counts = counts;
  }
  popupData(genomicLocation) {
    return [
      { name: "start", value: this.start + 1 },
      { name: "end", value: this.end },
      { name: "# downsampled:", value: this.counts }
    ];
  }
}
class SupplementaryAlignment {
  constructor(rec) {
    const tokens = rec.split(",");
    this.chr = tokens[0];
    this.start = parseInt(tokens[1]);
    this.strand = tokens[2].charAt(0);
    this.mapQ = parseInt(tokens[4]);
    this.numMismatches = parseInt(tokens[5]);
    this.lenOnRef = BamUtils.computeLengthOnReference(tokens[3]);
  }
  printString() {
    return this.chr + ":" + numberFormatter$1(this.start) + "-" + numberFormatter$1(this.start + this.lenOnRef) + " (" + this.strand + ") = " + numberFormatter$1(this.lenOnRef) + "bp @MAPQ: " + this.mapQ + " NM: " + this.numMismatches;
  }
}
function createSupplementaryAlignments(str) {
  const tokens = str.split(";");
  return tokens.filter((t) => t.length > 0).map((str2) => new SupplementaryAlignment(str2));
}
const READ_PAIRED_FLAG = 1;
const PROPER_PAIR_FLAG = 2;
const READ_UNMAPPED_FLAG = 4;
const MATE_UNMAPPED_FLAG = 8;
const READ_STRAND_FLAG$2 = 16;
const MATE_STRAND_FLAG$2 = 32;
const FIRST_OF_PAIR_FLAG = 64;
const SECOND_OF_PAIR_FLAG = 128;
const SECONDARY_ALIGNMNET_FLAG = 256;
const READ_FAILS_VENDOR_QUALITY_CHECK_FLAG = 512;
const DUPLICATE_READ_FLAG = 1024;
const SUPPLEMENTARY_ALIGNMENT_FLAG = 2048;
const ELEMENT_SIZE = {
  c: 1,
  C: 1,
  s: 2,
  S: 2,
  i: 4,
  I: 4,
  f: 4
};
const MAX_CIGAR = 50;
class BamAlignment {
  constructor() {
    this.hidden = false;
  }
  isMapped() {
    return (this.flags & READ_UNMAPPED_FLAG) === 0;
  }
  isPaired() {
    return (this.flags & READ_PAIRED_FLAG) !== 0;
  }
  isProperPair() {
    return (this.flags & PROPER_PAIR_FLAG) !== 0;
  }
  isFirstOfPair() {
    return (this.flags & FIRST_OF_PAIR_FLAG) !== 0;
  }
  isSecondOfPair() {
    return (this.flags & SECOND_OF_PAIR_FLAG) !== 0;
  }
  isSecondary() {
    return (this.flags & SECONDARY_ALIGNMNET_FLAG) !== 0;
  }
  isSupplementary() {
    return (this.flags & SUPPLEMENTARY_ALIGNMENT_FLAG) !== 0;
  }
  isFailsVendorQualityCheck() {
    return (this.flags & READ_FAILS_VENDOR_QUALITY_CHECK_FLAG) !== 0;
  }
  isDuplicate() {
    return (this.flags & DUPLICATE_READ_FLAG) !== 0;
  }
  isMateMapped() {
    return (this.flags & MATE_UNMAPPED_FLAG) === 0;
  }
  isNegativeStrand() {
    return (this.flags & READ_STRAND_FLAG$2) !== 0;
  }
  isMateNegativeStrand() {
    return (this.flags & MATE_STRAND_FLAG$2) !== 0;
  }
  hasTag(tag) {
    const tmpTags = this.tagDict || decodeTags(this.tagBA);
    return tmpTags.hasOwnProperty(tag);
  }
  tags() {
    if (!this.tagDict) {
      if (this.tagBA) {
        this.tagDict = decodeTags(this.tagBA);
        this.tagBA = void 0;
      } else {
        this.tagDict = {};
      }
    }
    return this.tagDict;
  }
  /**
   * Does alignment (or alignment extended by soft clips) contain the genomic location?
   *
   * @param genomicLocation
   * @param showSoftClips
   * @returns {boolean|boolean}
   */
  containsLocation(genomicLocation, showSoftClips) {
    const s = showSoftClips ? this.scStart : this.start;
    const l = showSoftClips ? this.scLengthOnRef : this.lengthOnRef;
    return genomicLocation >= s && genomicLocation <= s + l;
  }
  popupData(genomicLocation) {
    const nameValues = [];
    genomicLocation = Math.floor(genomicLocation);
    if (this.insertions) {
      const seq = this.seq;
      for (let insertion of this.insertions) {
        var ins_start = insertion.start;
        if (genomicLocation === ins_start || genomicLocation === ins_start - 1) {
          nameValues.push({ name: "Insertion", value: seq.substr(insertion.seqOffset, insertion.len) });
          nameValues.push({ name: "Location", value: ins_start });
          return nameValues;
        }
      }
    }
    nameValues.push({ name: "Read Name", value: this.readName });
    nameValues.push("<hr/>");
    nameValues.push({ name: "Alignment Start", value: numberFormatter$1(1 + this.start), borderTop: true });
    nameValues.push({ name: "Read Strand", value: true === this.strand ? "(+)" : "(-)", borderTop: true });
    let cigar = this.cigar;
    if (cigar && cigar.length > MAX_CIGAR) {
      const half = MAX_CIGAR / 2;
      cigar = `${cigar.substring(0, half - 2)} ... ${cigar.substring(cigar.length - half + 2)}`;
    }
    nameValues.push({ name: "Cigar", value: cigar });
    nameValues.push({ name: "Mapping Quality", value: this.mq });
    nameValues.push({ name: "Secondary", value: yesNo(this.isSecondary()) });
    nameValues.push({ name: "Supplementary", value: yesNo(this.isSupplementary()) });
    nameValues.push({ name: "Duplicate", value: yesNo(this.isDuplicate()) });
    nameValues.push({ name: "Failed QC", value: yesNo(this.isFailsVendorQualityCheck()) });
    if (this.isPaired()) {
      nameValues.push("<hr/>");
      nameValues.push({ name: "First in Pair", value: !this.isSecondOfPair(), borderTop: true });
      nameValues.push({ name: "Mate is Mapped", value: yesNo(this.isMateMapped()) });
      if (this.pairOrientation) {
        nameValues.push({ name: "Pair Orientation", value: this.pairOrientation });
      }
      if (this.isMateMapped()) {
        nameValues.push({ name: "Mate Chromosome", value: this.mate.chr });
        nameValues.push({ name: "Mate Start", value: this.mate.position + 1 });
        nameValues.push({ name: "Mate Strand", value: true === this.mate.strand ? "(+)" : "(-)" });
        nameValues.push({ name: "Insert Size", value: this.fragmentLength });
      }
    }
    const tagDict = this.tags();
    if (tagDict.hasOwnProperty("SA")) {
      nameValues.push("<hr/>");
      nameValues.push({ name: "Supplementary Alignments", value: "" });
      const sa = createSupplementaryAlignments(tagDict["SA"]);
      if (sa) {
        nameValues.push("<ul>");
        for (let s of sa) {
          nameValues.push(`<li>${s.printString()}</li>`);
        }
        nameValues.push("</ul>");
      }
    }
    const hiddenTags = /* @__PURE__ */ new Set(["SA", "MD"]);
    nameValues.push("<hr/>");
    for (let key in tagDict) {
      if (!hiddenTags.has(key)) {
        nameValues.push({ name: key, value: tagDict[key] });
      }
    }
    nameValues.push({ name: "Hidden Tags", value: "SA, MD" });
    nameValues.push("<hr/>");
    nameValues.push({ name: "Genomic Location: ", value: numberFormatter$1(1 + genomicLocation) });
    nameValues.push({ name: "Read Base:", value: this.readBaseAt(genomicLocation) });
    nameValues.push({ name: "Base Quality:", value: this.readBaseQualityAt(genomicLocation) });
    return nameValues;
    function yesNo(bool) {
      return bool ? "Yes" : "No";
    }
  }
  readBaseAt(genomicLocation) {
    const block = blockAtGenomicLocation(this.blocks, genomicLocation);
    if (block) {
      if ("*" === this.seq) {
        return "*";
      } else {
        const idx = block.seqIndexAt(genomicLocation);
        return this.seq[idx];
      }
    } else {
      return void 0;
    }
  }
  readBaseQualityAt(genomicLocation) {
    const block = blockAtGenomicLocation(this.blocks, genomicLocation);
    if (block) {
      if ("*" === this.qual) {
        return 30;
      } else {
        const idx = block.seqIndexAt(genomicLocation);
        if (idx >= 0 && this.qual && idx < this.qual.length) {
          return this.qual[idx];
        } else {
          return 30;
        }
      }
    } else {
      return void 0;
    }
  }
  gapSizeAt(genomicLocation) {
    if (this.gaps) {
      for (let gap of this.gaps) {
        if (genomicLocation >= gap.start && genomicLocation < gap.start + gap.len) {
          return gap.len;
        }
      }
    }
    return 0;
  }
  /**
   * Return soft clipped blocks, if they exist, keyed by alignment end (left or right)
   */
  softClippedBlocks() {
    let left;
    let right;
    let interiorSeen;
    for (let b of this.blocks) {
      if ("S" === b.type) {
        if (interiorSeen) {
          right = b;
        } else {
          left = b;
        }
      } else if ("H" !== b.type) {
        interiorSeen = true;
      }
    }
    return { left, right };
  }
}
function blockAtGenomicLocation(blocks, genomicLocation) {
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (genomicLocation >= block.start && genomicLocation < block.start + block.len) {
      return block;
    }
  }
  return void 0;
}
function decodeTags(ba) {
  let p = 0;
  const len2 = ba.length;
  const tags = {};
  while (p < len2) {
    const tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);
    p += 2;
    const type = String.fromCharCode(ba[p++]);
    let value;
    if (type === "A") {
      value = String.fromCharCode(ba[p]);
      p++;
    } else if (type === "i" || type === "I") {
      value = readInt$1(ba, p);
      p += 4;
    } else if (type === "c") {
      value = readInt8(ba, p);
      p++;
    } else if (type === "C") {
      value = readUInt8(ba, p);
      p++;
    } else if (type === "s" || type === "S") {
      value = readShort(ba, p);
      p += 2;
    } else if (type === "f") {
      value = readFloat(ba, p);
      p += 4;
    } else if (type === "Z") {
      value = "";
      for (; ; ) {
        var cc = ba[p++];
        if (cc === 0) {
          break;
        } else {
          value += String.fromCharCode(cc);
        }
      }
    } else if (type === "B") {
      const elementType = String.fromCharCode(ba[p++]);
      let elementSize = ELEMENT_SIZE[elementType];
      if (elementSize === void 0) {
        tags[tag] = `Error: unknown element type '${elementType}'`;
        break;
      }
      const numElements = readInt$1(ba, p);
      p += 4 + numElements * elementSize;
      value = "[not shown]";
    } else {
      value = "Error unknown type: " + type;
      tags[tag] = value;
      break;
    }
    tags[tag] = value;
  }
  return tags;
}
function readInt$1(ba, offset2) {
  return ba[offset2 + 3] << 24 | ba[offset2 + 2] << 16 | ba[offset2 + 1] << 8 | ba[offset2];
}
function readShort(ba, offset2) {
  return ba[offset2 + 1] << 8 | ba[offset2];
}
function readFloat(ba, offset2) {
  const dataView = new DataView(ba.buffer);
  return dataView.getFloat32(offset2);
}
function readInt8(ba, offset2) {
  const dataView = new DataView(ba.buffer);
  return dataView.getInt8(offset2);
}
function readUInt8(ba, offset2) {
  const dataView = new DataView(ba.buffer);
  return dataView.getUint8(offset2);
}
class AlignmentBlock {
  constructor(b) {
    if (b) {
      Object.assign(this, b);
    }
  }
  seqIndexAt(genomicLocation) {
    return Math.floor(genomicLocation) - this.start + this.seqOffset;
  }
}
class BamFilter {
  constructor(options2) {
    if (!options2) options2 = {};
    this.vendorFailed = options2.vendorFailed === void 0 ? true : options2.vendorFailed;
    this.duplicates = options2.duplicates === void 0 ? true : options2.duplicates;
    this.secondary = options2.secondary || false;
    this.supplementary = options2.supplementary || false;
    this.mqThreshold = options2.mqThreshold === void 0 ? 0 : options2.mqThreshold;
    if (options2.readgroups) {
      this.readgroups = new Set(options2.readgroups);
    }
  }
  pass(alignment) {
    if (this.vendorFailed && alignment.isFailsVendorQualityCheck()) return false;
    if (this.duplicates && alignment.isDuplicate()) return false;
    if (this.secondary && alignment.isSecondary()) return false;
    if (this.supplementary && alignment.isSupplementary()) return false;
    if (alignment.mq < this.mqThreshold) return false;
    if (this.readgroups) {
      var rg = alignment.tags()["RG"];
      return this.readgroups.has(rg);
    }
    return true;
  }
}
const SEQ_DECODER = ["=", "A", "C", "x", "G", "x", "x", "x", "T", "x", "x", "x", "x", "x", "x", "N"];
const CIGAR_DECODER = ["M", "I", "D", "N", "S", "H", "P", "=", "X", "?", "?", "?", "?", "?", "?", "?"];
const READ_STRAND_FLAG$1 = 16;
const MATE_STRAND_FLAG$1 = 32;
const BAM1_MAGIC_BYTES = new Uint8Array([66, 65, 77, 1]);
const BAM1_MAGIC_NUMBER = readInt(BAM1_MAGIC_BYTES, 0);
const DEFAULT_ALLELE_FREQ_THRESHOLD = 0.2;
const DEFAULT_SAMPLING_WINDOW_SIZE = 100;
const DEFAULT_SAMPLING_DEPTH = 500;
const MAXIMUM_SAMPLING_DEPTH = 1e4;
const BamUtils = {
  readHeader: function(url, options2, genome) {
    return igvxhr.loadArrayBuffer(url, options2).then(function(compressedBuffer) {
      var header, unc, uncba;
      unc = unbgzf(compressedBuffer);
      uncba = unc;
      header = BamUtils.decodeBamHeader(uncba, genome);
      return header;
    });
  },
  /**
   *
   * @param ba  bytes to decode as a UInt8Array
   * @param genome  optional igv genome object
   * @returns {{ magicNumer: number, size: number, chrNames: Array, chrToIndex: ({}|*), chrAliasTable: ({}|*) }}
   */
  decodeBamHeader: function(ba, genome) {
    var magic, samHeaderLen, samHeader, chrToIndex, chrNames, chrAliasTable, alias;
    magic = readInt(ba, 0);
    if (magic !== BAM1_MAGIC_NUMBER) {
      throw new Error("BAM header errror: bad magic number.  This could be caused by either a corrupt or missing file.");
    }
    samHeaderLen = readInt(ba, 4);
    samHeader = "";
    for (var i = 0; i < samHeaderLen; ++i) {
      samHeader += String.fromCharCode(ba[i + 8]);
    }
    var nRef = readInt(ba, samHeaderLen + 8);
    var p = samHeaderLen + 12;
    chrToIndex = {};
    chrNames = [];
    chrAliasTable = {};
    for (i = 0; i < nRef; ++i) {
      var lName = readInt(ba, p);
      var name2 = "";
      for (var j = 0; j < lName - 1; ++j) {
        name2 += String.fromCharCode(ba[p + 4 + j]);
      }
      readInt(ba, p + lName + 4);
      chrToIndex[name2] = i;
      chrNames[i] = name2;
      if (genome) {
        alias = genome.getChromosomeName(name2);
        chrAliasTable[alias] = name2;
      }
      p = p + 8 + lName;
    }
    return {
      magicNumber: magic,
      size: p,
      chrNames,
      chrToIndex,
      chrAliasTable
    };
  },
  bam_tag2cigar: function(ba, block_end, seq_offset, lseq, al, cigarArray) {
    function type2size(x) {
      if (x === "C" || x === "c" || x === "A") return 1;
      else if (x === "S" || x === "s") return 2;
      else if (x === "I" || x === "i" || x === "f") return 4;
      else return 0;
    }
    if (cigarArray.length !== 1 || al.start < 0) return false;
    var p = seq_offset + (lseq + 1 >> 1) + lseq;
    while (p + 4 < block_end) {
      var tag = String.fromCharCode(ba[p]) + String.fromCharCode(ba[p + 1]);
      if (tag === "CG") break;
      var type = String.fromCharCode(ba[p + 2]);
      if (type === "B") {
        type = String.fromCharCode(ba[p + 3]);
        var size = type2size(type);
        var len2 = readInt(ba, p + 4);
        p += 8 + size * len2;
      } else if (type === "Z" || type === "H") {
        p += 3;
        while (ba[p++] !== 0) {
        }
      } else {
        p += 3 + type2size(type);
      }
    }
    if (p >= block_end) return false;
    if (String.fromCharCode(ba[p + 2]) !== "B" || String.fromCharCode(ba[p + 3]) !== "I") return false;
    var cigar_len = readInt(ba, p + 4);
    var cigar_offset = p + 8;
    if (cigar_offset + cigar_len * 4 > block_end) return false;
    var cigar = "";
    var lengthOnRef = 0;
    cigarArray.length = 0;
    p = cigar_offset;
    for (var k = 0; k < cigar_len; ++k, p += 4) {
      var cigop = readInt(ba, p);
      var opLen = cigop >> 4;
      var opLtr = CIGAR_DECODER[cigop & 15];
      if (opLtr === "M" || opLtr === "EQ" || opLtr === "X" || opLtr === "D" || opLtr === "N" || opLtr === "=")
        lengthOnRef += opLen;
      cigar = cigar + opLen + opLtr;
      cigarArray.push({ len: opLen, ltr: opLtr });
    }
    al.cigar = cigar;
    al.lengthOnRef = lengthOnRef;
    return true;
  },
  /**
   *
   * @param ba                 bytes to decode as an UInt8Array
   * @param offset             offset position of ba array to start decoding
   * @param alignmentContainer container to receive the decoded alignments
   * @param min                minimum genomic position
   * @param max                maximum genomic position
   * @param chrIdx             chromosome index
   * @param chrNames            array of chromosome names
   * @param filter             a BamFilter object
   *
   * @return true if we have moved beyond the right end of the genomic range.
   */
  decodeBamRecords: function(ba, offset2, alignmentContainer, chrNames, chrIdx, min, max, filter) {
    while (offset2 < ba.length) {
      const blockSize = readInt(ba, offset2);
      const blockEnd = offset2 + blockSize + 4;
      const alignment = new BamAlignment();
      const refID = readInt(ba, offset2 + 4);
      const pos = readInt(ba, offset2 + 8);
      if (blockEnd > ba.length) {
        return;
      }
      if (refID < 0) {
        offset2 = blockEnd;
        continue;
      } else if (chrIdx !== void 0 && (refID > chrIdx || pos > max)) {
        return true;
      } else if (chrIdx !== void 0 && refID < chrIdx) {
        offset2 = blockEnd;
        continue;
      }
      const bin_mq_nl = readInt(ba, offset2 + 12);
      const mq = (bin_mq_nl & 65280) >> 8;
      const nl = bin_mq_nl & 255;
      const flag_nc = readInt(ba, offset2 + 16);
      const flag = (flag_nc & 4294901760) >> 16;
      const nc = flag_nc & 65535;
      const lseq = readInt(ba, offset2 + 20);
      const mateChrIdx = readInt(ba, offset2 + 24);
      const matePos = readInt(ba, offset2 + 28);
      const fragmentLength = readInt(ba, offset2 + 32);
      let readName = [];
      for (let j = 0; j < nl - 1; ++j) {
        readName.push(String.fromCharCode(ba[offset2 + 36 + j]));
      }
      readName = readName.join("");
      let lengthOnRef = 0;
      let cigar = "";
      let p = offset2 + 36 + nl;
      const cigarArray = [];
      let lastCigRecord;
      for (let c = 0; c < nc; ++c) {
        var cigop = readInt(ba, p);
        var opLen = cigop >> 4;
        var opLtr = CIGAR_DECODER[cigop & 15];
        if (opLtr === "M" || opLtr === "EQ" || opLtr === "X" || opLtr === "D" || opLtr === "N" || opLtr === "=")
          lengthOnRef += opLen;
        cigar = cigar + opLen + opLtr;
        p += 4;
        lastCigRecord = { len: opLen, ltr: opLtr };
        cigarArray.push(lastCigRecord);
      }
      alignment.chr = chrNames[refID];
      alignment.start = pos;
      alignment.flags = flag;
      alignment.strand = !(flag & READ_STRAND_FLAG$1);
      alignment.readName = readName;
      alignment.cigar = cigar;
      alignment.lengthOnRef = lengthOnRef;
      alignment.fragmentLength = fragmentLength;
      alignment.mq = mq;
      BamUtils.bam_tag2cigar(ba, blockEnd, p, lseq, alignment, cigarArray);
      alignment.end = alignment.start + alignment.lengthOnRef;
      if (alignment.end < min) {
        offset2 = blockEnd;
        continue;
      }
      let seq = [];
      const seqBytes = lseq + 1 >> 1;
      for (let j = 0; j < seqBytes; ++j) {
        var sb = ba[p + j];
        seq.push(SEQ_DECODER[(sb & 240) >> 4]);
        seq.push(SEQ_DECODER[sb & 15]);
      }
      seq = seq.slice(0, lseq).join("");
      p += seqBytes;
      const qualArray = [];
      for (let j = 0; j < lseq; ++j) {
        qualArray.push(ba[p + j]);
      }
      p += lseq;
      if (mateChrIdx >= 0) {
        alignment.mate = {
          chr: chrNames[mateChrIdx],
          position: matePos,
          strand: !(flag & MATE_STRAND_FLAG$1)
        };
      }
      alignment.seq = seq;
      alignment.qual = qualArray;
      alignment.tagBA = new Uint8Array(ba.buffer.slice(p, blockEnd));
      this.setPairOrientation(alignment);
      if (void 0 === filter || filter.pass(alignment)) {
        makeBlocks(alignment, cigarArray);
        alignmentContainer.push(alignment);
      }
      offset2 = blockEnd;
    }
  },
  decodeSamRecords: function(sam, alignmentContainer, chr, min, max, filter) {
    var lines, i, j, len2, tokens, qualString, rnext, lengthOnRef, alignment, cigarArray, started;
    lines = splitLines$5(sam);
    len2 = lines.length;
    started = false;
    for (i = 0; i < len2; i++) {
      tokens = lines[i].split("	");
      alignment = new BamAlignment();
      alignment.chr = tokens[2];
      alignment.start = Number.parseInt(tokens[3]) - 1;
      alignment.flags = Number.parseInt(tokens[1]);
      alignment.readName = tokens[0];
      alignment.strand = !(alignment.flags & READ_STRAND_FLAG$1);
      alignment.mq = Number.parseInt(tokens[4]);
      alignment.cigar = tokens[5];
      alignment.fragmentLength = Number.parseInt(tokens[8]);
      alignment.seq = tokens[9];
      if (alignment.chr === "*" || !alignment.isMapped()) continue;
      if (alignment.chr !== chr) {
        if (started) break;
        else continue;
      } else if (alignment.start > max) {
        break;
      }
      lengthOnRef = 0;
      cigarArray = buildOperators(alignment.cigar);
      cigarArray.forEach(function(op) {
        var opLen = op.len;
        var opLtr = op.ltr;
        if (opLtr === "M" || opLtr === "EQ" || opLtr === "X" || opLtr === "D" || opLtr === "N" || opLtr === "=")
          lengthOnRef += opLen;
      });
      alignment.lengthOnRef = lengthOnRef;
      if (alignment.start + lengthOnRef < min) {
        continue;
      }
      qualString = tokens[10];
      alignment.qual = [];
      for (j = 0; j < qualString.length; j++) {
        alignment.qual[j] = qualString.charCodeAt(j) - 33;
      }
      alignment.tagDict = tokens.length < 11 ? {} : decodeSamTags(tokens.slice(11));
      if (alignment.isMateMapped()) {
        rnext = tokens[6];
        alignment.mate = {
          chr: rnext === "=" ? alignment.chr : rnext,
          position: Number.parseInt(tokens[7]),
          strand: !(alignment.flags & MATE_STRAND_FLAG$1)
        };
      }
      this.setPairOrientation(alignment);
      if (void 0 === filter || filter.pass(alignment)) {
        makeBlocks(alignment, cigarArray);
        alignmentContainer.push(alignment);
      }
    }
  },
  setReaderDefaults: function(reader, config) {
    reader.filter = new BamFilter(config.filter);
    if (config.readgroup) {
      reader.filter.readgroups = /* @__PURE__ */ new Set([config.readgroup]);
    }
    reader.alleleFreqThreshold = config.alleleFreqThreshold === void 0 ? DEFAULT_ALLELE_FREQ_THRESHOLD : config.alleleFreqThreshold;
    reader.samplingWindowSize = config.samplingWindowSize === void 0 ? DEFAULT_SAMPLING_WINDOW_SIZE : config.samplingWindowSize;
    reader.samplingDepth = config.samplingDepth === void 0 ? DEFAULT_SAMPLING_DEPTH : config.samplingDepth;
    if (reader.samplingDepth > MAXIMUM_SAMPLING_DEPTH) {
      console.log("Warning: attempt to set sampling depth > maximum value of " + MAXIMUM_SAMPLING_DEPTH);
      reader.samplingDepth = MAXIMUM_SAMPLING_DEPTH;
    }
    if (config.viewAsPairs) {
      reader.pairsSupported = true;
    } else {
      reader.pairsSupported = config.pairsSupported === void 0 ? true : config.pairsSupported;
    }
  },
  setPairOrientation: function(alignment) {
    if (alignment.isMapped() && alignment.mate && alignment.isMateMapped() && alignment.mate.chr === alignment.chr) {
      var s1 = alignment.strand ? "F" : "R";
      var mate = alignment.mate;
      var s2 = mate.strand ? "F" : "R";
      var o1 = " ";
      var o2 = " ";
      if (alignment.isFirstOfPair()) {
        o1 = "1";
        o2 = "2";
      } else if (alignment.isSecondOfPair()) {
        o1 = "2";
        o2 = "1";
      }
      var tmp = [];
      var isize = alignment.fragmentLength;
      var estReadLen = alignment.end - alignment.start;
      if (isize === 0) {
        var estMateEnd = alignment.start < mate.position ? mate.position + estReadLen : mate.position - estReadLen;
        isize = estMateEnd - alignment.start;
      }
      if (isize > 0) {
        tmp[0] = s1;
        tmp[1] = o1;
        tmp[2] = s2;
        tmp[3] = o2;
      } else {
        tmp[2] = s1;
        tmp[3] = o1;
        tmp[0] = s2;
        tmp[1] = o2;
      }
      alignment.pairOrientation = tmp.join("");
    }
  },
  computeLengthOnReference: function(cigarString) {
    let len2 = 0;
    let buf = "";
    for (let i = 0; i < cigarString.length; i++) {
      const c = cigarString.charCodeAt(i);
      if (c > 47 && c < 58) {
        buf += cigarString.charAt(i);
      } else {
        switch (c) {
          case 78:
          // N
          case 68:
          // D
          case 77:
          // M
          case 61:
          // =
          case 88:
            len2 += parseInt(buf.toString());
        }
        buf = "";
      }
    }
    return len2;
  }
};
function makeBlocks(alignment, cigarArray) {
  const blocks = [];
  let insertions;
  let gaps;
  let seqOffset = 0;
  let pos = alignment.start;
  alignment.scStart = alignment.start;
  alignment.scLengthOnRef = alignment.lengthOnRef;
  for (let c of cigarArray) {
    let scPos;
    switch (c.ltr) {
      case "H":
        break;
      // ignore hard clips
      case "P":
        break;
      // ignore pads
      case "S":
        scPos = pos;
        alignment.scLengthOnRef += c.len;
        if (blocks.length === 0) {
          alignment.scStart -= c.len;
          scPos -= c.len;
        }
        blocks.push(new AlignmentBlock({
          start: scPos,
          seqOffset,
          len: c.len,
          type: "S"
        }));
        seqOffset += c.len;
        break;
      // soft clip read bases
      case "N":
      case "D":
        if (gaps === void 0) {
          gaps = [];
        }
        gaps.push({
          start: pos,
          len: c.len,
          type: c.ltr
        });
        pos += c.len;
        break;
      case "I":
        if (insertions === void 0) {
          insertions = [];
        }
        insertions.push(new AlignmentBlock({
          start: pos,
          len: c.len,
          seqOffset,
          type: "I"
        }));
        seqOffset += c.len;
        break;
      case "M":
      case "EQ":
      case "=":
      case "X":
        blocks.push(new AlignmentBlock({
          start: pos,
          seqOffset,
          len: c.len,
          type: "M"
        }));
        seqOffset += c.len;
        pos += c.len;
        break;
      default:
        console.log("Error processing cigar element: " + c.len + c.ltr);
    }
  }
  alignment.blocks = blocks;
  alignment.insertions = insertions;
  alignment.gaps = gaps;
}
function readInt(ba, offset2) {
  return ba[offset2 + 3] << 24 | ba[offset2 + 2] << 16 | ba[offset2 + 1] << 8 | ba[offset2];
}
function buildOperators(cigarString) {
  var operators, buffer, i, len2, prevOp, next, op, nBases;
  operators = [];
  buffer = [];
  prevOp = null;
  len2 = cigarString.length;
  for (i = 0; i < len2; i++) {
    next = cigarString.charAt(i);
    if (isDigit(next)) {
      buffer.push(next);
    } else {
      op = next;
      nBases = Number.parseInt(buffer.join(""));
      buffer = [];
      if (prevOp !== null && prevOp.ltr === op) {
        prevOp.len += nBases;
      } else {
        prevOp = { len: nBases, ltr: op };
        operators.push(prevOp);
      }
    }
  }
  return operators;
}
function isDigit(a) {
  var charCode = a.charCodeAt(0);
  return charCode >= 48 && charCode <= 57;
}
function decodeSamTags(tags) {
  var tagDict = {};
  tags.forEach(function(tag) {
    var tokens = tag.split(":");
    tagDict[tokens[0]] = tokens[2];
  });
  return tagDict;
}
class BamReaderNonIndexed {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.bamPath = config.url;
    this.isDataUri = isDataURL(config.url);
    BamUtils.setReaderDefaults(this, config);
  }
  // Return an alignment container
  async readAlignments(chr, bpStart, bpEnd) {
    if (this.alignmentCache) {
      const header = this.header;
      const queryChr = header.chrAliasTable.hasOwnProperty(chr) ? header.chrAliasTable[chr] : chr;
      const qAlignments = this.alignmentCache.queryFeatures(queryChr, bpStart, bpEnd);
      const alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, this.config);
      for (let a of qAlignments) {
        alignmentContainer.push(a);
      }
      alignmentContainer.finish();
      return alignmentContainer;
    } else {
      if (this.isDataUri) {
        const data = decodeDataURI(this.bamPath);
        const unc = unbgzf(data.buffer);
        this.parseAlignments(unc);
        return this.fetchAlignments(chr, bpStart, bpEnd);
      } else {
        const arrayBuffer = await igvxhr.loadArrayBuffer(this.bamPath, buildOptions$1(this.config));
        const unc = unbgzf(arrayBuffer);
        this.parseAlignments(unc);
        return this.fetchAlignments(chr, bpStart, bpEnd);
      }
    }
  }
  parseAlignments(data) {
    const alignments = [];
    this.header = BamUtils.decodeBamHeader(data);
    BamUtils.decodeBamRecords(data, this.header.size, alignments, this.header.chrNames);
    this.alignmentCache = new FeatureCache$1(alignments, this.genome);
  }
  fetchAlignments(chr, bpStart, bpEnd) {
    const queryChr = this.header.chrAliasTable.hasOwnProperty(chr) ? this.header.chrAliasTable[chr] : chr;
    const features = this.alignmentCache.queryFeatures(queryChr, bpStart, bpEnd);
    const alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, this.config);
    for (let feature2 of features) {
      alignmentContainer.push(feature2);
    }
    alignmentContainer.finish();
    return alignmentContainer;
  }
}
function decodeDataURI(dataURI) {
  const split = dataURI.split(",");
  const info = split[0].split(":")[1];
  let dataString = split[1];
  if (info.indexOf("base64") >= 0) {
    dataString = atob(dataString);
  } else {
    dataString = decodeURI(dataString);
  }
  const bytes = new Uint8Array(dataString.length);
  for (var i = 0; i < dataString.length; i++) {
    bytes[i] = dataString.charCodeAt(i);
  }
  return bytes;
}
class BamReader {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    this.bamPath = config.url;
    this.baiPath = config.indexURL;
    BamUtils.setReaderDefaults(this, config);
    this._blockLoader = new BGZBlockLoader(config);
  }
  async readAlignments(chr, bpStart, bpEnd) {
    const chrToIndex = await this.getChrIndex();
    const queryChr = this.chrAliasTable.hasOwnProperty(chr) ? this.chrAliasTable[chr] : chr;
    const chrId = chrToIndex[queryChr];
    const alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, this.config);
    if (chrId === void 0) {
      return alignmentContainer;
    } else {
      const bamIndex = await this.getIndex();
      const chunks = bamIndex.chunksForRange(chrId, bpStart, bpEnd);
      if (!chunks || chunks.length === 0) {
        return alignmentContainer;
      }
      for (let c of chunks) {
        const ba = await this._blockLoader.getData(c.minv, c.maxv);
        const done = BamUtils.decodeBamRecords(ba, c.minv.offset, alignmentContainer, this.indexToChr, chrId, bpStart, bpEnd, this.filter);
        if (done) {
          break;
        }
      }
      alignmentContainer.finish();
      return alignmentContainer;
    }
  }
  async getHeader() {
    if (!this.header) {
      const genome = this.genome;
      const index2 = await this.getIndex();
      let len2;
      if (index2.firstBlockPosition) {
        const bsizeOptions = buildOptions$1(this.config, { range: { start: index2.firstBlockPosition, size: 26 } });
        const abuffer = await igvxhr.loadArrayBuffer(this.bamPath, bsizeOptions);
        const bsize = bgzBlockSize$1(abuffer);
        len2 = index2.firstBlockPosition + bsize;
      } else {
        len2 = 64e3;
      }
      const options2 = buildOptions$1(this.config, { range: { start: 0, size: len2 } });
      this.header = await BamUtils.readHeader(this.bamPath, options2, genome);
    }
    return this.header;
  }
  async getIndex() {
    const genome = this.genome;
    if (!this.index) {
      this.index = await loadIndex(this.baiPath, this.config, genome);
    }
    return this.index;
  }
  async getChrIndex() {
    if (this.chrToIndex) {
      return this.chrToIndex;
    } else {
      const header = await this.getHeader();
      this.chrToIndex = header.chrToIndex;
      this.indexToChr = header.chrNames;
      this.chrAliasTable = header.chrAliasTable;
      return this.chrToIndex;
    }
  }
}
class ShardedBamReader {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
    const bamReaders = {};
    config.sources.sequences.forEach(function(chr) {
      const queryChr = genome ? genome.getChromosomeName(chr) : chr;
      bamReaders[queryChr] = getReader(config, genome, chr);
    });
    this.bamReaders = bamReaders;
    BamUtils.setReaderDefaults(this, config);
  }
  async readAlignments(chr, start, end) {
    if (!this.bamReaders.hasOwnProperty(chr)) {
      return new AlignmentContainer(chr, start, end, this.config);
    } else {
      let reader = this.bamReaders[chr];
      const a = await reader.readAlignments(chr, start, end);
      return a;
    }
  }
}
function getReader(config, genome, chr) {
  const tmp = {
    url: config.sources.url.replace("$CHR", chr)
  };
  if (config.sources.indexURL) {
    tmp.indexURL = config.sources.indexURL.replace("$CHR", chr);
  }
  const bamConfig = Object.assign(config, tmp);
  return new BamReader(bamConfig, genome);
}
const BamWebserviceReader = function(config, genome) {
  this.config = config;
  this.genome = genome;
  BamUtils.setReaderDefaults(this, config);
};
BamWebserviceReader.prototype.readAlignments = function(chr, bpStart, bpEnd) {
  var self2 = this;
  return getHeader.call(self2).then(function(header) {
    var queryChr, url;
    queryChr = header.chrAliasTable.hasOwnProperty(chr) ? header.chrAliasTable[chr] : chr;
    url = self2.config.url + "?reference=" + self2.config.referenceFile + "&file=" + self2.config.alignmentFile + "&region=" + queryChr + ":" + bpStart + "-" + bpEnd;
    return igvxhr.loadString(url, buildOptions$1(self2.config)).then(function(sam) {
      var alignmentContainer;
      header.chrToIndex[queryChr];
      alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, self2.config);
      BamUtils.decodeSamRecords(sam, alignmentContainer, queryChr, bpStart, bpEnd, self2.filter);
      return alignmentContainer;
    });
  });
};
function getHeader() {
  const self2 = this;
  const genome = this.genome;
  if (this.header) {
    return Promise.resolve(this.header);
  } else {
    const url = this.config.url + "?file=" + this.config.alignmentFile + "&options=-b,-H";
    const options2 = buildOptions$1(this.config);
    return BamUtils.readHeader(url, options2, genome).then(function(header) {
      self2.header = header;
      return header;
    });
  }
}
class HtsgetBamReader extends HtsgetReader {
  constructor(config, genome) {
    super(config, genome);
    BamUtils.setReaderDefaults(this, config);
  }
  async readAlignments(chr, start, end) {
    if (!this.header) {
      const compressedData2 = await this.readHeaderData();
      const ba2 = unbgzf(compressedData2.buffer);
      this.header = BamUtils.decodeBamHeader(ba2, this.genome);
      this.chrAliasTable = /* @__PURE__ */ new Map();
      for (let key of Object.keys(this.header.chrAliasTable)) {
        this.chrAliasTable.set(key, this.header.chrAliasTable[key]);
      }
    }
    let queryChr = this.chrAliasTable.has(chr) ? this.chrAliasTable.get(chr) : chr;
    const compressedData = await this.readData(queryChr, start, end);
    const ba = unbgzf(compressedData.buffer);
    const chrIdx = this.header.chrToIndex[chr];
    const alignmentContainer = new AlignmentContainer(chr, start, end, this.config);
    BamUtils.decodeBamRecords(ba, this.header.size, alignmentContainer, this.header.chrNames, chrIdx, start, end);
    alignmentContainer.finish();
    return alignmentContainer;
  }
}
/*! For license information please see cram-bundle.js.LICENSE.txt */
const fn = () => {
  var e = { 368: function(e2, t3, r2) {
    var n2 = this && this.__awaiter || function(e3, t4, r3, n3) {
      return new (r3 || (r3 = Promise))((function(i2, o2) {
        function s2(e4) {
          try {
            f2(n3.next(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function a2(e4) {
          try {
            f2(n3.throw(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function f2(e4) {
          var t5;
          e4.done ? i2(e4.value) : (t5 = e4.value, t5 instanceof r3 ? t5 : new r3((function(e5) {
            e5(t5);
          }))).then(s2, a2);
        }
        f2((n3 = n3.apply(e3, t4 || [])).next());
      }));
    }, i = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const o = i(r2(4105)), s = i(r2(1269)), a = r2(597), f = r2(3427), h = r2(8577);
    function l(e3, t4) {
      if (t4.some(((e4) => void 0 === e4))) throw new h.CramMalformedError("invalid .crai index file");
      const [r3, n3, i2, o2, s2, a2] = t4;
      e3[r3] || (e3[r3] = []), e3[r3].push({ start: n3, span: i2, containerStart: o2, sliceStart: s2, sliceBytes: a2 });
    }
    t3.default = class {
      constructor(e3) {
        this.filehandle = (0, f.open)(e3.url, e3.path, e3.filehandle), this._parseCache = new o.default({ cache: new s.default({ maxSize: 1 }), fill: (e4, t4) => this.parseIndex() });
      }
      parseIndex() {
        const e3 = {};
        return this.filehandle.readFile().then(((e4) => 31 === e4[0] && 139 === e4[1] ? (0, a.unzip)(e4) : e4)).then(((t4) => {
          if (t4.length > 4 && 21578050 === t4.readUInt32LE(0)) throw new h.CramMalformedError("invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support");
          let r3 = [], n3 = "";
          for (let i2 = 0; i2 < t4.length; i2 += 1) {
            const o2 = t4[i2];
            if (o2 >= 48 && o2 <= 57 || !n3 && 45 === o2) n3 += String.fromCharCode(o2);
            else if (9 === o2) r3.push(Number.parseInt(n3, 10)), n3 = "";
            else if (10 === o2) r3.push(Number.parseInt(n3, 10)), n3 = "", l(e3, r3), r3 = [];
            else if (13 !== o2 && 32 !== o2) throw new h.CramMalformedError("invalid .crai index file");
          }
          return n3 && r3.push(Number.parseInt(n3, 10)), 6 === r3.length && l(e3, r3), Object.entries(e3).forEach((([t5, r4]) => {
            e3[t5] = r4.sort(((e4, t6) => e4.start - t6.start || e4.span - t6.span));
          })), e3;
        }));
      }
      getIndex(e3 = {}) {
        return this._parseCache.get("index", null, e3.signal);
      }
      hasDataForReferenceSequence(e3) {
        return n2(this, void 0, void 0, (function* () {
          return !!(yield this.getIndex())[e3];
        }));
      }
      getEntriesForRange(e3, t4, r3) {
        return n2(this, void 0, void 0, (function* () {
          const n3 = (yield this.getIndex())[e3];
          if (!n3) return [];
          const i2 = (e4) => {
            const n4 = e4.start, i3 = e4.start + e4.span;
            return n4 > r3 ? -1 : i3 <= t4 ? 1 : 0;
          }, o2 = [];
          for (let e4 = 0; e4 < n3.length; e4 += 1) 0 === i2(n3[e4]) && o2.push(n3[e4]);
          return o2;
        }));
      }
    };
  }, 1050: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.default = class {
      constructor(e3, t4) {
        this.parameters = e3, this.dataType = t4;
      }
    };
  }, 4863: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(1074);
    class a extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), "int" !== this.dataType) throw new i.CramUnimplementedError(`${this.dataType} decoding not yet implemented by BETA codec`);
      }
      decode(e3, t4, r3, n3) {
        return (0, s.getBits)(t4.content, n3.coreBlock, this.parameters.length) - this.parameters.offset;
      }
    }
    t3.default = a;
  }, 1738: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(9488), o = n2(r2(1050));
    class s extends o.default {
      constructor(e3, t4, r3) {
        if (super(e3, t4), this.instantiateCodec = r3, "byteArray" !== t4) throw new TypeError(`byteArrayLength does not support data type ${t4}`);
      }
      decode(e3, t4, r3, n3) {
        const i2 = this._getLengthCodec().decode(e3, t4, r3, n3), o2 = this._getDataCodec(), s2 = new Uint8Array(i2);
        for (let a = 0; a < i2; a += 1) s2[a] = o2.decode(e3, t4, r3, n3);
        return s2;
      }
      _getLengthCodec() {
        const e3 = this.parameters.lengthsEncoding;
        return this.instantiateCodec(e3, "int");
      }
      _getDataCodec() {
        const e3 = this.parameters.valuesEncoding;
        return this.instantiateCodec(e3, "byte");
      }
    }
    t3.default = s, "_getLengthCodec _getDataCodec".split(" ").forEach(((e3) => (0, i.tinyMemoize)(s, e3)));
  }, 1405: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(1074);
    class a extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), "byteArray" !== t4) throw new TypeError(`byteArrayStop codec does not support data type ${t4}`);
      }
      decode(e3, t4, r3, n3) {
        const { blockContentId: o2 } = this.parameters, s2 = r3[o2];
        if (!s2) throw new i.CramMalformedError(`no block found with content ID ${o2}`);
        const a2 = n3.externalBlocks.getCursor(o2);
        return this._decodeByteArray(s2, a2);
      }
      _decodeByteArray(e3, t4) {
        const r3 = e3.content, { stopByte: n3 } = this.parameters, i2 = t4.bytePosition;
        let o2 = t4.bytePosition;
        for (; r3[o2] !== n3 && o2 < r3.length; ) {
          if (o2 === r3.length) throw new s.CramBufferOverrunError("byteArrayStop reading beyond length of data buffer?");
          o2 += 1;
        }
        return t4.bytePosition = o2 + 1, r3.subarray(i2, o2);
      }
    }
    t3.default = a;
  }, 5844: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(9488), a = r2(1074);
    class f extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), "int" === this.dataType) this._decodeData = this._decodeInt;
        else {
          if ("byte" !== this.dataType) throw new i.CramUnimplementedError(`${this.dataType} decoding not yet implemented by EXTERNAL codec`);
          this._decodeData = this._decodeByte;
        }
      }
      decode(e3, t4, r3, n3) {
        const { blockContentId: o2 } = this.parameters, s2 = r3[o2];
        if (!s2) throw new i.CramMalformedError(`no block found with content ID ${o2}`);
        const a2 = n3.externalBlocks.getCursor(o2);
        return this._decodeData(s2, a2);
      }
      _decodeInt(e3, t4) {
        const [r3, n3] = (0, s.parseItf8)(e3.content, t4.bytePosition);
        return t4.bytePosition = t4.bytePosition + n3, r3;
      }
      _decodeByte(e3, t4) {
        if (t4.bytePosition >= e3.content.length) throw new a.CramBufferOverrunError("attempted to read beyond end of block. this file seems truncated.");
        return e3.content[t4.bytePosition++];
      }
    }
    t3.default = f;
  }, 4229: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(1074);
    class a extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), "int" !== this.dataType) throw new i.CramUnimplementedError(`${this.dataType} decoding not yet implemented by GAMMA codec`);
      }
      decode(e3, t4, r3, n3) {
        let i2 = 1;
        for (; 0 === (0, s.getBits)(t4.content, n3.coreBlock, 1); ) i2 += 1;
        return ((0, s.getBits)(t4.content, n3.coreBlock, i2 - 1) | 1 << i2 - 1) - this.parameters.offset;
      }
    }
    t3.default = a;
  }, 1074: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.getBits = t3.CramBufferOverrunError = void 0;
    class r2 extends Error {
    }
    t3.CramBufferOverrunError = r2, t3.getBits = function(e3, t4, n2) {
      let i = 0;
      if (t4.bytePosition + (7 - t4.bitPosition + n2) / 8 > e3.length) throw new r2("read error during decoding. the file seems to be truncated.");
      for (let r3 = n2; r3; r3--) i <<= 1, i |= e3[t4.bytePosition] >> t4.bitPosition & 1, t4.bitPosition -= 1, t4.bitPosition < 0 && (t4.bytePosition += 1), t4.bitPosition &= 7;
      return i;
    };
  }, 2082: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(1074);
    class a extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), this.codes = {}, this.codeBook = {}, this.sortedByValue = [], this.sortedCodes = [], this.sortedValuesByBitCode = [], this.sortedBitCodes = [], this.sortedBitLengthsByBitCode = [], this.bitCodeToValue = [], !["byte", "int"].includes(this.dataType)) throw new TypeError(`${this.dataType} decoding not yet implemented by HUFFMAN_INT codec`);
        this.buildCodeBook(), this.buildCodes(), this.buildCaches(), 0 === this.sortedCodes[0].bitLength && (this._decode = this._decodeZeroLengthCode);
      }
      buildCodeBook() {
        let e3 = new Array(this.parameters.numCodes);
        for (let t4 = 0; t4 < this.parameters.numCodes; t4 += 1) e3[t4] = { symbol: this.parameters.symbols[t4], bitLength: this.parameters.bitLengths[t4] };
        e3 = e3.sort(((e4, t4) => e4.bitLength - t4.bitLength || e4.symbol - t4.symbol)), this.codeBook = {}, e3.forEach(((e4) => {
          this.codeBook[e4.bitLength] || (this.codeBook[e4.bitLength] = []), this.codeBook[e4.bitLength].push(e4.symbol);
        }));
      }
      buildCodes() {
        this.codes = {};
        let e3 = 0, t4 = -1;
        Object.entries(this.codeBook).forEach((([r3, n3]) => {
          const o2 = parseInt(r3, 10);
          n3.forEach(((r4) => {
            const n4 = { bitLength: o2, value: r4, bitCode: 0 };
            t4 += 1;
            const s2 = o2 - e3;
            if (t4 <<= s2, n4.bitCode = t4, e3 += s2, (function(e4) {
              let t5 = e4 - (e4 >> 1) & 1431655765;
              return t5 = (858993459 & t5) + (t5 >> 2 & 858993459), 16843009 * (t5 + (t5 >> 4) & 252645135) >> 24;
            })(t4) > o2) throw new i.CramMalformedError("Symbol out of range");
            this.codes[r4] = n4;
          }));
        }));
      }
      buildCaches() {
        this.sortedCodes = Object.values(this.codes).sort(((e4, t4) => e4.bitLength - t4.bitLength || e4.bitCode - t4.bitCode)), this.sortedByValue = Object.values(this.codes).sort(((e4, t4) => e4.value - t4.value)), this.sortedValuesByBitCode = this.sortedCodes.map(((e4) => e4.value)), this.sortedBitCodes = this.sortedCodes.map(((e4) => e4.bitCode)), this.sortedBitLengthsByBitCode = this.sortedCodes.map(((e4) => e4.bitLength));
        const e3 = Math.max(...this.sortedBitCodes);
        this.bitCodeToValue = new Array(e3 + 1).fill(-1);
        for (let e4 = 0; e4 < this.sortedBitCodes.length; e4 += 1) this.bitCodeToValue[this.sortedCodes[e4].bitCode] = e4;
      }
      decode(e3, t4, r3, n3) {
        return this._decode(e3, t4, n3.coreBlock);
      }
      _decodeZeroLengthCode() {
        return this.sortedCodes[0].value;
      }
      _decode(e3, t4, r3) {
        const n3 = t4.content;
        let o2 = 0, a2 = 0;
        for (let e4 = 0; e4 < this.sortedCodes.length; e4 += 1) {
          const t5 = this.sortedCodes[e4].bitLength;
          a2 <<= t5 - o2, a2 |= (0, s.getBits)(n3, r3, t5 - o2), o2 = t5;
          {
            const r4 = this.bitCodeToValue[a2];
            if (r4 > -1 && this.sortedBitLengthsByBitCode[r4] === t5) return this.sortedValuesByBitCode[r4];
            for (let r5 = e4; this.sortedCodes[r5 + 1].bitLength === t5 && r5 < this.sortedCodes.length; r5 += 1) e4 += 1;
          }
        }
        throw new i.CramMalformedError("Huffman symbol not found.");
      }
    }
    t3.default = a;
  }, 8772: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.instantiateCodec = void 0;
    const i = r2(8577), o = n2(r2(2082)), s = n2(r2(5844)), a = n2(r2(1405)), f = n2(r2(1738)), h = n2(r2(4863)), l = n2(r2(4229)), u = n2(r2(8821)), c = { 1: s.default, 3: o.default, 4: f.default, 5: a.default, 6: h.default, 7: u.default, 9: l.default };
    t3.instantiateCodec = function e3(t4, r3) {
      const n3 = (o2 = "ignore" === r3 ? 0 : t4.codecId, c[o2]);
      var o2;
      if (!n3) throw new i.CramUnimplementedError(`no codec implemented for codec ID ${t4.codecId}`);
      return new n3(t4.parameters, r3, e3);
    };
  }, 8821: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(1050)), s = r2(1074);
    class a extends o.default {
      constructor(e3, t4) {
        if (super(e3, t4), "int" !== this.dataType) throw new i.CramUnimplementedError(`${this.dataType} decoding not yet implemented by SUBEXP codec`);
      }
      decode(e3, t4, r3, n3) {
        let i2, o2, a2 = 0;
        for (; (0, s.getBits)(t4.content, n3.coreBlock, 1); ) a2 += 1;
        return 0 === a2 ? (i2 = this.parameters.K, o2 = (0, s.getBits)(t4.content, n3.coreBlock, i2)) : (i2 = a2 + this.parameters.K - 1, o2 = 1 << i2 | (0, s.getBits)(t4.content, n3.coreBlock, i2)), o2 - this.parameters.offset;
      }
    }
    t3.default = a;
  }, 2615: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.default = { CRAM_FLAG_PRESERVE_QUAL_SCORES: 1, CRAM_FLAG_DETACHED: 2, CRAM_FLAG_MATE_DOWNSTREAM: 4, CRAM_FLAG_NO_SEQ: 8, CRAM_FLAG_MASK: 15, CRAM_M_REVERSE: 1, CRAM_M_UNMAP: 2, BAM_FPAIRED: 1, BAM_FPROPER_PAIR: 2, BAM_FUNMAP: 4, BAM_FMUNMAP: 8, BAM_FREVERSE: 16, BAM_FMREVERSE: 32, BAM_FREAD1: 64, BAM_FREAD2: 128, BAM_FSECONDARY: 256, BAM_FQCFAIL: 512, BAM_FDUP: 1024, BAM_FSUPPLEMENTARY: 2048, BAM_CMATCH: 0, BAM_CINS: 1, BAM_CDEL: 2, BAM_CREF_SKIP: 3, BAM_CSOFT_CLIP: 4, BAM_CHARD_CLIP: 5, BAM_CPAD: 6, BAM_CEQUAL: 7, BAM_CDIFF: 8, BAM_CBACK: 9, BAM_CIGAR_STR: "MIDNSHP:XB", BAM_CIGAR_SHIFT: 4, BAM_CIGAR_MASK: 15, BAM_CIGAR_TYPE: 246183 };
  }, 8543: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true });
    const n2 = r2(8772), i = r2(8577), o = { BF: "int", CF: "int", RI: "int", RL: "int", AP: "int", RG: "int", MF: "int", NS: "int", NP: "int", TS: "int", NF: "int", TC: "byte", TN: "int", FN: "int", FC: "byte", FP: "int", BS: "byte", IN: "byteArray", SC: "byteArray", DL: "int", BA: "byte", BB: "byteArray", RS: "int", PD: "int", HC: "int", MQ: "int", RN: "byteArray", QS: "byte", QQ: "byteArray", TL: "int" };
    t3.default = class {
      constructor(e3) {
        this.dataSeriesCodecCache = {}, this.tagCodecCache = {}, this.tagEncoding = {}, this.readNamesIncluded = e3.preservation.RN, this.APdelta = e3.preservation.AP, this.referenceRequired = !!e3.preservation.RR, this.tagIdsDictionary = e3.preservation.TD, this.substitutionMatrix = (function(e4) {
          const t4 = new Array(5);
          for (let e5 = 0; e5 < 5; e5 += 1) t4[e5] = new Array(4);
          return t4[0][e4[0] >> 6 & 3] = "C", t4[0][e4[0] >> 4 & 3] = "G", t4[0][e4[0] >> 2 & 3] = "T", t4[0][e4[0] >> 0 & 3] = "N", t4[1][e4[1] >> 6 & 3] = "A", t4[1][e4[1] >> 4 & 3] = "G", t4[1][e4[1] >> 2 & 3] = "T", t4[1][e4[1] >> 0 & 3] = "N", t4[2][e4[2] >> 6 & 3] = "A", t4[2][e4[2] >> 4 & 3] = "C", t4[2][e4[2] >> 2 & 3] = "T", t4[2][e4[2] >> 0 & 3] = "N", t4[3][e4[3] >> 6 & 3] = "A", t4[3][e4[3] >> 4 & 3] = "C", t4[3][e4[3] >> 2 & 3] = "G", t4[3][e4[3] >> 0 & 3] = "N", t4[4][e4[4] >> 6 & 3] = "A", t4[4][e4[4] >> 4 & 3] = "C", t4[4][e4[4] >> 2 & 3] = "G", t4[4][e4[4] >> 0 & 3] = "T", t4;
        })(e3.preservation.SM), this.dataSeriesEncoding = e3.dataSeriesEncoding, this.tagEncoding = e3.tagEncoding, this.preservation = e3.preservation, this._size = e3._size, this._endPosition = e3._endPosition;
      }
      getCodecForTag(e3) {
        if (!this.tagCodecCache[e3]) {
          const t4 = this.tagEncoding[e3];
          t4 && (this.tagCodecCache[e3] = (0, n2.instantiateCodec)(t4, "byteArray"));
        }
        return this.tagCodecCache[e3];
      }
      getTagNames(e3) {
        return this.tagIdsDictionary[e3];
      }
      getCodecForDataSeries(e3) {
        let t4 = this.dataSeriesCodecCache[e3];
        if (void 0 === t4) {
          const r3 = this.dataSeriesEncoding[e3];
          if (r3) {
            const s = o[e3];
            if (!s) throw new i.CramMalformedError(`data series name ${e3} not defined in file compression header`);
            t4 = (0, n2.instantiateCodec)(r3, s), this.dataSeriesCodecCache[e3] = t4;
          }
        }
        return t4;
      }
      toJSON() {
        const e3 = {};
        return Object.keys(this).forEach(((t4) => {
          /Cache$/.test(t4) || (e3[t4] = this[t4]);
        })), e3;
      }
    };
  }, 6284: function(e2, t3, r2) {
    var n2 = this && this.__awaiter || function(e3, t4, r3, n3) {
      return new (r3 || (r3 = Promise))((function(i2, o2) {
        function s2(e4) {
          try {
            f2(n3.next(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function a2(e4) {
          try {
            f2(n3.throw(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function f2(e4) {
          var t5;
          e4.done ? i2(e4.value) : (t5 = e4.value, t5 instanceof r3 ? t5 : new r3((function(e5) {
            e5(t5);
          }))).then(s2, a2);
        }
        f2((n3 = n3.apply(e3, t4 || [])).next());
      }));
    }, i = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const o = r2(8577), s = r2(9488), a = i(r2(6601)), f = i(r2(8543));
    class h {
      constructor(e3, t4) {
        this.file = e3, this.filePosition = t4;
      }
      getHeader() {
        return this._readContainerHeader(this.filePosition);
      }
      getCompressionHeaderBlock() {
        return n2(this, void 0, void 0, (function* () {
          if (!(yield this.getHeader()).numRecords) return null;
          const e3 = yield this.file.getSectionParsers(), t4 = yield this.getFirstBlock();
          if (void 0 === t4) return;
          if ("COMPRESSION_HEADER" !== t4.contentType) throw new o.CramMalformedError(`invalid content type ${t4.contentType} in what is supposed to be the compression header block`);
          const r3 = (0, s.parseItem)(t4.content, e3.cramCompressionHeader.parser, 0, t4.contentPosition);
          return Object.assign(Object.assign({}, t4), { parsedContent: r3 });
        }));
      }
      getFirstBlock() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getHeader();
          return this.file.readBlock(e3._endPosition);
        }));
      }
      getCompressionScheme() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getCompressionHeaderBlock();
          if (e3) return new f.default(e3.parsedContent);
        }));
      }
      getSlice(e3, t4) {
        return new a.default(this, e3, t4);
      }
      _readContainerHeader(e3) {
        return n2(this, void 0, void 0, (function* () {
          const t4 = yield this.file.getSectionParsers(), { cramContainerHeader1: r3, cramContainerHeader2: n3 } = t4, { size: i2 } = yield this.file.stat();
          if (e3 >= i2) return;
          const o2 = Buffer.allocUnsafe(r3.maxLength);
          yield this.file.read(o2, 0, r3.maxLength, e3);
          const a2 = (0, s.parseItem)(o2, r3.parser), f2 = (0, s.itf8Size)(a2.numLandmarks);
          if (e3 + a2.length >= i2) return void console.warn(`${this.file}: container header at ${e3} indicates that the container has length ${a2.length}, which extends beyond the length of the file. Skipping this container.`);
          const h2 = Buffer.allocUnsafe(n3.maxLength(a2.numLandmarks));
          yield this.file.read(h2, 0, n3.maxLength(a2.numLandmarks), e3 + a2._size - f2);
          const l = (0, s.parseItem)(h2, n3.parser);
          return this.file.validateChecksums && void 0 !== l.crc32 && (yield this.file.checkCrc32(e3, a2._size + l._size - f2 - 4, l.crc32, `container header beginning at position ${e3}`)), Object.assign(a2, l, { _size: a2._size + l._size - f2, _endPosition: a2._size + l._size - f2 + e3 });
        }));
      }
    }
    t3.default = h, "getHeader getCompressionHeaderBlock getCompressionScheme".split(" ").forEach(((e3) => (0, s.tinyMemoize)(h, e3)));
  }, 5457: function(e2, t3, r2) {
    var n2 = this && this.__awaiter || function(e3, t4, r3, n3) {
      return new (r3 || (r3 = Promise))((function(i2, o2) {
        function s2(e4) {
          try {
            f2(n3.next(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function a2(e4) {
          try {
            f2(n3.throw(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function f2(e4) {
          var t5;
          e4.done ? i2(e4.value) : (t5 = e4.value, t5 instanceof r3 ? t5 : new r3((function(e5) {
            e5(t5);
          }))).then(s2, a2);
        }
        f2((n3 = n3.apply(e3, t4 || [])).next());
      }));
    }, i = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const o = r2(597), s = i(r2(2779)), a = i(r2(1269)), f = r2(8577), h = i(r2(9675)), l = r2(6141), u = i(r2(3498)), c = i(r2(6284)), d = r2(3427), p = r2(9488), g = r2(7578);
    class m {
      constructor(e3) {
        var t4;
        if (this.file = (0, d.open)(e3.url, e3.path, e3.filehandle), this.validateChecksums = true, this.fetchReferenceSequenceCallback = e3.seqFetch, this.options = { checkSequenceMD5: e3.checkSequenceMD5, cacheSize: null !== (t4 = e3.cacheSize) && void 0 !== t4 ? t4 : 2e4 }, this.featureCache = new a.default({ maxSize: this.options.cacheSize }), (function() {
          const e4 = new Uint32Array([287454020]), t5 = new Uint8Array(e4.buffer);
          return 68 === t5[0] ? 0 : 17 === t5[0] ? 1 : 2;
        })() > 0) throw new Error("Detected big-endian machine, may be unable to run");
      }
      read(e3, t4, r3, n3) {
        return this.file.read(e3, t4, r3, n3);
      }
      stat() {
        return this.file.stat();
      }
      getDefinition() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = Buffer.allocUnsafe(l.cramFileDefinition.maxLength);
          yield this.file.read(e3, 0, l.cramFileDefinition.maxLength, 0);
          const t4 = l.cramFileDefinition.parser.parse(e3).result;
          if (2 !== t4.majorVersion && 3 !== t4.majorVersion) throw new f.CramUnimplementedError(`CRAM version ${t4.majorVersion} not supported`);
          return t4;
        }));
      }
      getSamHeader() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getContainerById(0);
          if (!e3) throw new f.CramMalformedError("file contains no containers");
          const t4 = yield e3.getFirstBlock();
          if (void 0 === t4) return (0, g.parseHeaderText)("");
          const r3 = t4.content, n3 = r3.readInt32LE(0), i2 = r3.toString("utf8", 4, 4 + n3);
          return this.header = i2, (0, g.parseHeaderText)(i2);
        }));
      }
      getHeaderText() {
        return n2(this, void 0, void 0, (function* () {
          return yield this.getSamHeader(), this.header;
        }));
      }
      getSectionParsers() {
        return n2(this, void 0, void 0, (function* () {
          const { majorVersion: e3 } = yield this.getDefinition();
          return (0, l.getSectionParsers)(e3);
        }));
      }
      getContainerById(e3) {
        return n2(this, void 0, void 0, (function* () {
          const t4 = yield this.getSectionParsers();
          let r3 = t4.cramFileDefinition.maxLength;
          const { size: n3 } = yield this.file.stat(), { cramContainerHeader1: i2 } = t4;
          let o2;
          for (let t5 = 0; t5 <= e3; t5 += 1) {
            if (r3 + i2.maxLength + 8 >= n3) return;
            o2 = this.getContainerAtPosition(r3);
            const s2 = yield o2.getHeader();
            if (!s2) throw new f.CramMalformedError(`container ${e3} not found in file`);
            if (0 === t5) {
              r3 = s2._endPosition;
              for (let e4 = 0; e4 < s2.numBlocks; e4 += 1) {
                const e5 = yield this.readBlock(r3);
                if (void 0 === e5) return;
                r3 = e5._endPosition;
              }
            } else r3 += s2._size + s2.length;
          }
          return o2;
        }));
      }
      checkCrc32(e3, t4, r3, i2) {
        return n2(this, void 0, void 0, (function* () {
          const n3 = Buffer.allocUnsafe(t4);
          yield this.file.read(n3, 0, t4, e3);
          const o2 = s.default.unsigned(n3);
          if (o2 !== r3) throw new f.CramMalformedError(`crc mismatch in ${i2}: recorded CRC32 = ${r3}, but calculated CRC32 = ${o2}`);
        }));
      }
      containerCount() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getSectionParsers(), { size: t4 } = yield this.file.stat(), { cramContainerHeader1: r3 } = e3;
          let n3 = 0, i2 = e3.cramFileDefinition.maxLength;
          for (; i2 + r3.maxLength + 8 < t4; ) {
            const e4 = yield this.getContainerAtPosition(i2).getHeader();
            if (!e4) break;
            if (0 === n3) {
              i2 = e4._endPosition;
              for (let t5 = 0; t5 < e4.numBlocks; t5 += 1) {
                const e5 = yield this.readBlock(i2);
                if (void 0 === e5) return;
                i2 = e5._endPosition;
              }
            } else i2 += e4._size + e4.length;
            n3 += 1;
          }
          return n3;
        }));
      }
      getContainerAtPosition(e3) {
        return new c.default(this, e3);
      }
      readBlockHeader(e3) {
        return n2(this, void 0, void 0, (function* () {
          const t4 = yield this.getSectionParsers(), { cramBlockHeader: r3 } = t4, { size: n3 } = yield this.file.stat();
          if (e3 + r3.maxLength >= n3) return;
          const i2 = Buffer.allocUnsafe(r3.maxLength);
          return yield this.file.read(i2, 0, r3.maxLength, e3), (0, p.parseItem)(i2, r3.parser, 0, e3);
        }));
      }
      _parseSection(e3, t4, r3 = e3.maxLength, i2) {
        return n2(this, void 0, void 0, (function* () {
          let n3;
          if (i2) n3 = i2;
          else {
            const { size: e4 } = yield this.file.stat();
            if (t4 + r3 >= e4) return;
            n3 = Buffer.allocUnsafe(r3), yield this.file.read(n3, 0, r3, t4);
          }
          const o2 = (0, p.parseItem)(n3, e3.parser, 0, t4);
          if (o2._size !== r3) throw new f.CramMalformedError(`section read error: requested size ${r3} does not equal parsed size ${o2._size}`);
          return o2;
        }));
      }
      _uncompress(e3, t4, r3) {
        if ("gzip" === e3) (0, o.unzip)(t4).copy(r3);
        else if ("bzip2" === e3) {
          const e4 = bzip2.array(t4);
          let n3, i2 = bzip2.header(e4), o2 = 0;
          do {
            n3 = bzip2.decompress(e4, i2), -1 != n3 && (Buffer.from(n3).copy(r3, o2), o2 += n3.length, i2 -= n3.length);
          } while (-1 != n3);
        } else if ("rans" === e3) (0, h.default)(t4, r3);
        else if ("rans4x16" === e3) u.default.r4x16_uncompress(t4, r3);
        else if ("arith" === e3) u.default.arith_uncompress(t4, r3);
        else if ("fqzcomp" === e3) u.default.fqzcomp_uncompress(t4, r3);
        else {
          if ("tok3" !== e3) throw new f.CramUnimplementedError(`${e3} decompression not yet implemented`);
          u.default.tok3_uncompress(t4, r3);
        }
      }
      readBlock(e3) {
        return n2(this, void 0, void 0, (function* () {
          const { majorVersion: t4 } = yield this.getDefinition(), r3 = yield this.getSectionParsers(), n3 = yield this.readBlockHeader(e3);
          if (void 0 === n3) return;
          const i2 = n3._endPosition, o2 = Buffer.allocUnsafe(n3.uncompressedSize), s2 = Object.assign(Object.assign({}, n3), { _endPosition: i2, contentPosition: i2, content: o2 });
          if ("raw" !== n3.compressionMethod) {
            const e4 = Buffer.allocUnsafe(n3.compressedSize);
            yield this.read(e4, 0, n3.compressedSize, i2), this._uncompress(n3.compressionMethod, e4, o2);
          } else yield this.read(o2, 0, n3.uncompressedSize, i2);
          if (t4 >= 3) {
            const t5 = yield this._parseSection(r3.cramBlockCrc32, i2 + n3.compressedSize);
            if (void 0 === t5) return;
            s2.crc32 = t5.crc32, this.validateChecksums && (yield this.checkCrc32(e3, n3._size + n3.compressedSize, t5.crc32, "block data")), s2._endPosition = t5._endPosition, s2._size = s2.compressedSize + r3.cramBlockCrc32.maxLength;
          } else s2._endPosition = i2 + s2.compressedSize, s2._size = s2.compressedSize;
          return s2;
        }));
      }
    }
    t3.default = m, "getDefinition getSectionParsers getSamHeader".split(" ").forEach(((e3) => (0, p.tinyMemoize)(m, e3)));
  }, 8222: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.CramRecord = void 0;
    const i = n2(r2(5457));
    var o = r2(8631);
    Object.defineProperty(t3, "CramRecord", { enumerable: true, get: function() {
      return n2(o).default;
    } }), t3.default = i.default;
  }, 8631: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.MateFlagsDecoder = t3.CramFlagsDecoder = t3.BamFlagsDecoder = t3.MateFlags = t3.CramFlags = t3.BamFlags = void 0;
    const i = n2(r2(2615)), o = { a: 0, A: 0, c: 1, C: 1, g: 2, G: 2, t: 3, T: 3, n: 4, N: 4 };
    function s(e3) {
      const t4 = {};
      for (const [r3, n3] of e3) t4["is" + n3] = (e4) => !!(e4 & r3), t4["set" + n3] = (e4) => e4 | r3;
      return t4;
    }
    t3.BamFlags = [[1, "Paired"], [2, "ProperlyPaired"], [4, "SegmentUnmapped"], [8, "MateUnmapped"], [16, "ReverseComplemented"], [32, "MateReverseComplemented"], [64, "Read1"], [128, "Read2"], [256, "Secondary"], [512, "FailedQc"], [1024, "Duplicate"], [2048, "Supplementary"]], t3.CramFlags = [[1, "PreservingQualityScores"], [2, "Detached"], [4, "WithMateDownstream"], [8, "DecodeSequenceAsStar"]], t3.MateFlags = [[1, "OnNegativeStrand"], [2, "Unmapped"]], t3.BamFlagsDecoder = s(t3.BamFlags), t3.CramFlagsDecoder = s(t3.CramFlags), t3.MateFlagsDecoder = s(t3.MateFlags), t3.default = class {
      constructor({ flags: e3, cramFlags: t4, readLength: r3, mappingQuality: n3, lengthOnRef: i2, qualityScores: o2, mateRecordNumber: s2, readBases: a, readFeatures: f, mateToUse: h, readGroupId: l, readName: u, sequenceId: c, uniqueId: d, templateSize: p, alignmentStart: g, tags: m }) {
        this.flags = e3, this.cramFlags = t4, this.readLength = r3, this.mappingQuality = n3, this.lengthOnRef = i2, this.qualityScores = o2, a && (this.readBases = a), this.readGroupId = l, this.readName = u, this.sequenceId = c, this.uniqueId = d, this.templateSize = p, this.alignmentStart = g, this.tags = m, f && (this.readFeatures = f), h && (this.mate = { flags: h.mateFlags, readName: h.mateReadName, sequenceId: h.mateSequenceId, alignmentStart: h.mateAlignmentStart }), s2 && (this.mateRecordNumber = s2);
      }
      isPaired() {
        return !!(this.flags & i.default.BAM_FPAIRED);
      }
      isProperlyPaired() {
        return !!(this.flags & i.default.BAM_FPROPER_PAIR);
      }
      isSegmentUnmapped() {
        return !!(this.flags & i.default.BAM_FUNMAP);
      }
      isMateUnmapped() {
        return !!(this.flags & i.default.BAM_FMUNMAP);
      }
      isReverseComplemented() {
        return !!(this.flags & i.default.BAM_FREVERSE);
      }
      isMateReverseComplemented() {
        return !!(this.flags & i.default.BAM_FMREVERSE);
      }
      isRead1() {
        return !!(this.flags & i.default.BAM_FREAD1);
      }
      isRead2() {
        return !!(this.flags & i.default.BAM_FREAD2);
      }
      isSecondary() {
        return !!(this.flags & i.default.BAM_FSECONDARY);
      }
      isFailedQc() {
        return !!(this.flags & i.default.BAM_FQCFAIL);
      }
      isDuplicate() {
        return !!(this.flags & i.default.BAM_FDUP);
      }
      isSupplementary() {
        return !!(this.flags & i.default.BAM_FSUPPLEMENTARY);
      }
      isDetached() {
        return !!(this.cramFlags & i.default.CRAM_FLAG_DETACHED);
      }
      hasMateDownStream() {
        return !!(this.cramFlags & i.default.CRAM_FLAG_MATE_DOWNSTREAM);
      }
      isPreservingQualityScores() {
        return !!(this.cramFlags & i.default.CRAM_FLAG_PRESERVE_QUAL_SCORES);
      }
      isUnknownBases() {
        return !!(this.cramFlags & i.default.CRAM_FLAG_NO_SEQ);
      }
      getReadBases() {
        if (!this.readBases && this._refRegion) {
          const e3 = (function(e4, t4) {
            if (!e4.lengthOnRef && !e4.readLength) return null;
            if (e4.isUnknownBases()) return null;
            const r3 = e4.alignmentStart - t4.start;
            if (!e4.readFeatures) return t4.seq.substr(r3, e4.lengthOnRef).toUpperCase();
            let n3 = "", i2 = r3, o2 = 0;
            for (; n3.length < e4.readLength; ) if (o2 < e4.readFeatures.length) {
              const r4 = e4.readFeatures[o2];
              if ("Q" === r4.code || "q" === r4.code) o2 += 1;
              else if (r4.pos === n3.length + 1) if (o2 += 1, "b" === r4.code) {
                const e5 = r4.data;
                n3 += e5, i2 += e5.length;
              } else "B" === r4.code ? (n3 += r4.data[0], i2 += 1) : "X" === r4.code ? (n3 += r4.sub, i2 += 1) : "I" === r4.code ? n3 += r4.data : "D" === r4.code ? i2 += r4.data : "i" === r4.code ? n3 += r4.data : "N" === r4.code ? i2 += r4.data : "S" === r4.code ? n3 += r4.data : "P" === r4.code || r4.code;
              else if (o2 < e4.readFeatures.length) {
                const r5 = t4.seq.substr(i2, e4.readFeatures[o2].pos - n3.length - 1);
                n3 += r5, i2 += r5.length;
              }
            } else {
              const r4 = t4.seq.substr(i2, e4.readLength - n3.length);
              n3 += r4, i2 += r4.length;
            }
            return n3.toUpperCase();
          })(this, this._refRegion);
          e3 && (this.readBases = e3);
        }
        return this.readBases;
      }
      getPairOrientation() {
        if (!this.isSegmentUnmapped() && this.isPaired() && !this.isMateUnmapped() && this.mate && this.sequenceId === this.mate.sequenceId) {
          const e3 = this.isReverseComplemented() ? "R" : "F", t4 = this.isMateReverseComplemented() ? "R" : "F";
          let r3 = " ", n3 = " ";
          this.isRead1() ? (r3 = "1", n3 = "2") : this.isRead2() && (r3 = "2", n3 = "1");
          const i2 = [];
          let o2 = this.templateLength || this.templateSize;
          if (void 0 === o2) throw new Error("One of templateSize and templateLength must be set");
          return this.alignmentStart > this.mate.alignmentStart && o2 > 0 && (o2 = -o2), o2 > 0 ? (i2[0] = e3, i2[1] = r3, i2[2] = t4, i2[3] = n3) : (i2[2] = e3, i2[3] = r3, i2[0] = t4, i2[1] = n3), i2.join("");
        }
        return null;
      }
      addReferenceSequence(e3, t4) {
        this.readFeatures && this.readFeatures.forEach(((r3) => {
          "X" === r3.code && (function(e4, t5, r4, n3) {
            if (!t5) return;
            const i2 = n3.refPos - t5.start, s2 = t5.seq.charAt(i2);
            s2 && (n3.ref = s2);
            let a = o[s2];
            void 0 === a && (a = 4);
            const f = r4.substitutionMatrix[a][n3.data];
            f && (n3.sub = f);
          })(0, e3, t4, r3);
        })), !this.readBases && e3.start <= this.alignmentStart && e3.end >= this.alignmentStart + (this.lengthOnRef || this.readLength) - 1 && (this._refRegion = e3);
      }
      toJSON() {
        const e3 = {};
        return Object.keys(this).forEach(((t4) => {
          "_" !== t4.charAt(0) && (e3[t4] = this[t4]);
        })), e3.readBases = this.getReadBases(), e3;
      }
    };
  }, 6141: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.getSectionParsers = t3.cramFileDefinition = t3.isMappedSliceHeader = void 0;
    const n2 = r2(9996), i = new n2.Parser().itf8(), o = { parser: new n2.Parser().string("magic", { length: 4 }).uint8("majorVersion").uint8("minorVersion").string("fileId", { length: 20, stripNull: true }), maxLength: 26 };
    t3.cramFileDefinition = o;
    const s = { parser: new n2.Parser().uint8("compressionMethod", { formatter: (e3) => {
      const t4 = ["raw", "gzip", "bzip2", "lzma", "rans", "rans4x16", "arith", "fqzcomp", "tok3"][e3];
      if (!t4) throw new Error(`compression method number ${e3} not implemented`);
      return t4;
    } }).uint8("contentType", { formatter: (e3) => {
      const t4 = ["FILE_HEADER", "COMPRESSION_HEADER", "MAPPED_SLICE_HEADER", "UNMAPPED_SLICE_HEADER", "EXTERNAL_DATA", "CORE_DATA"][e3];
      if (!t4) throw new Error(`invalid block content type id ${e3}`);
      return t4;
    } }).itf8("contentId").itf8("compressedSize").itf8("uncompressedSize"), maxLength: 17 }, a = { parser: new n2.Parser().uint32("crc32"), maxLength: 4 }, f = new n2.Parser().itf8("size").buffer("ents", { length: "size", formatter: (e3) => {
      function t4(t5, r4) {
        const n4 = e3.toString("utf8", t5, r4), i3 = [];
        for (let e4 = 0; e4 < n4.length; e4 += 3) i3.push(n4.substr(e4, 3));
        return i3;
      }
      var r3, n3 = [], i2 = 0;
      for (r3 = 0; r3 < e3.length; r3 += 1) e3[r3] || (n3.push(t4(i2, r3)), i2 = r3 + 1);
      return r3 > i2 && n3.push(t4(i2, r3)), n3;
    } }), h = new n2.Parser().uint8(null, { formatter: (e3) => !!e3 }), l = new n2.Parser().itf8("mapSize").itf8("mapCount").array("ents", { length: "mapCount", type: new n2.Parser().string("key", { length: 2, stripNull: false }).choice("value", { tag: "key", choices: { MI: h, UI: h, PI: h, RN: h, AP: h, RR: h, SM: new n2.Parser().array(null, { type: "uint8", length: 5 }), TD: new n2.Parser().nest(null, { type: f, formatter: (e3) => e3.ents }) } }) });
    function u(e3) {
      const t4 = {};
      for (let r3 = 0; r3 < e3.ents.length; r3 += 1) {
        const { key: n3, value: i2 } = e3.ents[r3];
        t4[n3] && console.warn(`duplicate key ${n3} in map`), t4[n3] = i2;
      }
      return t4;
    }
    const c = { cramFileDefinition: o, cramBlockHeader: s, cramBlockCrc32: a };
    t3.isMappedSliceHeader = function(e3) {
      return "number" == typeof e3.refSeqId;
    };
    const d = { cramUnmappedSliceHeader(e3) {
      let t4 = 0, r3 = new n2.Parser().itf8("numRecords");
      return t4 += 5, e3 >= 3 ? (r3 = r3.ltf8("recordCounter"), t4 += 9) : 2 === e3 && (r3 = r3.itf8("recordCounter"), t4 += 5), r3 = r3.itf8("numBlocks").itf8("numContentIds").array("contentIds", { type: i, length: "numContentIds" }), t4 += 10, e3 >= 2 && (r3 = r3.array("md5", { type: "uint8", length: 16 }), t4 += 16), { parser: r3, maxLength: (e4) => t4 + 5 * e4 };
    }, cramMappedSliceHeader(e3) {
      let t4 = new n2.Parser().itf8("refSeqId").itf8("refSeqStart").itf8("refSeqSpan").itf8("numRecords"), r3 = 20;
      return e3 >= 3 ? (t4 = t4.ltf8("recordCounter"), r3 += 9) : 2 === e3 && (t4 = t4.itf8("recordCounter"), r3 += 5), t4 = t4.itf8("numBlocks").itf8("numContentIds").array("contentIds", { type: i, length: "numContentIds" }).itf8("refBaseBlockId"), r3 += 15, e3 >= 2 && (t4 = t4.array("md5", { type: "uint8", length: 16 }), r3 += 16), { parser: t4, maxLength: (e4) => r3 + 5 * e4 };
    }, cramEncoding: (e3) => ({ parser: new n2.Parser().namely("cramEncoding").itf8("codecId").itf8("parametersBytes").choice("parameters", { tag: "codecId", choices: { 0: new n2.Parser(), 1: new n2.Parser().itf8("blockContentId"), 2: new n2.Parser().itf8("offset").itf8("M"), 3: n2.Parser.start().itf8("numCodes").array("symbols", { length: "numCodes", type: i }).itf8("numLengths").array("bitLengths", { length: "numLengths", type: i }), 4: n2.Parser.start().nest("lengthsEncoding", { type: "cramEncoding" }).nest("valuesEncoding", { type: "cramEncoding" }), 5: new n2.Parser().uint8("stopByte").itf8("blockContentId"), 6: new n2.Parser().itf8("offset").itf8("length"), 7: new n2.Parser().itf8("offset").itf8("K"), 8: new n2.Parser().itf8("offset").itf8("log2m"), 9: new n2.Parser().itf8("offset") } }) }), cramDataSeriesEncodingMap(e3) {
      return new n2.Parser().itf8("mapSize").itf8("mapCount").array("ents", { length: "mapCount", type: new n2.Parser().string("key", { length: 2, stripNull: false }).nest("value", { type: this.cramEncoding(e3).parser }) });
    }, cramTagEncodingMap(e3) {
      return new n2.Parser().itf8("mapSize").itf8("mapCount").array("ents", { length: "mapCount", type: new n2.Parser().itf8("key", { formatter: (e4) => String.fromCharCode(e4 >> 16 & 255) + String.fromCharCode(e4 >> 8 & 255) + String.fromCharCode(255 & e4) }).nest("value", { type: this.cramEncoding(e3).parser }) });
    }, cramCompressionHeader(e3) {
      let t4 = new n2.Parser();
      return t4 = t4.nest("preservation", { type: l, formatter: u }).nest("dataSeriesEncoding", { type: this.cramDataSeriesEncodingMap(e3), formatter: u }).nest("tagEncoding", { type: this.cramTagEncodingMap(e3), formatter: u }), { parser: t4 };
    }, cramContainerHeader1(e3) {
      let t4 = new n2.Parser().int32("length").itf8("refSeqId").itf8("refSeqStart").itf8("alignmentSpan").itf8("numRecords"), r3 = 24;
      return e3 >= 3 ? (t4 = t4.ltf8("recordCounter"), r3 += 9) : 2 === e3 && (t4 = t4.itf8("recordCounter"), r3 += 5), e3 > 1 && (t4 = t4.ltf8("numBases"), r3 += 9), t4 = t4.itf8("numBlocks").itf8("numLandmarks"), r3 += 10, { parser: t4, maxLength: r3 };
    }, cramContainerHeader2(e3) {
      let t4 = new n2.Parser().itf8("numLandmarks").array("landmarks", { type: new n2.Parser().itf8(), length: "numLandmarks" }), r3 = 0;
      return e3 >= 3 && (t4 = t4.uint32("crc32"), r3 = 4), { parser: t4, maxLength: (e4) => 5 + 5 * e4 + r3 };
    } };
    t3.getSectionParsers = function(e3) {
      const t4 = Object.assign({}, c);
      return Object.keys(d).forEach(((r3) => {
        t4[r3] = d[r3](e3);
      })), t4;
    };
  }, 3757: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = n2(r2(3720)), o = r2(8577), s = r2(8631), a = r2(6141);
    function f(e3) {
      let t4 = "";
      for (let r3 = 0; r3 < e3.length && 0 !== e3[r3]; r3++) t4 += String.fromCharCode(e3[r3]);
      return t4;
    }
    function h(e3, t4) {
      if ("Z" === e3) return f(t4);
      if ("A" === e3) return String.fromCharCode(t4[0]);
      if ("I" === e3) return i.default.fromBytesLE(t4).toNumber();
      if ("i" === e3) return new Int32Array(t4.buffer)[0];
      if ("s" === e3) return new Int16Array(t4.buffer)[0];
      if ("S" === e3) return new Uint16Array(t4.buffer)[0];
      if ("c" === e3) return new Int8Array(t4.buffer)[0];
      if ("C" === e3) return t4[0];
      if ("f" === e3) return new Float32Array(t4.buffer)[0];
      if ("H" === e3) return Number.parseInt(f(t4).replace(/^0x/, ""), 16);
      if ("B" === e3) return (function(e4) {
        const t5 = String.fromCharCode(e4[0]), r3 = Int32Array.from(e4.slice(1))[0], n3 = new Array(r3);
        if (e4 = e4.slice(5), "c" === t5) {
          const t6 = new Int8Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else if ("C" === t5) {
          const t6 = new Uint8Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else if ("s" === t5) {
          const t6 = new Int16Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else if ("S" === t5) {
          const t6 = new Uint16Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else if ("i" === t5) {
          const t6 = new Int32Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else if ("I" === t5) {
          const t6 = new Uint32Array(e4.buffer);
          for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
        } else {
          if ("f" !== t5) throw new Error("unknown type: " + t5);
          {
            const t6 = new Float32Array(e4.buffer);
            for (let e5 = 0; e5 < r3; e5 += 1) n3[e5] = t6[e5];
          }
        }
        return n3;
      })(t4);
      throw new o.CramMalformedError(`Unrecognized tag type ${e3}`);
    }
    t3.default = function(e3, t4, r3, n3, i2, l, u, c, d) {
      let p = t4("BF");
      const g = t4("CF");
      if (!(0, a.isMappedSliceHeader)(n3.parsedContent)) throw new Error();
      let m;
      m = c > 1 && -2 === n3.parsedContent.refSeqId ? t4("RI") : n3.parsedContent.refSeqId;
      const y = t4("RL");
      let b = t4("AP");
      r3.APdelta && (b += u.lastAlignmentStart), u.lastAlignmentStart = b;
      const v = t4("RG");
      let w, _, B, E;
      if (r3.readNamesIncluded && (w = f(t4("RN"))), s.CramFlagsDecoder.isDetached(g)) {
        const e4 = t4("MF");
        let n4;
        r3.readNamesIncluded || (n4 = f(t4("RN")), w = n4);
        const i3 = t4("NS"), o2 = t4("NP");
        (e4 || i3 > -1) && (_ = { mateFlags: e4, mateSequenceId: i3, mateAlignmentStart: o2, mateReadName: n4 }), B = t4("TS"), s.MateFlagsDecoder.isUnmapped(e4) && (p = s.BamFlagsDecoder.setMateUnmapped(p)), s.MateFlagsDecoder.isOnNegativeStrand(e4) && (p = s.BamFlagsDecoder.setMateReverseComplemented(p));
      } else s.CramFlagsDecoder.isWithMateDownstream(g) && (E = t4("NF") + d + 1);
      const S = t4("TL");
      if (S < 0) throw new o.CramMalformedError("invalid TL index");
      const A = {}, C = r3.getTagNames(S), R = C.length;
      for (let t5 = 0; t5 < R; t5 += 1) {
        const n4 = C[t5], s2 = n4.substr(0, 2), a2 = n4.substr(2, 1), f2 = r3.getCodecForTag(n4);
        if (!f2) throw new o.CramMalformedError(`no codec defined for auxiliary tag ${n4}`);
        const c2 = f2.decode(e3, i2, l, u);
        A[s2] = h(a2, c2);
      }
      let k, x, I, M, F;
      if (s.BamFlagsDecoder.isSegmentUnmapped(p)) if (s.CramFlagsDecoder.isDecodeSequenceAsStar(g)) F = null, M = null;
      else {
        const e4 = new Array(y);
        for (let r4 = 0; r4 < e4.length; r4 += 1) e4[r4] = t4("BA");
        if (F = String.fromCharCode(...e4), s.CramFlagsDecoder.isPreservingQualityScores(g)) {
          M = new Array(y);
          for (let r4 = 0; r4 < e4.length; r4 += 1) M[r4] = t4("QS");
        }
      }
      else {
        const e4 = t4("FN");
        if (e4 && (k = (function(e5, t5, r4, n4, i3) {
          let s2 = 0, a2 = e5 - 1;
          const f2 = new Array(t5);
          function h2([e6, t6]) {
            const n5 = r4(t6);
            if ("character" === e6) return String.fromCharCode(n5);
            if ("string" === e6) {
              let e7 = "";
              for (let t7 = 0; t7 < n5.byteLength; t7++) e7 += String.fromCharCode(n5[t7]);
              return e7;
            }
            return "numArray" === e6 ? n5.toArray() : n5;
          }
          for (let e6 = 0; e6 < t5; e6 += 1) {
            const t6 = String.fromCharCode(r4("FC")), n5 = r4("FP"), l2 = { B: ["character", "BA"], S: ["string", i3 > 1 ? "SC" : "IN"], X: ["number", "BS"], D: ["number", "DL"], I: ["string", "IN"], i: ["character", "BA"], b: ["string", "BB"], q: ["numArray", "QQ"], Q: ["number", "QS"], H: ["number", "HC"], P: ["number", "PD"], N: ["number", "RS"] }[t6];
            if (!l2) throw new o.CramMalformedError(`invalid read feature code "${t6}"`);
            let u2 = h2(l2);
            const c2 = { B: ["number", "QS"] }[t6];
            c2 && (u2 = [u2, h2(c2)]), s2 += n5;
            const d2 = s2;
            a2 += n5;
            const p2 = a2;
            "D" === t6 || "N" === t6 ? a2 += u2 : "I" === t6 || "S" === t6 ? a2 -= u2.length : "i" === t6 && (a2 -= 1), f2[e6] = { code: t6, pos: d2, refPos: p2, data: u2 };
          }
          return f2;
        })(b, e4, t4, 0, c)), x = y, k) for (const { code: e5, data: t5 } of k) "D" === e5 || "N" === e5 ? x += t5 : "I" === e5 || "S" === e5 ? x -= t5.length : "i" === e5 && (x -= 1);
        if (Number.isNaN(x) && (console.warn(`${w || `${m}:${b}`} record has invalid read features`), x = y), I = t4("MQ"), s.CramFlagsDecoder.isPreservingQualityScores(g)) {
          M = new Array(y);
          for (let e5 = 0; e5 < M.length; e5++) M[e5] = t4("QS");
        }
      }
      return { readLength: y, sequenceId: m, cramFlags: g, flags: p, alignmentStart: b, readGroupId: v, readName: w, mateToUse: _, templateSize: B, mateRecordNumber: E, readFeatures: k, lengthOnRef: x, mappingQuality: I, qualityScores: M, readBases: F, tags: A };
    };
  }, 6601: function(e2, t3, r2) {
    var n2 = this && this.__awaiter || function(e3, t4, r3, n3) {
      return new (r3 || (r3 = Promise))((function(i2, o2) {
        function s2(e4) {
          try {
            f2(n3.next(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function a2(e4) {
          try {
            f2(n3.throw(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function f2(e4) {
          var t5;
          e4.done ? i2(e4.value) : (t5 = e4.value, t5 instanceof r3 ? t5 : new r3((function(e5) {
            e5(t5);
          }))).then(s2, a2);
        }
        f2((n3 = n3.apply(e3, t4 || [])).next());
      }));
    }, i = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const o = r2(8577), s = r2(9488), a = i(r2(2615)), f = i(r2(3757)), h = i(r2(8631)), l = r2(6141), u = r2(1074);
    function c(e3, t4, r3, n3) {
      if (!n3) throw new o.CramMalformedError("could not resolve intra-slice mate pairs, file seems truncated or malformed");
      const i2 = !!(n3.mate || void 0 !== n3.mateRecordNumber && n3.mateRecordNumber !== t4);
      r3.readName || (r3.readName = String(r3.uniqueId), n3.readName = r3.readName), r3.mate = { sequenceId: n3.sequenceId, alignmentStart: n3.alignmentStart, uniqueId: n3.uniqueId }, n3.readName && (r3.mate.readName = n3.readName), n3.mate || void 0 !== n3.mateRecordNumber || (n3.mate = { sequenceId: r3.sequenceId, alignmentStart: r3.alignmentStart, uniqueId: r3.uniqueId }, r3.readName && (n3.mate.readName = r3.readName)), r3.flags |= a.default.BAM_FPAIRED, n3.flags & a.default.BAM_FUNMAP && (r3.flags |= a.default.BAM_FMUNMAP), r3.flags & a.default.BAM_FUNMAP && (n3.flags |= a.default.BAM_FMUNMAP), n3.flags & a.default.BAM_FREVERSE && (r3.flags |= a.default.BAM_FMREVERSE), r3.flags & a.default.BAM_FREVERSE && (n3.flags |= a.default.BAM_FMREVERSE), void 0 === r3.templateLength && (i2 ? (function(e4, t5, r4) {
        const n4 = (function t6(r5) {
          const n5 = [r5];
          if (void 0 !== r5.mateRecordNumber && r5.mateRecordNumber >= 0) {
            const i4 = e4[r5.mateRecordNumber];
            if (!i4) throw new o.CramMalformedError("intra-slice mate record not found, this file seems malformed");
            n5.push(...t6(i4));
          }
          return n5;
        })(r4), i3 = n4.map(((e5) => e5.alignmentStart)), s2 = n4.map(((e5) => e5.alignmentStart + e5.readLength - 1)), a2 = Math.max(...s2) - Math.min(...i3) + 1;
        a2 >= 0 && n4.forEach(((e5) => {
          if (void 0 !== e5.templateLength) throw new o.CramMalformedError("mate pair group has some members that have template lengths already, this file seems malformed");
          e5.templateLength = a2;
        }));
      })(e3, 0, r3) : (function(e4, t5) {
        const r4 = Math.min(e4.alignmentStart, t5.alignmentStart), n4 = Math.max(e4.alignmentStart + e4.readLength - 1, t5.alignmentStart + t5.readLength - 1) - r4 + 1;
        e4.templateLength = n4, t5.templateLength = n4;
      })(r3, n3)), delete r3.mateRecordNumber;
    }
    class d {
      constructor(e3, t4, r3) {
        this.container = e3, this.containerPosition = t4, this.file = e3.file;
      }
      getHeader() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.file.getSectionParsers(), t4 = yield this.container.getHeader(), r3 = yield this.file.readBlock(t4._endPosition + this.containerPosition);
          if (void 0 === r3) throw new Error();
          if ("MAPPED_SLICE_HEADER" === r3.contentType) {
            const n3 = (0, s.parseItem)(r3.content, e3.cramMappedSliceHeader.parser, 0, t4._endPosition);
            return Object.assign(Object.assign({}, r3), { parsedContent: n3 });
          }
          if ("UNMAPPED_SLICE_HEADER" === r3.contentType) {
            const n3 = (0, s.parseItem)(r3.content, e3.cramUnmappedSliceHeader.parser, 0, t4._endPosition);
            return Object.assign(Object.assign({}, r3), { parsedContent: n3 });
          }
          throw new o.CramMalformedError(`error reading slice header block, invalid content type ${r3.contentType}`);
        }));
      }
      getBlocks() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getHeader();
          let t4 = e3._endPosition;
          const r3 = new Array(e3.parsedContent.numBlocks);
          for (let e4 = 0; e4 < r3.length; e4 += 1) {
            const n3 = yield this.file.readBlock(t4);
            if (void 0 === n3) throw new Error();
            r3[e4] = n3, t4 = r3[e4]._endPosition;
          }
          return r3;
        }));
      }
      getCoreDataBlock() {
        return n2(this, void 0, void 0, (function* () {
          return (yield this.getBlocks())[0];
        }));
      }
      _getBlocksContentIdIndex() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = yield this.getBlocks(), t4 = {};
          return e3.forEach(((e4) => {
            "EXTERNAL_DATA" === e4.contentType && (t4[e4.contentId] = e4);
          })), t4;
        }));
      }
      getBlockByContentId(e3) {
        return n2(this, void 0, void 0, (function* () {
          return (yield this._getBlocksContentIdIndex())[e3];
        }));
      }
      getReferenceRegion() {
        return n2(this, void 0, void 0, (function* () {
          const e3 = (yield this.getHeader()).parsedContent;
          if (!(0, l.isMappedSliceHeader)(e3)) throw new Error();
          if (e3.refSeqId < 0) return;
          const t4 = yield this.container.getCompressionScheme();
          if (void 0 === t4) throw new Error();
          if (e3.refBaseBlockId >= 0) {
            const t5 = yield this.getBlockByContentId(e3.refBaseBlockId);
            if (!t5) throw new o.CramMalformedError("embedded reference specified, but reference block does not exist");
            return { seq: t5.data.toString("utf8"), start: e3.refSeqStart, end: e3.refSeqStart + e3.refSeqSpan - 1, span: e3.refSeqSpan };
          }
          if (t4.referenceRequired || this.file.fetchReferenceSequenceCallback) {
            if (!this.file.fetchReferenceSequenceCallback) throw new Error("reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence");
            const t5 = yield this.file.fetchReferenceSequenceCallback(e3.refSeqId, e3.refSeqStart, e3.refSeqStart + e3.refSeqSpan - 1);
            if (t5.length !== e3.refSeqSpan) throw new o.CramArgumentError("seqFetch callback returned a reference sequence of the wrong length");
            return { seq: t5, start: e3.refSeqStart, end: e3.refSeqStart + e3.refSeqSpan - 1, span: e3.refSeqSpan };
          }
        }));
      }
      getAllRecords() {
        return this.getRecords((() => true));
      }
      _fetchRecords() {
        return n2(this, void 0, void 0, (function* () {
          const { majorVersion: e3 } = yield this.file.getDefinition(), t4 = yield this.container.getCompressionScheme();
          if (void 0 === t4) throw new Error();
          const r3 = yield this.getHeader();
          if (void 0 === r3) throw new Error();
          const n3 = yield this._getBlocksContentIdIndex();
          if (e3 > 1 && this.file.options.checkSequenceMD5 && (0, l.isMappedSliceHeader)(r3.parsedContent) && r3.parsedContent.refSeqId >= 0 && "0000000000000000" !== r3.parsedContent.md5.join("")) {
            const e4 = yield this.getReferenceRegion();
            if (e4) {
              const { seq: t5, start: n4, end: i3 } = e4, a3 = (0, s.sequenceMD5)(t5), f2 = r3.parsedContent.md5.map(((e5) => (e5 < 16 ? "0" : "") + e5.toString(16))).join("");
              if (a3 !== f2) throw new o.CramMalformedError(`MD5 checksum reference mismatch for ref ${r3.parsedContent.refSeqId} pos ${n4}..${i3}. recorded MD5: ${f2}, calculated MD5: ${a3}`);
            }
          }
          const i2 = yield this.getCoreDataBlock(), a2 = { lastAlignmentStart: (0, l.isMappedSliceHeader)(r3.parsedContent) ? r3.parsedContent.refSeqStart : 0, coreBlock: { bitPosition: 7, bytePosition: 0 }, externalBlocks: { map: /* @__PURE__ */ new Map(), getCursor(e4) {
            let t5 = this.map.get(e4);
            return void 0 === t5 && (t5 = { bitPosition: 7, bytePosition: 0 }, this.map.set(e4, t5)), t5;
          } } }, d2 = (e4) => {
            const r4 = t4.getCodecForDataSeries(e4);
            if (!r4) throw new o.CramMalformedError(`no codec defined for ${e4} data series`);
            return r4.decode(this, i2, n3, a2);
          };
          let p = new Array(r3.parsedContent.numRecords);
          for (let o2 = 0; o2 < p.length; o2 += 1) try {
            const s2 = (0, f.default)(this, d2, t4, r3, i2, n3, a2, e3, o2);
            p[o2] = new h.default(Object.assign(Object.assign({}, s2), { uniqueId: r3.contentPosition + r3.parsedContent.recordCounter + o2 + 1 }));
          } catch (e4) {
            if (e4 instanceof u.CramBufferOverrunError) {
              console.warn("read attempted beyond end of buffer, file seems truncated."), p = p.filter(((e5) => !!e5));
              break;
            }
            throw e4;
          }
          for (let e4 = 0; e4 < p.length; e4 += 1) {
            const { mateRecordNumber: t5 } = p[e4];
            void 0 !== t5 && t5 >= 0 && c(p, e4, p[e4], p[t5]);
          }
          return p;
        }));
      }
      getRecords(e3) {
        return n2(this, void 0, void 0, (function* () {
          const t4 = this.container.filePosition + this.containerPosition;
          let r3 = this.file.featureCache.get(t4.toString());
          r3 || (r3 = this._fetchRecords(), this.file.featureCache.set(t4.toString(), r3));
          const i2 = (yield r3).filter(e3);
          if (i2.length && this.file.fetchReferenceSequenceCallback) {
            const e4 = yield this.getHeader();
            if ((0, l.isMappedSliceHeader)(e4.parsedContent) && (e4.parsedContent.refSeqId >= 0 || -2 === e4.parsedContent.refSeqId)) {
              const t5 = e4.parsedContent.refSeqId >= 0 ? e4.parsedContent.refSeqId : void 0, r4 = yield this.container.getCompressionScheme();
              if (void 0 === r4) throw new Error();
              const o2 = {};
              for (let e5 = 0; e5 < i2.length; e5 += 1) {
                const r5 = void 0 !== t5 ? t5 : i2[e5].sequenceId;
                let n3 = o2[r5];
                n3 || (n3 = { id: r5, start: i2[e5].alignmentStart, end: -1 / 0, seq: null }, o2[r5] = n3);
                const s2 = i2[e5].alignmentStart + (i2[e5].lengthOnRef || i2[e5].readLength) - 1;
                s2 > n3.end && (n3.end = s2), i2[e5].alignmentStart < n3.start && (n3.start = i2[e5].alignmentStart);
              }
              yield Promise.all(Object.values(o2).map(((e5) => n2(this, void 0, void 0, (function* () {
                -1 !== e5.id && e5.start <= e5.end && (e5.seq = yield this.file.fetchReferenceSequenceCallback(e5.id, e5.start, e5.end));
              })))));
              for (let e5 = 0; e5 < i2.length; e5 += 1) {
                const n3 = o2[void 0 !== t5 ? t5 : i2[e5].sequenceId];
                if (n3 && n3.seq) {
                  const t6 = n3.seq;
                  i2[e5].addReferenceSequence(Object.assign(Object.assign({}, n3), { seq: t6 }), r4);
                }
              }
            }
          }
          return i2;
        }));
      }
    }
    t3.default = d, "getHeader getBlocks _getBlocksContentIdIndex".split(" ").forEach(((e3) => (0, s.tinyMemoize)(d, e3)));
  }, 9488: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.sequenceMD5 = t3.tinyMemoize = t3.parseItem = t3.parseItf8 = t3.itf8Size = void 0;
    const i = n2(r2(2568)), o = r2(1074);
    t3.itf8Size = function(e3) {
      return -128 & e3 ? -16384 & e3 ? -2097152 & e3 ? -268435456 & e3 ? 5 : 4 : 3 : 2 : 1;
    }, t3.parseItf8 = function(e3, t4) {
      let r3 = t4;
      const n3 = e3[r3];
      let i2;
      if (n3 < 128 ? (i2 = n3, r3 += 1) : n3 < 192 ? (i2 = 16383 & (n3 << 8 | e3[r3 + 1]), r3 += 2) : n3 < 224 ? (i2 = 2097151 & (n3 << 16 | e3[r3 + 1] << 8 | e3[r3 + 2]), r3 += 3) : n3 < 240 ? (i2 = 268435455 & (n3 << 24 | e3[r3 + 1] << 16 | e3[r3 + 2] << 8 | e3[r3 + 3]), r3 += 4) : (i2 = (15 & n3) << 28 | e3[r3 + 1] << 20 | e3[r3 + 2] << 12 | e3[r3 + 3] << 4 | 15 & e3[r3 + 4], r3 += 5), r3 > e3.length) throw new o.CramBufferOverrunError("Attempted to read beyond end of buffer; this file seems truncated.");
      return [i2, r3 - t4];
    }, t3.parseItem = function(e3, t4, r3 = 0, n3 = 0) {
      const { offset: i2, result: o2 } = t4.parse(e3);
      return Object.assign(Object.assign({}, o2), { _endPosition: i2 + n3, _size: i2 - r3 });
    }, t3.tinyMemoize = function(e3, t4) {
      const r3 = e3.prototype[t4], n3 = `_memo_${t4}`;
      e3.prototype[t4] = function() {
        if (!(n3 in this)) {
          const e4 = r3.call(this);
          this[n3] = e4, Promise.resolve(e4).catch((() => {
            delete this[n3];
          }));
        }
        return this[n3];
      };
    }, t3.sequenceMD5 = function(e3) {
      return (0, i.default)(e3.toUpperCase().replace(/[^\x21-\x7e]/g, ""));
    };
  }, 8577: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.CramArgumentError = t3.CramSizeLimitError = t3.CramMalformedError = t3.CramUnimplementedError = t3.CramError = void 0;
    class r2 extends Error {
    }
    t3.CramError = r2;
    class n2 extends Error {
    }
    t3.CramUnimplementedError = n2, t3.CramMalformedError = class extends r2 {
    }, t3.CramSizeLimitError = class extends r2 {
    }, t3.CramArgumentError = class extends r2 {
    };
  }, 5590: function(e2, t3, r2) {
    var n2 = this && this.__createBinding || (Object.create ? function(e3, t4, r3, n3) {
      void 0 === n3 && (n3 = r3);
      var i2 = Object.getOwnPropertyDescriptor(t4, r3);
      i2 && !("get" in i2 ? !t4.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
        return t4[r3];
      } }), Object.defineProperty(e3, n3, i2);
    } : function(e3, t4, r3, n3) {
      void 0 === n3 && (n3 = r3), e3[n3] = t4[r3];
    }), i = this && this.__setModuleDefault || (Object.create ? function(e3, t4) {
      Object.defineProperty(e3, "default", { enumerable: true, value: t4 });
    } : function(e3, t4) {
      e3.default = t4;
    }), o = this && this.__importStar || function(e3) {
      if (e3 && e3.__esModule) return e3;
      var t4 = {};
      if (null != e3) for (var r3 in e3) "default" !== r3 && Object.prototype.hasOwnProperty.call(e3, r3) && n2(t4, e3, r3);
      return i(t4, e3), t4;
    }, s = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.CramRecord = t3.CraiIndex = t3.IndexedCramFile = t3.CramFile = void 0;
    const a = o(r2(8222));
    t3.CramFile = a.default, Object.defineProperty(t3, "CramRecord", { enumerable: true, get: function() {
      return a.CramRecord;
    } });
    const f = s(r2(946));
    t3.IndexedCramFile = f.default;
    const h = s(r2(368));
    t3.CraiIndex = h.default;
  }, 946: function(e2, t3, r2) {
    var n2 = this && this.__awaiter || function(e3, t4, r3, n3) {
      return new (r3 || (r3 = Promise))((function(i2, o2) {
        function s2(e4) {
          try {
            f(n3.next(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function a(e4) {
          try {
            f(n3.throw(e4));
          } catch (e5) {
            o2(e5);
          }
        }
        function f(e4) {
          var t5;
          e4.done ? i2(e4.value) : (t5 = e4.value, t5 instanceof r3 ? t5 : new r3((function(e5) {
            e5(t5);
          }))).then(s2, a);
        }
        f((n3 = n3.apply(e3, t4 || [])).next());
      }));
    }, i = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const o = r2(8577), s = i(r2(8222));
    t3.default = class {
      constructor(e3) {
        if (e3.cram ? this.cram = e3.cram : this.cram = new s.default({ url: e3.cramUrl, path: e3.cramPath, filehandle: e3.cramFilehandle, seqFetch: e3.seqFetch, checkSequenceMD5: e3.checkSequenceMD5, cacheSize: e3.cacheSize }), !(this.cram instanceof s.default)) throw new Error("invalid arguments: no cramfile");
        if (this.index = e3.index, !this.index.getEntriesForRange) throw new Error("invalid arguments: not an index");
        this.fetchSizeLimit = e3.fetchSizeLimit || 3e6;
      }
      getRecordsForRange(e3, t4, r3, i2 = {}) {
        return n2(this, void 0, void 0, (function* () {
          if (i2.viewAsPairs = i2.viewAsPairs || false, i2.pairAcrossChr = i2.pairAcrossChr || false, i2.maxInsertSize = i2.maxInsertSize || 2e5, "string" == typeof e3) throw new o.CramUnimplementedError("string sequence names not yet supported");
          const n3 = e3, s2 = yield this.index.getEntriesForRange(n3, t4, r3), a = s2.map(((e4) => e4.sliceBytes)).reduce(((e4, t5) => e4 + t5), 0);
          if (a > this.fetchSizeLimit) throw new o.CramSizeLimitError(`data size of ${a.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);
          const f = (n4) => n4.sequenceId === e3 && n4.alignmentStart <= r3 && void 0 !== n4.lengthOnRef && n4.alignmentStart + n4.lengthOnRef - 1 >= t4, h = yield Promise.all(s2.map(((e4) => this.getRecordsInSlice(e4, f))));
          let l = Array.prototype.concat(...h);
          if (i2.viewAsPairs) {
            const e4 = {}, t5 = {};
            for (let r5 = 0; r5 < l.length; r5 += 1) {
              const n4 = l[r5].readName;
              if (void 0 === n4) throw new Error();
              const i3 = l[r5].uniqueId;
              e4[n4] || (e4[n4] = 0), e4[n4] += 1, t5[i3] = 1;
            }
            const r4 = {};
            Object.entries(e4).forEach((([e5, t6]) => {
              1 === t6 && (r4[e5] = true);
            }));
            const o2 = [];
            for (let e5 = 0; e5 < l.length; e5 += 1) {
              const t6 = l[e5], s4 = t6.readName;
              if (void 0 === s4) throw new Error();
              if (r4[s4] && t6.mate && (t6.mate.sequenceId === n3 || i2.pairAcrossChr) && Math.abs(t6.alignmentStart - t6.mate.alignmentStart) < i2.maxInsertSize) {
                const e6 = this.index.getEntriesForRange(t6.mate.sequenceId, t6.mate.alignmentStart, t6.mate.alignmentStart + 1);
                o2.push(e6);
              }
            }
            const s3 = yield Promise.all(o2);
            let a2 = [];
            for (let e5 = 0; e5 < s3.length; e5 += 1) a2.push(...s3[e5]);
            a2 = a2.sort(((e5, t6) => e5.toString().localeCompare(t6.toString()))).filter(((e5, t6, r5) => !t6 || e5.toString() !== r5[t6 - 1].toString()));
            const h2 = [], u = a2.map(((e5) => e5.sliceBytes)).reduce(((e5, t6) => e5 + t6), 0);
            if (u > this.fetchSizeLimit) throw new Error(`mate data size of ${u.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`);
            a2.forEach(((e5) => {
              let n4 = this.cram.featureCache.get(e5.toString());
              n4 || (n4 = this.getRecordsInSlice(e5, (() => true)), this.cram.featureCache.set(e5.toString(), n4));
              const i3 = n4.then(((e6) => {
                const n5 = [];
                for (let i4 = 0; i4 < e6.length; i4 += 1) {
                  const o3 = e6[i4];
                  if (void 0 === o3.readName) throw new Error();
                  r4[o3.readName] && !t5[o3.uniqueId] && n5.push(o3);
                }
                return n5;
              }));
              h2.push(i3);
            }));
            const c = yield Promise.all(h2);
            if (c.length) {
              const e5 = c.reduce(((e6, t6) => e6.concat(t6)));
              l = l.concat(e5);
            }
          }
          return l;
        }));
      }
      getRecordsInSlice({ containerStart: e3, sliceStart: t4, sliceBytes: r3 }, n3) {
        return this.cram.getContainerAtPosition(e3).getSlice(t4, r3).getRecords(n3);
      }
      hasDataForReferenceSequence(e3) {
        return this.index.hasDataForReferenceSequence(e3);
      }
    };
  }, 3427: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.open = t3.fromUrl = t3.RemoteFile = t3.LocalFile = void 0;
    const i = n2(r2(8575)), o = r2(4319), s = r2(2949);
    function a(e3) {
      const { protocol: t4, pathname: r3 } = i.default.parse(e3);
      return "file:" === t4 ? new s.LocalFile(unescape((0, o.ensureNotNullish)(r3))) : new s.RemoteFile(e3);
    }
    Object.defineProperty(t3, "LocalFile", { enumerable: true, get: function() {
      return s.LocalFile;
    } }), Object.defineProperty(t3, "RemoteFile", { enumerable: true, get: function() {
      return s.RemoteFile;
    } }), t3.fromUrl = a, t3.open = function(e3, t4, r3) {
      if (r3) return r3;
      if (e3) return a(e3);
      if (t4) return new s.LocalFile(t4);
      throw new Error("no url, path, or filehandle provided, cannot open");
    };
  }, 5702: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.RANS_BYTE_L = t3.TOTFREQ = t3.TF_SHIFT = void 0, t3.TF_SHIFT = 12, t3.TOTFREQ = 4096, t3.RANS_BYTE_L = 1 << 23;
  }, 6484: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = r2(5702), s = n2(r2(7634));
    t3.default = function(e3, t4, r3, n3) {
      let a = e3.getInt(), f = e3.getInt(), h = e3.getInt(), l = e3.getInt();
      const u = n3.remaining(), c = -4 & u;
      for (let i2 = 0; i2 < c; i2 += 4) {
        const u2 = t4.R[s.default.get(a, o.TF_SHIFT)], c2 = t4.R[s.default.get(f, o.TF_SHIFT)], d2 = t4.R[s.default.get(h, o.TF_SHIFT)], p = t4.R[s.default.get(l, o.TF_SHIFT)];
        n3.putAt(i2, u2), n3.putAt(i2 + 1, c2), n3.putAt(i2 + 2, d2), n3.putAt(i2 + 3, p), a = s.default.advanceSymbolStep(a, r3[255 & u2], o.TF_SHIFT), f = s.default.advanceSymbolStep(f, r3[255 & c2], o.TF_SHIFT), h = s.default.advanceSymbolStep(h, r3[255 & d2], o.TF_SHIFT), l = s.default.advanceSymbolStep(l, r3[255 & p], o.TF_SHIFT), a = s.default.renormalize(a, e3), f = s.default.renormalize(f, e3), h = s.default.renormalize(h, e3), l = s.default.renormalize(l, e3);
      }
      let d;
      switch (n3.setPosition(c), 3 & u) {
        case 0:
          break;
        case 1:
          d = t4.R[s.default.get(a, o.TF_SHIFT)], s.default.advanceSymbol(a, e3, r3[255 & d], o.TF_SHIFT), n3.put(d);
          break;
        case 2:
          d = t4.R[s.default.get(a, o.TF_SHIFT)], s.default.advanceSymbol(a, e3, r3[255 & d], o.TF_SHIFT), n3.put(d), d = t4.R[s.default.get(f, o.TF_SHIFT)], s.default.advanceSymbol(f, e3, r3[255 & d], o.TF_SHIFT), n3.put(d);
          break;
        case 3:
          d = t4.R[s.default.get(a, o.TF_SHIFT)], s.default.advanceSymbol(a, e3, r3[255 & d], o.TF_SHIFT), n3.put(d), d = t4.R[s.default.get(f, o.TF_SHIFT)], s.default.advanceSymbol(f, e3, r3[255 & d], o.TF_SHIFT), n3.put(d), d = t4.R[s.default.get(h, o.TF_SHIFT)], s.default.advanceSymbol(h, e3, r3[255 & d], o.TF_SHIFT), n3.put(d);
          break;
        default:
          throw new i.CramMalformedError("invalid output size encountered during rANS decoding");
      }
      n3.setPosition(0);
    };
  }, 7121: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(5702), o = n2(r2(7634));
    t3.default = function(e3, t4, r3, n3) {
      const s = t4.remaining();
      let a = e3.getInt(), f = e3.getInt(), h = e3.getInt(), l = e3.getInt();
      const u = s >> 2;
      let c = 0, d = u, p = 2 * u, g = 3 * u, m = 0, y = 0, b = 0, v = 0;
      for (; c < u; c += 1, d += 1, p += 1, g += 1) {
        const s2 = 255 & r3[m].R[o.default.get(a, i.TF_SHIFT)], u2 = 255 & r3[y].R[o.default.get(f, i.TF_SHIFT)], w = 255 & r3[b].R[o.default.get(h, i.TF_SHIFT)], _ = 255 & r3[v].R[o.default.get(l, i.TF_SHIFT)];
        t4.putAt(c, s2), t4.putAt(d, u2), t4.putAt(p, w), t4.putAt(g, _), a = o.default.advanceSymbolStep(a, n3[m][s2], i.TF_SHIFT), f = o.default.advanceSymbolStep(f, n3[y][u2], i.TF_SHIFT), h = o.default.advanceSymbolStep(h, n3[b][w], i.TF_SHIFT), l = o.default.advanceSymbolStep(l, n3[v][_], i.TF_SHIFT), a = o.default.renormalize(a, e3), f = o.default.renormalize(f, e3), h = o.default.renormalize(h, e3), l = o.default.renormalize(l, e3), m = s2, y = u2, b = w, v = _;
      }
      for (; g < s; g += 1) {
        const s2 = 255 & r3[v].R[o.default.get(l, i.TF_SHIFT)];
        t4.putAt(g, s2), l = o.default.advanceSymbol(l, e3, n3[v][s2], i.TF_SHIFT), v = s2;
      }
    };
  }, 7634: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true });
    const n2 = r2(8577), i = r2(5702);
    class o {
      constructor() {
        this.F = void 0, this.C = void 0;
      }
    }
    function s(e3, t4, r3, n3) {
      return r3 * (e3 >> n3) + (e3 & (1 << n3) - 1) - t4;
    }
    const a = { FC: o, AriDecoder: class {
      constructor() {
        this.fc = new Array(256);
        for (let e3 = 0; e3 < this.fc.length; e3 += 1) this.fc[e3] = new o();
        this.R = null;
      }
    }, Symbol: class {
      constructor() {
        this.start = void 0, this.freq = void 0;
      }
    }, symbolInit: function(e3, t4, r3) {
      if (!(t4 <= 65536)) throw new n2.CramMalformedError("assertion failed: start <= 1<<16");
      if (!(r3 <= 65536 - t4)) throw new n2.CramMalformedError("assertion failed: freq <= 1<<16");
      e3.start = t4, e3.freq = r3;
    }, advanceStep: s, advanceSymbolStep: function(e3, t4, r3) {
      return s(e3, t4.start, t4.freq, r3);
    }, get: function(e3, t4) {
      return e3 & (1 << t4) - 1;
    }, advanceSymbol: function(e3, t4, r3, n3) {
      return (function(e4, t5, r4, n4, o2) {
        if ((e4 = n4 * (e4 >> o2) + (e4 & (1 << o2) - 1) - r4) < i.RANS_BYTE_L) do {
          e4 = e4 << 8 | 255 & t5.get();
        } while (e4 < i.RANS_BYTE_L);
        return e4;
      })(e3, t4, r3.start, r3.freq, n3);
    }, renormalize: function(e3, t4) {
      if (e3 < i.RANS_BYTE_L) do {
        e3 = e3 << 8 | 255 & t4.get();
      } while (e3 < i.RANS_BYTE_L);
      return e3;
    } };
    t3.default = a;
  }, 696: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true }), t3.readStatsO1 = t3.readStatsO0 = void 0;
    const i = r2(8577), o = r2(5702), s = n2(r2(7634));
    function a(e3) {
      if (!e3) throw new i.CramMalformedError("assertion failed");
    }
    t3.readStatsO0 = function(e3, t4, r3) {
      let n3 = 0, i2 = 0, f = 255 & e3.get();
      do {
        null == t4.fc[f] && (t4.fc[f] = new s.default.FC()), t4.fc[f].F = 255 & e3.get(), t4.fc[f].F >= 128 && (t4.fc[f].F &= -129, t4.fc[f].F = (127 & t4.fc[f].F) << 8 | 255 & e3.get()), t4.fc[f].C = i2, s.default.symbolInit(r3[f], t4.fc[f].C, t4.fc[f].F), t4.R || (t4.R = new Array(o.TOTFREQ)), t4.R.fill(f, i2, i2 + t4.fc[f].F), i2 += t4.fc[f].F, 0 === n3 && f + 1 === (255 & e3.getByteAt(e3.position())) ? (f = 255 & e3.get(), n3 = 255 & e3.get()) : 0 !== n3 ? (n3 -= 1, f += 1) : f = 255 & e3.get();
      } while (0 !== f);
      a(i2 < o.TOTFREQ);
    }, t3.readStatsO1 = function(e3, t4, r3) {
      let n3 = 0, i2 = 255 & e3.get();
      do {
        let f = 0, h = 0, l = 255 & e3.get();
        null == t4[i2] && (t4[i2] = new s.default.AriDecoder());
        do {
          null == t4[i2].fc[l] && (t4[i2].fc[l] = new s.default.FC()), t4[i2].fc[l].F = 255 & e3.get(), t4[i2].fc[l].F >= 128 && (t4[i2].fc[l].F &= -129, t4[i2].fc[l].F = (127 & t4[i2].fc[l].F) << 8 | 255 & e3.get()), t4[i2].fc[l].C = h, 0 === t4[i2].fc[l].F && (t4[i2].fc[l].F = o.TOTFREQ), null == r3[i2][l] && (r3[i2][l] = new s.default.RansDecSymbol()), s.default.symbolInit(r3[i2][l], t4[i2].fc[l].C, t4[i2].fc[l].F), null == t4[i2].R && (t4[i2].R = new Array(o.TOTFREQ)), t4[i2].R.fill(l, h, h + t4[i2].fc[l].F), h += t4[i2].fc[l].F, a(h <= o.TOTFREQ), 0 === f && l + 1 === (255 & e3.getByteAt(e3.position())) ? (l = 255 & e3.get(), f = 255 & e3.get()) : 0 !== f ? (f -= 1, l += 1) : l = 255 & e3.get();
        } while (0 !== l);
        0 === n3 && i2 + 1 === (255 & e3.getByteAt(e3.position())) ? (i2 = 255 & e3.get(), n3 = 255 & e3.get()) : 0 !== n3 ? (n3 -= 1, i2 += 1) : i2 = 255 & e3.get();
      } while (0 !== i2);
    };
  }, 9675: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8577), o = n2(r2(7634)), s = r2(696), a = n2(r2(6484)), f = n2(r2(7121));
    class h {
      constructor(e3, t4 = 0) {
        this._buffer = e3, this._position = t4, this.length = e3.length;
      }
      get() {
        const e3 = this._buffer[this._position];
        return this._position += 1, e3;
      }
      getByte() {
        return this.get();
      }
      getByteAt(e3) {
        return this._buffer[e3];
      }
      position() {
        return this._position;
      }
      put(e3) {
        return this._buffer[this._position] = e3, this._position += 1, e3;
      }
      putAt(e3, t4) {
        return this._buffer[e3] = t4, t4;
      }
      setPosition(e3) {
        return this._position = e3, e3;
      }
      getInt() {
        const e3 = this._buffer.readInt32LE(this._position);
        return this._position += 4, e3;
      }
      remaining() {
        return this._buffer.length - this._position;
      }
    }
    t3.default = function(e3, t4, r3 = 0) {
      if (0 === e3.length) return t4.fill(0), t4;
      const n3 = new h(e3, r3), l = n3.get();
      if (0 !== l && 1 !== l) throw new i.CramMalformedError(`Invalid rANS order ${l}`);
      if (n3.getInt() !== n3.remaining() - 4) throw new i.CramMalformedError("Incorrect input length.");
      const u = n3.getInt(), c = new h(t4 || Buffer.allocUnsafe(u));
      if (c.length < u) throw new i.CramMalformedError(`Output buffer too small to fit ${u} bytes.`);
      switch (l) {
        case 0:
          return (function(e4, t5) {
            const r4 = new o.default.AriDecoder(), n4 = new Array(256);
            for (let e5 = 0; e5 < n4.length; e5 += 1) n4[e5] = new o.default.Symbol();
            return (0, s.readStatsO0)(e4, r4, n4), (0, a.default)(e4, r4, n4, t5), t5;
          })(n3, c);
        case 1:
          return (function(e4, t5) {
            const r4 = new Array(256);
            for (let e5 = 0; e5 < r4.length; e5 += 1) r4[e5] = new o.default.AriDecoder();
            const n4 = new Array(256);
            for (let e5 = 0; e5 < n4.length; e5 += 1) {
              n4[e5] = new Array(256);
              for (let t6 = 0; t6 < n4[e5].length; t6 += 1) n4[e5][t6] = new o.default.Symbol();
            }
            return (0, s.readStatsO1)(e4, r4, n4), (0, f.default)(e4, t5, r4, n4), t5;
          })(n3, c);
        default:
          throw new i.CramMalformedError(`Invalid rANS order: ${l}`);
      }
    };
  }, 7578: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.parseHeaderText = void 0, t3.parseHeaderText = function(e3) {
      const t4 = e3.split(/\r?\n/), r2 = [];
      return t4.forEach(((e4) => {
        const [t5, ...n2] = e4.split(/\t/), i = n2.map(((e5) => {
          const [t6, r3] = e5.split(":", 2);
          return { tag: t6, value: r3 };
        }));
        t5 && r2.push({ tag: t5.substr(1), data: i });
      })), r2;
    };
  }, 4319: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.ensureNotNullish = void 0, t3.ensureNotNullish = function(e3) {
      if (null == e3) throw new Error("Value must not be nullish.");
      return e3;
    };
  }, 597: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.unzip = void 0;
    const n2 = r2(9591);
    t3.unzip = function(e3) {
      return Buffer.from((0, n2.inflate)(e3));
    };
  }, 9996: (e2, t3, r2) => {
    function n2(e3) {
      return n2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      }, n2(e3);
    }
    var i = r2(8764).Buffer, o = r2(22), s = r2(2961)._, a = r2(3720);
    "undefined" != typeof window && (window.Buffer = i), "undefined" != typeof self && (self.Buffer = i);
    var f = { UInt8: 1, UInt16LE: 2, UInt16BE: 2, UInt32LE: 4, UInt32BE: 4, Int8: 1, Int16LE: 2, Int16BE: 2, Int32LE: 4, Int32BE: 4, FloatLE: 4, FloatBE: 4, DoubleLE: 8, DoubleBE: 8, UInt64: 8, Int64: 8 }, h = {}, l = "___parser_", u = [];
    !(function() {
      var e3;
      for (e3 = 1; e3 <= 32; e3++) u.push(e3);
    })();
    var c = {};
    Object.keys(f).concat(Object.keys({ String: null, Buffer: null, Array: null, Skip: null, Choice: null, Nest: null, Bit: null, Itf8: null, Ltf8: null })).forEach((function(e3) {
      c[e3.toLowerCase()] = e3;
    }));
    var d = function() {
      this.varName = "", this.type = "", this.options = {}, this.next = null, this.head = null, this.compiled = null, this.endian = "le", this.constructorFn = null, this.alias = null;
    };
    d.start = function() {
      return new d();
    }, Object.keys(f).forEach((function(e3) {
      d.prototype[e3.toLowerCase()] = function(t5, r3) {
        return this.setNextParser(e3.toLowerCase(), t5, r3);
      };
      var t4 = e3.replace(/BE|LE/, "").toLowerCase();
      t4 in d.prototype || (d.prototype[t4] = function(e4, r3) {
        return this[t4 + this.endian](e4, r3);
      });
    })), u.forEach((function(e3) {
      d.prototype["bit".concat(e3.toString())] = function(t4, r3) {
        return r3 || (r3 = {}), r3.length = e3, this.setNextParser("bit", t4, r3);
      };
    })), d.prototype.namely = function(e3) {
      return h[e3] = this, this.alias = e3, this;
    }, d.prototype.skip = function(e3, t4) {
      if (t4 && t4.assert) throw new Error("assert option on skip is not allowed.");
      return this.setNextParser("skip", "", { length: e3 });
    }, d.prototype.string = function(e3, t4) {
      if (!t4.zeroTerminated && !t4.length && !t4.greedy) throw new Error("Neither length, zeroTerminated, nor greedy is defined for string.");
      if ((t4.zeroTerminated || t4.length) && t4.greedy) throw new Error("greedy is mutually exclusive with length and zeroTerminated for string.");
      if (t4.stripNull && !t4.length && !t4.greedy) throw new Error("Length or greedy must be defined if stripNull is defined.");
      return t4.encoding = t4.encoding || "utf8", this.setNextParser("string", e3, t4);
    }, d.prototype.buffer = function(e3, t4) {
      if (!t4.length && !t4.readUntil) throw new Error("Length nor readUntil is defined in buffer parser");
      return this.setNextParser("buffer", e3, t4);
    }, d.prototype.array = function(e3, t4) {
      if (!t4.readUntil && !t4.length && !t4.lengthInBytes) throw new Error("Length option of array is not defined.");
      if (!t4.type) throw new Error("Type option of array is not defined.");
      if ("string" == typeof t4.type && !h[t4.type] && Object.keys(f).indexOf(c[t4.type]) < 0) throw new Error('Specified primitive type "'.concat(t4.type, '" is not supported.'));
      return this.setNextParser("array", e3, t4);
    }, d.prototype.choice = function(e3, t4) {
      if (1 === arguments.length && "object" === n2(e3) && (t4 = e3, e3 = null), !t4.tag) throw new Error("Tag option of array is not defined.");
      if (!t4.choices) throw new Error("Choices option of array is not defined.");
      return Object.keys(t4.choices).forEach((function(r3) {
        if (!t4.choices[r3]) throw new Error("Choice Case ".concat(r3, " of ").concat(e3, " is not valid."));
        if ("string" == typeof t4.choices[r3] && !h[t4.choices[r3]] && Object.keys(f).indexOf(c[t4.choices[r3]]) < 0) throw new Error('Specified primitive type "'.concat(t4.choices[r3], '" is not supported.'));
      }), this), this.setNextParser("choice", e3, t4);
    }, d.prototype.nest = function(e3, t4) {
      if (1 === arguments.length && "object" === n2(e3) && (t4 = e3, e3 = null), !t4.type) throw new Error("Type option of nest is not defined.");
      if (!(t4.type instanceof d || h[t4.type])) throw new Error("Type option of nest must be a Parser object.");
      if (!(t4.type instanceof d || e3)) throw new Error("options.type must be a object if variable name is omitted.");
      return this.setNextParser("nest", e3, t4);
    }, d.prototype.endianess = function(e3) {
      switch (e3.toLowerCase()) {
        case "little":
          this.endian = "le";
          break;
        case "big":
          this.endian = "be";
          break;
        default:
          throw new Error("Invalid endianess: ".concat(e3));
      }
      return this;
    }, d.prototype.create = function(e3) {
      if (!(e3 instanceof Function)) throw new Error("Constructor must be a Function object.");
      return this.constructorFn = e3, this;
    }, d.prototype.getCode = function() {
      var e3 = new s();
      return e3.pushCode("if (!Buffer.isBuffer(buffer)) {"), e3.generateError('"argument buffer is not a Buffer object"'), e3.pushCode("}"), this.alias ? this.addAliasedCode(e3) : this.addRawCode(e3), this.alias ? e3.pushCode("return {0}(0)", l + this.alias) : e3.pushCode("return { offset: offset, result: vars };"), e3.code;
    }, d.prototype.addRawCode = function(e3) {
      e3.pushCode("var offset = 0;"), this.constructorFn ? e3.pushCode("var vars = new constructorFn();") : e3.pushCode("var vars = {};"), this.generate(e3), this.resolveReferences(e3), e3.pushCode("return { offset: offset, result: vars };");
    }, d.prototype.addAliasedCode = function(e3) {
      return e3.pushCode("function {0}(offset) {", l + this.alias), this.constructorFn ? e3.pushCode("var vars = new constructorFn();") : e3.pushCode("var vars = {};"), this.generate(e3), e3.markResolved(this.alias), this.resolveReferences(e3), e3.pushCode("return { offset: offset, result: vars };"), e3.pushCode("}"), e3;
    }, d.prototype.resolveReferences = function(e3) {
      var t4 = e3.getUnresolvedReferences();
      e3.markRequested(t4), t4.forEach((function(t5) {
        h[t5].addAliasedCode(e3);
      }));
    }, d.prototype.compile = function() {
      var e3 = "(function(buffer, constructorFn, Long) { ".concat(this.getCode(), " })");
      this.compiled = o.runInThisContext(e3);
    }, d.prototype.sizeOf = function() {
      var e3 = NaN;
      if (Object.keys(f).indexOf(this.type) >= 0) e3 = f[this.type];
      else if ("String" === this.type && "number" == typeof this.options.length) e3 = this.options.length;
      else if ("Buffer" === this.type && "number" == typeof this.options.length) e3 = this.options.length;
      else if ("Array" === this.type && "number" == typeof this.options.length) {
        var t4 = NaN;
        "string" == typeof this.options.type ? t4 = f[c[this.options.type]] : this.options.type instanceof d && (t4 = this.options.type.sizeOf()), e3 = this.options.length * t4;
      } else "Skip" === this.type ? e3 = this.options.length : "Nest" === this.type ? e3 = this.options.type.sizeOf() : this.type || (e3 = 0);
      return this.next && (e3 += this.next.sizeOf()), e3;
    }, d.prototype.parse = function(e3) {
      return this.compiled || this.compile(), this.compiled(e3, this.constructorFn, a);
    }, d.prototype.setNextParser = function(e3, t4, r3) {
      var n3 = new d();
      return n3.type = c[e3], n3.varName = t4, n3.options = r3 || n3.options, n3.endian = this.endian, this.head ? this.head.next = n3 : this.next = n3, this.head = n3, this;
    }, d.prototype.generate = function(e3) {
      this.type && (this["generate".concat(this.type)](e3), this.generateAssert(e3));
      var t4 = e3.generateVariable(this.varName);
      return this.options.formatter && this.generateFormatter(e3, t4, this.options.formatter), this.generateNext(e3);
    }, d.prototype.generateAssert = function(e3) {
      if (this.options.assert) {
        var t4 = e3.generateVariable(this.varName);
        switch (n2(this.options.assert)) {
          case "function":
            e3.pushCode("if (!({0}).call(vars, {1})) {", this.options.assert, t4);
            break;
          case "number":
            e3.pushCode("if ({0} !== {1}) {", this.options.assert, t4);
            break;
          case "string":
            e3.pushCode('if ("{0}" !== {1}) {', this.options.assert, t4);
            break;
          default:
            throw new Error("Assert option supports only strings, numbers and assert functions.");
        }
        e3.generateError('"Assert error: {0} is " + {0}', t4), e3.pushCode("}");
      }
    }, d.prototype.generateNext = function(e3) {
      return this.next && (e3 = this.next.generate(e3)), e3;
    }, Object.keys(f).forEach((function(e3) {
      d.prototype["generate".concat(e3)] = function(t4) {
        "UInt64" === e3 ? t4.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), true, this.endian === 'le').toNumber();", t4.generateVariable(this.varName), e3) : "Int64" === e3 ? t4.pushCode("{0} = Long.fromBytes(buffer.slice(offset,offset+8), false, this.endian === 'le').toNumber();", t4.generateVariable(this.varName), e3) : t4.pushCode("{0} = buffer.read{1}(offset);", t4.generateVariable(this.varName), e3), t4.pushCode("offset += {0};", f[e3]);
      };
    })), d.prototype.generateBit = function(e3) {
      var t4 = JSON.parse(JSON.stringify(this));
      if (t4.varName = e3.generateVariable(t4.varName), e3.bitFields.push(t4), !this.next || this.next && ["Bit", "Nest"].indexOf(this.next.type) < 0) {
        var r3 = 0;
        e3.bitFields.forEach((function(e4) {
          r3 += e4.options.length;
        }));
        var n3 = e3.generateTmpVariable();
        if (r3 <= 8) e3.pushCode("var {0} = buffer.readUInt8(offset);", n3), r3 = 8;
        else if (r3 <= 16) e3.pushCode("var {0} = buffer.readUInt16BE(offset);", n3), r3 = 16;
        else if (r3 <= 24) {
          var i2 = e3.generateTmpVariable(), o2 = e3.generateTmpVariable();
          e3.pushCode("var {0} = buffer.readUInt16BE(offset);", i2), e3.pushCode("var {0} = buffer.readUInt8(offset + 2);", o2), e3.pushCode("var {2} = ({0} << 8) | {1};", i2, o2, n3), r3 = 24;
        } else {
          if (!(r3 <= 32)) throw new Error("Currently, bit field sequence longer than 4-bytes is not supported.");
          e3.pushCode("var {0} = buffer.readUInt32BE(offset);", n3), r3 = 32;
        }
        e3.pushCode("offset += {0};", r3 / 8);
        var s2 = 0, a2 = "be" === this.endian;
        e3.bitFields.forEach((function(t5) {
          e3.pushCode("{0} = {1} >> {2} & {3};", t5.varName, n3, a2 ? r3 - s2 - t5.options.length : s2, (1 << t5.options.length) - 1), s2 += t5.options.length;
        })), e3.bitFields = [];
      }
    }, d.prototype.generateSkip = function(e3) {
      var t4 = e3.generateOption(this.options.length);
      e3.pushCode("offset += {0};", t4);
    }, d.prototype.generateString = function(e3) {
      var t4 = e3.generateVariable(this.varName), r3 = e3.generateTmpVariable();
      this.options.length && this.options.zeroTerminated ? (e3.pushCode("var {0} = offset;", r3), e3.pushCode("while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});", r3, this.options.length), e3.pushCode("{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);", t4, this.options.encoding, r3, this.options.length)) : this.options.length ? (e3.pushCode("{0} = buffer.toString('{1}', offset, offset + {2});", t4, this.options.encoding, e3.generateOption(this.options.length)), e3.pushCode("offset += {0};", e3.generateOption(this.options.length))) : this.options.zeroTerminated ? (e3.pushCode("var {0} = offset;", r3), e3.pushCode("while(buffer.readUInt8(offset++) !== 0);"), e3.pushCode("{0} = buffer.toString('{1}', {2}, offset - 1);", t4, this.options.encoding, r3)) : this.options.greedy && (e3.pushCode("var {0} = offset;", r3), e3.pushCode("while(buffer.length > offset++);"), e3.pushCode("{0} = buffer.toString('{1}', {2}, offset);", t4, this.options.encoding, r3)), this.options.stripNull && e3.pushCode("{0} = {0}.replace(/\\x00+$/g, '')", t4);
    }, d.prototype.generateBuffer = function(e3) {
      "eof" === this.options.readUntil ? e3.pushCode("{0} = buffer.slice(offset);", e3.generateVariable(this.varName)) : (e3.pushCode("{0} = buffer.slice(offset, offset + {1});", e3.generateVariable(this.varName), e3.generateOption(this.options.length)), e3.pushCode("offset += {0};", e3.generateOption(this.options.length))), this.options.clone && e3.pushCode("{0} = Buffer.from({0});", e3.generateVariable(this.varName));
    }, d.prototype.generateArray = function(e3) {
      var t4 = e3.generateOption(this.options.length), r3 = e3.generateOption(this.options.lengthInBytes), n3 = this.options.type, i2 = e3.generateTmpVariable(), o2 = e3.generateVariable(this.varName), s2 = e3.generateTmpVariable(), a2 = this.options.key, u2 = "string" == typeof a2;
      if (u2 ? e3.pushCode("{0} = {};", o2) : e3.pushCode("{0} = [];", o2), "function" == typeof this.options.readUntil ? e3.pushCode("do {") : "eof" === this.options.readUntil ? e3.pushCode("for (var {0} = 0; offset < buffer.length; {0}++) {", i2) : void 0 !== r3 ? e3.pushCode("for (var {0} = offset; offset - {0} < {1}; ) {", i2, r3) : e3.pushCode("for (var {0} = 0; {0} < {1}; {0}++) {", i2, t4), "string" == typeof n3) if (h[n3]) {
        var p = e3.generateTmpVariable();
        e3.pushCode("var {0} = {1}(offset);", p, l + n3), e3.pushCode("var {0} = {1}.result; offset = {1}.offset;", s2, p), n3 !== this.alias && e3.addReference(n3);
      } else e3.pushCode("var {0} = buffer.read{1}(offset);", s2, c[n3]), e3.pushCode("offset += {0};", f[c[n3]]);
      else n3 instanceof d && (e3.pushCode("var {0} = {};", s2), e3.pushScope(s2), n3.generate(e3), e3.popScope());
      u2 ? e3.pushCode("{0}[{2}.{1}] = {2};", o2, a2, s2) : e3.pushCode("{0}.push({1});", o2, s2), e3.pushCode("}"), "function" == typeof this.options.readUntil && e3.pushCode(" while (!({0}).call(this, {1}, buffer.slice(offset)));", this.options.readUntil, s2);
    }, d.prototype.generateChoiceCase = function(e3, t4, r3) {
      if ("string" == typeof r3) if (h[r3]) {
        var n3 = e3.generateTmpVariable();
        e3.pushCode("var {0} = {1}(offset);", n3, l + r3), e3.pushCode("{0} = {1}.result; offset = {1}.offset;", e3.generateVariable(this.varName), n3), r3 !== this.alias && e3.addReference(r3);
      } else e3.pushCode("{0} = buffer.read{1}(offset);", e3.generateVariable(this.varName), c[r3]), e3.pushCode("offset += {0};", f[c[r3]]);
      else r3 instanceof d && (e3.pushPath(t4), r3.generate(e3), e3.popPath(t4));
    }, d.prototype.generateChoice = function(e3) {
      var t4 = e3.generateOption(this.options.tag);
      this.varName && e3.pushCode("{0} = {};", e3.generateVariable(this.varName)), e3.pushCode("switch({0}) {", t4), Object.keys(this.options.choices).forEach((function(t5) {
        var r3 = this.options.choices[t5];
        Number.isNaN(parseInt(t5, 10)) ? e3.pushCode("case '{0}':", t5) : e3.pushCode("case {0}:", t5), this.generateChoiceCase(e3, this.varName, r3), e3.pushCode("break;");
      }), this), e3.pushCode("default:"), this.options.defaultChoice ? this.generateChoiceCase(e3, this.varName, this.options.defaultChoice) : e3.generateError('"Met undefined tag value " + {0} + " at choice"', t4), e3.pushCode("}");
    }, d.prototype.generateNest = function(e3) {
      var t4 = e3.generateVariable(this.varName);
      if (this.options.type instanceof d) this.varName && e3.pushCode("{0} = {};", t4), e3.pushPath(this.varName), this.options.type.generate(e3), e3.popPath(this.varName);
      else if (h[this.options.type]) {
        var r3 = e3.generateTmpVariable();
        e3.pushCode("var {0} = {1}(offset);", r3, l + this.options.type), e3.pushCode("{0} = {1}.result; offset = {1}.offset;", t4, r3), this.options.type !== this.alias && e3.addReference(this.options.type);
      }
    }, d.prototype.generateFormatter = function(e3, t4, r3) {
      "function" == typeof r3 && e3.pushCode("{0} = ({1}).call(this, {0});", t4, r3);
    }, d.prototype.isInteger = function() {
      return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\d+/);
    }, d.prototype.itf8 = function(e3, t4) {
      return this.setNextParser("itf8", e3, t4);
    }, d.prototype.itf8 = function(e3, t4) {
      return this.setNextParser("itf8", e3, t4);
    }, d.prototype.generateItf8 = function(e3) {
      var t4 = e3.generateVariable(this.varName), r3 = e3.generateTmpVariable();
      e3.pushCode("\n    var ".concat(r3, " = buffer[offset];\n    if (").concat(r3, " < 0x80) {\n      ").concat(t4, " = ").concat(r3, ";\n      offset += 1;\n    } else if (").concat(r3, " < 0xc0) {\n      ").concat(t4, " = ((").concat(r3, "<<8) | buffer[offset+1]) & 0x3fff;\n      offset += 2;\n    } else if (").concat(r3, " < 0xe0) {\n      ").concat(t4, " = ((").concat(r3, "<<16) | (buffer[offset+1]<< 8) |  buffer[offset+2]) & 0x1fffff;\n      offset += 3;\n    } else if (").concat(r3, " < 0xf0) {\n      ").concat(t4, " = ((").concat(r3, "<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\n      offset += 4\n    } else {\n      ").concat(t4, " = ((").concat(r3, " & 0x0f)<<28) | (buffer[offset+1]<<20) | (buffer[offset+2]<<12) | (buffer[offset+3]<<4) | (buffer[offset+4] & 0x0f);\n      // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\n      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n      offset += 5\n    }\n  "));
    }, d.prototype.ltf8 = function(e3, t4) {
      return this.setNextParser("ltf8", e3, t4);
    }, d.prototype.generateLtf8 = function(e3) {
      var t4 = e3.generateVariable(this.varName), r3 = e3.generateTmpVariable();
      e3.pushCode("\n  var ".concat(r3, " = buffer[offset];\n  if (").concat(r3, " < 0x80) {\n    ").concat(t4, " = ").concat(r3, ";\n    offset += 1;\n  } else if (").concat(r3, " < 0xc0) {\n    ").concat(t4, " = ((buffer[offset]<<8) | buffer[offset+1]) & 0x3fff;\n    offset += 2;\n  } else if (").concat(r3, " < 0xe0) {\n    ").concat(t4, " = ((buffer[offset]<<16) | (buffer[offset+1]<<8) | buffer[offset+2]) & 0x1fffff;\n    ").concat(t4, " = (((").concat(r3, " & 63) << 16) | buffer.readUInt16LE(offset + 1));\n    offset += 3;\n  } else if (").concat(r3, " < 0xf0) {\n    ").concat(t4, " = ((buffer[offset]<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\n    offset += 4;\n  } else if (").concat(r3, " < 0xf8) {\n    ").concat(t4, " = (((buffer[offset] & 15) * Math.pow(2,32))) +\n      (buffer[offset+1]<<24) | (buffer[offset+2]<<16 | buffer[offset+3]<<8 | buffer[offset+4])\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n    offset += 5;\n  } else if (").concat(r3, " < 0xfc) {\n    ").concat(t4, " = ((((buffer[offset] & 7) << 8) | buffer[offset+1] )) * Math.pow(2,32) +\n      (buffer[offset+2]<<24) | (buffer[offset+3]<<16 | buffer[offset+4]<<8 | buffer[offset+5])\n    offset += 6;\n  } else if (").concat(r3, " < 0xfe) {\n    ").concat(t4, " = ((((buffer[offset] & 3) << 16) | buffer[offset+1]<<8 | buffer[offset+2])) * Math.pow(2,32) +\n      (buffer[offset+3]<<24) | (buffer[offset+4]<<16 | buffer[offset+5]<<8 | buffer[offset+6])\n    offset += 7;\n  } else if (").concat(r3, " < 0xff) {\n    ").concat(t4, " = Long.fromBytesBE(buffer.slice(offset+1,offset+8));\n    if (").concat(t4, ".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(t4, ".lessThan(Number.MIN_SAFE_INTEGER))\n      throw new Error('integer overflow')\n    ").concat(t4, " = ").concat(t4, ".toNumber()\n    offset += 8;\n  } else {\n    ").concat(t4, " = Long.fromBytesBE(buffer.slice(offset+1,offset+9));\n    if (").concat(t4, ".greaterThan(Number.MAX_SAFE_INTEGER) || ").concat(t4, ".lessThan(Number.MIN_SAFE_INTEGER))\n      throw new Error('integer overflow')\n    ").concat(t4, " = ").concat(t4, ".toNumber()\n    offset += 9;\n  }\n  "));
    }, t3.Parser = d;
  }, 2961: (e2, t3) => {
    function r2(e3) {
      return r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
        return typeof e4;
      } : function(e4) {
        return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
      }, r2(e3);
    }
    var n2 = function() {
      this.code = "", this.scopes = [["vars"]], this.isAsync = false, this.bitFields = [], this.tmpVariableCount = 0, this.references = {};
    };
    n2.prototype.generateVariable = function(e3) {
      var t4 = [];
      for (Array.prototype.push.apply(t4, this.scopes[this.scopes.length - 1]); /^\$parent\./.test(e3); ) t4.pop(), e3 = e3.replace(/^\$parent\./, "");
      return e3 && t4.push(e3), t4.join(".");
    }, n2.prototype.generateOption = function(e3) {
      switch (r2(e3)) {
        case "number":
          return e3.toString();
        case "string":
          return this.generateVariable(e3);
        case "function":
          return "(".concat(e3, ").call(").concat(this.generateVariable(), ", vars)");
        default:
          return;
      }
    }, n2.prototype.generateError = function() {
      var e3 = Array.prototype.slice.call(arguments), t4 = n2.interpolate.apply(this, e3);
      this.isAsync ? this.pushCode("return process.nextTick(function() { callback(new Error(".concat(t4, "), vars); });")) : this.pushCode("throw new Error(".concat(t4, ");"));
    }, n2.prototype.generateTmpVariable = function() {
      return "$tmp".concat(this.tmpVariableCount++);
    }, n2.prototype.pushCode = function() {
      var e3 = Array.prototype.slice.call(arguments);
      this.code += "".concat(n2.interpolate.apply(this, e3), "\n");
    }, n2.prototype.pushPath = function(e3) {
      e3 && this.scopes[this.scopes.length - 1].push(e3);
    }, n2.prototype.popPath = function(e3) {
      e3 && this.scopes[this.scopes.length - 1].pop();
    }, n2.prototype.pushScope = function(e3) {
      this.scopes.push([e3]);
    }, n2.prototype.popScope = function() {
      this.scopes.pop();
    }, n2.prototype.addReference = function(e3) {
      this.references[e3] || (this.references[e3] = { resolved: false, requested: false });
    }, n2.prototype.markResolved = function(e3) {
      this.references[e3].resolved = true;
    }, n2.prototype.markRequested = function(e3) {
      e3.forEach((function(e4) {
        this.references[e4].requested = true;
      }).bind(this));
    }, n2.prototype.getUnresolvedReferences = function() {
      var e3 = this.references;
      return Object.keys(this.references).filter((function(t4) {
        return !e3[t4].resolved && !e3[t4].requested;
      }));
    }, n2.interpolate = function(e3) {
      var t4 = /{\d+}/g, r3 = e3.match(t4), n3 = Array.prototype.slice.call(arguments, 1);
      return r3 && r3.forEach((function(t5) {
        var r4 = parseInt(t5.substr(1, t5.length - 2), 10);
        e3 = e3.replace(t5, n3[r4].toString());
      })), e3;
    }, t3._ = n2;
  }, 22: (e2) => {
    e2.exports.runInThisContext = function(e3) {
      return new Function("code", "return eval(code);").call(globalThis, e3);
    };
  }, 445: (e2, t3, r2) => {
    const n2 = r2(7381), i = r2(9260), o = r2(576), s = r2(4693), a = 128;
    e2.exports = class {
      decode(e3) {
        return this.stream = new i(e3), this.decodeStream(this.stream);
      }
      decodeStream(e3, t4 = 0) {
        var r3 = this.stream.ReadByte();
        16 & r3 || (t4 = this.stream.ReadUint7());
        var n3, i2 = t4, o2 = 1 & r3;
        if (8 & r3) return this.decodeStripe(this.stream, t4);
        if (r3 & a && ([n3, i2] = this.decodePackMeta(this.stream)), 32 & r3) var s2 = this.decodeCat(this.stream, i2);
        else s2 = 4 & r3 ? this.decodeExt(this.stream, i2) : 64 & r3 ? o2 ? this.decodeRLE1(this.stream, i2) : this.decodeRLE0(this.stream, i2) : o2 ? this.decode1(this.stream, i2) : this.decode0(this.stream, i2);
        return r3 & a && (s2 = this.decodePack(s2, n3, t4)), s2;
      }
      encode(e3, t4) {
        if (this.stream = new i("", 0, 1.1 * e3.length + 100), this.stream.WriteByte(t4), 16 & t4 || this.stream.WriteUint7(e3.length), 8 & t4) return Buffer.concat([this.stream.buf.slice(0, this.stream.pos), this.encodeStripe(this.stream, e3, t4 >> 8)]);
        var r3, n3 = 1 & t4, o2 = e3.length;
        return t4 & a && ([r3, e3, o2] = this.encodePack(e3)), t4 & a && this.stream.WriteStream(r3), 64 & t4 ? n3 ? this.encodeRLE1(e3, o2, this.stream) : this.encodeRLE0(e3, o2, this.stream) : n3 ? this.encode1(e3, o2, this.stream) : this.encode0(e3, o2, this.stream);
      }
      decode0(e3, t4) {
        var r3 = new Buffer.allocUnsafe(t4), i2 = e3.ReadByte();
        0 == i2 && (i2 = 256);
        var s2 = new o(i2), a2 = new n2(e3);
        a2.RangeStartDecode(e3);
        for (var f = 0; f < t4; f++) r3[f] = s2.ModelDecode(e3, a2);
        return r3;
      }
      encode0(e3, t4, r3) {
        for (var i2 = 0, s2 = 0; s2 < t4; s2++) i2 < e3[s2] && (i2 = e3[s2]);
        i2++;
        var a2 = new o(i2);
        r3.WriteByte(i2);
        var f = new n2(r3);
        for (s2 = 0; s2 < t4; s2++) a2.ModelEncode(r3, f, e3[s2]);
        return f.RangeFinishEncode(r3), r3.buf.slice(0, r3.pos);
      }
      decode1(e3, t4) {
        var r3 = new Buffer.allocUnsafe(t4), i2 = e3.ReadByte();
        0 == i2 && (i2 = 256);
        for (var s2 = new Array(i2), a2 = 0; a2 < i2; a2++) s2[a2] = new o(i2);
        var f = new n2(e3);
        f.RangeStartDecode(e3);
        var h = 0;
        for (a2 = 0; a2 < t4; a2++) r3[a2] = s2[h].ModelDecode(e3, f), h = r3[a2];
        return r3;
      }
      encode1(e3, t4, r3) {
        for (var i2 = 0, s2 = 0; s2 < t4; s2++) i2 < e3[s2] && (i2 = e3[s2]);
        i2++;
        var a2 = new Array(i2);
        for (s2 = 0; s2 < i2; s2++) a2[s2] = new o(i2);
        r3.WriteByte(i2);
        var f = new n2(r3), h = 0;
        for (s2 = 0; s2 < t4; s2++) a2[h].ModelEncode(r3, f, e3[s2]), h = e3[s2];
        return f.RangeFinishEncode(r3), r3.buf.slice(0, r3.pos);
      }
      decodeExt(e3, t4) {
        var r3 = new Buffer.allocUnsafe(t4), n3 = s.array(e3.buf.slice(e3.pos)), i2 = s.header(n3), o2 = 0;
        do {
          var a2 = s.decompress(n3, i2);
          -1 != a2 && (Buffer.from(a2).copy(r3, o2), o2 += a2.length, i2 -= a2.length);
        } while (-1 != a2);
        return r3;
      }
      encodeExt(e3, t4) {
      }
      decodeRLE0(e3, t4) {
        var r3 = new Buffer.allocUnsafe(t4), i2 = e3.ReadByte();
        0 == i2 && (i2 = 256);
        for (var s2 = new o(i2), a2 = new Array(258), f = 0; f <= 257; f++) a2[f] = new o(4);
        var h = new n2(e3);
        for (h.RangeStartDecode(e3), f = 0; f < t4; ) {
          r3[f] = s2.ModelDecode(e3, h);
          for (var l = a2[r3[f]].ModelDecode(e3, h), u = l, c = 256; 3 == l; ) l = a2[c].ModelDecode(e3, h), c = 257, u += l;
          for (var d = 1; d <= u; d++) r3[f + d] = r3[f];
          f += u + 1;
        }
        return r3;
      }
      encodeRLE0(e3, t4, r3) {
        for (var i2 = 0, s2 = 0; s2 < t4; s2++) i2 < e3[s2] && (i2 = e3[s2]);
        i2++;
        var a2 = new o(i2), f = new Array(258);
        for (s2 = 0; s2 <= 257; s2++) f[s2] = new o(4);
        r3.WriteByte(i2);
        var h = new n2(r3);
        for (s2 = 0; s2 < t4; ) {
          a2.ModelEncode(r3, h, e3[s2]);
          for (var l = 1; s2 + l < t4 && e3[s2 + l] == e3[s2]; ) l++;
          l--;
          var u = e3[s2];
          e3[s2], s2 += l + 1;
          var c = l >= 3 ? 3 : l;
          for (f[u].ModelEncode(r3, h, c), l -= c, u = 256; 3 == c; ) c = l >= 3 ? 3 : l, f[u].ModelEncode(r3, h, c), u = 257, l -= c;
        }
        return h.RangeFinishEncode(r3), r3.buf.slice(0, r3.pos);
      }
      decodeRLE1(e3, t4) {
        var r3 = new Buffer.allocUnsafe(t4), i2 = e3.ReadByte();
        0 == i2 && (i2 = 256);
        for (var s2 = new Array(i2), a2 = 0; a2 < i2; a2++) s2[a2] = new o(i2);
        var f = new Array(258);
        for (a2 = 0; a2 <= 257; a2++) f[a2] = new o(4);
        var h = new n2(e3);
        h.RangeStartDecode(e3);
        var l = 0;
        for (a2 = 0; a2 < t4; ) {
          r3[a2] = s2[l].ModelDecode(e3, h), l = r3[a2];
          for (var u = f[r3[a2]].ModelDecode(e3, h), c = u, d = 256; 3 == u; ) u = f[d].ModelDecode(e3, h), d = 257, c += u;
          for (var p = 1; p <= c; p++) r3[a2 + p] = r3[a2];
          a2 += c + 1;
        }
        return r3;
      }
      encodeRLE1(e3, t4, r3) {
        for (var i2 = 0, s2 = 0; s2 < t4; s2++) i2 < e3[s2] && (i2 = e3[s2]);
        i2++;
        var a2 = new Array(i2);
        for (s2 = 0; s2 < i2; s2++) a2[s2] = new o(i2);
        var f = new Array(258);
        for (s2 = 0; s2 <= 257; s2++) f[s2] = new o(4);
        r3.WriteByte(i2);
        for (var h = new n2(r3), l = (s2 = 0, 0); s2 < t4; ) {
          a2[l].ModelEncode(r3, h, e3[s2]);
          for (var u = 1; s2 + u < t4 && e3[s2 + u] == e3[s2]; ) u++;
          u--;
          var c = e3[s2];
          l = e3[s2], s2 += u + 1;
          var d = u >= 3 ? 3 : u;
          for (f[c].ModelEncode(r3, h, d), u -= d, c = 256; 3 == d; ) d = u >= 3 ? 3 : u, f[c].ModelEncode(r3, h, d), c = 257, u -= d;
        }
        return h.RangeFinishEncode(r3), r3.buf.slice(0, r3.pos);
      }
      decodePackMeta(e3) {
        this.nsym = e3.ReadByte();
        for (var t4 = new Array(this.nsym), r3 = 0; r3 < this.nsym; r3++) t4[r3] = e3.ReadByte();
        return [t4, e3.ReadUint7()];
      }
      decodePack(e3, t4, r3) {
        var n3 = new Buffer.allocUnsafe(r3);
        if (this.nsym <= 1) for (var i2 = 0; i2 < r3; i2++) n3[i2] = t4[0];
        else if (this.nsym <= 2) {
          i2 = 0;
          for (var o2 = 0; i2 < r3; i2++) {
            if (i2 % 8 == 0) var s2 = e3[o2++];
            n3[i2] = t4[1 & s2], s2 >>= 1;
          }
        } else if (this.nsym <= 4) for (i2 = 0, o2 = 0; i2 < r3; i2++) i2 % 4 == 0 && (s2 = e3[o2++]), n3[i2] = t4[3 & s2], s2 >>= 2;
        else {
          if (!(this.nsym <= 16)) return e3;
          for (i2 = 0, o2 = 0; i2 < r3; i2++) i2 % 2 == 0 && (s2 = e3[o2++]), n3[i2] = t4[15 & s2], s2 >>= 4;
        }
        return n3;
      }
      packMeta(e3) {
        for (var t4 = new i("", 0, 1024), r3 = new Array(256), n3 = 0; n3 < e3.length; n3++) r3[e3[n3]] = 1;
        var o2 = 0;
        for (n3 = 0; n3 < 256; n3++) r3[n3] && (r3[n3] = ++o2);
        for (t4.WriteByte(o2), n3 = 0; n3 < 256; n3++) r3[n3] && (t4.WriteByte(n3), r3[n3]--);
        return [t4, r3, o2];
      }
      encodePack(e3) {
        var t4, r3, n3;
        [t4, r3, n3] = this.packMeta(e3);
        var i2 = e3.length, o2 = 0;
        if (n3 <= 1) return t4.WriteUint7(0), [t4, new Buffer.allocUnsafe(0), 0];
        if (n3 <= 2) {
          for (var s2 = new Buffer.allocUnsafe(Math.floor((i2 + 7) / 8)), a2 = (o2 = 0, 0); o2 < (-8 & i2); o2 += 8, a2++) s2[a2] = (r3[e3[o2 + 0]] << 0) + (r3[e3[o2 + 1]] << 1) + (r3[e3[o2 + 2]] << 2) + (r3[e3[o2 + 3]] << 3) + (r3[e3[o2 + 4]] << 4) + (r3[e3[o2 + 5]] << 5) + (r3[e3[o2 + 6]] << 6) + (r3[e3[o2 + 7]] << 7);
          if (o2 < i2) {
            s2[a2] = 0;
            for (var f = 0; o2 < i2; ) s2[a2] |= r3[e3[o2++]] << f, f++;
            a2++;
          }
          return t4.WriteUint7(a2), [t4, s2, s2.length];
        }
        if (n3 <= 4) {
          for (s2 = new Buffer.allocUnsafe(Math.floor((i2 + 3) / 4)), o2 = 0, a2 = 0; o2 < (-4 & i2); o2 += 4, a2++) s2[a2] = (r3[e3[o2 + 0]] << 0) + (r3[e3[o2 + 1]] << 2) + (r3[e3[o2 + 2]] << 4) + (r3[e3[o2 + 3]] << 6);
          if (o2 < i2) {
            for (s2[a2] = 0, f = 0; o2 < i2; ) s2[a2] |= r3[e3[o2++]] << f, f += 2;
            a2++;
          }
          return t4.WriteUint7(a2), [t4, s2, s2.length];
        }
        if (n3 <= 16) {
          for (s2 = new Buffer.allocUnsafe(Math.floor((i2 + 1) / 2)), o2 = 0, a2 = 0; o2 < (-2 & i2); o2 += 2, a2++) s2[a2] = (r3[e3[o2 + 0]] << 0) + (r3[e3[o2 + 1]] << 4);
          return o2 < i2 && (s2[a2++] = r3[e3[o2++]]), t4.WriteUint7(a2), [t4, s2, s2.length];
        }
        return t4.WriteUint7(e3.length), [t4, e3, e3.length];
      }
      encodeStripe(e3, t4, r3) {
        0 == r3 && (r3 = 4);
        for (var n3 = new Array(r3), o2 = new Array(r3), s2 = 0; s2 < r3; s2++) o2[s2] = Math.floor(t4.length / r3) + (t4.length % r3 > s2), n3[s2] = new Array(o2[s2]);
        for (var a2 = 0, f = 0; f < t4.length; f += r3, a2++) for (var h = 0; h < r3; h++) a2 < n3[h].length && (n3[h][a2] = t4[f + h]);
        var l = new Array(r3), u = 0;
        for (s2 = 0; s2 < r3; s2++) {
          var c = this.encode(n3[s2], 0), d = this.encode(n3[s2], 1);
          l[s2] = d.length < c.length ? d : c, u += l[s2].length;
        }
        var p = new i("", 0, u + 5 * r3 + 1);
        for (p.WriteByte(r3), s2 = 0; s2 < r3; s2++) p.WriteUint7(l[s2].length);
        for (s2 = 0; s2 < r3; s2++) p.WriteData(l[s2], l[s2].length);
        return p.buf.slice(0, p.buf.pos);
      }
      decodeStripe(e3, t4) {
        for (var r3 = e3.ReadByte(), n3 = new Array(r3), i2 = new Array(r3), o2 = 0; o2 < r3; o2++) n3[o2] = e3.ReadUint7();
        var s2 = new Array(r3);
        for (o2 = 0; o2 < r3; o2++) i2[o2] = Math.floor(t4 / r3) + (t4 % r3 > o2), s2[o2] = this.decodeStream(e3, i2[o2]);
        var a2 = new Buffer.allocUnsafe(t4);
        for (o2 = 0; o2 < r3; o2++) for (var f = 0; f < i2[o2]; f++) a2[f * r3 + o2] = s2[o2][f];
        return a2;
      }
      decodeCat(e3, t4) {
        for (var r3 = new Buffer.allocUnsafe(t4), n3 = 0; n3 < t4; n3++) r3[n3] = e3.ReadByte();
        return r3;
      }
    };
  }, 7381: (e2) => {
    e2.exports = class {
      constructor(e3) {
        this.low = 0, this.range = 4294967295, this.code = 0, this.FFnum = 0, this.carry = 0, this.cache = 0;
      }
      RangeStartDecode(e3) {
        for (var t3 = 0; t3 < 5; t3++) this.code = (this.code << 8) + e3.ReadByte();
        this.code &= 4294967295, this.code >>>= 0;
      }
      RangeGetFrequency(e3) {
        return this.range = Math.floor(this.range / e3), Math.floor(this.code / this.range);
      }
      RangeDecode(e3, t3, r2, n2) {
        for (this.code -= t3 * this.range, this.range *= r2; this.range < 1 << 24; ) this.range *= 256, this.code = 256 * this.code + e3.ReadByte();
      }
      RangeShiftLow(e3) {
        if (this.low < 4278190080 | this.carry) {
          for (e3.WriteByte(this.cache + this.carry); this.FFnum; ) e3.WriteByte(this.carry - 1), this.FFnum--;
          this.cache = this.low >>> 24, this.carry = 0;
        } else this.FFnum++;
        this.low <<= 8, this.low >>>= 0;
      }
      RangeEncode(e3, t3, r2, n2) {
        var i = this.low;
        for (this.range = Math.floor(this.range / n2), this.low += t3 * this.range, this.low >>>= 0, this.range *= r2, this.low < i && (0 != this.carry && console.log("ERROR: Multiple carry"), this.carry = 1); this.range < 1 << 24; ) this.range *= 256, this.RangeShiftLow(e3);
      }
      RangeFinishEncode(e3) {
        for (var t3 = 0; t3 < 5; t3++) this.RangeShiftLow(e3);
      }
    };
  }, 576: (e2) => {
    e2.exports = class {
      constructor(e3 = 256) {
        this.total_freq = e3, this.max_sym = e3 - 1, this.S = new Array(), this.F = new Array();
        for (var t3 = 0; t3 <= this.max_sym; t3++) this.S[t3] = t3, this.F[t3] = 1;
      }
      ModelDecode(e3, t3) {
        for (var r2 = t3.RangeGetFrequency(this.total_freq), n2 = 0, i = 0; n2 + this.F[i] <= r2; ) n2 += this.F[i++];
        t3.RangeDecode(e3, n2, this.F[i], this.total_freq), this.F[i] += 16, this.total_freq += 16, this.total_freq > 65519 && this.ModelRenormalise();
        var o = this.S[i];
        if (i > 0 && this.F[i] > this.F[i - 1]) {
          var s = this.F[i];
          this.F[i] = this.F[i - 1], this.F[i - 1] = s, s = this.S[i], this.S[i] = this.S[i - 1], this.S[i - 1] = s;
        }
        return o;
      }
      ModelRenormalise() {
        this.total_freq = 0;
        for (var e3 = 0; e3 <= this.max_sym; e3++) this.F[e3] -= Math.floor(this.F[e3] / 2), this.total_freq += this.F[e3];
      }
      ModelEncode(e3, t3, r2) {
        for (var n2 = 0, i = 0; this.S[i] != r2; i++) n2 += this.F[i];
        if (t3.RangeEncode(e3, n2, this.F[i], this.total_freq), this.F[i] += 16, this.total_freq += 16, this.total_freq > 65519 && this.ModelRenormalise(), r2 = this.S[i], i > 0 && this.F[i] > this.F[i - 1]) {
          var o = this.F[i];
          this.F[i] = this.F[i - 1], this.F[i - 1] = o, o = this.S[i], this.S[i] = this.S[i - 1], this.S[i - 1] = o;
        }
      }
    };
  }, 5260: (e2, t3, r2) => {
    const n2 = r2(9260), i = r2(576), o = r2(7381);
    function s(e3, t4, r3) {
      for (var n3 = 0, i2 = 0, o2 = -1, s2 = new Array(1024); i2 < r3; ) {
        var a2 = e3.ReadByte();
        if (s2[n3++] = a2, i2 += a2, a2 == o2) {
          var f2 = e3.ReadByte();
          for (i2 += a2 * f2; f2--; ) s2[n3++] = a2;
        }
        o2 = a2;
      }
      var h2 = 0;
      for (n3 = 0, i2 = 0; i2 < r3; ) {
        var l2 = 0;
        do {
          var u = s2[n3++];
          l2 += u;
        } while (255 == u);
        for (; l2--; ) t4[i2++] = h2;
        h2++;
      }
    }
    function a(e3, t4, r3) {
      var n3 = e3.context;
      return t4.qctx = (t4.qctx << e3.qshift) + e3.qtab[r3], n3 += (t4.qctx & (1 << e3.qbits) - 1) << e3.qloc, e3.do_pos && (n3 += e3.ptab[Math.min(t4.p, 1023)] << e3.ploc), e3.do_delta && (n3 += e3.dtab[Math.min(t4.delta, 255)] << e3.dloc, t4.delta += t4.prevq != r3 ? 1 : 0, t4.prevq = r3), e3.do_sel && (n3 += t4.s << e3.sloc), t4.p--, 65535 & n3;
    }
    function f(e3) {
      var t4 = {};
      t4.context = e3.ReadUint16(), t4.pflags = e3.ReadByte(), t4.do_dedup = 2 & t4.pflags, t4.fixed_len = 4 & t4.pflags, t4.do_sel = 8 & t4.pflags, t4.do_qmap = 16 & t4.pflags, t4.do_pos = 32 & t4.pflags, t4.do_delta = 64 & t4.pflags, t4.do_qtab = 128 & t4.pflags, t4.max_sym = e3.ReadByte();
      var r3 = e3.ReadByte();
      if (t4.qbits = r3 >> 4, t4.qshift = 15 & r3, r3 = e3.ReadByte(), t4.qloc = r3 >> 4, t4.sloc = 15 & r3, r3 = e3.ReadByte(), t4.ploc = r3 >> 4, t4.dloc = 15 & r3, t4.qmap = new Array(256), 16 & t4.pflags) for (var n3 = 0; n3 < t4.max_sym; n3++) t4.qmap[n3] = e3.ReadByte();
      else for (n3 = 0; n3 < 256; n3++) t4.qmap[n3] = n3;
      if (t4.qtab = new Array(1024), t4.qbits > 0 && 128 & t4.pflags) s(e3, t4.qtab, 256);
      else for (n3 = 0; n3 < 256; n3++) t4.qtab[n3] = n3;
      return t4.ptab = new Array(1024), 32 & t4.pflags && s(e3, t4.ptab, 1024), t4.dtab = new Array(256), 64 & t4.pflags && s(e3, t4.dtab, 256), t4;
    }
    function h(e3, t4, r3, n3, i2, o2) {
      r3.max_sel > 0 ? i2.s = n3.sel.ModelDecode(e3, t4) : i2.s = 0, i2.x = r3.stab[i2.s];
      var s2 = r3.params[i2.x];
      if (s2.fixed_len >= 0) {
        var a2 = n3.len[0].ModelDecode(e3, t4);
        a2 |= n3.len[1].ModelDecode(e3, t4) << 8, a2 |= n3.len[2].ModelDecode(e3, t4) << 16, a2 |= n3.len[3].ModelDecode(e3, t4) << 24, s2.fixed_len > 0 && (s2.fixed_len = -a2);
      } else a2 = -s2.fixed_len;
      i2.len = a2, r3.do_rev && (o2[i2.rec] = n3.rev.ModelDecode(e3, t4)), i2.is_dup = 0, 2 & s2.pflags && n3.dup.ModelDecode(e3, t4) && (i2.is_dup = 1), i2.p = a2, i2.delta = 0, i2.qctx = 0, i2.prevq = 0, i2.rec++;
    }
    function l(e3, t4, r3) {
      for (var n3 = 0, i2 = 0, o2 = new Array(2 * r3), s2 = 0; n3 < r3; ) {
        for (var a2 = n3; n3 < r3 && t4[n3] == i2; ) n3++;
        var f2 = n3 - a2;
        do {
          var h2 = Math.min(255, f2);
          o2[s2++] = h2, f2 -= h2;
        } while (255 == h2);
        i2++;
      }
      var l2 = -1, u = new Array(2 * r3), c = 0;
      for (n3 = 0; n3 < s2; ) {
        var d = o2[n3++];
        if (u[c++] = d, d == l2) {
          for (a2 = n3; n3 < s2 && o2[n3] == l2 && n3 - a2 < 255; ) n3++;
          u[c++] = n3 - a2;
        } else l2 = d;
      }
      e3.WriteData(u, c);
    }
    e2.exports = { decode: function(e3, t4) {
      return (function(e4, t5) {
        var r3 = e4.ReadUint7(), n3 = (function(e5) {
          var t6 = { max_sym: 0 };
          if (5 == e5.ReadByte()) {
            var r4 = e5.ReadByte(), n4 = 1 & r4 ? e5.ReadByte() : 1, i2 = r4.nparam > 1 ? r4.nparam - 1 : 0, o2 = new Array(256);
            if (2 & r4) i2 = e5.ReadByte(), s(e5, o2, 256);
            else {
              for (var a2 = 0; a2 < n4; a2++) o2[a2] = a2;
              for (; a2 < 256; a2++) o2[a2] = n4 - 1;
            }
            t6.do_rev = 4 & r4, t6.stab = o2, t6.max_sel = i2, t6.params = new Array(t6.nparam);
            for (var h2 = 0; h2 < n4; h2++) t6.params[h2] = f(e5), t6.max_sym < t6.params[h2].max_sym && (t6.max_sym = t6.params[h2].max_sym);
            return t6;
          }
          console.error("Invalid FQZComp version number");
        })(e4);
        if (n3) {
          var l2 = n3.params, u = new Array(t5.length), c = (function(e5) {
            var t6 = {};
            t6.qual = new Array(65536);
            for (var r4 = 0; r4 < 65536; r4++) t6.qual[r4] = new i(e5.max_sym + 1);
            for (t6.len = new Array(4), r4 = 0; r4 < 4; r4++) t6.len[r4] = new i(256);
            return t6.rev = new i(2), t6.dup = new i(2), e5.max_sel > 0 && (t6.sel = new i(e5.max_sel + 1)), t6;
          })(n3), d = new o(e4);
          d.RangeStartDecode(e4);
          for (var p = new Buffer.allocUnsafe(r3), g = { qctx: 0, prevq: 0, delta: 0, p: 0, s: 0, x: 0, len: 0, is_dup: 0, rec: 0 }, m = 0; m < r3; ) {
            if (0 == g.p) {
              if (h(e4, d, n3, c, g, u), g.is_dup > 0 && c.dup.ModelDecode(e4, d)) {
                for (var y = 0; y < len; y++) p[m + y] = p[m + y - g.len];
                m += g.len, g.p = 0;
                continue;
              }
              t5.push(g.len);
              var b = (l2 = n3.params[g.x]).context;
            }
            var v = c.qual[b].ModelDecode(e4, d);
            p[m++] = l2.qmap[v], b = a(l2, g, v);
          }
          return n3.do_rev && (function(e5, t6, r4, n4) {
            for (var i2 = 0, o2 = 0; o2 < t6; ) {
              if (r4[i2]) for (var s2 = 0, a2 = n4[i2] - 1; s2 < a2; ) {
                var f2 = e5[o2 + s2];
                e5[o2 + s2] = e5[o2 + a2], e5[o2 + a2] = f2, s2++, a2--;
              }
              o2 += n4[i2++];
            }
          })(p, r3, u, t5), p;
        }
      })(new n2(e3), t4);
    }, encode: function(e3, t4, r3) {
      for (var s2 = new Array(2), a2 = new Array(2), f2 = new Array(2), h2 = new Array(2), u = new Array(256), c = 0; c < 2; c++) s2[c] = new Array(256), a2[c] = new Array(256), f2[c] = new Array(1024), h2[c] = new Array(256);
      (p = new n2("", 0, 1.1 * e3.length + 100)).WriteUint7(e3.length);
      var d = (function(e4, t5, r4, n3) {
        for (var i2 = r4[0], o2 = 0; o2 < r4.length && r4[o2] == i2; o2++) ;
        var s3 = o2 == r4.length ? 1 : 0, a3 = 0, f3 = 0;
        for (o2 = 0; o2 < 256; o2++) n3[0][o2] = 0;
        var h3 = 0, l2 = 0;
        for (o2 = 0; o2 < e4.length; o2++) 0 == l2 && (l2 = t5[h3 < t5.length - 1 ? h3++ : h3]), n3[0][e4[o2]]++, l2--;
        for (o2 = 0; o2 < 256; o2++) n3[0][o2] && (f3 < o2 && (f3 = o2), a3++);
        var u2 = 5, c2 = 0;
        return a3 <= 16 && (c2 = 1, u2 = a3 <= 2 ? 1 : a3 <= 4 ? 2 : a3 <= 8 ? 3 : 4), [{ qbits: 8 + (u2 > 4), qshift: u2, qloc: 7, pbits: 7, pshift: t5[0] > 128 ? 1 : 0, ploc: 0, dbits: u2 > 4 ? 0 : 1, dshift: 3, dloc: 15, sbits: 0, sloc: 15, do_stab: 0, context: 0, max_sym: f3, nsym: a3, do_qmap: c2, do_dedup: 0, fixed_len: 1 == t5.length ? 1 : 0, do_sel: 0, do_rev: 0, do_pos: 1, do_delta: u2 <= 4 ? 1 : 0, do_qtab: 0, qbits: 8 + (u2 > 4) - (0 == s3), sbits: 1, sloc: 15 - (u2 <= 4), do_stab: 1, do_sel: 1 }];
      })(e3, t4, r3, s2), p = (function(e4, t5, r4, n3, i2, o2, s3) {
        for (var a3 = [0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7], f3 = 0; f3 < t5.length; f3++) s3[f3] = f3;
        for (; f3 < 256; f3++) s3[f3] = t5.length - 1;
        e4.WriteByte(5);
        var h3 = (t5.length > 1 ? 1 : 0) | (t5[0].do_stab ? 2 : 0);
        if (e4.WriteByte(h3), 1 & h3 && e4.WriteByte(t5.length), 2 & h3) {
          var u2 = 1 << t5[0].sbits;
          u2 > 0 && u2--, e4.WriteByte(u2), l(e4, s3, 256);
        }
        for (var c2 = 0; c2 < t5.length; c2++) {
          if (e4.WriteUint16(t5[c2].context), e4.WriteByte((t5[c2].do_qtab ? 128 : 0) | (t5[c2].do_delta ? 64 : 0) | (t5[c2].do_pos ? 32 : 0) | (t5[c2].do_qmap ? 16 : 0) | (t5[c2].do_sel ? 8 : 0) | (t5[c2].fixed_len ? 4 : 0) | (t5[c2].do_dedup ? 2 : 0)), t5[c2].do_qmap ? e4.WriteByte(t5[c2].nsym) : e4.WriteByte(t5[c2].max_sym), e4.WriteByte(t5[c2].qbits << 4 | t5[c2].qshift), e4.WriteByte(t5[c2].qloc << 4 | t5[c2].sloc), e4.WriteByte(t5[c2].ploc << 4 | t5[c2].dloc), t5[c2].do_qmap) {
            t5[c2].max_sym = t5[c2].nsym;
            var d2 = 0;
            for (f3 = 0; f3 < 256; f3++) r4[c2][f3] && (e4.WriteByte(f3), r4[c2][f3] = d2++);
            for (; d2 < t5[c2].nsym; d2++) e4.WriteByte(0);
          } else for (f3 = 0; f3 < 256; f3++) r4[c2][f3] = f3;
          if (t5[c2].qbits > 0) {
            for (f3 = 0; f3 < 256; f3++) n3[c2][f3] = f3;
            t5[c2].do_qtab && l(e4, n3[c2], 256);
          }
          if (t5[c2].pbits > 0) {
            for (f3 = 0; f3 < 1024; f3++) i2[c2][f3] = Math.min((1 << t5[c2].pbits) - 1, f3 >> t5[c2].pshift);
            l(e4, i2[c2], 1024);
          }
          if (t5[c2].dbits > 0) {
            for (f3 = 0; f3 < 256; f3++) a3[f3] > (1 << t5[c2].dbits) - 1 && (a3[f3] = (1 << t5[c2].dbits) - 1);
            for (f3 = 0; f3 < 256; f3++) o2[c2][f3] = a3[Math.min(a3.length - 1, f3 >> t5[c2].dshift)];
            l(e4, o2[c2], 256);
          }
        }
        return e4;
      })(p, d, s2, a2, f2, h2, u);
      return (function(e4, t5, r4, n3, s3, a3, f3, h3, l2, u2) {
        var c2 = 1 << s3[0].sbits;
        c2 > 0 && c2--;
        for (var d2 = t5.length, p2 = 0, g = 0; g < s3.length; g++) p2 < s3[g].max_sym && (p2 = s3[g].max_sym);
        for (var m = new Array(65536), y = 0; y < 65536; y++) m[y] = new i(p2 + 1);
        var b = new Array(4);
        for (y = 0; y < 4; y++) b[y] = new i(256);
        new i(2), new i(2);
        for (var v = new i(c2 + 1), w = new o(t5), _ = (g = 0, y = 0, 0); y < d2; ) {
          if (0 == g) {
            var B = n3[_];
            s3[0].sbits > 0 && v.ModelEncode(e4, w, B);
            var E = u2[B], S = r4[Math.min(r4.length - 1, _++)];
            s3[E].fixed_len ? s3[E].fixed_len > 0 && (b[0].ModelEncode(e4, w, 255 & S), b[1].ModelEncode(e4, w, S >> 8 & 255), b[2].ModelEncode(e4, w, S >> 16 & 255), b[3].ModelEncode(e4, w, S >> 24 & 255), s3[E].fixed_len = -1) : (b[0].ModelEncode(e4, w, 255 & S), b[1].ModelEncode(e4, w, S >> 8 & 255), b[2].ModelEncode(e4, w, S >> 16 & 255), b[3].ModelEncode(e4, w, S >> 24 & 255)), s3[E].do_dedup && process.exit(1), g = S;
            var A = 0, C = s3[E].context, R = 0, k = 0;
          }
          var x = t5[y++], I = a3[E][x];
          m[C].ModelEncode(e4, w, I), R = (R << s3[E].qshift) + f3[E][I], C = s3[E].context, C += (R & (1 << s3[E].qbits) - 1) << s3[E].qloc, s3[E].pbits > 0 && (C += h3[E][Math.min(g, 1023)] << s3[E].ploc), s3[E].dbits > 0 && (C += l2[E][Math.min(A, 255)] << s3[E].dloc, A += k != I ? 1 : 0, k = I), s3[E].do_sel && (C += B << s3[E].sloc), C &= 65535, g--;
        }
        return w.RangeFinishEncode(e4), e4.buf.slice(0, e4.pos);
      })(p, e3, t4, r3, d, s2, a2, f2, h2, u);
    } };
  }, 3498: (e2, t3, r2) => {
    var n2 = r2(4459), i = r2(594), o = r2(445), s = r2(5260), a = r2(2881);
    e2.exports = { r4x8_uncompress: function(e3, t4) {
      n2.decode(e3).copy(t4, 0, 0);
    }, r4x16_uncompress: function(e3, t4) {
      i.decode(e3).copy(t4, 0, 0);
    }, arith_uncompress: function(e3, t4) {
      o.decode(e3).copy(t4, 0, 0);
    }, fqzcomp_uncompress: function(e3, t4) {
      var r3 = new Array();
      s.decode(e3, r3).copy(t4, 0, 0);
    }, tok3_uncompress: function(e3, t4) {
      var r3 = a.decode(e3, 0, "\0");
      Buffer.from(r3, "binary").copy(t4, 0, 0);
    } };
  }, 9260: (e2) => {
    e2.exports = class {
      constructor(e3, t3 = 0, r2 = 0) {
        0 != r2 ? (this.buf = Buffer.allocUnsafe(r2), this.length = r2) : (this.buf = e3, this.length = e3.length), this.pos = t3;
      }
      EOF() {
        return this.pos >= this.length;
      }
      ReadData(e3) {
        var t3 = this.buf.slice(this.pos, this.pos + e3);
        return this.pos += e3, t3;
      }
      ReadByte() {
        const e3 = this.buf[this.pos];
        return this.pos++, e3;
      }
      ReadChar() {
        const e3 = this.buf[this.pos];
        return this.pos++, String.fromCharCode(e3);
      }
      ReadUint16() {
        return this.ReadByte() | this.ReadByte() << 8;
      }
      ReadUint32() {
        const e3 = this.buf.readInt32LE(this.pos);
        return this.pos += 4, e3;
      }
      ReadString() {
        var e3 = "";
        do {
          var t3 = this.buf[this.pos++];
          t3 && (e3 += String.fromCharCode(t3));
        } while (t3);
        return e3;
      }
      ReadUint7() {
        var e3 = 0;
        do {
          var t3 = this.ReadByte();
          e3 = e3 << 7 | 127 & t3;
        } while (128 & t3);
        return e3;
      }
      ReadITF8() {
        var e3 = this.buf[this.pos];
        return this.pos++, e3 >= 240 ? (e3 = (15 & e3) << 28, e3 += (this.buf[this.pos + 0] << 20) + (this.buf[this.pos + 1] << 12) + (this.buf[this.pos + 2] << 4) + (this.buf[this.pos + 3] >> 4), this.pos += 4) : e3 >= 224 ? (e3 = (15 & e3) << 24, e3 += (this.buf[this.pos + 0] << 16) + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 0), this.pos += 3) : e3 >= 192 ? (e3 = (31 & e3) << 16, e3 += (this.buf[this.pos + 0] << 8) + (this.buf[this.pos + 1] << 0), this.pos += 2) : e3 >= 128 && (e3 = (63 & e3) << 8, e3 += this.buf[this.pos], this.pos++), e3;
      }
      WriteByte(e3) {
        this.buf[this.pos++] = e3;
      }
      WriteChar(e3) {
        this.buf[this.pos++] = e3.charCodeAt(0);
      }
      WriteString(e3) {
        for (var t3 = 0; t3 < e3.length; t3++) this.buf[this.pos++] = e3.charCodeAt(t3);
        this.buf[this.pos++] = 0;
      }
      WriteData(e3, t3) {
        for (var r2 = 0; r2 < t3; r2++) this.buf[this.pos++] = e3[r2];
      }
      WriteStream(e3) {
        this.WriteData(e3.buf, e3.pos);
      }
      WriteUint16(e3) {
        this.WriteByte(255 & e3), this.WriteByte(e3 >> 8 & 255);
      }
      WriteUint32(e3) {
        this.buf.writeInt32LE(e3, this.pos), this.pos += 4;
      }
      WriteUint7(e3) {
        var t3 = 0, r2 = e3;
        do {
          t3 += 7, r2 >>= 7;
        } while (r2 > 0);
        do {
          t3 -= 7, this.WriteByte((e3 >> t3 & 127) + ((t3 > 0) << 7));
        } while (t3 > 0);
      }
      WriteITF8(e3) {
        e3 < 0 && (e3 = 1 + e3), e3 <= 127 ? this.buf[this.pos++] = e3 : e3 <= 16383 ? (this.buf[this.pos++] = 128 | Math.floor(e3 / 256), this.buf[this.pos++] = 255 & e3) : e3 < 131071 ? (this.buf[this.pos++] = 192 | Math.floor(e3 / 65536), this.buf[this.pos++] = 255 & Math.floor(e3 / 256), this.buf[this.pos++] = 255 & e3) : e3 < 268435455 ? (this.buf[this.pos++] = 224 | Math.floor(e3 / 16777216), this.buf[this.pos++] = 255 & Math.floor(e3 / 65536), this.buf[this.pos++] = 255 & Math.floor(e3 / 256), this.buf[this.pos++] = 255 & e3) : (this.buf[this.pos++] = 240 | Math.floor(e3 / 268435456), this.buf[this.pos++] = 255 & Math.floor(e3 / 1048576), this.buf[this.pos++] = 255 & Math.floor(e3 / 4096), this.buf[this.pos++] = 255 & Math.floor(e3 / 4), this.buf[this.pos++] = 15 & e3);
      }
      WriteByteNeg(e3) {
        this.buf[--this.pos] = e3;
      }
    };
  }, 4459: (e2, t3, r2) => {
    const n2 = r2(9260);
    function i(e3) {
      return 4095 & e3;
    }
    function o(e3, t4) {
      for (var r3 = 0; t4 >= e3[r3 + 1]; ) r3++;
      return r3;
    }
    function s(e3) {
      for (var t4 = new Array(4096), r3 = 0, n3 = 0; n3 < 4096; n3++) {
        for (; n3 >= e3[r3 + 1]; ) r3++;
        t4[n3] = r3;
      }
      return t4;
    }
    function a(e3, t4, r3) {
      return r3 * (e3 >> 12) + (4095 & e3) - t4;
    }
    function f(e3, t4) {
      for (; t4 < 1 << 23; ) t4 = (t4 << 8) + e3.ReadByte();
      return t4;
    }
    function h(e3, t4) {
      t4.WriteByteNeg(e3 >> 24 & 255), t4.WriteByteNeg(e3 >> 16 & 255), t4.WriteByteNeg(e3 >> 8 & 255), t4.WriteByteNeg(e3 >> 0 & 255);
    }
    function l(e3, t4, r3, n3, i2) {
      return e3 = (function(e4, t5, r4, n4) {
        for (var i3 = (1 << 23 >> n4 << 8) * r4; e4 >= i3; ) t5.WriteByteNeg(255 & e4), e4 >>= 8;
        return e4;
      })(e3, t4, n3, i2), (Math.floor(e3 / n3) << i2) + e3 % n3 + r3;
    }
    function u(e3, t4, r3) {
      for (var n3 = 0; n3 < 256; n3++) t4[n3] = 0;
      var i2 = e3.ReadByte(), o2 = i2, s2 = 0;
      do {
        var a2 = e3.ReadITF8();
        t4[i2] = a2, s2 > 0 ? (s2--, i2++) : (i2 = e3.ReadByte()) == o2 + 1 && (s2 = e3.ReadByte()), o2 = i2;
      } while (0 != i2);
      for (r3[0] = 0, n3 = 0; n3 <= 255; n3++) r3[n3 + 1] = r3[n3] + t4[n3];
    }
    function c(e3) {
      for (var t4 = 0, r3 = 0; r3 < 256; r3++) t4 += e3[r3];
      const n3 = 4096;
      var i2 = n3 / t4;
      do {
        var o2 = 0, s2 = 0, a2 = 0;
        for (t4 = 0, r3 = 0; r3 < 256; r3++) 0 != e3[r3] && (o2 < e3[r3] && (o2 = e3[r3], s2 = r3), e3[r3] = Math.floor(e3[r3] * i2), 0 == e3[r3] && (e3[r3] = 1), t4 += e3[r3]);
        t4 < n3 ? e3[s2] += n3 - t4 : t4 - n3 < e3[s2] / 2 && e3[s2] > 2 ? e3[s2] -= t4 - n3 : t4 != n3 && (i2 *= 0.99, a2 = 1);
      } while (a2);
    }
    function d(e3, t4) {
      for (var r3 = 0, n3 = 0; n3 < 256; n3++) if (t4[n3]) {
        if (r3 > 0) r3--;
        else if (e3.WriteByte(n3), n3 > 0 && t4[n3 - 1] > 0) {
          for (r3 = n3 + 1; r3 < 256 && t4[r3]; r3++) ;
          r3 -= n3 + 1, e3.WriteByte(r3);
        }
        e3.WriteITF8(t4[n3]);
      }
      e3.WriteByte(0);
    }
    e2.exports = { decode: function(e3) {
      var t4 = new n2(e3), r3 = t4.ReadByte(), h2 = (t4.ReadUint32(), t4.ReadUint32());
      return 0 == r3 ? (function(e4, t5) {
        var r4 = new Array(256), n3 = new Array(256);
        u(e4, r4, n3);
        for (var o2 = s(n3), h3 = new Array(4), l2 = 0; l2 < 4; l2++) h3[l2] = e4.ReadUint32();
        var c2 = new Buffer.allocUnsafe(t5);
        for (l2 = 0; l2 < t5; l2++) {
          var d2 = l2 % 4, p = o2[i(h3[d2])];
          c2[l2] = p, h3[d2] = a(h3[d2], n3[p], r4[p]), h3[d2] = f(e4, h3[d2]);
        }
        return c2;
      })(t4, h2) : (function(e4, t5) {
        var r4 = new Array(256), n3 = new Array(256);
        !(function(e5, t6, r5) {
          for (var n4 = 0; n4 < 256; n4++) {
            t6[n4] = new Array(256), r5[n4] = new Array(256);
            for (var i2 = 0; i2 < 256; i2++) t6[n4][i2] = 0;
          }
          var o2 = e5.ReadByte(), s2 = o2, a2 = 0;
          do {
            u(e5, t6[o2], r5[o2]), a2 > 0 ? (a2--, o2++) : (o2 = e5.ReadByte()) == s2 + 1 && (a2 = e5.ReadByte()), s2 = o2;
          } while (0 != o2);
        })(e4, r4, n3);
        for (var h3 = new Array(256), l2 = 0; l2 < 256; l2++) h3[l2] = s(n3[l2]);
        for (var c2 = new Array(4), d2 = new Array(4), p = 0; p < 4; p++) c2[p] = e4.ReadUint32(), d2[p] = 0;
        var g = new Buffer.allocUnsafe(t5), m = Math.floor(t5 / 4);
        for (l2 = 0; l2 < m; l2++) for (p = 0; p < 4; p++) {
          var y = i(c2[p]), b = h3[d2[p]][y];
          g[l2 + p * m] = b, c2[p] = a(c2[p], n3[d2[p]][b], r4[d2[p]][b]), c2[p] = f(e4, c2[p]), d2[p] = b;
        }
        for (l2 *= 4; l2 < t5; ) y = i(c2[3]), b = o(n3[d2[3]], y), g[l2++] = b, c2[3] = a(c2[3], n3[d2[3]][b], r4[d2[3]][b]), c2[3] = f(e4, c2[3]), d2[3] = b;
        return g;
      })(t4, h2);
    }, encode: function(e3, t4) {
      return 0 == t4 ? (function(e4) {
        const t5 = e4.length;
        var r3 = new n2("", 0, 780);
        r3.WriteByte(0), r3.WriteUint32(0), r3.WriteUint32(0);
        var i2 = new Array(256);
        (function(e5, t6) {
          for (var r4 = 0; r4 < 256; r4++) t6[r4] = 0;
          for (r4 = 0; r4 < e5.length; r4++) t6[e5[r4]]++;
        })(e4, i2), c(i2), d(r3, i2);
        var o2 = new Array(256);
        o2[0] = 0;
        for (var s2 = 1; s2 < 256; s2++) o2[s2] = o2[s2 - 1] + i2[s2 - 1];
        var a2 = new Array(4);
        for (s2 = 0; s2 < 4; s2++) a2[s2] = 1 << 23;
        var f2 = Math.floor(1.05 * t5 + 100), u2 = new n2("", f2, f2);
        for (s2 = t5 - 1; s2 >= 0; s2--) a2[s2 % 4] = l(a2[s2 % 4], u2, o2[e4[s2]], i2[e4[s2]], 12);
        for (s2 = 3; s2 >= 0; s2--) h(a2[s2], u2);
        var p = r3.pos;
        return r3.buf.writeInt32LE(p - 9 + (u2.length - u2.pos), 1), r3.buf.writeInt32LE(t5, 5), Buffer.concat([r3.buf.slice(0, r3.pos), u2.buf.slice(u2.pos, u2.length)], r3.pos + u2.length - u2.pos);
      })(e3) : (function(e4) {
        const t5 = e4.length;
        var r3 = new n2("", 0, 198156);
        r3.WriteByte(1), r3.WriteUint32(0), r3.WriteUint32(0);
        for (var i2 = new Array(256), o2 = new Array(256), s2 = new Array(256), a2 = 0; a2 < 256; a2++) o2[a2] = new Array(256), s2[a2] = new Array(256);
        for ((function(e5, t6, r4) {
          for (var n3 = 0; n3 < 256; n3++) {
            r4[n3] = 0;
            for (var i3 = 0; i3 < 256; i3++) t6[n3][i3] = 0;
          }
          var o3 = 0;
          for (n3 = 0; n3 < e5.length; n3++) r4[e5[n3]]++, t6[o3][e5[n3]]++, o3 = e5[n3];
          t6[0][e5[1 * (e5.length >> 2)]]++, t6[0][e5[2 * (e5.length >> 2)]]++, t6[0][e5[3 * (e5.length >> 2)]]++, r4[0] += 3;
        })(e4, o2, i2), (function(e5, t6) {
          for (var r4 = 0; r4 < 256; r4++) t6[r4] && c(e5[r4]);
        })(o2, i2), (function(e5, t6, r4) {
          for (var n3 = 0, i3 = 0; i3 < 256; i3++) if (r4[i3]) {
            if (n3 > 0) n3--;
            else if (e5.WriteByte(i3), i3 > 0 && r4[i3 - 1] > 0) {
              for (n3 = i3 + 1; n3 < 256 && r4[n3]; n3++) ;
              n3 -= i3 + 1, e5.WriteByte(n3);
            }
            d(e5, t6[i3]);
          }
          e5.WriteByte(0);
        })(r3, o2, i2), a2 = 0; a2 < 256; a2++) if (i2[a2]) {
          s2[a2][0] = 0;
          for (var f2 = 1; f2 < 256; f2++) s2[a2][f2] = s2[a2][f2 - 1] + o2[a2][f2 - 1];
        }
        var u2 = new Array(4), p = new Array(4);
        for (f2 = 0; f2 < 4; f2++) u2[f2] = 1 << 23, p[f2] = 0;
        var g = new n2("", t5, t5), m = Math.floor(t5 / 4), y = new Array(4), b = new Array(4);
        for (f2 = 0; f2 < 4; f2++) y[f2] = (f2 + 1) * m - 2, b[f2] = e4[y[f2] + 1];
        for (b[3] = e4[t5 - 1], a2 = t5 - 2; a2 > 4 * m - 2; a2--) u2[3] = l(u2[3], g, s2[e4[a2]][b[3]], o2[e4[a2]][b[3]], 12), b[3] = e4[a2];
        for (; y[0] >= 0; ) for (f2 = 3; f2 >= 0; f2--) {
          var v = e4[y[f2]];
          u2[f2] = l(u2[f2], g, s2[v][b[f2]], o2[v][b[f2]], 12), b[f2] = v, y[f2]--;
        }
        for (f2 = 3; f2 >= 0; f2--) u2[f2] = l(u2[f2], g, s2[0][b[f2]], o2[0][b[f2]], 12);
        for (a2 = 3; a2 >= 0; a2--) h(u2[a2], g);
        var w = r3.pos;
        return r3.buf.writeInt32LE(w - 9 + (g.length - g.pos), 1), r3.buf.writeInt32LE(t5, 5), Buffer.concat([r3.buf.slice(0, r3.pos), g.buf.slice(g.pos, g.length)], r3.pos + g.length - g.pos);
      })(e3);
    } };
  }, 594: (e2, t3, r2) => {
    const n2 = r2(9260);
    function i(e3, t4) {
      return e3 & (1 << t4) - 1;
    }
    function o(e3, t4) {
      for (var r3 = 0; t4 >= e3[r3 + 1]; ) r3++;
      return r3;
    }
    function s(e3, t4) {
      for (var r3 = 1 << t4, n3 = new Array(r3), i2 = 0, o2 = 0; o2 < r3; o2++) {
        for (; o2 >= e3[i2 + 1]; ) i2++;
        n3[o2] = i2;
      }
      return n3;
    }
    function a(e3, t4, r3, n3) {
      return r3 * (e3 >> n3) + (e3 & (1 << n3) - 1) - t4;
    }
    function f(e3, t4) {
      return t4 < 32768 && (t4 = (t4 << 16) + e3.ReadUint16()), t4;
    }
    function h(e3, t4) {
      t4.WriteByteNeg(e3 >> 24 & 255), t4.WriteByteNeg(e3 >> 16 & 255), t4.WriteByteNeg(e3 >> 8 & 255), t4.WriteByteNeg(e3 >> 0 & 255);
    }
    function l(e3, t4, r3, n3, i2) {
      return e3 = (function(e4, t5, r4, n4) {
        for (var i3 = (1 << 31 - n4) * r4; e4 >= i3; ) t5.WriteByteNeg(e4 >> 8 & 255), t5.WriteByteNeg(255 & e4), e4 >>= 16;
        return e4;
      })(e3, t4, n3, i2), (Math.floor(e3 / n3) << i2) + e3 % n3 + r3;
    }
    function u(e3, t4, r3) {
      0 == r3 && (r3 = 4);
      for (var i2 = new Array(r3), o2 = new Array(r3), s2 = 0; s2 < r3; s2++) o2[s2] = Math.floor(t4.length / r3) + (t4.length % r3 > s2), i2[s2] = new Array(o2[s2]);
      for (var a2 = 0, f2 = 0; f2 < t4.length; f2 += r3, a2++) for (var h2 = 0; h2 < r3; h2++) a2 < i2[h2].length && (i2[h2][a2] = t4[f2 + h2]);
      var l2 = new Array(r3), u2 = 0;
      for (s2 = 0; s2 < r3; s2++) {
        var c2 = d(i2[s2], 0), p2 = d(i2[s2], 1);
        l2[s2] = p2.length < c2.length ? p2 : c2, u2 += l2[s2].length;
      }
      var g2 = new n2("", 0, u2 + 5 * r3 + 1);
      for (g2.WriteByte(r3), s2 = 0; s2 < r3; s2++) g2.WriteUint7(l2[s2].length);
      for (s2 = 0; s2 < r3; s2++) g2.WriteData(l2[s2], l2[s2].length);
      return g2.buf.slice(0, g2.buf.pos);
    }
    function c(e3, t4) {
      var r3 = e3.ReadByte(), h2 = 1 & r3, l2 = 8 & r3, u2 = 32 & r3, d2 = 64 & r3, m2 = 128 & r3;
      if (16 & r3 || (t4 = e3.ReadUint7()), l2) return (function(e4, t5) {
        for (var r4 = e4.ReadByte(), n3 = new Array(r4), i2 = new Array(r4), o2 = 0; o2 < r4; o2++) n3[o2] = e4.ReadUint7();
        var s2 = new Array(r4);
        for (o2 = 0; o2 < r4; o2++) i2[o2] = Math.floor(t5 / r4) + (t5 % r4 > o2), s2[o2] = c(e4, i2[o2]);
        var a2 = new Buffer.allocUnsafe(t5);
        for (o2 = 0; o2 < r4; o2++) for (var f2 = 0; f2 < i2[o2]; f2++) a2[f2 * r4 + o2] = s2[o2][f2];
        return a2;
      })(e3, t4);
      if (m2) var b2 = t4, [v2, w, t4] = (function(e4) {
        for (var t5 = e4.ReadByte(), r4 = new Array(t5), n3 = 0; n3 < t5; n3++) r4[n3] = e4.ReadByte();
        return [r4, t5, e4.ReadUint7()];
      })(e3);
      if (d2) var _ = t4, [B, E, t4] = (function(e4) {
        var t5 = e4.ReadUint7(), r4 = e4.ReadUint7();
        if (1 & t5) var i2 = e4.ReadData((t5 - 1) / 2);
        else {
          var o2 = e4.ReadUint7();
          i2 = e4.ReadData(o2), i2 = g(new n2(i2), t5 / 2);
        }
        i2 = new n2(i2);
        var s2 = new Array(256), a2 = i2.ReadByte();
        0 == a2 && (a2 = 256);
        for (var f2 = 0; f2 < a2; f2++) s2[i2.ReadByte()] = 1;
        return [s2, i2, r4];
      })(e3);
      if (u2) var S = e3.ReadData(t4);
      else S = 0 == h2 ? g(e3, t4) : (function(e4, t5) {
        var r4 = (c2 = e4.ReadByte()) >> 4, h3 = e4;
        if (1 & c2) {
          var l3 = e4.ReadUint7(), u3 = e4.ReadUint7(), c2 = new n2(e4.ReadData(u3));
          h3 = new n2(g(c2, l3));
        }
        var d3 = new Array(256), m3 = new Array(256);
        !(function(e5, t6, r5, n3) {
          for (var i2 = 0; i2 < 256; i2++) {
            t6[i2] = new Array(256), r5[i2] = new Array(256);
            for (var o2 = 0; o2 < 256; o2++) t6[i2][o2] = 0;
          }
          var s2 = p(e5);
          for (i2 = 0; i2 < 256; i2++) if (s2[i2]) {
            var a2 = 0;
            for (o2 = 0; o2 < 256; o2++) s2[o2] && (a2 > 0 ? a2-- : (t6[i2][o2] = e5.ReadUint7(), 0 == t6[i2][o2] && (a2 = e5.ReadByte())));
            for (y(t6[i2], n3), r5[i2][0] = 0, o2 = 0; o2 < 256; o2++) r5[i2][o2 + 1] = r5[i2][o2] + t6[i2][o2];
          }
        })(h3, d3, m3, r4);
        for (var b3 = new Array(256), v3 = 0; v3 < 256; v3++) b3[v3] = s(m3[v3], r4);
        for (var w2 = new Array(4), _2 = new Array(4), B2 = 0; B2 < 4; B2++) w2[B2] = e4.ReadUint32(), _2[B2] = 0;
        var E2 = new Buffer.allocUnsafe(t5), S2 = Math.floor(t5 / 4);
        for (v3 = 0; v3 < S2; v3++) for (B2 = 0; B2 < 4; B2++) {
          var A = i(w2[B2], r4), C = b3[_2[B2]][A];
          E2[v3 + B2 * S2] = C, w2[B2] = a(w2[B2], m3[_2[B2]][C], d3[_2[B2]][C], r4), w2[B2] = f(e4, w2[B2]), _2[B2] = C;
        }
        for (v3 *= 4; v3 < t5; ) A = i(w2[3], r4), C = o(m3[_2[3]], A), E2[v3++] = C, w2[3] = a(w2[3], m3[_2[3]][C], d3[_2[3]][C], r4), w2[3] = f(e4, w2[3]), _2[3] = C;
        return E2;
      })(e3, t4);
      return d2 && (S = (function(e4, t5, r4, i2) {
        new n2(e4);
        for (var o2 = new Buffer.allocUnsafe(i2), s2 = 0, a2 = 0; s2 < i2; a2++) {
          var f2 = e4[a2];
          if (t5[f2]) for (var h3 = r4.ReadUint7(), l3 = 0; l3 <= h3; l3++) o2[s2++] = f2;
          else o2[s2++] = f2;
        }
        return o2;
      })(S, B, E, _)), m2 && (S = (function(e4, t5, r4, n3) {
        var i2 = new Buffer.allocUnsafe(n3), o2 = 0;
        if (r4 <= 1) for (var s2 = 0; s2 < n3; s2++) i2[s2] = t5[0];
        else if (r4 <= 2) for (s2 = 0; s2 < n3; s2++) {
          if (s2 % 8 == 0) var a2 = e4[o2++];
          i2[s2] = t5[1 & a2], a2 >>= 1;
        }
        else if (r4 <= 4) for (s2 = 0; s2 < n3; s2++) s2 % 4 == 0 && (a2 = e4[o2++]), i2[s2] = t5[3 & a2], a2 >>= 2;
        else if (r4 <= 16) for (s2 = 0; s2 < n3; s2++) s2 % 2 == 0 && (a2 = e4[o2++]), i2[s2] = t5[15 & a2], a2 >>= 4;
        return i2;
      })(S, v2, w, b2)), S;
    }
    function d(e3, t4) {
      var r3 = new n2("", 0, 10);
      r3.WriteByte(t4);
      var i2 = 1 & t4, o2 = 8 & t4, s2 = 32 & t4, a2 = 64 & t4, f2 = 128 & t4, c2 = t4 >> 8;
      if (16 & t4 || r3.WriteUint7(e3.length), o2) return Buffer.concat([r3.buf.slice(0, r3.pos), u(0, e3, c2)]);
      var d2 = new Buffer.alloc(0);
      f2 && ([d2, e3] = (function(e4) {
        for (var t5 = new Array(256), r4 = 0; r4 < 256; r4++) t5[r4] = 0;
        for (r4 = 0; r4 < e4.length; r4++) t5[e4[r4]]++;
        var i3 = new Array(256), o3 = 0;
        for (r4 = 0; r4 < 256; r4++) t5[r4] > 0 && (i3[r4] = o3++);
        if (!(o3 > 16)) {
          if (o3 <= 1) var s3 = new Buffer.allocUnsafe(0);
          else if (o3 <= 2) {
            s3 = new Buffer.allocUnsafe(Math.ceil(e4.length / 8));
            var a3 = -1;
            for (r4 = 0; r4 < e4.length; r4++) r4 % 8 == 0 && (s3[++a3] = 0), s3[a3] += i3[e4[r4]] << r4 % 8;
          } else if (o3 <= 4) for (s3 = new Buffer.allocUnsafe(Math.ceil(e4.length / 4)), a3 = -1, r4 = 0; r4 < e4.length; r4++) r4 % 4 == 0 && (s3[++a3] = 0), s3[a3] += i3[e4[r4]] << r4 % 4 * 2;
          else for (s3 = new Buffer.allocUnsafe(Math.ceil(e4.length / 2)), a3 = -1, r4 = 0; r4 < e4.length; r4++) r4 % 2 == 0 && (s3[++a3] = 0), s3[a3] += i3[e4[r4]] << r4 % 2 * 4;
          var f3 = new n2("", 0, o3 + 5);
          for (f3.WriteByte(o3), a3 = 0, r4 = 0; r4 < 256; r4++) t5[r4] > 0 && (t5[r4] = a3++, f3.WriteByte(r4));
          return f3.WriteUint7(s3.length), [f3.buf.slice(0, f3.pos), s3];
        }
      })(e3));
      var p2 = new Buffer.alloc(0);
      if (a2 && ([p2, e3] = (function(e4) {
        for (var t5 = new Array(256), r4 = 0; r4 < 256; r4++) t5[r4] = 0;
        var i3 = -1;
        for (r4 = 0; r4 < e4.length; r4++) t5[e4[r4]] += e4[r4] == i3 ? 1 : -1, i3 = e4[r4];
        var o3 = 0;
        for (r4 = 0; r4 < 256; r4++) t5[r4] > 0 && o3++;
        for (o3 || (o3 = 1, t5[0] = 1), (h2 = new n2("", 0, o3 + 1 + e4.length)).WriteByte(o3), r4 = 0; r4 < 256; r4++) t5[r4] > 0 && h2.WriteByte(r4);
        var s3 = new Buffer.allocUnsafe(e4.length), a3 = 0;
        for (r4 = 0; r4 < e4.length; r4++) if (s3[a3++] = e4[r4], t5[e4[r4]] > 0) {
          i3 = e4[r4];
          for (var f3 = 0; r4 + f3 + 1 < e4.length && e4[r4 + f3 + 1] == i3; ) f3++;
          h2.WriteUint7(f3), r4 += f3;
        }
        var h2, l2 = v(h2.buf.slice(0, h2.pos)), u2 = new n2("", 0, 16);
        return u2.WriteUint7(2 * h2.pos), u2.WriteUint7(a3), u2.WriteUint7(l2.length), [h2 = Buffer.concat([u2.buf.slice(0, u2.pos), l2]), s3.slice(0, a3)];
      })(e3)), e3.length < 4 && 1 == i2 && (i2 = 0, r3.buf[0] &= -2), s2) var g2 = e3;
      else g2 = 0 == i2 ? v(e3) : (function(e4) {
        const t5 = e4.length;
        for (var r4 = new n2("", 0, 198156), i3 = new Array(256), o3 = new Array(256), s3 = new Array(256), a3 = 0; a3 < 256; a3++) o3[a3] = new Array(256), s3[a3] = new Array(256);
        var f3 = 12;
        (function(e5, t6, r5) {
          for (var n3 = 0; n3 < 256; n3++) {
            r5[n3] = 0;
            for (var i4 = 0; i4 < 256; i4++) t6[n3][i4] = 0;
          }
          var o4 = 0;
          for (n3 = 0; n3 < e5.length; n3++) r5[o4]++, t6[o4][e5[n3]]++, o4 = e5[n3];
          r5[o4]++, t6[0][e5[1 * (e5.length >> 2)]]++, t6[0][e5[2 * (e5.length >> 2)]]++, t6[0][e5[3 * (e5.length >> 2)]]++, r5[0] += 3;
        })(e4, o3, i3), (function(e5, t6, r5) {
          for (var n3 = 0; n3 < 256; n3++) if (t6[n3]) {
            var i4 = Math.ceil(Math.log2(t6[n3]));
            i4 > 12 && (i4 = 12), m(e5[n3], i4);
          }
        })(o3, i3);
        var u2 = new n2("", 0, 198156);
        !(function(e5, t6, r5) {
          b(e5, r5);
          for (var n3 = 0; n3 < 256; n3++) if (r5[n3]) {
            for (var i4 = 0, o4 = 0; o4 < 256; o4++) if (r5[o4]) {
              if (i4) i4--;
              else if (e5.WriteUint7(t6[n3][o4]), !t6[n3][o4]) {
                for (var s4 = o4 + 1; s4 < 256; s4++) if (r5[s4]) {
                  if (0 != t6[n3][s4]) break;
                  i4++;
                }
                e5.WriteByte(i4);
              }
            }
          }
        })(u2, o3, i3);
        var c3 = v(u2.buf.slice(0, u2.pos));
        for (c3.length < u2.pos ? (r4.WriteByte(193), r4.WriteUint7(u2.pos), r4.WriteUint7(c3.length), r4.WriteData(c3, c3.length)) : (r4.WriteByte(192), r4.WriteData(u2.buf, u2.pos)), (function(e5, t6, r5) {
          for (var n3 = 0; n3 < 256; n3++) t6[n3] && y(e5[n3], 12);
        })(o3, i3), a3 = 0; a3 < 256; a3++) if (i3[a3]) {
          s3[a3][0] = 0;
          for (var d3 = 1; d3 < 256; d3++) s3[a3][d3] = s3[a3][d3 - 1] + o3[a3][d3 - 1];
        }
        var p3 = new Array(4), g3 = new Array(4);
        for (d3 = 0; d3 < 4; d3++) p3[d3] = 32768, g3[d3] = 0;
        var w = new n2("", 1.05 * t5 + 100 >> 0, 1.05 * t5 + 100 >> 0), _ = Math.floor(t5 / 4), B = new Array(4), E = new Array(4);
        for (d3 = 0; d3 < 4; d3++) B[d3] = (d3 + 1) * _ - 2, E[d3] = e4[B[d3] + 1];
        for (E[3] = e4[t5 - 1], a3 = t5 - 2; a3 > 4 * _ - 2; a3--) p3[3] = l(p3[3], w, s3[e4[a3]][E[3]], o3[e4[a3]][E[3]], f3), E[3] = e4[a3];
        for (; B[0] >= 0; ) for (d3 = 3; d3 >= 0; d3--) {
          var S = e4[B[d3]];
          p3[d3] = l(p3[d3], w, s3[S][E[d3]], o3[S][E[d3]], f3), E[d3] = S, B[d3]--;
        }
        for (d3 = 3; d3 >= 0; d3--) p3[d3] = l(p3[d3], w, s3[0][E[d3]], o3[0][E[d3]], f3);
        for (a3 = 3; a3 >= 0; a3--) h(p3[a3], w);
        return Buffer.concat([r4.buf.slice(0, r4.pos), w.buf.slice(w.pos, w.length)], r4.pos + w.length - w.pos);
      })(e3);
      return Buffer.concat([r3.buf.slice(0, r3.pos), d2, p2, g2]);
    }
    function p(e3) {
      for (var t4 = new Array(256), r3 = 0; r3 < 256; r3++) t4[r3] = 0;
      var n3 = 0, i2 = e3.ReadByte(), o2 = i2;
      do {
        t4[i2] = 1, n3 > 0 ? (n3--, i2++) : (i2 = e3.ReadByte()) == o2 + 1 && (n3 = e3.ReadByte()), o2 = i2;
      } while (0 != i2);
      return t4;
    }
    function g(e3, t4) {
      var r3 = new Array(256), n3 = new Array(256);
      !(function(e4, t5, r4) {
        for (var n4 = 0; n4 < 256; n4++) t5[n4] = 0;
        var i2 = p(e4);
        for (n4 = 0; n4 < 256; n4++) i2[n4] > 0 && (t5[n4] = e4.ReadUint7());
        for (y(t5, 12), r4[0] = 0, n4 = 0; n4 <= 255; n4++) r4[n4 + 1] = r4[n4] + t5[n4];
      })(e3, r3, n3);
      for (var o2 = s(n3, 12), h2 = new Array(4), l2 = 0; l2 < 4; l2++) h2[l2] = e3.ReadUint32();
      var u2 = new Buffer.allocUnsafe(t4);
      for (l2 = 0; l2 < t4; l2++) {
        var c2 = l2 % 4, d2 = o2[i(h2[c2], 12)];
        u2[l2] = d2, h2[c2] = a(h2[c2], n3[d2], r3[d2], 12), h2[c2] = f(e3, h2[c2]);
      }
      return u2;
    }
    function m(e3, t4) {
      for (var r3 = 0, n3 = 0; n3 < 256; n3++) r3 += e3[n3];
      const i2 = 1 << t4;
      var o2 = i2 / r3;
      do {
        var s2 = 0, a2 = 0, f2 = 0;
        for (r3 = 0, n3 = 0; n3 < 256; n3++) 0 != e3[n3] && (s2 < e3[n3] && (s2 = e3[n3], a2 = n3), e3[n3] = Math.floor(e3[n3] * o2), 0 == e3[n3] && (e3[n3] = 1), r3 += e3[n3]);
        r3 < i2 ? e3[a2] += i2 - r3 : r3 - i2 < e3[a2] / 2 && e3[a2] > 2 ? e3[a2] -= r3 - i2 : r3 != i2 && (o2 = i2 / r3, f2 = 1);
      } while (f2);
    }
    function y(e3, t4) {
      for (var r3 = 0, n3 = 0; n3 < 256; n3++) r3 += e3[n3];
      if (0 != r3 && r3 != 1 << t4) {
        for (var i2 = 0; r3 < 1 << t4; ) r3 *= 2, i2++;
        for (n3 = 0; n3 < 256; n3++) e3[n3] <<= i2;
      }
    }
    function b(e3, t4) {
      for (var r3 = 0, n3 = 0; n3 < 256; n3++) if (t4[n3]) {
        if (r3 > 0) r3--;
        else if (e3.WriteByte(n3), n3 > 0 && t4[n3 - 1] > 0) {
          for (r3 = n3 + 1; r3 < 256 && t4[r3]; r3++) ;
          r3 -= n3 + 1, e3.WriteByte(r3);
        }
      }
      e3.WriteByte(0);
    }
    function v(e3) {
      const t4 = e3.length;
      var r3 = new n2("", 0, 780), i2 = new Array(256);
      !(function(e4, t5) {
        for (var r4 = 0; r4 < 256; r4++) t5[r4] = 0;
        for (r4 = 0; r4 < e4.length; r4++) t5[e4[r4]]++;
      })(e3, i2);
      var o2 = Math.ceil(Math.log2(t4));
      o2 > 12 && (o2 = 12), m(i2, o2), (function(e4, t5) {
        b(e4, t5);
        for (var r4 = 0; r4 < 256; r4++) t5[r4] && e4.WriteUint7(t5[r4]);
      })(r3, i2), m(i2, 12);
      var s2 = new Array(256);
      s2[0] = 0;
      for (var a2 = 1; a2 < 256; a2++) s2[a2] = s2[a2 - 1] + i2[a2 - 1];
      var f2 = new Array(4);
      for (a2 = 0; a2 < 4; a2++) f2[a2] = 32768;
      var u2 = new n2("", 1.05 * t4 + 100 >> 0, 1.05 * t4 + 100 >> 0);
      for (a2 = t4 - 1; a2 >= 0; a2--) f2[a2 % 4] = l(f2[a2 % 4], u2, s2[e3[a2]], i2[e3[a2]], 12);
      for (a2 = 3; a2 >= 0; a2--) h(f2[a2], u2);
      return Buffer.concat([r3.buf.slice(0, r3.pos), u2.buf.slice(u2.pos, u2.length)], r3.pos + u2.length - u2.pos);
    }
    e2.exports = { decode: function(e3) {
      return c(new n2(e3), 0);
    }, encode: d };
  }, 2881: (e2, t3, r2) => {
    const n2 = r2(9260), i = r2(594);
    var o = new (r2(445))();
    function s(e3, t4) {
      for (var r3 = e3 + ""; r3.length < t4; ) r3 = "0" + r3;
      return r3;
    }
    function a(e3, t4, r3, n3) {
      var i2 = e3[0][0].ReadByte(), o2 = n3 - e3[0][i2].ReadUint32();
      if (5 == i2) return t4[n3] = t4[o2], r3[n3] = r3[o2], t4[n3];
      var a2 = 1;
      t4[n3] = "", r3[n3] = new Array(256);
      do {
        switch (i2 = e3[a2][0].ReadByte()) {
          case 2:
            r3[n3][a2] = e3[a2][2].ReadChar();
            break;
          case 1:
            r3[n3][a2] = e3[a2][1].ReadString();
            break;
          case 7:
            r3[n3][a2] = e3[a2][7].ReadUint32();
            break;
          case 3:
            var f2 = e3[a2][3].ReadUint32(), h2 = e3[a2][4].ReadByte();
            r3[n3][a2] = s(f2, h2);
            break;
          case 8:
            r3[n3][a2] = (r3[o2][a2] >> 0) + e3[a2][8].ReadByte();
            break;
          case 9:
            f2 = (r3[o2][a2] >> 0) + e3[a2][9].ReadByte(), h2 = r3[o2][a2].length, r3[n3][a2] = s(f2, h2);
            break;
          case 10:
            r3[n3][a2] = r3[o2][a2];
            break;
          default:
            r3[n3][a2] = "";
        }
        t4[n3] += r3[n3][a2++];
      } while (12 != i2);
      return t4[n3];
    }
    function f(e3, t4, r3, n3, i2, o2) {
      for (var s2 = 0; s2 < n3.length; s2++) if (!(r3 > 0 && 5 == t4[s2][0].type) && t4[s2][r3]) switch (e3[0].WriteByte(t4[s2][r3].type), t4[s2][r3].type) {
        case 6:
          e3[6].WriteUint32(t4[s2][r3].val);
          break;
        case 5:
          e3[5].WriteUint32(t4[s2][r3].val);
          break;
        case 1:
          e3[1].WriteString(t4[s2][r3].val);
          break;
        case 2:
          e3[2].WriteChar(t4[s2][r3].val);
          break;
        case 7:
          e3[7].WriteUint32(t4[s2][r3].val);
          break;
        case 3:
          e3[3].WriteUint32(t4[s2][r3].val), e3[4].WriteByte(t4[s2][r3].val.length);
          break;
        case 8:
        case 9:
          e3[t4[s2][r3].type].WriteByte(t4[s2][r3].val);
      }
    }
    function h(e3, t4, r3, n3) {
      for (var i2 = 0; i2 <= 12; i2++) if (!(e3[i2].pos <= 0)) {
        n3.WriteByte(i2 + (0 == i2 ? 128 : 0)), e3[i2] = e3[i2].buf.slice(0, e3[i2].pos);
        var o2 = l(e3[i2], r3);
        n3.WriteUint7(o2.length), n3.WriteData(o2, o2.length);
      }
    }
    function l(e3, t4) {
      var r3, n3 = 1 << 30, s2 = [0, 1, 64, 65, 128, 129, 201];
      for (var a2 in s2) {
        var f2 = s2[a2];
        if (!(1 & f2 && e3.length < 100 || 8 & f2 && e3.length % 4 != 0)) {
          try {
            var h2 = t4 ? o.encode(e3, f2) : i.encode(e3, f2);
          } catch (e4) {
            h2 = 0;
          }
          h2 && n3 > h2.length && (n3 = h2.length, r3 = h2);
        }
      }
      return r3;
    }
    function u(e3, t4, r3, n3, i2) {
      var o2 = 0, s2 = i2 - 1;
      e3[i2] = new Array(256), t4[n3] ? e3[i2][0] = { type: 5, val: i2 - t4[n3] } : e3[i2][0] = { type: 6, val: 0 == i2 ? 0 : 1 }, t4[n3] = i2;
      for (var a2 = n3.match(/([a-zA-Z0-9]{1,9})|([^a-zA-Z0-9]+)/g), f2 = 0; f2 < a2.length; f2++) {
        var h2 = f2 + 1, l2 = 1, u2 = a2[f2];
        if (a2[f2].match(/^0+[0-9]*$/g) ? l2 = 3 : a2[f2].match(/^[0-9]+$/g) ? l2 = 7 : 1 == a2[f2].length && (l2 = 2), s2 >= 0 && e3[s2][h2]) if (e3[s2][h2].str == a2[f2]) l2 = 10, u2 = "";
        else if (7 == e3[s2][h2].type || 8 == e3[s2][h2].type) {
          var c = u2 - e3[s2][h2].str;
          r3[h2]++, c >= 0 && c < 256 && r3[h2] > i2 / 2 && (l2 = 8, u2 = c);
        } else 3 != e3[s2][h2].type && 9 != e3[s2][h2].type || e3[s2][h2].str.length != u2.length || (c = u2 - e3[s2][h2].str, r3[h2]++, c >= 0 && c < 256 && r3[h2] > i2 / 2 && (l2 = 9, u2 = c));
        e3[i2][h2] = { str: a2[f2], val: u2, type: l2 }, o2 < e3[i2][h2].val.length + 3 && (o2 = e3[i2][h2].val.length + 3);
      }
      return e3[i2][++h2] = { type: 12 }, [h2 + 1, o2];
    }
    e2.exports = { encode: function(e3, t4) {
      var r3 = e3.toString();
      "\n" == r3[r3.length - 1] && (r3 = r3.substring(0, r3.length - 1));
      var i2 = r3.split("\n"), o2 = new n2("", 0, 2 * r3.length + 1e4);
      o2.WriteUint32(r3.length), o2.WriteUint32(i2.length), o2.WriteByte(t4);
      for (var s2 = new Array(i2.length), a2 = {}, l2 = new Array(256).fill(0), c = 0, d = 0, p = 0; p < i2.length; p++) {
        var [g, m] = u(s2, a2, l2, i2[p], p);
        c < g && (c = g), d < m && (d = m);
      }
      for (var y = 0; y < c; y++) {
        for (var b = new Array(13), v = 0; v <= 12; v++) b[v] = new n2("", 0, i2.length * d);
        f(b, s2, y, i2), h(b, 0, t4, o2);
      }
      return o2.buf.slice(0, o2.pos);
    }, decode: function(e3, t4, r3) {
      (e3 = new n2(e3)).ReadUint32();
      var s2 = e3.ReadUint32(), f2 = e3.ReadByte(), h2 = (function(e4, t5, r4, s3) {
        for (var a2 = -1, f3 = new Array(256); !e4.EOF(); ) {
          var h3 = e4.ReadByte(), l3 = 128 & h3, u3 = 64 & h3, c2 = 63 & h3;
          if (l3 && (f3[++a2] = new Array(13)), 0 != c2 && l3) {
            var d2 = new Array(s3 - 1).fill(10);
            f3[a2][0] = new n2(Buffer.from([c2].concat(d2)));
          }
          if (u3) {
            var p = e4.ReadByte(), g = e4.ReadByte();
            f3[a2][c2] = new n2(f3[p][g].buf);
          } else {
            var m = e4.ReadUint7(), y = e4.ReadData(m);
            f3[a2][c2] = r4 ? o.decode(y) : i.decode(y), f3[a2][c2] = new n2(f3[a2][c2]);
          }
        }
        return f3;
      })(e3, 0, f2, s2), l2 = new Array(s2), u2 = new Array(s2), c = "";
      void 0 === r3 && (r3 = "\n");
      for (var d = 0; d < s2; d++) c += a(h2, l2, u2, d) + r3;
      return c;
    } };
  }, 1422: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = r2(8904), o = n2(r2(9049)), s = n2(r2(450));
    class a {
      constructor({ fill: e3, cache: t4 }) {
        if ("function" != typeof e3) throw new TypeError("must pass a fill function");
        if ("object" != typeof t4) throw new TypeError("must pass a cache object");
        if ("function" != typeof t4.get || "function" != typeof t4.set || "function" != typeof t4.delete) throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");
        this.cache = t4, this.fillCallback = e3;
      }
      static isAbortException(e3) {
        return "AbortError" === e3.name || "ERR_ABORTED" === e3.code || "AbortError: aborted" === e3.message || "Error: aborted" === e3.message;
      }
      evict(e3, t4) {
        this.cache.get(e3) === t4 && this.cache.delete(e3);
      }
      fill(e3, t4, r3, n3) {
        const i2 = new o.default(), a2 = new s.default();
        a2.addCallback(n3);
        const f = { aborter: i2, promise: this.fillCallback(t4, i2.signal, ((e4) => {
          a2.callback(e4);
        })), settled: false, statusReporter: a2, get aborted() {
          return this.aborter.signal.aborted;
        } };
        f.aborter.addSignal(r3), f.aborter.signal.addEventListener("abort", (() => {
          f.settled || this.evict(e3, f);
        })), f.promise.then((() => {
          f.settled = true;
        }), (() => {
          f.settled = true, this.evict(e3, f);
        })).catch(((e4) => {
          throw console.error(e4), e4;
        })), this.cache.set(e3, f);
      }
      static checkSinglePromise(e3, t4) {
        function r3() {
          if (t4 && t4.aborted) throw Object.assign(new Error("aborted"), { code: "ERR_ABORTED" });
        }
        return e3.then(((e4) => (r3(), e4)), ((e4) => {
          throw r3(), e4;
        }));
      }
      has(e3) {
        return this.cache.has(e3);
      }
      get(e3, t4, r3, n3) {
        if (!r3 && t4 instanceof i.AbortSignal) throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");
        const o2 = this.cache.get(e3);
        return o2 ? o2.aborted && !o2.settled ? (this.evict(e3, o2), this.get(e3, t4, r3, n3)) : o2.settled ? o2.promise : (o2.aborter.addSignal(r3), o2.statusReporter.addCallback(n3), a.checkSinglePromise(o2.promise, r3)) : (this.fill(e3, t4, r3, n3), a.checkSinglePromise(this.cache.get(e3).promise, r3));
      }
      delete(e3) {
        const t4 = this.cache.get(e3);
        t4 && (t4.settled || t4.aborter.abort(), this.cache.delete(e3));
      }
      clear() {
        const e3 = this.cache.keys();
        let t4 = 0;
        for (let r3 = e3.next(); !r3.done; r3 = e3.next()) this.delete(r3.value), t4 += 1;
        return t4;
      }
    }
    t3.default = a;
  }, 9049: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true });
    const n2 = r2(8904);
    class i {
    }
    t3.default = class {
      constructor() {
        this.signals = /* @__PURE__ */ new Set(), this.abortController = new n2.AbortController();
      }
      addSignal(e3 = new i()) {
        if (this.signal.aborted) throw new Error("cannot add a signal, already aborted!");
        this.signals.add(e3), e3.aborted ? this.handleAborted(e3) : "function" == typeof e3.addEventListener && e3.addEventListener("abort", (() => {
          this.handleAborted(e3);
        }));
      }
      handleAborted(e3) {
        this.signals.delete(e3), 0 === this.signals.size && this.abortController.abort();
      }
      get signal() {
        return this.abortController.signal;
      }
      abort() {
        this.abortController.abort();
      }
    };
  }, 450: (e2, t3) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.default = class {
      constructor() {
        this.callbacks = /* @__PURE__ */ new Set();
      }
      addCallback(e3 = (() => {
      })) {
        this.callbacks.add(e3), e3(this.currentMessage);
      }
      callback(e3) {
        this.currentMessage = e3, this.callbacks.forEach(((t4) => {
          t4(e3);
        }));
      }
    };
  }, 8904: (e2, t3, r2) => {
    Object.defineProperty(t3, "__esModule", { value: true }), t3.AbortSignal = t3.AbortController = void 0;
    const n2 = r2(5988);
    var i = function() {
      if ("undefined" != typeof self) return self;
      if ("undefined" != typeof window) return window;
      if (void 0 !== r2.g) return r2.g;
      throw new Error("unable to locate global object");
    };
    let o = void 0 === i().AbortController ? n2.AbortController : i().AbortController;
    t3.AbortController = o;
    let s = void 0 === i().AbortController ? n2.AbortSignal : i().AbortSignal;
    t3.AbortSignal = s;
  }, 4105: function(e2, t3, r2) {
    var n2 = this && this.__importDefault || function(e3) {
      return e3 && e3.__esModule ? e3 : { default: e3 };
    };
    Object.defineProperty(t3, "__esModule", { value: true });
    const i = n2(r2(1422));
    t3.default = i.default;
  }, 5988: (e2, t3) => {
    function r2(e3, t4) {
      if (!(e3 instanceof t4)) throw new TypeError("Cannot call a class as a function");
    }
    function n2(e3, t4) {
      for (var r3 = 0; r3 < t4.length; r3++) {
        var n3 = t4[r3];
        n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
      }
    }
    function i(e3, t4, r3) {
      return t4 && n2(e3.prototype, t4), Object.defineProperty(e3, "prototype", { writable: false }), e3;
    }
    function o(e3) {
      return o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e4) {
        return e4.__proto__ || Object.getPrototypeOf(e4);
      }, o(e3);
    }
    function s(e3, t4) {
      return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e4, t5) {
        return e4.__proto__ = t5, e4;
      }, s(e3, t4);
    }
    function a(e3) {
      if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e3;
    }
    function f(e3, t4) {
      if (t4 && ("object" == typeof t4 || "function" == typeof t4)) return t4;
      if (void 0 !== t4) throw new TypeError("Derived constructors may only return object or undefined");
      return a(e3);
    }
    function h(e3, t4) {
      for (; !Object.prototype.hasOwnProperty.call(e3, t4) && null !== (e3 = o(e3)); ) ;
      return e3;
    }
    function l() {
      return l = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e3, t4, r3) {
        var n3 = h(e3, t4);
        if (n3) {
          var i2 = Object.getOwnPropertyDescriptor(n3, t4);
          return i2.get ? i2.get.call(arguments.length < 3 ? e3 : r3) : i2.value;
        }
      }, l.apply(this, arguments);
    }
    Object.defineProperty(t3, "__esModule", { value: true });
    var u = (function() {
      function e3() {
        r2(this, e3), Object.defineProperty(this, "listeners", { value: {}, writable: true, configurable: true });
      }
      return i(e3, [{ key: "addEventListener", value: function(e4, t4, r3) {
        e4 in this.listeners || (this.listeners[e4] = []), this.listeners[e4].push({ callback: t4, options: r3 });
      } }, { key: "removeEventListener", value: function(e4, t4) {
        if (e4 in this.listeners) {
          for (var r3 = this.listeners[e4], n3 = 0, i2 = r3.length; n3 < i2; n3++) if (r3[n3].callback === t4) return void r3.splice(n3, 1);
        }
      } }, { key: "dispatchEvent", value: function(e4) {
        if (e4.type in this.listeners) {
          for (var t4 = this.listeners[e4.type].slice(), r3 = 0, n3 = t4.length; r3 < n3; r3++) {
            var i2 = t4[r3];
            try {
              i2.callback.call(this, e4);
            } catch (e5) {
              Promise.resolve().then((function() {
                throw e5;
              }));
            }
            i2.options && i2.options.once && this.removeEventListener(e4.type, i2.callback);
          }
          return !e4.defaultPrevented;
        }
      } }]), e3;
    })(), c = (function(e3) {
      !(function(e4, t5) {
        if ("function" != typeof t5 && null !== t5) throw new TypeError("Super expression must either be null or a function");
        e4.prototype = Object.create(t5 && t5.prototype, { constructor: { value: e4, writable: true, configurable: true } }), Object.defineProperty(e4, "prototype", { writable: false }), t5 && s(e4, t5);
      })(c2, e3);
      var t4, n3, h2 = (t4 = c2, n3 = (function() {
        if ("undefined" == typeof Reflect || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if ("function" == typeof Proxy) return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {
          }))), true;
        } catch (e4) {
          return false;
        }
      })(), function() {
        var e4, r3 = o(t4);
        if (n3) {
          var i2 = o(this).constructor;
          e4 = Reflect.construct(r3, arguments, i2);
        } else e4 = r3.apply(this, arguments);
        return f(this, e4);
      });
      function c2() {
        var e4;
        return r2(this, c2), (e4 = h2.call(this)).listeners || u.call(a(e4)), Object.defineProperty(a(e4), "aborted", { value: false, writable: true, configurable: true }), Object.defineProperty(a(e4), "onabort", { value: null, writable: true, configurable: true }), Object.defineProperty(a(e4), "reason", { value: void 0, writable: true, configurable: true }), e4;
      }
      return i(c2, [{ key: "toString", value: function() {
        return "[object AbortSignal]";
      } }, { key: "dispatchEvent", value: function(e4) {
        "abort" === e4.type && (this.aborted = true, "function" == typeof this.onabort && this.onabort.call(this, e4)), l(o(c2.prototype), "dispatchEvent", this).call(this, e4);
      } }]), c2;
    })(u), d = (function() {
      function e3() {
        r2(this, e3), Object.defineProperty(this, "signal", { value: new c(), writable: true, configurable: true });
      }
      return i(e3, [{ key: "abort", value: function(e4) {
        var t4;
        try {
          t4 = new Event("abort");
        } catch (e5) {
          "undefined" != typeof document ? document.createEvent ? (t4 = document.createEvent("Event")).initEvent("abort", false, false) : (t4 = document.createEventObject()).type = "abort" : t4 = { type: "abort", bubbles: false, cancelable: false };
        }
        var r3 = e4;
        if (void 0 === r3) if ("undefined" == typeof document) (r3 = new Error("This operation was aborted")).name = "AbortError";
        else try {
          r3 = new DOMException("signal is aborted without reason");
        } catch (e5) {
          (r3 = new Error("This operation was aborted")).name = "AbortError";
        }
        this.signal.reason = r3, this.signal.dispatchEvent(t4);
      } }, { key: "toString", value: function() {
        return "[object AbortController]";
      } }]), e3;
    })();
    "undefined" != typeof Symbol && Symbol.toStringTag && (d.prototype[Symbol.toStringTag] = "AbortController", c.prototype[Symbol.toStringTag] = "AbortSignal"), t3.AbortController = d, t3.AbortSignal = c, t3.abortableFetch = function(e3) {
      "function" == typeof e3 && (e3 = { fetch: e3 });
      var t4 = e3, r3 = t4.fetch, n3 = t4.Request, i2 = void 0 === n3 ? r3.Request : n3, o2 = t4.AbortController, s2 = t4.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL, a2 = void 0 !== s2 && s2;
      if (!(function(e4) {
        return e4.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"), true) : "function" == typeof e4.Request && !e4.Request.prototype.hasOwnProperty("signal") || !e4.AbortController;
      })({ Request: i2, AbortController: o2, __FORCE_INSTALL_ABORTCONTROLLER_POLYFILL: a2 })) return { fetch: r3, Request: f2 };
      var f2 = i2;
      (f2 && !f2.prototype.hasOwnProperty("signal") || a2) && ((f2 = function(e4, t5) {
        var r4;
        t5 && t5.signal && (r4 = t5.signal, delete t5.signal);
        var n4 = new i2(e4, t5);
        return r4 && Object.defineProperty(n4, "signal", { writable: false, enumerable: false, configurable: true, value: r4 }), n4;
      }).prototype = i2.prototype);
      var h2 = r3;
      return { fetch: function(e4, t5) {
        var r4 = f2 && f2.prototype.isPrototypeOf(e4) ? e4.signal : t5 ? t5.signal : void 0;
        if (r4) {
          var n4;
          try {
            n4 = new DOMException("Aborted", "AbortError");
          } catch (e5) {
            (n4 = new Error("Aborted")).name = "AbortError";
          }
          if (r4.aborted) return Promise.reject(n4);
          var i3 = new Promise((function(e5, t6) {
            r4.addEventListener("abort", (function() {
              return t6(n4);
            }), { once: true });
          }));
          return t5 && t5.signal && delete t5.signal, Promise.race([i3, h2(e4, t5)]);
        }
        return h2(e4, t5);
      }, Request: f2 };
    };
  }, 9742: (e2, t3) => {
    t3.byteLength = function(e3) {
      var t4 = f(e3), r3 = t4[0], n3 = t4[1];
      return 3 * (r3 + n3) / 4 - n3;
    }, t3.toByteArray = function(e3) {
      var t4, r3, o2 = f(e3), s2 = o2[0], a2 = o2[1], h2 = new i((function(e4, t5, r4) {
        return 3 * (t5 + r4) / 4 - r4;
      })(0, s2, a2)), l = 0, u = a2 > 0 ? s2 - 4 : s2;
      for (r3 = 0; r3 < u; r3 += 4) t4 = n2[e3.charCodeAt(r3)] << 18 | n2[e3.charCodeAt(r3 + 1)] << 12 | n2[e3.charCodeAt(r3 + 2)] << 6 | n2[e3.charCodeAt(r3 + 3)], h2[l++] = t4 >> 16 & 255, h2[l++] = t4 >> 8 & 255, h2[l++] = 255 & t4;
      return 2 === a2 && (t4 = n2[e3.charCodeAt(r3)] << 2 | n2[e3.charCodeAt(r3 + 1)] >> 4, h2[l++] = 255 & t4), 1 === a2 && (t4 = n2[e3.charCodeAt(r3)] << 10 | n2[e3.charCodeAt(r3 + 1)] << 4 | n2[e3.charCodeAt(r3 + 2)] >> 2, h2[l++] = t4 >> 8 & 255, h2[l++] = 255 & t4), h2;
    }, t3.fromByteArray = function(e3) {
      for (var t4, n3 = e3.length, i2 = n3 % 3, o2 = [], s2 = 16383, a2 = 0, f2 = n3 - i2; a2 < f2; a2 += s2) o2.push(h(e3, a2, a2 + s2 > f2 ? f2 : a2 + s2));
      return 1 === i2 ? (t4 = e3[n3 - 1], o2.push(r2[t4 >> 2] + r2[t4 << 4 & 63] + "==")) : 2 === i2 && (t4 = (e3[n3 - 2] << 8) + e3[n3 - 1], o2.push(r2[t4 >> 10] + r2[t4 >> 4 & 63] + r2[t4 << 2 & 63] + "=")), o2.join("");
    };
    for (var r2 = [], n2 = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0, a = o.length; s < a; ++s) r2[s] = o[s], n2[o.charCodeAt(s)] = s;
    function f(e3) {
      var t4 = e3.length;
      if (t4 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
      var r3 = e3.indexOf("=");
      return -1 === r3 && (r3 = t4), [r3, r3 === t4 ? 0 : 4 - r3 % 4];
    }
    function h(e3, t4, n3) {
      for (var i2, o2, s2 = [], a2 = t4; a2 < n3; a2 += 3) i2 = (e3[a2] << 16 & 16711680) + (e3[a2 + 1] << 8 & 65280) + (255 & e3[a2 + 2]), s2.push(r2[(o2 = i2) >> 18 & 63] + r2[o2 >> 12 & 63] + r2[o2 >> 6 & 63] + r2[63 & o2]);
      return s2.join("");
    }
    n2["-".charCodeAt(0)] = 62, n2["_".charCodeAt(0)] = 63;
  }, 2779: (e2, t3, r2) => {
    var n2 = r2(8764).Buffer, i = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    function o(e3) {
      if (n2.isBuffer(e3)) return e3;
      var t4 = "function" == typeof n2.alloc && "function" == typeof n2.from;
      if ("number" == typeof e3) return t4 ? n2.alloc(e3) : new n2(e3);
      if ("string" == typeof e3) return t4 ? n2.from(e3) : new n2(e3);
      throw new Error("input must be buffer, number, or string, received " + typeof e3);
    }
    function s(e3) {
      var t4 = o(4);
      return t4.writeInt32BE(e3, 0), t4;
    }
    function a(e3, t4) {
      e3 = o(e3), n2.isBuffer(t4) && (t4 = t4.readUInt32BE(0));
      for (var r3 = -1 ^ ~~t4, s2 = 0; s2 < e3.length; s2++) r3 = i[255 & (r3 ^ e3[s2])] ^ r3 >>> 8;
      return -1 ^ r3;
    }
    function f() {
      return s(a.apply(null, arguments));
    }
    "undefined" != typeof Int32Array && (i = new Int32Array(i)), f.signed = function() {
      return a.apply(null, arguments);
    }, f.unsigned = function() {
      return a.apply(null, arguments) >>> 0;
    }, e2.exports = f;
  }, 8764: (e2, t3, r2) => {
    const n2 = r2(9742), i = r2(645), o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
    t3.Buffer = f, t3.SlowBuffer = function(e3) {
      return +e3 != e3 && (e3 = 0), f.alloc(+e3);
    }, t3.INSPECT_MAX_BYTES = 50;
    const s = 2147483647;
    function a(e3) {
      if (e3 > s) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
      const t4 = new Uint8Array(e3);
      return Object.setPrototypeOf(t4, f.prototype), t4;
    }
    function f(e3, t4, r3) {
      if ("number" == typeof e3) {
        if ("string" == typeof t4) throw new TypeError('The "string" argument must be of type string. Received type number');
        return u(e3);
      }
      return h(e3, t4, r3);
    }
    function h(e3, t4, r3) {
      if ("string" == typeof e3) return (function(e4, t5) {
        if ("string" == typeof t5 && "" !== t5 || (t5 = "utf8"), !f.isEncoding(t5)) throw new TypeError("Unknown encoding: " + t5);
        const r4 = 0 | g(e4, t5);
        let n4 = a(r4);
        const i3 = n4.write(e4, t5);
        return i3 !== r4 && (n4 = n4.slice(0, i3)), n4;
      })(e3, t4);
      if (ArrayBuffer.isView(e3)) return (function(e4) {
        if (Q(e4, Uint8Array)) {
          const t5 = new Uint8Array(e4);
          return d(t5.buffer, t5.byteOffset, t5.byteLength);
        }
        return c(e4);
      })(e3);
      if (null == e3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
      if (Q(e3, ArrayBuffer) || e3 && Q(e3.buffer, ArrayBuffer)) return d(e3, t4, r3);
      if ("undefined" != typeof SharedArrayBuffer && (Q(e3, SharedArrayBuffer) || e3 && Q(e3.buffer, SharedArrayBuffer))) return d(e3, t4, r3);
      if ("number" == typeof e3) throw new TypeError('The "value" argument must not be of type number. Received type number');
      const n3 = e3.valueOf && e3.valueOf();
      if (null != n3 && n3 !== e3) return f.from(n3, t4, r3);
      const i2 = (function(e4) {
        if (f.isBuffer(e4)) {
          const t5 = 0 | p(e4.length), r4 = a(t5);
          return 0 === r4.length || e4.copy(r4, 0, 0, t5), r4;
        }
        return void 0 !== e4.length ? "number" != typeof e4.length || Y(e4.length) ? a(0) : c(e4) : "Buffer" === e4.type && Array.isArray(e4.data) ? c(e4.data) : void 0;
      })(e3);
      if (i2) return i2;
      if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e3[Symbol.toPrimitive]) return f.from(e3[Symbol.toPrimitive]("string"), t4, r3);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
    }
    function l(e3) {
      if ("number" != typeof e3) throw new TypeError('"size" argument must be of type number');
      if (e3 < 0) throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
    }
    function u(e3) {
      return l(e3), a(e3 < 0 ? 0 : 0 | p(e3));
    }
    function c(e3) {
      const t4 = e3.length < 0 ? 0 : 0 | p(e3.length), r3 = a(t4);
      for (let n3 = 0; n3 < t4; n3 += 1) r3[n3] = 255 & e3[n3];
      return r3;
    }
    function d(e3, t4, r3) {
      if (t4 < 0 || e3.byteLength < t4) throw new RangeError('"offset" is outside of buffer bounds');
      if (e3.byteLength < t4 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
      let n3;
      return n3 = void 0 === t4 && void 0 === r3 ? new Uint8Array(e3) : void 0 === r3 ? new Uint8Array(e3, t4) : new Uint8Array(e3, t4, r3), Object.setPrototypeOf(n3, f.prototype), n3;
    }
    function p(e3) {
      if (e3 >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
      return 0 | e3;
    }
    function g(e3, t4) {
      if (f.isBuffer(e3)) return e3.length;
      if (ArrayBuffer.isView(e3) || Q(e3, ArrayBuffer)) return e3.byteLength;
      if ("string" != typeof e3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
      const r3 = e3.length, n3 = arguments.length > 2 && true === arguments[2];
      if (!n3 && 0 === r3) return 0;
      let i2 = false;
      for (; ; ) switch (t4) {
        case "ascii":
        case "latin1":
        case "binary":
          return r3;
        case "utf8":
        case "utf-8":
          return V(e3).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * r3;
        case "hex":
          return r3 >>> 1;
        case "base64":
          return Z(e3).length;
        default:
          if (i2) return n3 ? -1 : V(e3).length;
          t4 = ("" + t4).toLowerCase(), i2 = true;
      }
    }
    function m(e3, t4, r3) {
      let n3 = false;
      if ((void 0 === t4 || t4 < 0) && (t4 = 0), t4 > this.length) return "";
      if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
      if ((r3 >>>= 0) <= (t4 >>>= 0)) return "";
      for (e3 || (e3 = "utf8"); ; ) switch (e3) {
        case "hex":
          return I(this, t4, r3);
        case "utf8":
        case "utf-8":
          return C(this, t4, r3);
        case "ascii":
          return k(this, t4, r3);
        case "latin1":
        case "binary":
          return x(this, t4, r3);
        case "base64":
          return A(this, t4, r3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return M(this, t4, r3);
        default:
          if (n3) throw new TypeError("Unknown encoding: " + e3);
          e3 = (e3 + "").toLowerCase(), n3 = true;
      }
    }
    function y(e3, t4, r3) {
      const n3 = e3[t4];
      e3[t4] = e3[r3], e3[r3] = n3;
    }
    function b(e3, t4, r3, n3, i2) {
      if (0 === e3.length) return -1;
      if ("string" == typeof r3 ? (n3 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), Y(r3 = +r3) && (r3 = i2 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
        if (i2) return -1;
        r3 = e3.length - 1;
      } else if (r3 < 0) {
        if (!i2) return -1;
        r3 = 0;
      }
      if ("string" == typeof t4 && (t4 = f.from(t4, n3)), f.isBuffer(t4)) return 0 === t4.length ? -1 : v(e3, t4, r3, n3, i2);
      if ("number" == typeof t4) return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(e3, t4, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t4, r3) : v(e3, [t4], r3, n3, i2);
      throw new TypeError("val must be string, number or Buffer");
    }
    function v(e3, t4, r3, n3, i2) {
      let o2, s2 = 1, a2 = e3.length, f2 = t4.length;
      if (void 0 !== n3 && ("ucs2" === (n3 = String(n3).toLowerCase()) || "ucs-2" === n3 || "utf16le" === n3 || "utf-16le" === n3)) {
        if (e3.length < 2 || t4.length < 2) return -1;
        s2 = 2, a2 /= 2, f2 /= 2, r3 /= 2;
      }
      function h2(e4, t5) {
        return 1 === s2 ? e4[t5] : e4.readUInt16BE(t5 * s2);
      }
      if (i2) {
        let n4 = -1;
        for (o2 = r3; o2 < a2; o2++) if (h2(e3, o2) === h2(t4, -1 === n4 ? 0 : o2 - n4)) {
          if (-1 === n4 && (n4 = o2), o2 - n4 + 1 === f2) return n4 * s2;
        } else -1 !== n4 && (o2 -= o2 - n4), n4 = -1;
      } else for (r3 + f2 > a2 && (r3 = a2 - f2), o2 = r3; o2 >= 0; o2--) {
        let r4 = true;
        for (let n4 = 0; n4 < f2; n4++) if (h2(e3, o2 + n4) !== h2(t4, n4)) {
          r4 = false;
          break;
        }
        if (r4) return o2;
      }
      return -1;
    }
    function w(e3, t4, r3, n3) {
      r3 = Number(r3) || 0;
      const i2 = e3.length - r3;
      n3 ? (n3 = Number(n3)) > i2 && (n3 = i2) : n3 = i2;
      const o2 = t4.length;
      let s2;
      for (n3 > o2 / 2 && (n3 = o2 / 2), s2 = 0; s2 < n3; ++s2) {
        const n4 = parseInt(t4.substr(2 * s2, 2), 16);
        if (Y(n4)) return s2;
        e3[r3 + s2] = n4;
      }
      return s2;
    }
    function _(e3, t4, r3, n3) {
      return G(V(t4, e3.length - r3), e3, r3, n3);
    }
    function B(e3, t4, r3, n3) {
      return G((function(e4) {
        const t5 = [];
        for (let r4 = 0; r4 < e4.length; ++r4) t5.push(255 & e4.charCodeAt(r4));
        return t5;
      })(t4), e3, r3, n3);
    }
    function E(e3, t4, r3, n3) {
      return G(Z(t4), e3, r3, n3);
    }
    function S(e3, t4, r3, n3) {
      return G((function(e4, t5) {
        let r4, n4, i2;
        const o2 = [];
        for (let s2 = 0; s2 < e4.length && !((t5 -= 2) < 0); ++s2) r4 = e4.charCodeAt(s2), n4 = r4 >> 8, i2 = r4 % 256, o2.push(i2), o2.push(n4);
        return o2;
      })(t4, e3.length - r3), e3, r3, n3);
    }
    function A(e3, t4, r3) {
      return 0 === t4 && r3 === e3.length ? n2.fromByteArray(e3) : n2.fromByteArray(e3.slice(t4, r3));
    }
    function C(e3, t4, r3) {
      r3 = Math.min(e3.length, r3);
      const n3 = [];
      let i2 = t4;
      for (; i2 < r3; ) {
        const t5 = e3[i2];
        let o2 = null, s2 = t5 > 239 ? 4 : t5 > 223 ? 3 : t5 > 191 ? 2 : 1;
        if (i2 + s2 <= r3) {
          let r4, n4, a2, f2;
          switch (s2) {
            case 1:
              t5 < 128 && (o2 = t5);
              break;
            case 2:
              r4 = e3[i2 + 1], 128 == (192 & r4) && (f2 = (31 & t5) << 6 | 63 & r4, f2 > 127 && (o2 = f2));
              break;
            case 3:
              r4 = e3[i2 + 1], n4 = e3[i2 + 2], 128 == (192 & r4) && 128 == (192 & n4) && (f2 = (15 & t5) << 12 | (63 & r4) << 6 | 63 & n4, f2 > 2047 && (f2 < 55296 || f2 > 57343) && (o2 = f2));
              break;
            case 4:
              r4 = e3[i2 + 1], n4 = e3[i2 + 2], a2 = e3[i2 + 3], 128 == (192 & r4) && 128 == (192 & n4) && 128 == (192 & a2) && (f2 = (15 & t5) << 18 | (63 & r4) << 12 | (63 & n4) << 6 | 63 & a2, f2 > 65535 && f2 < 1114112 && (o2 = f2));
          }
        }
        null === o2 ? (o2 = 65533, s2 = 1) : o2 > 65535 && (o2 -= 65536, n3.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | 1023 & o2), n3.push(o2), i2 += s2;
      }
      return (function(e4) {
        const t5 = e4.length;
        if (t5 <= R) return String.fromCharCode.apply(String, e4);
        let r4 = "", n4 = 0;
        for (; n4 < t5; ) r4 += String.fromCharCode.apply(String, e4.slice(n4, n4 += R));
        return r4;
      })(n3);
    }
    t3.kMaxLength = s, f.TYPED_ARRAY_SUPPORT = (function() {
      try {
        const e3 = new Uint8Array(1), t4 = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(t4, Uint8Array.prototype), Object.setPrototypeOf(e3, t4), 42 === e3.foo();
      } catch (e3) {
        return false;
      }
    })(), f.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
      if (f.isBuffer(this)) return this.buffer;
    } }), Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
      if (f.isBuffer(this)) return this.byteOffset;
    } }), f.poolSize = 8192, f.from = function(e3, t4, r3) {
      return h(e3, t4, r3);
    }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array), f.alloc = function(e3, t4, r3) {
      return (function(e4, t5, r4) {
        return l(e4), e4 <= 0 ? a(e4) : void 0 !== t5 ? "string" == typeof r4 ? a(e4).fill(t5, r4) : a(e4).fill(t5) : a(e4);
      })(e3, t4, r3);
    }, f.allocUnsafe = function(e3) {
      return u(e3);
    }, f.allocUnsafeSlow = function(e3) {
      return u(e3);
    }, f.isBuffer = function(e3) {
      return null != e3 && true === e3._isBuffer && e3 !== f.prototype;
    }, f.compare = function(e3, t4) {
      if (Q(e3, Uint8Array) && (e3 = f.from(e3, e3.offset, e3.byteLength)), Q(t4, Uint8Array) && (t4 = f.from(t4, t4.offset, t4.byteLength)), !f.isBuffer(e3) || !f.isBuffer(t4)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (e3 === t4) return 0;
      let r3 = e3.length, n3 = t4.length;
      for (let i2 = 0, o2 = Math.min(r3, n3); i2 < o2; ++i2) if (e3[i2] !== t4[i2]) {
        r3 = e3[i2], n3 = t4[i2];
        break;
      }
      return r3 < n3 ? -1 : n3 < r3 ? 1 : 0;
    }, f.isEncoding = function(e3) {
      switch (String(e3).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, f.concat = function(e3, t4) {
      if (!Array.isArray(e3)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === e3.length) return f.alloc(0);
      let r3;
      if (void 0 === t4) for (t4 = 0, r3 = 0; r3 < e3.length; ++r3) t4 += e3[r3].length;
      const n3 = f.allocUnsafe(t4);
      let i2 = 0;
      for (r3 = 0; r3 < e3.length; ++r3) {
        let t5 = e3[r3];
        if (Q(t5, Uint8Array)) i2 + t5.length > n3.length ? (f.isBuffer(t5) || (t5 = f.from(t5)), t5.copy(n3, i2)) : Uint8Array.prototype.set.call(n3, t5, i2);
        else {
          if (!f.isBuffer(t5)) throw new TypeError('"list" argument must be an Array of Buffers');
          t5.copy(n3, i2);
        }
        i2 += t5.length;
      }
      return n3;
    }, f.byteLength = g, f.prototype._isBuffer = true, f.prototype.swap16 = function() {
      const e3 = this.length;
      if (e3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let t4 = 0; t4 < e3; t4 += 2) y(this, t4, t4 + 1);
      return this;
    }, f.prototype.swap32 = function() {
      const e3 = this.length;
      if (e3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let t4 = 0; t4 < e3; t4 += 4) y(this, t4, t4 + 3), y(this, t4 + 1, t4 + 2);
      return this;
    }, f.prototype.swap64 = function() {
      const e3 = this.length;
      if (e3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t4 = 0; t4 < e3; t4 += 8) y(this, t4, t4 + 7), y(this, t4 + 1, t4 + 6), y(this, t4 + 2, t4 + 5), y(this, t4 + 3, t4 + 4);
      return this;
    }, f.prototype.toString = function() {
      const e3 = this.length;
      return 0 === e3 ? "" : 0 === arguments.length ? C(this, 0, e3) : m.apply(this, arguments);
    }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(e3) {
      if (!f.isBuffer(e3)) throw new TypeError("Argument must be a Buffer");
      return this === e3 || 0 === f.compare(this, e3);
    }, f.prototype.inspect = function() {
      let e3 = "";
      const r3 = t3.INSPECT_MAX_BYTES;
      return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
    }, o && (f.prototype[o] = f.prototype.inspect), f.prototype.compare = function(e3, t4, r3, n3, i2) {
      if (Q(e3, Uint8Array) && (e3 = f.from(e3, e3.offset, e3.byteLength)), !f.isBuffer(e3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
      if (void 0 === t4 && (t4 = 0), void 0 === r3 && (r3 = e3 ? e3.length : 0), void 0 === n3 && (n3 = 0), void 0 === i2 && (i2 = this.length), t4 < 0 || r3 > e3.length || n3 < 0 || i2 > this.length) throw new RangeError("out of range index");
      if (n3 >= i2 && t4 >= r3) return 0;
      if (n3 >= i2) return -1;
      if (t4 >= r3) return 1;
      if (this === e3) return 0;
      let o2 = (i2 >>>= 0) - (n3 >>>= 0), s2 = (r3 >>>= 0) - (t4 >>>= 0);
      const a2 = Math.min(o2, s2), h2 = this.slice(n3, i2), l2 = e3.slice(t4, r3);
      for (let e4 = 0; e4 < a2; ++e4) if (h2[e4] !== l2[e4]) {
        o2 = h2[e4], s2 = l2[e4];
        break;
      }
      return o2 < s2 ? -1 : s2 < o2 ? 1 : 0;
    }, f.prototype.includes = function(e3, t4, r3) {
      return -1 !== this.indexOf(e3, t4, r3);
    }, f.prototype.indexOf = function(e3, t4, r3) {
      return b(this, e3, t4, r3, true);
    }, f.prototype.lastIndexOf = function(e3, t4, r3) {
      return b(this, e3, t4, r3, false);
    }, f.prototype.write = function(e3, t4, r3, n3) {
      if (void 0 === t4) n3 = "utf8", r3 = this.length, t4 = 0;
      else if (void 0 === r3 && "string" == typeof t4) n3 = t4, r3 = this.length, t4 = 0;
      else {
        if (!isFinite(t4)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t4 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n3 && (n3 = "utf8")) : (n3 = r3, r3 = void 0);
      }
      const i2 = this.length - t4;
      if ((void 0 === r3 || r3 > i2) && (r3 = i2), e3.length > 0 && (r3 < 0 || t4 < 0) || t4 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      n3 || (n3 = "utf8");
      let o2 = false;
      for (; ; ) switch (n3) {
        case "hex":
          return w(this, e3, t4, r3);
        case "utf8":
        case "utf-8":
          return _(this, e3, t4, r3);
        case "ascii":
        case "latin1":
        case "binary":
          return B(this, e3, t4, r3);
        case "base64":
          return E(this, e3, t4, r3);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return S(this, e3, t4, r3);
        default:
          if (o2) throw new TypeError("Unknown encoding: " + n3);
          n3 = ("" + n3).toLowerCase(), o2 = true;
      }
    }, f.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    const R = 4096;
    function k(e3, t4, r3) {
      let n3 = "";
      r3 = Math.min(e3.length, r3);
      for (let i2 = t4; i2 < r3; ++i2) n3 += String.fromCharCode(127 & e3[i2]);
      return n3;
    }
    function x(e3, t4, r3) {
      let n3 = "";
      r3 = Math.min(e3.length, r3);
      for (let i2 = t4; i2 < r3; ++i2) n3 += String.fromCharCode(e3[i2]);
      return n3;
    }
    function I(e3, t4, r3) {
      const n3 = e3.length;
      (!t4 || t4 < 0) && (t4 = 0), (!r3 || r3 < 0 || r3 > n3) && (r3 = n3);
      let i2 = "";
      for (let n4 = t4; n4 < r3; ++n4) i2 += K[e3[n4]];
      return i2;
    }
    function M(e3, t4, r3) {
      const n3 = e3.slice(t4, r3);
      let i2 = "";
      for (let e4 = 0; e4 < n3.length - 1; e4 += 2) i2 += String.fromCharCode(n3[e4] + 256 * n3[e4 + 1]);
      return i2;
    }
    function F(e3, t4, r3) {
      if (e3 % 1 != 0 || e3 < 0) throw new RangeError("offset is not uint");
      if (e3 + t4 > r3) throw new RangeError("Trying to access beyond buffer length");
    }
    function O(e3, t4, r3, n3, i2, o2) {
      if (!f.isBuffer(e3)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t4 > i2 || t4 < o2) throw new RangeError('"value" argument is out of bounds');
      if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
    }
    function T(e3, t4, r3, n3, i2) {
      j(t4, n3, i2, e3, r3, 7);
      let o2 = Number(t4 & BigInt(4294967295));
      e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2;
      let s2 = Number(t4 >> BigInt(32) & BigInt(4294967295));
      return e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, s2 >>= 8, e3[r3++] = s2, r3;
    }
    function U(e3, t4, r3, n3, i2) {
      j(t4, n3, i2, e3, r3, 7);
      let o2 = Number(t4 & BigInt(4294967295));
      e3[r3 + 7] = o2, o2 >>= 8, e3[r3 + 6] = o2, o2 >>= 8, e3[r3 + 5] = o2, o2 >>= 8, e3[r3 + 4] = o2;
      let s2 = Number(t4 >> BigInt(32) & BigInt(4294967295));
      return e3[r3 + 3] = s2, s2 >>= 8, e3[r3 + 2] = s2, s2 >>= 8, e3[r3 + 1] = s2, s2 >>= 8, e3[r3] = s2, r3 + 8;
    }
    function P(e3, t4, r3, n3, i2, o2) {
      if (r3 + n3 > e3.length) throw new RangeError("Index out of range");
      if (r3 < 0) throw new RangeError("Index out of range");
    }
    function N(e3, t4, r3, n3, o2) {
      return t4 = +t4, r3 >>>= 0, o2 || P(e3, 0, r3, 4), i.write(e3, t4, r3, n3, 23, 4), r3 + 4;
    }
    function L(e3, t4, r3, n3, o2) {
      return t4 = +t4, r3 >>>= 0, o2 || P(e3, 0, r3, 8), i.write(e3, t4, r3, n3, 52, 8), r3 + 8;
    }
    f.prototype.slice = function(e3, t4) {
      const r3 = this.length;
      (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t4 = void 0 === t4 ? r3 : ~~t4) < 0 ? (t4 += r3) < 0 && (t4 = 0) : t4 > r3 && (t4 = r3), t4 < e3 && (t4 = e3);
      const n3 = this.subarray(e3, t4);
      return Object.setPrototypeOf(n3, f.prototype), n3;
    }, f.prototype.readUintLE = f.prototype.readUIntLE = function(e3, t4, r3) {
      e3 >>>= 0, t4 >>>= 0, r3 || F(e3, t4, this.length);
      let n3 = this[e3], i2 = 1, o2 = 0;
      for (; ++o2 < t4 && (i2 *= 256); ) n3 += this[e3 + o2] * i2;
      return n3;
    }, f.prototype.readUintBE = f.prototype.readUIntBE = function(e3, t4, r3) {
      e3 >>>= 0, t4 >>>= 0, r3 || F(e3, t4, this.length);
      let n3 = this[e3 + --t4], i2 = 1;
      for (; t4 > 0 && (i2 *= 256); ) n3 += this[e3 + --t4] * i2;
      return n3;
    }, f.prototype.readUint8 = f.prototype.readUInt8 = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 1, this.length), this[e3];
    }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
    }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
    }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
    }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
    }, f.prototype.readBigUInt64LE = X((function(e3) {
      H(e3 >>>= 0, "offset");
      const t4 = this[e3], r3 = this[e3 + 7];
      void 0 !== t4 && void 0 !== r3 || W(e3, this.length - 8);
      const n3 = t4 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, i2 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
      return BigInt(n3) + (BigInt(i2) << BigInt(32));
    })), f.prototype.readBigUInt64BE = X((function(e3) {
      H(e3 >>>= 0, "offset");
      const t4 = this[e3], r3 = this[e3 + 7];
      void 0 !== t4 && void 0 !== r3 || W(e3, this.length - 8);
      const n3 = t4 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], i2 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
      return (BigInt(n3) << BigInt(32)) + BigInt(i2);
    })), f.prototype.readIntLE = function(e3, t4, r3) {
      e3 >>>= 0, t4 >>>= 0, r3 || F(e3, t4, this.length);
      let n3 = this[e3], i2 = 1, o2 = 0;
      for (; ++o2 < t4 && (i2 *= 256); ) n3 += this[e3 + o2] * i2;
      return i2 *= 128, n3 >= i2 && (n3 -= Math.pow(2, 8 * t4)), n3;
    }, f.prototype.readIntBE = function(e3, t4, r3) {
      e3 >>>= 0, t4 >>>= 0, r3 || F(e3, t4, this.length);
      let n3 = t4, i2 = 1, o2 = this[e3 + --n3];
      for (; n3 > 0 && (i2 *= 256); ) o2 += this[e3 + --n3] * i2;
      return i2 *= 128, o2 >= i2 && (o2 -= Math.pow(2, 8 * t4)), o2;
    }, f.prototype.readInt8 = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
    }, f.prototype.readInt16LE = function(e3, t4) {
      e3 >>>= 0, t4 || F(e3, 2, this.length);
      const r3 = this[e3] | this[e3 + 1] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, f.prototype.readInt16BE = function(e3, t4) {
      e3 >>>= 0, t4 || F(e3, 2, this.length);
      const r3 = this[e3 + 1] | this[e3] << 8;
      return 32768 & r3 ? 4294901760 | r3 : r3;
    }, f.prototype.readInt32LE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
    }, f.prototype.readInt32BE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
    }, f.prototype.readBigInt64LE = X((function(e3) {
      H(e3 >>>= 0, "offset");
      const t4 = this[e3], r3 = this[e3 + 7];
      void 0 !== t4 && void 0 !== r3 || W(e3, this.length - 8);
      const n3 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
      return (BigInt(n3) << BigInt(32)) + BigInt(t4 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
    })), f.prototype.readBigInt64BE = X((function(e3) {
      H(e3 >>>= 0, "offset");
      const t4 = this[e3], r3 = this[e3 + 7];
      void 0 !== t4 && void 0 !== r3 || W(e3, this.length - 8);
      const n3 = (t4 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
      return (BigInt(n3) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
    })), f.prototype.readFloatLE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), i.read(this, e3, true, 23, 4);
    }, f.prototype.readFloatBE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 4, this.length), i.read(this, e3, false, 23, 4);
    }, f.prototype.readDoubleLE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 8, this.length), i.read(this, e3, true, 52, 8);
    }, f.prototype.readDoubleBE = function(e3, t4) {
      return e3 >>>= 0, t4 || F(e3, 8, this.length), i.read(this, e3, false, 52, 8);
    }, f.prototype.writeUintLE = f.prototype.writeUIntLE = function(e3, t4, r3, n3) {
      e3 = +e3, t4 >>>= 0, r3 >>>= 0, n3 || O(this, e3, t4, r3, Math.pow(2, 8 * r3) - 1, 0);
      let i2 = 1, o2 = 0;
      for (this[t4] = 255 & e3; ++o2 < r3 && (i2 *= 256); ) this[t4 + o2] = e3 / i2 & 255;
      return t4 + r3;
    }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(e3, t4, r3, n3) {
      e3 = +e3, t4 >>>= 0, r3 >>>= 0, n3 || O(this, e3, t4, r3, Math.pow(2, 8 * r3) - 1, 0);
      let i2 = r3 - 1, o2 = 1;
      for (this[t4 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); ) this[t4 + i2] = e3 / o2 & 255;
      return t4 + r3;
    }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 1, 255, 0), this[t4] = 255 & e3, t4 + 1;
    }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 2, 65535, 0), this[t4] = 255 & e3, this[t4 + 1] = e3 >>> 8, t4 + 2;
    }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 2, 65535, 0), this[t4] = e3 >>> 8, this[t4 + 1] = 255 & e3, t4 + 2;
    }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 4, 4294967295, 0), this[t4 + 3] = e3 >>> 24, this[t4 + 2] = e3 >>> 16, this[t4 + 1] = e3 >>> 8, this[t4] = 255 & e3, t4 + 4;
    }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 4, 4294967295, 0), this[t4] = e3 >>> 24, this[t4 + 1] = e3 >>> 16, this[t4 + 2] = e3 >>> 8, this[t4 + 3] = 255 & e3, t4 + 4;
    }, f.prototype.writeBigUInt64LE = X((function(e3, t4 = 0) {
      return T(this, e3, t4, BigInt(0), BigInt("0xffffffffffffffff"));
    })), f.prototype.writeBigUInt64BE = X((function(e3, t4 = 0) {
      return U(this, e3, t4, BigInt(0), BigInt("0xffffffffffffffff"));
    })), f.prototype.writeIntLE = function(e3, t4, r3, n3) {
      if (e3 = +e3, t4 >>>= 0, !n3) {
        const n4 = Math.pow(2, 8 * r3 - 1);
        O(this, e3, t4, r3, n4 - 1, -n4);
      }
      let i2 = 0, o2 = 1, s2 = 0;
      for (this[t4] = 255 & e3; ++i2 < r3 && (o2 *= 256); ) e3 < 0 && 0 === s2 && 0 !== this[t4 + i2 - 1] && (s2 = 1), this[t4 + i2] = (e3 / o2 >> 0) - s2 & 255;
      return t4 + r3;
    }, f.prototype.writeIntBE = function(e3, t4, r3, n3) {
      if (e3 = +e3, t4 >>>= 0, !n3) {
        const n4 = Math.pow(2, 8 * r3 - 1);
        O(this, e3, t4, r3, n4 - 1, -n4);
      }
      let i2 = r3 - 1, o2 = 1, s2 = 0;
      for (this[t4 + i2] = 255 & e3; --i2 >= 0 && (o2 *= 256); ) e3 < 0 && 0 === s2 && 0 !== this[t4 + i2 + 1] && (s2 = 1), this[t4 + i2] = (e3 / o2 >> 0) - s2 & 255;
      return t4 + r3;
    }, f.prototype.writeInt8 = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t4] = 255 & e3, t4 + 1;
    }, f.prototype.writeInt16LE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 2, 32767, -32768), this[t4] = 255 & e3, this[t4 + 1] = e3 >>> 8, t4 + 2;
    }, f.prototype.writeInt16BE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 2, 32767, -32768), this[t4] = e3 >>> 8, this[t4 + 1] = 255 & e3, t4 + 2;
    }, f.prototype.writeInt32LE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e3, this[t4 + 1] = e3 >>> 8, this[t4 + 2] = e3 >>> 16, this[t4 + 3] = e3 >>> 24, t4 + 4;
    }, f.prototype.writeInt32BE = function(e3, t4, r3) {
      return e3 = +e3, t4 >>>= 0, r3 || O(this, e3, t4, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t4] = e3 >>> 24, this[t4 + 1] = e3 >>> 16, this[t4 + 2] = e3 >>> 8, this[t4 + 3] = 255 & e3, t4 + 4;
    }, f.prototype.writeBigInt64LE = X((function(e3, t4 = 0) {
      return T(this, e3, t4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    })), f.prototype.writeBigInt64BE = X((function(e3, t4 = 0) {
      return U(this, e3, t4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    })), f.prototype.writeFloatLE = function(e3, t4, r3) {
      return N(this, e3, t4, true, r3);
    }, f.prototype.writeFloatBE = function(e3, t4, r3) {
      return N(this, e3, t4, false, r3);
    }, f.prototype.writeDoubleLE = function(e3, t4, r3) {
      return L(this, e3, t4, true, r3);
    }, f.prototype.writeDoubleBE = function(e3, t4, r3) {
      return L(this, e3, t4, false, r3);
    }, f.prototype.copy = function(e3, t4, r3, n3) {
      if (!f.isBuffer(e3)) throw new TypeError("argument should be a Buffer");
      if (r3 || (r3 = 0), n3 || 0 === n3 || (n3 = this.length), t4 >= e3.length && (t4 = e3.length), t4 || (t4 = 0), n3 > 0 && n3 < r3 && (n3 = r3), n3 === r3) return 0;
      if (0 === e3.length || 0 === this.length) return 0;
      if (t4 < 0) throw new RangeError("targetStart out of bounds");
      if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
      if (n3 < 0) throw new RangeError("sourceEnd out of bounds");
      n3 > this.length && (n3 = this.length), e3.length - t4 < n3 - r3 && (n3 = e3.length - t4 + r3);
      const i2 = n3 - r3;
      return this === e3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(t4, r3, n3) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n3), t4), i2;
    }, f.prototype.fill = function(e3, t4, r3, n3) {
      if ("string" == typeof e3) {
        if ("string" == typeof t4 ? (n3 = t4, t4 = 0, r3 = this.length) : "string" == typeof r3 && (n3 = r3, r3 = this.length), void 0 !== n3 && "string" != typeof n3) throw new TypeError("encoding must be a string");
        if ("string" == typeof n3 && !f.isEncoding(n3)) throw new TypeError("Unknown encoding: " + n3);
        if (1 === e3.length) {
          const t5 = e3.charCodeAt(0);
          ("utf8" === n3 && t5 < 128 || "latin1" === n3) && (e3 = t5);
        }
      } else "number" == typeof e3 ? e3 &= 255 : "boolean" == typeof e3 && (e3 = Number(e3));
      if (t4 < 0 || this.length < t4 || this.length < r3) throw new RangeError("Out of range index");
      if (r3 <= t4) return this;
      let i2;
      if (t4 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, e3 || (e3 = 0), "number" == typeof e3) for (i2 = t4; i2 < r3; ++i2) this[i2] = e3;
      else {
        const o2 = f.isBuffer(e3) ? e3 : f.from(e3, n3), s2 = o2.length;
        if (0 === s2) throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
        for (i2 = 0; i2 < r3 - t4; ++i2) this[i2 + t4] = o2[i2 % s2];
      }
      return this;
    };
    const z = {};
    function D(e3, t4, r3) {
      z[e3] = class extends r3 {
        constructor() {
          super(), Object.defineProperty(this, "message", { value: t4.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
        }
        get code() {
          return e3;
        }
        set code(e4) {
          Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
        }
        toString() {
          return `${this.name} [${e3}]: ${this.message}`;
        }
      };
    }
    function q(e3) {
      let t4 = "", r3 = e3.length;
      const n3 = "-" === e3[0] ? 1 : 0;
      for (; r3 >= n3 + 4; r3 -= 3) t4 = `_${e3.slice(r3 - 3, r3)}${t4}`;
      return `${e3.slice(0, r3)}${t4}`;
    }
    function j(e3, t4, r3, n3, i2, o2) {
      if (e3 > r3 || e3 < t4) {
        const n4 = "bigint" == typeof t4 ? "n" : "";
        let i3;
        throw i3 = 0 === t4 || t4 === BigInt(0) ? `>= 0${n4} and < 2${n4} ** ${8 * (o2 + 1)}${n4}` : `>= -(2${n4} ** ${8 * (o2 + 1) - 1}${n4}) and < 2 ** ${8 * (o2 + 1) - 1}${n4}`, new z.ERR_OUT_OF_RANGE("value", i3, e3);
      }
      !(function(e4, t5, r4) {
        H(t5, "offset"), void 0 !== e4[t5] && void 0 !== e4[t5 + r4] || W(t5, e4.length - (r4 + 1));
      })(n3, i2, o2);
    }
    function H(e3, t4) {
      if ("number" != typeof e3) throw new z.ERR_INVALID_ARG_TYPE(t4, "number", e3);
    }
    function W(e3, t4, r3) {
      if (Math.floor(e3) !== e3) throw H(e3, r3), new z.ERR_OUT_OF_RANGE("offset", "an integer", e3);
      if (t4 < 0) throw new z.ERR_BUFFER_OUT_OF_BOUNDS();
      throw new z.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${t4}`, e3);
    }
    D("ERR_BUFFER_OUT_OF_BOUNDS", (function(e3) {
      return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    }), RangeError), D("ERR_INVALID_ARG_TYPE", (function(e3, t4) {
      return `The "${e3}" argument must be of type number. Received type ${typeof t4}`;
    }), TypeError), D("ERR_OUT_OF_RANGE", (function(e3, t4, r3) {
      let n3 = `The value of "${e3}" is out of range.`, i2 = r3;
      return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i2 = q(String(r3)) : "bigint" == typeof r3 && (i2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i2 = q(i2)), i2 += "n"), n3 += ` It must be ${t4}. Received ${i2}`, n3;
    }), RangeError);
    const $2 = /[^+/0-9A-Za-z-_]/g;
    function V(e3, t4) {
      let r3;
      t4 = t4 || 1 / 0;
      const n3 = e3.length;
      let i2 = null;
      const o2 = [];
      for (let s2 = 0; s2 < n3; ++s2) {
        if (r3 = e3.charCodeAt(s2), r3 > 55295 && r3 < 57344) {
          if (!i2) {
            if (r3 > 56319) {
              (t4 -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            if (s2 + 1 === n3) {
              (t4 -= 3) > -1 && o2.push(239, 191, 189);
              continue;
            }
            i2 = r3;
            continue;
          }
          if (r3 < 56320) {
            (t4 -= 3) > -1 && o2.push(239, 191, 189), i2 = r3;
            continue;
          }
          r3 = 65536 + (i2 - 55296 << 10 | r3 - 56320);
        } else i2 && (t4 -= 3) > -1 && o2.push(239, 191, 189);
        if (i2 = null, r3 < 128) {
          if ((t4 -= 1) < 0) break;
          o2.push(r3);
        } else if (r3 < 2048) {
          if ((t4 -= 2) < 0) break;
          o2.push(r3 >> 6 | 192, 63 & r3 | 128);
        } else if (r3 < 65536) {
          if ((t4 -= 3) < 0) break;
          o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        } else {
          if (!(r3 < 1114112)) throw new Error("Invalid code point");
          if ((t4 -= 4) < 0) break;
          o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
        }
      }
      return o2;
    }
    function Z(e3) {
      return n2.toByteArray((function(e4) {
        if ((e4 = (e4 = e4.split("=")[0]).trim().replace($2, "")).length < 2) return "";
        for (; e4.length % 4 != 0; ) e4 += "=";
        return e4;
      })(e3));
    }
    function G(e3, t4, r3, n3) {
      let i2;
      for (i2 = 0; i2 < n3 && !(i2 + r3 >= t4.length || i2 >= e3.length); ++i2) t4[i2 + r3] = e3[i2];
      return i2;
    }
    function Q(e3, t4) {
      return e3 instanceof t4 || null != e3 && null != e3.constructor && null != e3.constructor.name && e3.constructor.name === t4.name;
    }
    function Y(e3) {
      return e3 != e3;
    }
    const K = (function() {
      const e3 = "0123456789abcdef", t4 = new Array(256);
      for (let r3 = 0; r3 < 16; ++r3) {
        const n3 = 16 * r3;
        for (let i2 = 0; i2 < 16; ++i2) t4[n3 + i2] = e3[r3] + e3[i2];
      }
      return t4;
    })();
    function X(e3) {
      return "undefined" == typeof BigInt ? J : e3;
    }
    function J() {
      throw new Error("BigInt not supported");
    }
  }, 4693: (e2) => {
    var t3 = { array: function(e3) {
      var t4 = 0, r2 = 0, n2 = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(i) {
        for (var o = 0; i > 0; ) {
          var s = 8 - t4;
          i >= s ? (o <<= s, o |= n2[s] & e3[r2++], t4 = 0, i -= s) : (o <<= i, o |= (e3[r2] & n2[i] << 8 - i - t4) >> 8 - i - t4, t4 += i, i = 0);
        }
        return o;
      };
    }, simple: function(e3) {
      var r2, n2, i = t3.header(e3), o = [], s = 0;
      do {
        -1 != (n2 = t3.decompress(e3, i)) && (o.push(n2), s += n2.byteLength);
      } while (-1 != n2);
      r2 = new Uint8Array(s), s = 0;
      for (var a = 0; a < o.length; ++a) n2 = o[a], r2.set(n2, s), s += n2.byteLength;
      return r2;
    }, header: function(e3) {
      if (4348520 != e3(24)) throw "No magic number found";
      var t4 = e3(8) - 48;
      if (t4 < 1 || t4 > 9) throw "Not a BZIP archive";
      return t4;
    }, decompress: function(e3, t4, r2) {
      for (var n2 = 9e5, i = "", o = 0; o < 6; o++) i += e3(8).toString(16);
      if ("177245385090" == i) return -1;
      if ("314159265359" != i) throw "eek not valid bzip data";
      if (e3(32), e3(1)) throw "unsupported obsolete version";
      var s = e3(24);
      if (s > n2) throw "Initial position larger than buffer size";
      var a = e3(16), f = new Uint8Array(256), h = 0;
      for (o = 0; o < 16; o++) if (a & 1 << 15 - o) {
        var l = e3(16);
        for (g = 0; g < 16; g++) l & 1 << 15 - g && (f[h++] = 16 * o + g);
      }
      var u = e3(3);
      if (u < 2 || u > 6) throw "another error";
      var c = e3(15);
      if (0 == c) throw "meh";
      var d = [];
      for (o = 0; o < u; o++) d[o] = o;
      var p = new Uint8Array(32768);
      for (o = 0; o < c; o++) {
        for (var g = 0; e3(1); g++) if (g >= u) throw "whoops another error";
        var m = d[g];
        d.splice(g, 1), d.splice(0, 0, m), p[o] = m;
      }
      var y = h + 2, b = [];
      for (g = 0; g < u; g++) {
        var v, w, _, B = new Uint8Array(258), E = new Uint8Array(21);
        for (a = e3(5), o = 0; o < y; o++) {
          for (; ; ) {
            if (a < 1 || a > 20) throw "I gave up a while ago on writing error messages";
            if (!e3(1)) break;
            e3(1) ? a-- : a++;
          }
          B[o] = a;
        }
        for (v = w = B[0], o = 1; o < y; o++) B[o] > w ? w = B[o] : B[o] < v && (v = B[o]);
        (_ = b[g] = {}).permute = new Uint32Array(258), _.limit = new Uint32Array(21), _.base = new Uint32Array(21), _.minLen = v, _.maxLen = w;
        var S = _.base.subarray(1), A = _.limit.subarray(1), C = 0;
        for (o = v; o <= w; o++) for (a = 0; a < y; a++) B[a] == o && (_.permute[C++] = a);
        for (o = v; o <= w; o++) E[o] = A[o] = 0;
        for (o = 0; o < y; o++) E[B[o]]++;
        for (C = a = 0, o = v; o < w; o++) C += E[o], A[o] = C - 1, C <<= 1, S[o + 1] = C - (a += E[o]);
        A[w] = C + E[w] - 1, S[v] = 0;
      }
      var R, k, x, I = new Uint32Array(256);
      for (o = 0; o < 256; o++) d[o] = o;
      R = k = y = x = 0;
      for (var M = new Uint32Array(n2); ; ) {
        if (!y--) {
          if (y = 49, x >= c) throw "meow i'm a kitty, that's an error";
          S = (_ = b[p[x++]]).base.subarray(1), A = _.limit.subarray(1);
        }
        for (g = e3(o = _.minLen); ; ) {
          if (o > _.maxLen) throw "rawr i'm a dinosaur";
          if (g <= A[o]) break;
          o++, g = g << 1 | e3(1);
        }
        if ((g -= S[o]) < 0 || g >= 258) throw "moo i'm a cow";
        var F = _.permute[g];
        if (0 != F && 1 != F) {
          if (R) {
            if (R = 0, k + a >= n2) throw "Boom.";
            for (I[m = f[d[0]]] += a; a--; ) M[k++] = m;
          }
          if (F > h) break;
          if (k >= n2) throw "I can't think of anything. Error";
          m = d[o = F - 1], d.splice(o, 1), d.splice(0, 0, m), I[m = f[m]]++, M[k++] = m;
        } else R || (R = 1, a = 0), a += 0 == F ? R : 2 * R, R <<= 1;
      }
      if (s < 0 || s >= k) throw "I'm a monkey and I'm throwing something at someone, namely you";
      for (g = 0, o = 0; o < 256; o++) l = g + I[o], I[o] = g, g = l;
      for (o = 0; o < k; o++) M[I[m = 255 & M[o]]] |= o << 8, I[m]++;
      var O = 0, T = 0, U = 0;
      k && (T = 255 & (O = M[s]), O >>= 8, U = -1);
      var P, N, L, z = new Uint8Array(n2), D = 0;
      for (r2 || (r2 = 1 / 0); k; ) {
        for (k--, N = T, T = 255 & (O = M[O]), O >>= 8, 3 == U++ ? (P = T, L = N, T = -1) : (P = 1, L = T); P--; ) if (z[D++] = L, !--r2) return z;
        T != N && (U = 0);
      }
      return z.subarray(0, D);
    } };
    e2.exports = t3;
  }, 487: (e2) => {
    var t3 = { utf8: { stringToBytes: function(e3) {
      return t3.bin.stringToBytes(unescape(encodeURIComponent(e3)));
    }, bytesToString: function(e3) {
      return decodeURIComponent(escape(t3.bin.bytesToString(e3)));
    } }, bin: { stringToBytes: function(e3) {
      for (var t4 = [], r2 = 0; r2 < e3.length; r2++) t4.push(255 & e3.charCodeAt(r2));
      return t4;
    }, bytesToString: function(e3) {
      for (var t4 = [], r2 = 0; r2 < e3.length; r2++) t4.push(String.fromCharCode(e3[r2]));
      return t4.join("");
    } } };
    e2.exports = t3;
  }, 1012: (e2) => {
    var t3, r2;
    t3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r2 = { rotl: function(e3, t4) {
      return e3 << t4 | e3 >>> 32 - t4;
    }, rotr: function(e3, t4) {
      return e3 << 32 - t4 | e3 >>> t4;
    }, endian: function(e3) {
      if (e3.constructor == Number) return 16711935 & r2.rotl(e3, 8) | 4278255360 & r2.rotl(e3, 24);
      for (var t4 = 0; t4 < e3.length; t4++) e3[t4] = r2.endian(e3[t4]);
      return e3;
    }, randomBytes: function(e3) {
      for (var t4 = []; e3 > 0; e3--) t4.push(Math.floor(256 * Math.random()));
      return t4;
    }, bytesToWords: function(e3) {
      for (var t4 = [], r3 = 0, n2 = 0; r3 < e3.length; r3++, n2 += 8) t4[n2 >>> 5] |= e3[r3] << 24 - n2 % 32;
      return t4;
    }, wordsToBytes: function(e3) {
      for (var t4 = [], r3 = 0; r3 < 32 * e3.length; r3 += 8) t4.push(e3[r3 >>> 5] >>> 24 - r3 % 32 & 255);
      return t4;
    }, bytesToHex: function(e3) {
      for (var t4 = [], r3 = 0; r3 < e3.length; r3++) t4.push((e3[r3] >>> 4).toString(16)), t4.push((15 & e3[r3]).toString(16));
      return t4.join("");
    }, hexToBytes: function(e3) {
      for (var t4 = [], r3 = 0; r3 < e3.length; r3 += 2) t4.push(parseInt(e3.substr(r3, 2), 16));
      return t4;
    }, bytesToBase64: function(e3) {
      for (var r3 = [], n2 = 0; n2 < e3.length; n2 += 3) for (var i = e3[n2] << 16 | e3[n2 + 1] << 8 | e3[n2 + 2], o = 0; o < 4; o++) 8 * n2 + 6 * o <= 8 * e3.length ? r3.push(t3.charAt(i >>> 6 * (3 - o) & 63)) : r3.push("=");
      return r3.join("");
    }, base64ToBytes: function(e3) {
      e3 = e3.replace(/[^A-Z0-9+\/]/gi, "");
      for (var r3 = [], n2 = 0, i = 0; n2 < e3.length; i = ++n2 % 4) 0 != i && r3.push((t3.indexOf(e3.charAt(n2 - 1)) & Math.pow(2, -2 * i + 8) - 1) << 2 * i | t3.indexOf(e3.charAt(n2)) >>> 6 - 2 * i);
      return r3;
    } }, e2.exports = r2;
  }, 2949: (e2, t3, r2) => {
    r2.r(t3), r2.d(t3, { BlobFile: () => h, LocalFile: () => i(), RemoteFile: () => a, fromUrl: () => l, open: () => u });
    var n2 = r2(7067), i = r2.n(n2), o = r2(8764);
    const s = "undefined" != typeof window ? window : "undefined" != typeof self ? self : { fetch: void 0 };
    class a {
      constructor(e3, t4 = {}) {
        this.baseOverrides = {}, this.url = e3;
        const r3 = t4.fetch || s.fetch && s.fetch.bind(s);
        if (!r3) throw new TypeError("no fetch function supplied, and none found in global environment");
        t4.overrides && (this.baseOverrides = t4.overrides), this.fetchImplementation = r3;
      }
      async getBufferFromResponse(e3) {
        if ("function" == typeof e3.buffer) return e3.buffer();
        if ("function" == typeof e3.arrayBuffer) {
          const t4 = await e3.arrayBuffer();
          return o.Buffer.from(t4);
        }
        throw new TypeError("invalid HTTP response object, has no buffer method, and no arrayBuffer method");
      }
      async fetch(e3, t4) {
        let r3;
        try {
          r3 = await this.fetchImplementation(e3, t4);
        } catch (n3) {
          if (!`${n3}`.includes("Failed to fetch")) throw n3;
          console.warn(`generic-filehandle: refetching ${e3} to attempt to work around chrome CORS header caching bug`), r3 = await this.fetchImplementation(e3, { ...t4, cache: "reload" });
        }
        return r3;
      }
      async read(e3, t4 = 0, r3, n3 = 0, i2 = {}) {
        const { headers: o2 = {}, signal: s2, overrides: a2 = {} } = i2;
        r3 < 1 / 0 ? o2.range = `bytes=${n3}-${n3 + r3}` : r3 === 1 / 0 && 0 !== n3 && (o2.range = `bytes=${n3}-`);
        const f2 = { ...this.baseOverrides, ...a2, headers: { ...o2, ...a2.headers, ...this.baseOverrides.headers }, method: "GET", redirect: "follow", mode: "cors", signal: s2 }, h2 = await this.fetch(this.url, f2);
        if (!h2.ok) throw new Error(`HTTP ${h2.status} ${h2.statusText} ${this.url}`);
        if (200 === h2.status && 0 === n3 || 206 === h2.status) {
          const n4 = await this.getBufferFromResponse(h2), i3 = n4.copy(e3, t4, 0, Math.min(r3, n4.length)), o3 = h2.headers.get("content-range"), s3 = /\/(\d+)$/.exec(o3 || "");
          return s3 && s3[1] && (this._stat = { size: parseInt(s3[1], 10) }), { bytesRead: i3, buffer: e3 };
        }
        if (200 === h2.status) throw new Error("${this.url} fetch returned status 200, expected 206");
        throw new Error(`HTTP ${h2.status} fetching ${this.url}`);
      }
      async readFile(e3 = {}) {
        let t4, r3;
        "string" == typeof e3 ? (t4 = e3, r3 = {}) : (t4 = e3.encoding, r3 = e3, delete r3.encoding);
        const { headers: n3 = {}, signal: i2, overrides: o2 = {} } = r3, s2 = { headers: n3, method: "GET", redirect: "follow", mode: "cors", signal: i2, ...this.baseOverrides, ...o2 }, a2 = await this.fetch(this.url, s2);
        if (!a2) throw new Error("generic-filehandle failed to fetch");
        if (200 !== a2.status) throw Object.assign(new Error(`HTTP ${a2.status} fetching ${this.url}`), { status: a2.status });
        if ("utf8" === t4) return a2.text();
        if (t4) throw new Error(`unsupported encoding: ${t4}`);
        return this.getBufferFromResponse(a2);
      }
      async stat() {
        if (!this._stat) {
          const e3 = o.Buffer.allocUnsafe(10);
          if (await this.read(e3, 0, 10, 0), !this._stat) throw new Error(`unable to determine size of file at ${this.url}`);
        }
        return this._stat;
      }
      async close() {
      }
    }
    function f(e3) {
      const t4 = new FileReader();
      return new Promise(((r3, n3) => {
        t4.onerror = () => {
          t4.abort(), n3(new Error("problem reading blob"));
        }, t4.onabort = () => {
          n3(new Error("blob reading was aborted"));
        }, t4.onload = () => {
          t4.result && "string" != typeof t4.result ? r3(t4.result) : n3(new Error("unknown error reading blob"));
        }, t4.readAsArrayBuffer(e3);
      }));
    }
    class h {
      constructor(e3) {
        this.blob = e3, this.size = e3.size;
      }
      async read(e3, t4 = 0, r3, n3 = 0) {
        if (!r3) return { bytesRead: 0, buffer: e3 };
        const i2 = n3, s2 = i2 + r3, a2 = await f(this.blob.slice(i2, s2)), h2 = o.Buffer.from(a2);
        return { bytesRead: h2.copy(e3, t4), buffer: h2 };
      }
      async readFile(e3) {
        let t4;
        if (t4 = "string" == typeof e3 ? e3 : e3 && e3.encoding, "utf8" === t4) return (function(e4) {
          const t5 = new FileReader();
          return new Promise(((r4, n3) => {
            t5.onerror = () => {
              t5.abort(), n3(new Error("problem reading blob"));
            }, t5.onabort = () => {
              n3(new Error("blob reading was aborted"));
            }, t5.onload = () => {
              t5.result && "string" == typeof t5.result ? r4(t5.result) : n3(new Error("unknown error reading blob"));
            }, t5.readAsText(e4);
          }));
        })(this.blob);
        if (t4) throw new Error(`unsupported encoding: ${t4}`);
        const r3 = await f(this.blob);
        return o.Buffer.from(r3);
      }
      async stat() {
        return { size: this.size };
      }
      async close() {
      }
    }
    function l(e3, t4 = {}) {
      return new a(e3, t4);
    }
    function u(e3, t4, r3, n3 = {}) {
      if (void 0 !== r3) return r3;
      if (void 0 !== e3) return l(e3, n3);
      if (void 0 !== t4) return new (i())(t4, n3);
      throw new Error("no url, path, or filehandle provided, cannot open");
    }
  }, 645: (e2, t3) => {
    t3.read = function(e3, t4, r2, n2, i) {
      var o, s, a = 8 * i - n2 - 1, f = (1 << a) - 1, h = f >> 1, l = -7, u = r2 ? i - 1 : 0, c = r2 ? -1 : 1, d = e3[t4 + u];
      for (u += c, o = d & (1 << -l) - 1, d >>= -l, l += a; l > 0; o = 256 * o + e3[t4 + u], u += c, l -= 8) ;
      for (s = o & (1 << -l) - 1, o >>= -l, l += n2; l > 0; s = 256 * s + e3[t4 + u], u += c, l -= 8) ;
      if (0 === o) o = 1 - h;
      else {
        if (o === f) return s ? NaN : 1 / 0 * (d ? -1 : 1);
        s += Math.pow(2, n2), o -= h;
      }
      return (d ? -1 : 1) * s * Math.pow(2, o - n2);
    }, t3.write = function(e3, t4, r2, n2, i, o) {
      var s, a, f, h = 8 * o - i - 1, l = (1 << h) - 1, u = l >> 1, c = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n2 ? 0 : o - 1, p = n2 ? 1 : -1, g = t4 < 0 || 0 === t4 && 1 / t4 < 0 ? 1 : 0;
      for (t4 = Math.abs(t4), isNaN(t4) || t4 === 1 / 0 ? (a = isNaN(t4) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t4) / Math.LN2), t4 * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), (t4 += s + u >= 1 ? c / f : c * Math.pow(2, 1 - u)) * f >= 2 && (s++, f /= 2), s + u >= l ? (a = 0, s = l) : s + u >= 1 ? (a = (t4 * f - 1) * Math.pow(2, i), s += u) : (a = t4 * Math.pow(2, u - 1) * Math.pow(2, i), s = 0)); i >= 8; e3[r2 + d] = 255 & a, d += p, a /= 256, i -= 8) ;
      for (s = s << i | a, h += i; h > 0; e3[r2 + d] = 255 & s, d += p, s /= 256, h -= 8) ;
      e3[r2 + d - p] |= 128 * g;
    };
  }, 8738: (e2) => {
    function t3(e3) {
      return !!e3.constructor && "function" == typeof e3.constructor.isBuffer && e3.constructor.isBuffer(e3);
    }
    e2.exports = function(e3) {
      return null != e3 && (t3(e3) || (function(e4) {
        return "function" == typeof e4.readFloatLE && "function" == typeof e4.slice && t3(e4.slice(0, 0));
      })(e3) || !!e3._isBuffer);
    };
  }, 3720: (e2) => {
    e2.exports = r2;
    var t3 = null;
    try {
      t3 = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
    } catch (e3) {
    }
    function r2(e3, t4, r3) {
      this.low = 0 | e3, this.high = 0 | t4, this.unsigned = !!r3;
    }
    function n2(e3) {
      return true === (e3 && e3.__isLong__);
    }
    r2.prototype.__isLong__, Object.defineProperty(r2.prototype, "__isLong__", { value: true }), r2.isLong = n2;
    var i = {}, o = {};
    function s(e3, t4) {
      var r3, n3, s2;
      return t4 ? (s2 = 0 <= (e3 >>>= 0) && e3 < 256) && (n3 = o[e3]) ? n3 : (r3 = f(e3, (0 | e3) < 0 ? -1 : 0, true), s2 && (o[e3] = r3), r3) : (s2 = -128 <= (e3 |= 0) && e3 < 128) && (n3 = i[e3]) ? n3 : (r3 = f(e3, e3 < 0 ? -1 : 0, false), s2 && (i[e3] = r3), r3);
    }
    function a(e3, t4) {
      if (isNaN(e3)) return t4 ? y : m;
      if (t4) {
        if (e3 < 0) return y;
        if (e3 >= d) return B;
      } else {
        if (e3 <= -p) return E;
        if (e3 + 1 >= p) return _;
      }
      return e3 < 0 ? a(-e3, t4).neg() : f(e3 % c | 0, e3 / c | 0, t4);
    }
    function f(e3, t4, n3) {
      return new r2(e3, t4, n3);
    }
    r2.fromInt = s, r2.fromNumber = a, r2.fromBits = f;
    var h = Math.pow;
    function l(e3, t4, r3) {
      if (0 === e3.length) throw Error("empty string");
      if ("NaN" === e3 || "Infinity" === e3 || "+Infinity" === e3 || "-Infinity" === e3) return m;
      if ("number" == typeof t4 ? (r3 = t4, t4 = false) : t4 = !!t4, (r3 = r3 || 10) < 2 || 36 < r3) throw RangeError("radix");
      var n3;
      if ((n3 = e3.indexOf("-")) > 0) throw Error("interior hyphen");
      if (0 === n3) return l(e3.substring(1), t4, r3).neg();
      for (var i2 = a(h(r3, 8)), o2 = m, s2 = 0; s2 < e3.length; s2 += 8) {
        var f2 = Math.min(8, e3.length - s2), u2 = parseInt(e3.substring(s2, s2 + f2), r3);
        if (f2 < 8) {
          var c2 = a(h(r3, f2));
          o2 = o2.mul(c2).add(a(u2));
        } else o2 = (o2 = o2.mul(i2)).add(a(u2));
      }
      return o2.unsigned = t4, o2;
    }
    function u(e3, t4) {
      return "number" == typeof e3 ? a(e3, t4) : "string" == typeof e3 ? l(e3, t4) : f(e3.low, e3.high, "boolean" == typeof t4 ? t4 : e3.unsigned);
    }
    r2.fromString = l, r2.fromValue = u;
    var c = 4294967296, d = c * c, p = d / 2, g = s(1 << 24), m = s(0);
    r2.ZERO = m;
    var y = s(0, true);
    r2.UZERO = y;
    var b = s(1);
    r2.ONE = b;
    var v = s(1, true);
    r2.UONE = v;
    var w = s(-1);
    r2.NEG_ONE = w;
    var _ = f(-1, 2147483647, false);
    r2.MAX_VALUE = _;
    var B = f(-1, -1, true);
    r2.MAX_UNSIGNED_VALUE = B;
    var E = f(0, -2147483648, false);
    r2.MIN_VALUE = E;
    var S = r2.prototype;
    S.toInt = function() {
      return this.unsigned ? this.low >>> 0 : this.low;
    }, S.toNumber = function() {
      return this.unsigned ? (this.high >>> 0) * c + (this.low >>> 0) : this.high * c + (this.low >>> 0);
    }, S.toString = function(e3) {
      if ((e3 = e3 || 10) < 2 || 36 < e3) throw RangeError("radix");
      if (this.isZero()) return "0";
      if (this.isNegative()) {
        if (this.eq(E)) {
          var t4 = a(e3), r3 = this.div(t4), n3 = r3.mul(t4).sub(this);
          return r3.toString(e3) + n3.toInt().toString(e3);
        }
        return "-" + this.neg().toString(e3);
      }
      for (var i2 = a(h(e3, 6), this.unsigned), o2 = this, s2 = ""; ; ) {
        var f2 = o2.div(i2), l2 = (o2.sub(f2.mul(i2)).toInt() >>> 0).toString(e3);
        if ((o2 = f2).isZero()) return l2 + s2;
        for (; l2.length < 6; ) l2 = "0" + l2;
        s2 = "" + l2 + s2;
      }
    }, S.getHighBits = function() {
      return this.high;
    }, S.getHighBitsUnsigned = function() {
      return this.high >>> 0;
    }, S.getLowBits = function() {
      return this.low;
    }, S.getLowBitsUnsigned = function() {
      return this.low >>> 0;
    }, S.getNumBitsAbs = function() {
      if (this.isNegative()) return this.eq(E) ? 64 : this.neg().getNumBitsAbs();
      for (var e3 = 0 != this.high ? this.high : this.low, t4 = 31; t4 > 0 && 0 == (e3 & 1 << t4); t4--) ;
      return 0 != this.high ? t4 + 33 : t4 + 1;
    }, S.isZero = function() {
      return 0 === this.high && 0 === this.low;
    }, S.eqz = S.isZero, S.isNegative = function() {
      return !this.unsigned && this.high < 0;
    }, S.isPositive = function() {
      return this.unsigned || this.high >= 0;
    }, S.isOdd = function() {
      return 1 == (1 & this.low);
    }, S.isEven = function() {
      return 0 == (1 & this.low);
    }, S.equals = function(e3) {
      return n2(e3) || (e3 = u(e3)), (this.unsigned === e3.unsigned || this.high >>> 31 != 1 || e3.high >>> 31 != 1) && this.high === e3.high && this.low === e3.low;
    }, S.eq = S.equals, S.notEquals = function(e3) {
      return !this.eq(e3);
    }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(e3) {
      return this.comp(e3) < 0;
    }, S.lt = S.lessThan, S.lessThanOrEqual = function(e3) {
      return this.comp(e3) <= 0;
    }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(e3) {
      return this.comp(e3) > 0;
    }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(e3) {
      return this.comp(e3) >= 0;
    }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(e3) {
      if (n2(e3) || (e3 = u(e3)), this.eq(e3)) return 0;
      var t4 = this.isNegative(), r3 = e3.isNegative();
      return t4 && !r3 ? -1 : !t4 && r3 ? 1 : this.unsigned ? e3.high >>> 0 > this.high >>> 0 || e3.high === this.high && e3.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e3).isNegative() ? -1 : 1;
    }, S.comp = S.compare, S.negate = function() {
      return !this.unsigned && this.eq(E) ? E : this.not().add(b);
    }, S.neg = S.negate, S.add = function(e3) {
      n2(e3) || (e3 = u(e3));
      var t4 = this.high >>> 16, r3 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, s2 = e3.high >>> 16, a2 = 65535 & e3.high, h2 = e3.low >>> 16, l2 = 0, c2 = 0, d2 = 0, p2 = 0;
      return d2 += (p2 += o2 + (65535 & e3.low)) >>> 16, c2 += (d2 += i2 + h2) >>> 16, l2 += (c2 += r3 + a2) >>> 16, l2 += t4 + s2, f((d2 &= 65535) << 16 | (p2 &= 65535), (l2 &= 65535) << 16 | (c2 &= 65535), this.unsigned);
    }, S.subtract = function(e3) {
      return n2(e3) || (e3 = u(e3)), this.add(e3.neg());
    }, S.sub = S.subtract, S.multiply = function(e3) {
      if (this.isZero()) return m;
      if (n2(e3) || (e3 = u(e3)), t3) return f(t3.mul(this.low, this.high, e3.low, e3.high), t3.get_high(), this.unsigned);
      if (e3.isZero()) return m;
      if (this.eq(E)) return e3.isOdd() ? E : m;
      if (e3.eq(E)) return this.isOdd() ? E : m;
      if (this.isNegative()) return e3.isNegative() ? this.neg().mul(e3.neg()) : this.neg().mul(e3).neg();
      if (e3.isNegative()) return this.mul(e3.neg()).neg();
      if (this.lt(g) && e3.lt(g)) return a(this.toNumber() * e3.toNumber(), this.unsigned);
      var r3 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, s2 = 65535 & this.low, h2 = e3.high >>> 16, l2 = 65535 & e3.high, c2 = e3.low >>> 16, d2 = 65535 & e3.low, p2 = 0, y2 = 0, b2 = 0, v2 = 0;
      return b2 += (v2 += s2 * d2) >>> 16, y2 += (b2 += o2 * d2) >>> 16, b2 &= 65535, y2 += (b2 += s2 * c2) >>> 16, p2 += (y2 += i2 * d2) >>> 16, y2 &= 65535, p2 += (y2 += o2 * c2) >>> 16, y2 &= 65535, p2 += (y2 += s2 * l2) >>> 16, p2 += r3 * d2 + i2 * c2 + o2 * l2 + s2 * h2, f((b2 &= 65535) << 16 | (v2 &= 65535), (p2 &= 65535) << 16 | (y2 &= 65535), this.unsigned);
    }, S.mul = S.multiply, S.divide = function(e3) {
      if (n2(e3) || (e3 = u(e3)), e3.isZero()) throw Error("division by zero");
      var r3, i2, o2;
      if (t3) return this.unsigned || -2147483648 !== this.high || -1 !== e3.low || -1 !== e3.high ? f((this.unsigned ? t3.div_u : t3.div_s)(this.low, this.high, e3.low, e3.high), t3.get_high(), this.unsigned) : this;
      if (this.isZero()) return this.unsigned ? y : m;
      if (this.unsigned) {
        if (e3.unsigned || (e3 = e3.toUnsigned()), e3.gt(this)) return y;
        if (e3.gt(this.shru(1))) return v;
        o2 = y;
      } else {
        if (this.eq(E)) return e3.eq(b) || e3.eq(w) ? E : e3.eq(E) ? b : (r3 = this.shr(1).div(e3).shl(1)).eq(m) ? e3.isNegative() ? b : w : (i2 = this.sub(e3.mul(r3)), o2 = r3.add(i2.div(e3)));
        if (e3.eq(E)) return this.unsigned ? y : m;
        if (this.isNegative()) return e3.isNegative() ? this.neg().div(e3.neg()) : this.neg().div(e3).neg();
        if (e3.isNegative()) return this.div(e3.neg()).neg();
        o2 = m;
      }
      for (i2 = this; i2.gte(e3); ) {
        r3 = Math.max(1, Math.floor(i2.toNumber() / e3.toNumber()));
        for (var s2 = Math.ceil(Math.log(r3) / Math.LN2), l2 = s2 <= 48 ? 1 : h(2, s2 - 48), c2 = a(r3), d2 = c2.mul(e3); d2.isNegative() || d2.gt(i2); ) d2 = (c2 = a(r3 -= l2, this.unsigned)).mul(e3);
        c2.isZero() && (c2 = b), o2 = o2.add(c2), i2 = i2.sub(d2);
      }
      return o2;
    }, S.div = S.divide, S.modulo = function(e3) {
      return n2(e3) || (e3 = u(e3)), t3 ? f((this.unsigned ? t3.rem_u : t3.rem_s)(this.low, this.high, e3.low, e3.high), t3.get_high(), this.unsigned) : this.sub(this.div(e3).mul(e3));
    }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
      return f(~this.low, ~this.high, this.unsigned);
    }, S.and = function(e3) {
      return n2(e3) || (e3 = u(e3)), f(this.low & e3.low, this.high & e3.high, this.unsigned);
    }, S.or = function(e3) {
      return n2(e3) || (e3 = u(e3)), f(this.low | e3.low, this.high | e3.high, this.unsigned);
    }, S.xor = function(e3) {
      return n2(e3) || (e3 = u(e3)), f(this.low ^ e3.low, this.high ^ e3.high, this.unsigned);
    }, S.shiftLeft = function(e3) {
      return n2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? f(this.low << e3, this.high << e3 | this.low >>> 32 - e3, this.unsigned) : f(0, this.low << e3 - 32, this.unsigned);
    }, S.shl = S.shiftLeft, S.shiftRight = function(e3) {
      return n2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63) ? this : e3 < 32 ? f(this.low >>> e3 | this.high << 32 - e3, this.high >> e3, this.unsigned) : f(this.high >> e3 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(e3) {
      if (n2(e3) && (e3 = e3.toInt()), 0 == (e3 &= 63)) return this;
      var t4 = this.high;
      return e3 < 32 ? f(this.low >>> e3 | t4 << 32 - e3, t4 >>> e3, this.unsigned) : f(32 === e3 ? t4 : t4 >>> e3 - 32, 0, this.unsigned);
    }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function() {
      return this.unsigned ? f(this.low, this.high, false) : this;
    }, S.toUnsigned = function() {
      return this.unsigned ? this : f(this.low, this.high, true);
    }, S.toBytes = function(e3) {
      return e3 ? this.toBytesLE() : this.toBytesBE();
    }, S.toBytesLE = function() {
      var e3 = this.high, t4 = this.low;
      return [255 & t4, t4 >>> 8 & 255, t4 >>> 16 & 255, t4 >>> 24, 255 & e3, e3 >>> 8 & 255, e3 >>> 16 & 255, e3 >>> 24];
    }, S.toBytesBE = function() {
      var e3 = this.high, t4 = this.low;
      return [e3 >>> 24, e3 >>> 16 & 255, e3 >>> 8 & 255, 255 & e3, t4 >>> 24, t4 >>> 16 & 255, t4 >>> 8 & 255, 255 & t4];
    }, r2.fromBytes = function(e3, t4, n3) {
      return n3 ? r2.fromBytesLE(e3, t4) : r2.fromBytesBE(e3, t4);
    }, r2.fromBytesLE = function(e3, t4) {
      return new r2(e3[0] | e3[1] << 8 | e3[2] << 16 | e3[3] << 24, e3[4] | e3[5] << 8 | e3[6] << 16 | e3[7] << 24, t4);
    }, r2.fromBytesBE = function(e3, t4) {
      return new r2(e3[4] << 24 | e3[5] << 16 | e3[6] << 8 | e3[7], e3[0] << 24 | e3[1] << 16 | e3[2] << 8 | e3[3], t4);
    };
  }, 2568: (e2, t3, r2) => {
    var n2, i, o, s, a;
    n2 = r2(1012), i = r2(487).utf8, o = r2(8738), s = r2(487).bin, (a = function(e3, t4) {
      e3.constructor == String ? e3 = t4 && "binary" === t4.encoding ? s.stringToBytes(e3) : i.stringToBytes(e3) : o(e3) ? e3 = Array.prototype.slice.call(e3, 0) : Array.isArray(e3) || e3.constructor === Uint8Array || (e3 = e3.toString());
      for (var r3 = n2.bytesToWords(e3), f = 8 * e3.length, h = 1732584193, l = -271733879, u = -1732584194, c = 271733878, d = 0; d < r3.length; d++) r3[d] = 16711935 & (r3[d] << 8 | r3[d] >>> 24) | 4278255360 & (r3[d] << 24 | r3[d] >>> 8);
      r3[f >>> 5] |= 128 << f % 32, r3[14 + (f + 64 >>> 9 << 4)] = f;
      var p = a._ff, g = a._gg, m = a._hh, y = a._ii;
      for (d = 0; d < r3.length; d += 16) {
        var b = h, v = l, w = u, _ = c;
        h = p(h, l, u, c, r3[d + 0], 7, -680876936), c = p(c, h, l, u, r3[d + 1], 12, -389564586), u = p(u, c, h, l, r3[d + 2], 17, 606105819), l = p(l, u, c, h, r3[d + 3], 22, -1044525330), h = p(h, l, u, c, r3[d + 4], 7, -176418897), c = p(c, h, l, u, r3[d + 5], 12, 1200080426), u = p(u, c, h, l, r3[d + 6], 17, -1473231341), l = p(l, u, c, h, r3[d + 7], 22, -45705983), h = p(h, l, u, c, r3[d + 8], 7, 1770035416), c = p(c, h, l, u, r3[d + 9], 12, -1958414417), u = p(u, c, h, l, r3[d + 10], 17, -42063), l = p(l, u, c, h, r3[d + 11], 22, -1990404162), h = p(h, l, u, c, r3[d + 12], 7, 1804603682), c = p(c, h, l, u, r3[d + 13], 12, -40341101), u = p(u, c, h, l, r3[d + 14], 17, -1502002290), h = g(h, l = p(l, u, c, h, r3[d + 15], 22, 1236535329), u, c, r3[d + 1], 5, -165796510), c = g(c, h, l, u, r3[d + 6], 9, -1069501632), u = g(u, c, h, l, r3[d + 11], 14, 643717713), l = g(l, u, c, h, r3[d + 0], 20, -373897302), h = g(h, l, u, c, r3[d + 5], 5, -701558691), c = g(c, h, l, u, r3[d + 10], 9, 38016083), u = g(u, c, h, l, r3[d + 15], 14, -660478335), l = g(l, u, c, h, r3[d + 4], 20, -405537848), h = g(h, l, u, c, r3[d + 9], 5, 568446438), c = g(c, h, l, u, r3[d + 14], 9, -1019803690), u = g(u, c, h, l, r3[d + 3], 14, -187363961), l = g(l, u, c, h, r3[d + 8], 20, 1163531501), h = g(h, l, u, c, r3[d + 13], 5, -1444681467), c = g(c, h, l, u, r3[d + 2], 9, -51403784), u = g(u, c, h, l, r3[d + 7], 14, 1735328473), h = m(h, l = g(l, u, c, h, r3[d + 12], 20, -1926607734), u, c, r3[d + 5], 4, -378558), c = m(c, h, l, u, r3[d + 8], 11, -2022574463), u = m(u, c, h, l, r3[d + 11], 16, 1839030562), l = m(l, u, c, h, r3[d + 14], 23, -35309556), h = m(h, l, u, c, r3[d + 1], 4, -1530992060), c = m(c, h, l, u, r3[d + 4], 11, 1272893353), u = m(u, c, h, l, r3[d + 7], 16, -155497632), l = m(l, u, c, h, r3[d + 10], 23, -1094730640), h = m(h, l, u, c, r3[d + 13], 4, 681279174), c = m(c, h, l, u, r3[d + 0], 11, -358537222), u = m(u, c, h, l, r3[d + 3], 16, -722521979), l = m(l, u, c, h, r3[d + 6], 23, 76029189), h = m(h, l, u, c, r3[d + 9], 4, -640364487), c = m(c, h, l, u, r3[d + 12], 11, -421815835), u = m(u, c, h, l, r3[d + 15], 16, 530742520), h = y(h, l = m(l, u, c, h, r3[d + 2], 23, -995338651), u, c, r3[d + 0], 6, -198630844), c = y(c, h, l, u, r3[d + 7], 10, 1126891415), u = y(u, c, h, l, r3[d + 14], 15, -1416354905), l = y(l, u, c, h, r3[d + 5], 21, -57434055), h = y(h, l, u, c, r3[d + 12], 6, 1700485571), c = y(c, h, l, u, r3[d + 3], 10, -1894986606), u = y(u, c, h, l, r3[d + 10], 15, -1051523), l = y(l, u, c, h, r3[d + 1], 21, -2054922799), h = y(h, l, u, c, r3[d + 8], 6, 1873313359), c = y(c, h, l, u, r3[d + 15], 10, -30611744), u = y(u, c, h, l, r3[d + 6], 15, -1560198380), l = y(l, u, c, h, r3[d + 13], 21, 1309151649), h = y(h, l, u, c, r3[d + 4], 6, -145523070), c = y(c, h, l, u, r3[d + 11], 10, -1120210379), u = y(u, c, h, l, r3[d + 2], 15, 718787259), l = y(l, u, c, h, r3[d + 9], 21, -343485551), h = h + b >>> 0, l = l + v >>> 0, u = u + w >>> 0, c = c + _ >>> 0;
      }
      return n2.endian([h, l, u, c]);
    })._ff = function(e3, t4, r3, n3, i2, o2, s2) {
      var a2 = e3 + (t4 & r3 | ~t4 & n3) + (i2 >>> 0) + s2;
      return (a2 << o2 | a2 >>> 32 - o2) + t4;
    }, a._gg = function(e3, t4, r3, n3, i2, o2, s2) {
      var a2 = e3 + (t4 & n3 | r3 & ~n3) + (i2 >>> 0) + s2;
      return (a2 << o2 | a2 >>> 32 - o2) + t4;
    }, a._hh = function(e3, t4, r3, n3, i2, o2, s2) {
      var a2 = e3 + (t4 ^ r3 ^ n3) + (i2 >>> 0) + s2;
      return (a2 << o2 | a2 >>> 32 - o2) + t4;
    }, a._ii = function(e3, t4, r3, n3, i2, o2, s2) {
      var a2 = e3 + (r3 ^ (t4 | ~n3)) + (i2 >>> 0) + s2;
      return (a2 << o2 | a2 >>> 32 - o2) + t4;
    }, a._blocksize = 16, a._digestsize = 16, e2.exports = function(e3, t4) {
      if (null == e3) throw new Error("Illegal argument " + e3);
      var r3 = n2.wordsToBytes(a(e3, t4));
      return t4 && t4.asBytes ? r3 : t4 && t4.asString ? s.bytesToString(r3) : n2.bytesToHex(r3);
    };
  }, 9591: (e2, t3, r2) => {
    var n2 = {};
    (0, r2(4236).assign)(n2, r2(4555), r2(8843), r2(1619)), e2.exports = n2;
  }, 4555: (e2, t3, r2) => {
    var n2 = r2(405), i = r2(4236), o = r2(9373), s = r2(8898), a = r2(2292), f = Object.prototype.toString;
    function h(e3) {
      if (!(this instanceof h)) return new h(e3);
      this.options = i.assign({ level: -1, method: 8, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: 0, to: "" }, e3 || {});
      var t4 = this.options;
      t4.raw && t4.windowBits > 0 ? t4.windowBits = -t4.windowBits : t4.gzip && t4.windowBits > 0 && t4.windowBits < 16 && (t4.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new a(), this.strm.avail_out = 0;
      var r3 = n2.deflateInit2(this.strm, t4.level, t4.method, t4.windowBits, t4.memLevel, t4.strategy);
      if (0 !== r3) throw new Error(s[r3]);
      if (t4.header && n2.deflateSetHeader(this.strm, t4.header), t4.dictionary) {
        var l2;
        if (l2 = "string" == typeof t4.dictionary ? o.string2buf(t4.dictionary) : "[object ArrayBuffer]" === f.call(t4.dictionary) ? new Uint8Array(t4.dictionary) : t4.dictionary, 0 !== (r3 = n2.deflateSetDictionary(this.strm, l2))) throw new Error(s[r3]);
        this._dict_set = true;
      }
    }
    function l(e3, t4) {
      var r3 = new h(t4);
      if (r3.push(e3, true), r3.err) throw r3.msg || s[r3.err];
      return r3.result;
    }
    h.prototype.push = function(e3, t4) {
      var r3, s2, a2 = this.strm, h2 = this.options.chunkSize;
      if (this.ended) return false;
      s2 = t4 === ~~t4 ? t4 : true === t4 ? 4 : 0, "string" == typeof e3 ? a2.input = o.string2buf(e3) : "[object ArrayBuffer]" === f.call(e3) ? a2.input = new Uint8Array(e3) : a2.input = e3, a2.next_in = 0, a2.avail_in = a2.input.length;
      do {
        if (0 === a2.avail_out && (a2.output = new i.Buf8(h2), a2.next_out = 0, a2.avail_out = h2), 1 !== (r3 = n2.deflate(a2, s2)) && 0 !== r3) return this.onEnd(r3), this.ended = true, false;
        0 !== a2.avail_out && (0 !== a2.avail_in || 4 !== s2 && 2 !== s2) || ("string" === this.options.to ? this.onData(o.buf2binstring(i.shrinkBuf(a2.output, a2.next_out))) : this.onData(i.shrinkBuf(a2.output, a2.next_out)));
      } while ((a2.avail_in > 0 || 0 === a2.avail_out) && 1 !== r3);
      return 4 === s2 ? (r3 = n2.deflateEnd(this.strm), this.onEnd(r3), this.ended = true, 0 === r3) : 2 !== s2 || (this.onEnd(0), a2.avail_out = 0, true);
    }, h.prototype.onData = function(e3) {
      this.chunks.push(e3);
    }, h.prototype.onEnd = function(e3) {
      0 === e3 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
    }, t3.Deflate = h, t3.deflate = l, t3.deflateRaw = function(e3, t4) {
      return (t4 = t4 || {}).raw = true, l(e3, t4);
    }, t3.gzip = function(e3, t4) {
      return (t4 = t4 || {}).gzip = true, l(e3, t4);
    };
  }, 8843: (e2, t3, r2) => {
    var n2 = r2(7948), i = r2(4236), o = r2(9373), s = r2(1619), a = r2(8898), f = r2(2292), h = r2(2401), l = Object.prototype.toString;
    function u(e3) {
      if (!(this instanceof u)) return new u(e3);
      this.options = i.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e3 || {});
      var t4 = this.options;
      t4.raw && t4.windowBits >= 0 && t4.windowBits < 16 && (t4.windowBits = -t4.windowBits, 0 === t4.windowBits && (t4.windowBits = -15)), !(t4.windowBits >= 0 && t4.windowBits < 16) || e3 && e3.windowBits || (t4.windowBits += 32), t4.windowBits > 15 && t4.windowBits < 48 && 0 == (15 & t4.windowBits) && (t4.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new f(), this.strm.avail_out = 0;
      var r3 = n2.inflateInit2(this.strm, t4.windowBits);
      if (r3 !== s.Z_OK) throw new Error(a[r3]);
      if (this.header = new h(), n2.inflateGetHeader(this.strm, this.header), t4.dictionary && ("string" == typeof t4.dictionary ? t4.dictionary = o.string2buf(t4.dictionary) : "[object ArrayBuffer]" === l.call(t4.dictionary) && (t4.dictionary = new Uint8Array(t4.dictionary)), t4.raw && (r3 = n2.inflateSetDictionary(this.strm, t4.dictionary)) !== s.Z_OK)) throw new Error(a[r3]);
    }
    function c(e3, t4) {
      var r3 = new u(t4);
      if (r3.push(e3, true), r3.err) throw r3.msg || a[r3.err];
      return r3.result;
    }
    u.prototype.push = function(e3, t4) {
      var r3, a2, f2, h2, u2, c2 = this.strm, d = this.options.chunkSize, p = this.options.dictionary, g = false;
      if (this.ended) return false;
      a2 = t4 === ~~t4 ? t4 : true === t4 ? s.Z_FINISH : s.Z_NO_FLUSH, "string" == typeof e3 ? c2.input = o.binstring2buf(e3) : "[object ArrayBuffer]" === l.call(e3) ? c2.input = new Uint8Array(e3) : c2.input = e3, c2.next_in = 0, c2.avail_in = c2.input.length;
      do {
        if (0 === c2.avail_out && (c2.output = new i.Buf8(d), c2.next_out = 0, c2.avail_out = d), (r3 = n2.inflate(c2, s.Z_NO_FLUSH)) === s.Z_NEED_DICT && p && (r3 = n2.inflateSetDictionary(this.strm, p)), r3 === s.Z_BUF_ERROR && true === g && (r3 = s.Z_OK, g = false), r3 !== s.Z_STREAM_END && r3 !== s.Z_OK) return this.onEnd(r3), this.ended = true, false;
        c2.next_out && (0 !== c2.avail_out && r3 !== s.Z_STREAM_END && (0 !== c2.avail_in || a2 !== s.Z_FINISH && a2 !== s.Z_SYNC_FLUSH) || ("string" === this.options.to ? (f2 = o.utf8border(c2.output, c2.next_out), h2 = c2.next_out - f2, u2 = o.buf2string(c2.output, f2), c2.next_out = h2, c2.avail_out = d - h2, h2 && i.arraySet(c2.output, c2.output, f2, h2, 0), this.onData(u2)) : this.onData(i.shrinkBuf(c2.output, c2.next_out)))), 0 === c2.avail_in && 0 === c2.avail_out && (g = true);
      } while ((c2.avail_in > 0 || 0 === c2.avail_out) && r3 !== s.Z_STREAM_END);
      return r3 === s.Z_STREAM_END && (a2 = s.Z_FINISH), a2 === s.Z_FINISH ? (r3 = n2.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, r3 === s.Z_OK) : a2 !== s.Z_SYNC_FLUSH || (this.onEnd(s.Z_OK), c2.avail_out = 0, true);
    }, u.prototype.onData = function(e3) {
      this.chunks.push(e3);
    }, u.prototype.onEnd = function(e3) {
      e3 === s.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
    }, t3.Inflate = u, t3.inflate = c, t3.inflateRaw = function(e3, t4) {
      return (t4 = t4 || {}).raw = true, c(e3, t4);
    }, t3.ungzip = c;
  }, 4236: (e2, t3) => {
    var r2 = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
    function n2(e3, t4) {
      return Object.prototype.hasOwnProperty.call(e3, t4);
    }
    t3.assign = function(e3) {
      for (var t4 = Array.prototype.slice.call(arguments, 1); t4.length; ) {
        var r3 = t4.shift();
        if (r3) {
          if ("object" != typeof r3) throw new TypeError(r3 + "must be non-object");
          for (var i2 in r3) n2(r3, i2) && (e3[i2] = r3[i2]);
        }
      }
      return e3;
    }, t3.shrinkBuf = function(e3, t4) {
      return e3.length === t4 ? e3 : e3.subarray ? e3.subarray(0, t4) : (e3.length = t4, e3);
    };
    var i = { arraySet: function(e3, t4, r3, n3, i2) {
      if (t4.subarray && e3.subarray) e3.set(t4.subarray(r3, r3 + n3), i2);
      else for (var o2 = 0; o2 < n3; o2++) e3[i2 + o2] = t4[r3 + o2];
    }, flattenChunks: function(e3) {
      var t4, r3, n3, i2, o2, s;
      for (n3 = 0, t4 = 0, r3 = e3.length; t4 < r3; t4++) n3 += e3[t4].length;
      for (s = new Uint8Array(n3), i2 = 0, t4 = 0, r3 = e3.length; t4 < r3; t4++) o2 = e3[t4], s.set(o2, i2), i2 += o2.length;
      return s;
    } }, o = { arraySet: function(e3, t4, r3, n3, i2) {
      for (var o2 = 0; o2 < n3; o2++) e3[i2 + o2] = t4[r3 + o2];
    }, flattenChunks: function(e3) {
      return [].concat.apply([], e3);
    } };
    t3.setTyped = function(e3) {
      e3 ? (t3.Buf8 = Uint8Array, t3.Buf16 = Uint16Array, t3.Buf32 = Int32Array, t3.assign(t3, i)) : (t3.Buf8 = Array, t3.Buf16 = Array, t3.Buf32 = Array, t3.assign(t3, o));
    }, t3.setTyped(r2);
  }, 9373: (e2, t3, r2) => {
    var n2 = r2(4236), i = true, o = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (e3) {
      i = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e3) {
      o = false;
    }
    for (var s = new n2.Buf8(256), a = 0; a < 256; a++) s[a] = a >= 252 ? 6 : a >= 248 ? 5 : a >= 240 ? 4 : a >= 224 ? 3 : a >= 192 ? 2 : 1;
    function f(e3, t4) {
      if (t4 < 65534 && (e3.subarray && o || !e3.subarray && i)) return String.fromCharCode.apply(null, n2.shrinkBuf(e3, t4));
      for (var r3 = "", s2 = 0; s2 < t4; s2++) r3 += String.fromCharCode(e3[s2]);
      return r3;
    }
    s[254] = s[254] = 1, t3.string2buf = function(e3) {
      var t4, r3, i2, o2, s2, a2 = e3.length, f2 = 0;
      for (o2 = 0; o2 < a2; o2++) 55296 == (64512 & (r3 = e3.charCodeAt(o2))) && o2 + 1 < a2 && 56320 == (64512 & (i2 = e3.charCodeAt(o2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (i2 - 56320), o2++), f2 += r3 < 128 ? 1 : r3 < 2048 ? 2 : r3 < 65536 ? 3 : 4;
      for (t4 = new n2.Buf8(f2), s2 = 0, o2 = 0; s2 < f2; o2++) 55296 == (64512 & (r3 = e3.charCodeAt(o2))) && o2 + 1 < a2 && 56320 == (64512 & (i2 = e3.charCodeAt(o2 + 1))) && (r3 = 65536 + (r3 - 55296 << 10) + (i2 - 56320), o2++), r3 < 128 ? t4[s2++] = r3 : r3 < 2048 ? (t4[s2++] = 192 | r3 >>> 6, t4[s2++] = 128 | 63 & r3) : r3 < 65536 ? (t4[s2++] = 224 | r3 >>> 12, t4[s2++] = 128 | r3 >>> 6 & 63, t4[s2++] = 128 | 63 & r3) : (t4[s2++] = 240 | r3 >>> 18, t4[s2++] = 128 | r3 >>> 12 & 63, t4[s2++] = 128 | r3 >>> 6 & 63, t4[s2++] = 128 | 63 & r3);
      return t4;
    }, t3.buf2binstring = function(e3) {
      return f(e3, e3.length);
    }, t3.binstring2buf = function(e3) {
      for (var t4 = new n2.Buf8(e3.length), r3 = 0, i2 = t4.length; r3 < i2; r3++) t4[r3] = e3.charCodeAt(r3);
      return t4;
    }, t3.buf2string = function(e3, t4) {
      var r3, n3, i2, o2, a2 = t4 || e3.length, h = new Array(2 * a2);
      for (n3 = 0, r3 = 0; r3 < a2; ) if ((i2 = e3[r3++]) < 128) h[n3++] = i2;
      else if ((o2 = s[i2]) > 4) h[n3++] = 65533, r3 += o2 - 1;
      else {
        for (i2 &= 2 === o2 ? 31 : 3 === o2 ? 15 : 7; o2 > 1 && r3 < a2; ) i2 = i2 << 6 | 63 & e3[r3++], o2--;
        o2 > 1 ? h[n3++] = 65533 : i2 < 65536 ? h[n3++] = i2 : (i2 -= 65536, h[n3++] = 55296 | i2 >> 10 & 1023, h[n3++] = 56320 | 1023 & i2);
      }
      return f(h, n3);
    }, t3.utf8border = function(e3, t4) {
      var r3;
      for ((t4 = t4 || e3.length) > e3.length && (t4 = e3.length), r3 = t4 - 1; r3 >= 0 && 128 == (192 & e3[r3]); ) r3--;
      return r3 < 0 || 0 === r3 ? t4 : r3 + s[e3[r3]] > t4 ? r3 : t4;
    };
  }, 6069: (e2) => {
    e2.exports = function(e3, t3, r2, n2) {
      for (var i = 65535 & e3 | 0, o = e3 >>> 16 & 65535 | 0, s = 0; 0 !== r2; ) {
        r2 -= s = r2 > 2e3 ? 2e3 : r2;
        do {
          o = o + (i = i + t3[n2++] | 0) | 0;
        } while (--s);
        i %= 65521, o %= 65521;
      }
      return i | o << 16 | 0;
    };
  }, 1619: (e2) => {
    e2.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  }, 2869: (e2) => {
    var t3 = (function() {
      for (var e3, t4 = [], r2 = 0; r2 < 256; r2++) {
        e3 = r2;
        for (var n2 = 0; n2 < 8; n2++) e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
        t4[r2] = e3;
      }
      return t4;
    })();
    e2.exports = function(e3, r2, n2, i) {
      var o = t3, s = i + n2;
      e3 ^= -1;
      for (var a = i; a < s; a++) e3 = e3 >>> 8 ^ o[255 & (e3 ^ r2[a])];
      return -1 ^ e3;
    };
  }, 405: (e2, t3, r2) => {
    var n2, i = r2(4236), o = r2(342), s = r2(6069), a = r2(2869), f = r2(8898), h = -2, l = 258, u = 262, c = 103, d = 113, p = 666;
    function g(e3, t4) {
      return e3.msg = f[t4], t4;
    }
    function m(e3) {
      return (e3 << 1) - (e3 > 4 ? 9 : 0);
    }
    function y(e3) {
      for (var t4 = e3.length; --t4 >= 0; ) e3[t4] = 0;
    }
    function b(e3) {
      var t4 = e3.state, r3 = t4.pending;
      r3 > e3.avail_out && (r3 = e3.avail_out), 0 !== r3 && (i.arraySet(e3.output, t4.pending_buf, t4.pending_out, r3, e3.next_out), e3.next_out += r3, t4.pending_out += r3, e3.total_out += r3, e3.avail_out -= r3, t4.pending -= r3, 0 === t4.pending && (t4.pending_out = 0));
    }
    function v(e3, t4) {
      o._tr_flush_block(e3, e3.block_start >= 0 ? e3.block_start : -1, e3.strstart - e3.block_start, t4), e3.block_start = e3.strstart, b(e3.strm);
    }
    function w(e3, t4) {
      e3.pending_buf[e3.pending++] = t4;
    }
    function _(e3, t4) {
      e3.pending_buf[e3.pending++] = t4 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t4;
    }
    function B(e3, t4, r3, n3) {
      var o2 = e3.avail_in;
      return o2 > n3 && (o2 = n3), 0 === o2 ? 0 : (e3.avail_in -= o2, i.arraySet(t4, e3.input, e3.next_in, o2, r3), 1 === e3.state.wrap ? e3.adler = s(e3.adler, t4, o2, r3) : 2 === e3.state.wrap && (e3.adler = a(e3.adler, t4, o2, r3)), e3.next_in += o2, e3.total_in += o2, o2);
    }
    function E(e3, t4) {
      var r3, n3, i2 = e3.max_chain_length, o2 = e3.strstart, s2 = e3.prev_length, a2 = e3.nice_match, f2 = e3.strstart > e3.w_size - u ? e3.strstart - (e3.w_size - u) : 0, h2 = e3.window, c2 = e3.w_mask, d2 = e3.prev, p2 = e3.strstart + l, g2 = h2[o2 + s2 - 1], m2 = h2[o2 + s2];
      e3.prev_length >= e3.good_match && (i2 >>= 2), a2 > e3.lookahead && (a2 = e3.lookahead);
      do {
        if (h2[(r3 = t4) + s2] === m2 && h2[r3 + s2 - 1] === g2 && h2[r3] === h2[o2] && h2[++r3] === h2[o2 + 1]) {
          o2 += 2, r3++;
          do {
          } while (h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && h2[++o2] === h2[++r3] && o2 < p2);
          if (n3 = l - (p2 - o2), o2 = p2 - l, n3 > s2) {
            if (e3.match_start = t4, s2 = n3, n3 >= a2) break;
            g2 = h2[o2 + s2 - 1], m2 = h2[o2 + s2];
          }
        }
      } while ((t4 = d2[t4 & c2]) > f2 && 0 != --i2);
      return s2 <= e3.lookahead ? s2 : e3.lookahead;
    }
    function S(e3) {
      var t4, r3, n3, o2, s2, a2 = e3.w_size;
      do {
        if (o2 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= a2 + (a2 - u)) {
          i.arraySet(e3.window, e3.window, a2, a2, 0), e3.match_start -= a2, e3.strstart -= a2, e3.block_start -= a2, t4 = r3 = e3.hash_size;
          do {
            n3 = e3.head[--t4], e3.head[t4] = n3 >= a2 ? n3 - a2 : 0;
          } while (--r3);
          t4 = r3 = a2;
          do {
            n3 = e3.prev[--t4], e3.prev[t4] = n3 >= a2 ? n3 - a2 : 0;
          } while (--r3);
          o2 += a2;
        }
        if (0 === e3.strm.avail_in) break;
        if (r3 = B(e3.strm, e3.window, e3.strstart + e3.lookahead, o2), e3.lookahead += r3, e3.lookahead + e3.insert >= 3) for (s2 = e3.strstart - e3.insert, e3.ins_h = e3.window[s2], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + 1]) & e3.hash_mask; e3.insert && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[s2 + 3 - 1]) & e3.hash_mask, e3.prev[s2 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = s2, s2++, e3.insert--, !(e3.lookahead + e3.insert < 3)); ) ;
      } while (e3.lookahead < u && 0 !== e3.strm.avail_in);
    }
    function A(e3, t4) {
      for (var r3, n3; ; ) {
        if (e3.lookahead < u) {
          if (S(e3), e3.lookahead < u && 0 === t4) return 1;
          if (0 === e3.lookahead) break;
        }
        if (r3 = 0, e3.lookahead >= 3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), 0 !== r3 && e3.strstart - r3 <= e3.w_size - u && (e3.match_length = E(e3, r3)), e3.match_length >= 3) if (n3 = o._tr_tally(e3, e3.strstart - e3.match_start, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= 3) {
          e3.match_length--;
          do {
            e3.strstart++, e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart;
          } while (0 != --e3.match_length);
          e3.strstart++;
        } else e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 1]) & e3.hash_mask;
        else n3 = o._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
        if (n3 && (v(e3, false), 0 === e3.strm.avail_out)) return 1;
      }
      return e3.insert = e3.strstart < 2 ? e3.strstart : 2, 4 === t4 ? (v(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (v(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
    }
    function C(e3, t4) {
      for (var r3, n3, i2; ; ) {
        if (e3.lookahead < u) {
          if (S(e3), e3.lookahead < u && 0 === t4) return 1;
          if (0 === e3.lookahead) break;
        }
        if (r3 = 0, e3.lookahead >= 3 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = 2, 0 !== r3 && e3.prev_length < e3.max_lazy_match && e3.strstart - r3 <= e3.w_size - u && (e3.match_length = E(e3, r3), e3.match_length <= 5 && (1 === e3.strategy || 3 === e3.match_length && e3.strstart - e3.match_start > 4096) && (e3.match_length = 2)), e3.prev_length >= 3 && e3.match_length <= e3.prev_length) {
          i2 = e3.strstart + e3.lookahead - 3, n3 = o._tr_tally(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - 3), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2;
          do {
            ++e3.strstart <= i2 && (e3.ins_h = (e3.ins_h << e3.hash_shift ^ e3.window[e3.strstart + 3 - 1]) & e3.hash_mask, r3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart);
          } while (0 != --e3.prev_length);
          if (e3.match_available = 0, e3.match_length = 2, e3.strstart++, n3 && (v(e3, false), 0 === e3.strm.avail_out)) return 1;
        } else if (e3.match_available) {
          if ((n3 = o._tr_tally(e3, 0, e3.window[e3.strstart - 1])) && v(e3, false), e3.strstart++, e3.lookahead--, 0 === e3.strm.avail_out) return 1;
        } else e3.match_available = 1, e3.strstart++, e3.lookahead--;
      }
      return e3.match_available && (n3 = o._tr_tally(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < 2 ? e3.strstart : 2, 4 === t4 ? (v(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : e3.last_lit && (v(e3, false), 0 === e3.strm.avail_out) ? 1 : 2;
    }
    function R(e3, t4, r3, n3, i2) {
      this.good_length = e3, this.max_lazy = t4, this.nice_length = r3, this.max_chain = n3, this.func = i2;
    }
    function k() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(1146), this.dyn_dtree = new i.Buf16(122), this.bl_tree = new i.Buf16(78), y(this.dyn_ltree), y(this.dyn_dtree), y(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(16), this.heap = new i.Buf16(573), y(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(573), y(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function x(e3) {
      var t4;
      return e3 && e3.state ? (e3.total_in = e3.total_out = 0, e3.data_type = 2, (t4 = e3.state).pending = 0, t4.pending_out = 0, t4.wrap < 0 && (t4.wrap = -t4.wrap), t4.status = t4.wrap ? 42 : d, e3.adler = 2 === t4.wrap ? 0 : 1, t4.last_flush = 0, o._tr_init(t4), 0) : g(e3, h);
    }
    function I(e3) {
      var t4, r3 = x(e3);
      return 0 === r3 && ((t4 = e3.state).window_size = 2 * t4.w_size, y(t4.head), t4.max_lazy_match = n2[t4.level].max_lazy, t4.good_match = n2[t4.level].good_length, t4.nice_match = n2[t4.level].nice_length, t4.max_chain_length = n2[t4.level].max_chain, t4.strstart = 0, t4.block_start = 0, t4.lookahead = 0, t4.insert = 0, t4.match_length = t4.prev_length = 2, t4.match_available = 0, t4.ins_h = 0), r3;
    }
    function M(e3, t4, r3, n3, o2, s2) {
      if (!e3) return h;
      var a2 = 1;
      if (-1 === t4 && (t4 = 6), n3 < 0 ? (a2 = 0, n3 = -n3) : n3 > 15 && (a2 = 2, n3 -= 16), o2 < 1 || o2 > 9 || 8 !== r3 || n3 < 8 || n3 > 15 || t4 < 0 || t4 > 9 || s2 < 0 || s2 > 4) return g(e3, h);
      8 === n3 && (n3 = 9);
      var f2 = new k();
      return e3.state = f2, f2.strm = e3, f2.wrap = a2, f2.gzhead = null, f2.w_bits = n3, f2.w_size = 1 << f2.w_bits, f2.w_mask = f2.w_size - 1, f2.hash_bits = o2 + 7, f2.hash_size = 1 << f2.hash_bits, f2.hash_mask = f2.hash_size - 1, f2.hash_shift = ~~((f2.hash_bits + 3 - 1) / 3), f2.window = new i.Buf8(2 * f2.w_size), f2.head = new i.Buf16(f2.hash_size), f2.prev = new i.Buf16(f2.w_size), f2.lit_bufsize = 1 << o2 + 6, f2.pending_buf_size = 4 * f2.lit_bufsize, f2.pending_buf = new i.Buf8(f2.pending_buf_size), f2.d_buf = 1 * f2.lit_bufsize, f2.l_buf = 3 * f2.lit_bufsize, f2.level = t4, f2.strategy = s2, f2.method = r3, I(e3);
    }
    n2 = [new R(0, 0, 0, 0, (function(e3, t4) {
      var r3 = 65535;
      for (r3 > e3.pending_buf_size - 5 && (r3 = e3.pending_buf_size - 5); ; ) {
        if (e3.lookahead <= 1) {
          if (S(e3), 0 === e3.lookahead && 0 === t4) return 1;
          if (0 === e3.lookahead) break;
        }
        e3.strstart += e3.lookahead, e3.lookahead = 0;
        var n3 = e3.block_start + r3;
        if ((0 === e3.strstart || e3.strstart >= n3) && (e3.lookahead = e3.strstart - n3, e3.strstart = n3, v(e3, false), 0 === e3.strm.avail_out)) return 1;
        if (e3.strstart - e3.block_start >= e3.w_size - u && (v(e3, false), 0 === e3.strm.avail_out)) return 1;
      }
      return e3.insert = 0, 4 === t4 ? (v(e3, true), 0 === e3.strm.avail_out ? 3 : 4) : (e3.strstart > e3.block_start && (v(e3, false), e3.strm.avail_out), 1);
    })), new R(4, 4, 8, 4, A), new R(4, 5, 16, 8, A), new R(4, 6, 32, 32, A), new R(4, 4, 16, 16, C), new R(8, 16, 32, 32, C), new R(8, 16, 128, 128, C), new R(8, 32, 128, 256, C), new R(32, 128, 258, 1024, C), new R(32, 258, 258, 4096, C)], t3.deflateInit = function(e3, t4) {
      return M(e3, t4, 8, 15, 8, 0);
    }, t3.deflateInit2 = M, t3.deflateReset = I, t3.deflateResetKeep = x, t3.deflateSetHeader = function(e3, t4) {
      return e3 && e3.state ? 2 !== e3.state.wrap ? h : (e3.state.gzhead = t4, 0) : h;
    }, t3.deflate = function(e3, t4) {
      var r3, i2, s2, f2;
      if (!e3 || !e3.state || t4 > 5 || t4 < 0) return e3 ? g(e3, h) : h;
      if (i2 = e3.state, !e3.output || !e3.input && 0 !== e3.avail_in || i2.status === p && 4 !== t4) return g(e3, 0 === e3.avail_out ? -5 : h);
      if (i2.strm = e3, r3 = i2.last_flush, i2.last_flush = t4, 42 === i2.status) if (2 === i2.wrap) e3.adler = 0, w(i2, 31), w(i2, 139), w(i2, 8), i2.gzhead ? (w(i2, (i2.gzhead.text ? 1 : 0) + (i2.gzhead.hcrc ? 2 : 0) + (i2.gzhead.extra ? 4 : 0) + (i2.gzhead.name ? 8 : 0) + (i2.gzhead.comment ? 16 : 0)), w(i2, 255 & i2.gzhead.time), w(i2, i2.gzhead.time >> 8 & 255), w(i2, i2.gzhead.time >> 16 & 255), w(i2, i2.gzhead.time >> 24 & 255), w(i2, 9 === i2.level ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), w(i2, 255 & i2.gzhead.os), i2.gzhead.extra && i2.gzhead.extra.length && (w(i2, 255 & i2.gzhead.extra.length), w(i2, i2.gzhead.extra.length >> 8 & 255)), i2.gzhead.hcrc && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending, 0)), i2.gzindex = 0, i2.status = 69) : (w(i2, 0), w(i2, 0), w(i2, 0), w(i2, 0), w(i2, 0), w(i2, 9 === i2.level ? 2 : i2.strategy >= 2 || i2.level < 2 ? 4 : 0), w(i2, 3), i2.status = d);
      else {
        var u2 = 8 + (i2.w_bits - 8 << 4) << 8;
        u2 |= (i2.strategy >= 2 || i2.level < 2 ? 0 : i2.level < 6 ? 1 : 6 === i2.level ? 2 : 3) << 6, 0 !== i2.strstart && (u2 |= 32), u2 += 31 - u2 % 31, i2.status = d, _(i2, u2), 0 !== i2.strstart && (_(i2, e3.adler >>> 16), _(i2, 65535 & e3.adler)), e3.adler = 1;
      }
      if (69 === i2.status) if (i2.gzhead.extra) {
        for (s2 = i2.pending; i2.gzindex < (65535 & i2.gzhead.extra.length) && (i2.pending !== i2.pending_buf_size || (i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), b(e3), s2 = i2.pending, i2.pending !== i2.pending_buf_size)); ) w(i2, 255 & i2.gzhead.extra[i2.gzindex]), i2.gzindex++;
        i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), i2.gzindex === i2.gzhead.extra.length && (i2.gzindex = 0, i2.status = 73);
      } else i2.status = 73;
      if (73 === i2.status) if (i2.gzhead.name) {
        s2 = i2.pending;
        do {
          if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), b(e3), s2 = i2.pending, i2.pending === i2.pending_buf_size)) {
            f2 = 1;
            break;
          }
          f2 = i2.gzindex < i2.gzhead.name.length ? 255 & i2.gzhead.name.charCodeAt(i2.gzindex++) : 0, w(i2, f2);
        } while (0 !== f2);
        i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), 0 === f2 && (i2.gzindex = 0, i2.status = 91);
      } else i2.status = 91;
      if (91 === i2.status) if (i2.gzhead.comment) {
        s2 = i2.pending;
        do {
          if (i2.pending === i2.pending_buf_size && (i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), b(e3), s2 = i2.pending, i2.pending === i2.pending_buf_size)) {
            f2 = 1;
            break;
          }
          f2 = i2.gzindex < i2.gzhead.comment.length ? 255 & i2.gzhead.comment.charCodeAt(i2.gzindex++) : 0, w(i2, f2);
        } while (0 !== f2);
        i2.gzhead.hcrc && i2.pending > s2 && (e3.adler = a(e3.adler, i2.pending_buf, i2.pending - s2, s2)), 0 === f2 && (i2.status = c);
      } else i2.status = c;
      if (i2.status === c && (i2.gzhead.hcrc ? (i2.pending + 2 > i2.pending_buf_size && b(e3), i2.pending + 2 <= i2.pending_buf_size && (w(i2, 255 & e3.adler), w(i2, e3.adler >> 8 & 255), e3.adler = 0, i2.status = d)) : i2.status = d), 0 !== i2.pending) {
        if (b(e3), 0 === e3.avail_out) return i2.last_flush = -1, 0;
      } else if (0 === e3.avail_in && m(t4) <= m(r3) && 4 !== t4) return g(e3, -5);
      if (i2.status === p && 0 !== e3.avail_in) return g(e3, -5);
      if (0 !== e3.avail_in || 0 !== i2.lookahead || 0 !== t4 && i2.status !== p) {
        var B2 = 2 === i2.strategy ? (function(e4, t5) {
          for (var r4; ; ) {
            if (0 === e4.lookahead && (S(e4), 0 === e4.lookahead)) {
              if (0 === t5) return 1;
              break;
            }
            if (e4.match_length = 0, r4 = o._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, r4 && (v(e4, false), 0 === e4.strm.avail_out)) return 1;
          }
          return e4.insert = 0, 4 === t5 ? (v(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (v(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
        })(i2, t4) : 3 === i2.strategy ? (function(e4, t5) {
          for (var r4, n3, i3, s3, a2 = e4.window; ; ) {
            if (e4.lookahead <= l) {
              if (S(e4), e4.lookahead <= l && 0 === t5) return 1;
              if (0 === e4.lookahead) break;
            }
            if (e4.match_length = 0, e4.lookahead >= 3 && e4.strstart > 0 && (n3 = a2[i3 = e4.strstart - 1]) === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3]) {
              s3 = e4.strstart + l;
              do {
              } while (n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && n3 === a2[++i3] && i3 < s3);
              e4.match_length = l - (s3 - i3), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
            }
            if (e4.match_length >= 3 ? (r4 = o._tr_tally(e4, 1, e4.match_length - 3), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (r4 = o._tr_tally(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), r4 && (v(e4, false), 0 === e4.strm.avail_out)) return 1;
          }
          return e4.insert = 0, 4 === t5 ? (v(e4, true), 0 === e4.strm.avail_out ? 3 : 4) : e4.last_lit && (v(e4, false), 0 === e4.strm.avail_out) ? 1 : 2;
        })(i2, t4) : n2[i2.level].func(i2, t4);
        if (3 !== B2 && 4 !== B2 || (i2.status = p), 1 === B2 || 3 === B2) return 0 === e3.avail_out && (i2.last_flush = -1), 0;
        if (2 === B2 && (1 === t4 ? o._tr_align(i2) : 5 !== t4 && (o._tr_stored_block(i2, 0, 0, false), 3 === t4 && (y(i2.head), 0 === i2.lookahead && (i2.strstart = 0, i2.block_start = 0, i2.insert = 0))), b(e3), 0 === e3.avail_out)) return i2.last_flush = -1, 0;
      }
      return 4 !== t4 ? 0 : i2.wrap <= 0 ? 1 : (2 === i2.wrap ? (w(i2, 255 & e3.adler), w(i2, e3.adler >> 8 & 255), w(i2, e3.adler >> 16 & 255), w(i2, e3.adler >> 24 & 255), w(i2, 255 & e3.total_in), w(i2, e3.total_in >> 8 & 255), w(i2, e3.total_in >> 16 & 255), w(i2, e3.total_in >> 24 & 255)) : (_(i2, e3.adler >>> 16), _(i2, 65535 & e3.adler)), b(e3), i2.wrap > 0 && (i2.wrap = -i2.wrap), 0 !== i2.pending ? 0 : 1);
    }, t3.deflateEnd = function(e3) {
      var t4;
      return e3 && e3.state ? 42 !== (t4 = e3.state.status) && 69 !== t4 && 73 !== t4 && 91 !== t4 && t4 !== c && t4 !== d && t4 !== p ? g(e3, h) : (e3.state = null, t4 === d ? g(e3, -3) : 0) : h;
    }, t3.deflateSetDictionary = function(e3, t4) {
      var r3, n3, o2, a2, f2, l2, u2, c2, d2 = t4.length;
      if (!e3 || !e3.state) return h;
      if (2 === (a2 = (r3 = e3.state).wrap) || 1 === a2 && 42 !== r3.status || r3.lookahead) return h;
      for (1 === a2 && (e3.adler = s(e3.adler, t4, d2, 0)), r3.wrap = 0, d2 >= r3.w_size && (0 === a2 && (y(r3.head), r3.strstart = 0, r3.block_start = 0, r3.insert = 0), c2 = new i.Buf8(r3.w_size), i.arraySet(c2, t4, d2 - r3.w_size, r3.w_size, 0), t4 = c2, d2 = r3.w_size), f2 = e3.avail_in, l2 = e3.next_in, u2 = e3.input, e3.avail_in = d2, e3.next_in = 0, e3.input = t4, S(r3); r3.lookahead >= 3; ) {
        n3 = r3.strstart, o2 = r3.lookahead - 2;
        do {
          r3.ins_h = (r3.ins_h << r3.hash_shift ^ r3.window[n3 + 3 - 1]) & r3.hash_mask, r3.prev[n3 & r3.w_mask] = r3.head[r3.ins_h], r3.head[r3.ins_h] = n3, n3++;
        } while (--o2);
        r3.strstart = n3, r3.lookahead = 2, S(r3);
      }
      return r3.strstart += r3.lookahead, r3.block_start = r3.strstart, r3.insert = r3.lookahead, r3.lookahead = 0, r3.match_length = r3.prev_length = 2, r3.match_available = 0, e3.next_in = l2, e3.input = u2, e3.avail_in = f2, r3.wrap = a2, 0;
    }, t3.deflateInfo = "pako deflate (from Nodeca project)";
  }, 2401: (e2) => {
    e2.exports = function() {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
    };
  }, 4264: (e2) => {
    e2.exports = function(e3, t3) {
      var r2, n2, i, o, s, a, f, h, l, u, c, d, p, g, m, y, b, v, w, _, B, E, S, A, C;
      r2 = e3.state, n2 = e3.next_in, A = e3.input, i = n2 + (e3.avail_in - 5), o = e3.next_out, C = e3.output, s = o - (t3 - e3.avail_out), a = o + (e3.avail_out - 257), f = r2.dmax, h = r2.wsize, l = r2.whave, u = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, g = r2.lencode, m = r2.distcode, y = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
      e: do {
        p < 15 && (d += A[n2++] << p, p += 8, d += A[n2++] << p, p += 8), v = g[d & y];
        t: for (; ; ) {
          if (d >>>= w = v >>> 24, p -= w, 0 == (w = v >>> 16 & 255)) C[o++] = 65535 & v;
          else {
            if (!(16 & w)) {
              if (0 == (64 & w)) {
                v = g[(65535 & v) + (d & (1 << w) - 1)];
                continue t;
              }
              if (32 & w) {
                r2.mode = 12;
                break e;
              }
              e3.msg = "invalid literal/length code", r2.mode = 30;
              break e;
            }
            _ = 65535 & v, (w &= 15) && (p < w && (d += A[n2++] << p, p += 8), _ += d & (1 << w) - 1, d >>>= w, p -= w), p < 15 && (d += A[n2++] << p, p += 8, d += A[n2++] << p, p += 8), v = m[d & b];
            r: for (; ; ) {
              if (d >>>= w = v >>> 24, p -= w, !(16 & (w = v >>> 16 & 255))) {
                if (0 == (64 & w)) {
                  v = m[(65535 & v) + (d & (1 << w) - 1)];
                  continue r;
                }
                e3.msg = "invalid distance code", r2.mode = 30;
                break e;
              }
              if (B = 65535 & v, p < (w &= 15) && (d += A[n2++] << p, (p += 8) < w && (d += A[n2++] << p, p += 8)), (B += d & (1 << w) - 1) > f) {
                e3.msg = "invalid distance too far back", r2.mode = 30;
                break e;
              }
              if (d >>>= w, p -= w, B > (w = o - s)) {
                if ((w = B - w) > l && r2.sane) {
                  e3.msg = "invalid distance too far back", r2.mode = 30;
                  break e;
                }
                if (E = 0, S = c, 0 === u) {
                  if (E += h - w, w < _) {
                    _ -= w;
                    do {
                      C[o++] = c[E++];
                    } while (--w);
                    E = o - B, S = C;
                  }
                } else if (u < w) {
                  if (E += h + u - w, (w -= u) < _) {
                    _ -= w;
                    do {
                      C[o++] = c[E++];
                    } while (--w);
                    if (E = 0, u < _) {
                      _ -= w = u;
                      do {
                        C[o++] = c[E++];
                      } while (--w);
                      E = o - B, S = C;
                    }
                  }
                } else if (E += u - w, w < _) {
                  _ -= w;
                  do {
                    C[o++] = c[E++];
                  } while (--w);
                  E = o - B, S = C;
                }
                for (; _ > 2; ) C[o++] = S[E++], C[o++] = S[E++], C[o++] = S[E++], _ -= 3;
                _ && (C[o++] = S[E++], _ > 1 && (C[o++] = S[E++]));
              } else {
                E = o - B;
                do {
                  C[o++] = C[E++], C[o++] = C[E++], C[o++] = C[E++], _ -= 3;
                } while (_ > 2);
                _ && (C[o++] = C[E++], _ > 1 && (C[o++] = C[E++]));
              }
              break;
            }
          }
          break;
        }
      } while (n2 < i && o < a);
      n2 -= _ = p >> 3, d &= (1 << (p -= _ << 3)) - 1, e3.next_in = n2, e3.next_out = o, e3.avail_in = n2 < i ? i - n2 + 5 : 5 - (n2 - i), e3.avail_out = o < a ? a - o + 257 : 257 - (o - a), r2.hold = d, r2.bits = p;
    };
  }, 7948: (e2, t3, r2) => {
    var n2 = r2(4236), i = r2(6069), o = r2(2869), s = r2(4264), a = r2(9241), f = -2, h = 12, l = 30;
    function u(e3) {
      return (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
    }
    function c() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n2.Buf16(320), this.work = new n2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function d(e3) {
      var t4;
      return e3 && e3.state ? (t4 = e3.state, e3.total_in = e3.total_out = t4.total = 0, e3.msg = "", t4.wrap && (e3.adler = 1 & t4.wrap), t4.mode = 1, t4.last = 0, t4.havedict = 0, t4.dmax = 32768, t4.head = null, t4.hold = 0, t4.bits = 0, t4.lencode = t4.lendyn = new n2.Buf32(852), t4.distcode = t4.distdyn = new n2.Buf32(592), t4.sane = 1, t4.back = -1, 0) : f;
    }
    function p(e3) {
      var t4;
      return e3 && e3.state ? ((t4 = e3.state).wsize = 0, t4.whave = 0, t4.wnext = 0, d(e3)) : f;
    }
    function g(e3, t4) {
      var r3, n3;
      return e3 && e3.state ? (n3 = e3.state, t4 < 0 ? (r3 = 0, t4 = -t4) : (r3 = 1 + (t4 >> 4), t4 < 48 && (t4 &= 15)), t4 && (t4 < 8 || t4 > 15) ? f : (null !== n3.window && n3.wbits !== t4 && (n3.window = null), n3.wrap = r3, n3.wbits = t4, p(e3))) : f;
    }
    function m(e3, t4) {
      var r3, n3;
      return e3 ? (n3 = new c(), e3.state = n3, n3.window = null, 0 !== (r3 = g(e3, t4)) && (e3.state = null), r3) : f;
    }
    var y, b, v = true;
    function w(e3) {
      if (v) {
        var t4;
        for (y = new n2.Buf32(512), b = new n2.Buf32(32), t4 = 0; t4 < 144; ) e3.lens[t4++] = 8;
        for (; t4 < 256; ) e3.lens[t4++] = 9;
        for (; t4 < 280; ) e3.lens[t4++] = 7;
        for (; t4 < 288; ) e3.lens[t4++] = 8;
        for (a(1, e3.lens, 0, 288, y, 0, e3.work, { bits: 9 }), t4 = 0; t4 < 32; ) e3.lens[t4++] = 5;
        a(2, e3.lens, 0, 32, b, 0, e3.work, { bits: 5 }), v = false;
      }
      e3.lencode = y, e3.lenbits = 9, e3.distcode = b, e3.distbits = 5;
    }
    function _(e3, t4, r3, i2) {
      var o2, s2 = e3.state;
      return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new n2.Buf8(s2.wsize)), i2 >= s2.wsize ? (n2.arraySet(s2.window, t4, r3 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : ((o2 = s2.wsize - s2.wnext) > i2 && (o2 = i2), n2.arraySet(s2.window, t4, r3 - i2, o2, s2.wnext), (i2 -= o2) ? (n2.arraySet(s2.window, t4, r3 - i2, i2, 0), s2.wnext = i2, s2.whave = s2.wsize) : (s2.wnext += o2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += o2))), 0;
    }
    t3.inflateReset = p, t3.inflateReset2 = g, t3.inflateResetKeep = d, t3.inflateInit = function(e3) {
      return m(e3, 15);
    }, t3.inflateInit2 = m, t3.inflate = function(e3, t4) {
      var r3, c2, d2, p2, g2, m2, y2, b2, v2, B, E, S, A, C, R, k, x, I, M, F, O, T, U, P, N = 0, L = new n2.Buf8(4), z = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!e3 || !e3.state || !e3.output || !e3.input && 0 !== e3.avail_in) return f;
      (r3 = e3.state).mode === h && (r3.mode = 13), g2 = e3.next_out, d2 = e3.output, y2 = e3.avail_out, p2 = e3.next_in, c2 = e3.input, m2 = e3.avail_in, b2 = r3.hold, v2 = r3.bits, B = m2, E = y2, T = 0;
      e: for (; ; ) switch (r3.mode) {
        case 1:
          if (0 === r3.wrap) {
            r3.mode = 13;
            break;
          }
          for (; v2 < 16; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if (2 & r3.wrap && 35615 === b2) {
            r3.check = 0, L[0] = 255 & b2, L[1] = b2 >>> 8 & 255, r3.check = o(r3.check, L, 2, 0), b2 = 0, v2 = 0, r3.mode = 2;
            break;
          }
          if (r3.flags = 0, r3.head && (r3.head.done = false), !(1 & r3.wrap) || (((255 & b2) << 8) + (b2 >> 8)) % 31) {
            e3.msg = "incorrect header check", r3.mode = l;
            break;
          }
          if (8 != (15 & b2)) {
            e3.msg = "unknown compression method", r3.mode = l;
            break;
          }
          if (v2 -= 4, O = 8 + (15 & (b2 >>>= 4)), 0 === r3.wbits) r3.wbits = O;
          else if (O > r3.wbits) {
            e3.msg = "invalid window size", r3.mode = l;
            break;
          }
          r3.dmax = 1 << O, e3.adler = r3.check = 1, r3.mode = 512 & b2 ? 10 : h, b2 = 0, v2 = 0;
          break;
        case 2:
          for (; v2 < 16; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if (r3.flags = b2, 8 != (255 & r3.flags)) {
            e3.msg = "unknown compression method", r3.mode = l;
            break;
          }
          if (57344 & r3.flags) {
            e3.msg = "unknown header flags set", r3.mode = l;
            break;
          }
          r3.head && (r3.head.text = b2 >> 8 & 1), 512 & r3.flags && (L[0] = 255 & b2, L[1] = b2 >>> 8 & 255, r3.check = o(r3.check, L, 2, 0)), b2 = 0, v2 = 0, r3.mode = 3;
        case 3:
          for (; v2 < 32; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          r3.head && (r3.head.time = b2), 512 & r3.flags && (L[0] = 255 & b2, L[1] = b2 >>> 8 & 255, L[2] = b2 >>> 16 & 255, L[3] = b2 >>> 24 & 255, r3.check = o(r3.check, L, 4, 0)), b2 = 0, v2 = 0, r3.mode = 4;
        case 4:
          for (; v2 < 16; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          r3.head && (r3.head.xflags = 255 & b2, r3.head.os = b2 >> 8), 512 & r3.flags && (L[0] = 255 & b2, L[1] = b2 >>> 8 & 255, r3.check = o(r3.check, L, 2, 0)), b2 = 0, v2 = 0, r3.mode = 5;
        case 5:
          if (1024 & r3.flags) {
            for (; v2 < 16; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            r3.length = b2, r3.head && (r3.head.extra_len = b2), 512 & r3.flags && (L[0] = 255 & b2, L[1] = b2 >>> 8 & 255, r3.check = o(r3.check, L, 2, 0)), b2 = 0, v2 = 0;
          } else r3.head && (r3.head.extra = null);
          r3.mode = 6;
        case 6:
          if (1024 & r3.flags && ((S = r3.length) > m2 && (S = m2), S && (r3.head && (O = r3.head.extra_len - r3.length, r3.head.extra || (r3.head.extra = new Array(r3.head.extra_len)), n2.arraySet(r3.head.extra, c2, p2, S, O)), 512 & r3.flags && (r3.check = o(r3.check, c2, S, p2)), m2 -= S, p2 += S, r3.length -= S), r3.length)) break e;
          r3.length = 0, r3.mode = 7;
        case 7:
          if (2048 & r3.flags) {
            if (0 === m2) break e;
            S = 0;
            do {
              O = c2[p2 + S++], r3.head && O && r3.length < 65536 && (r3.head.name += String.fromCharCode(O));
            } while (O && S < m2);
            if (512 & r3.flags && (r3.check = o(r3.check, c2, S, p2)), m2 -= S, p2 += S, O) break e;
          } else r3.head && (r3.head.name = null);
          r3.length = 0, r3.mode = 8;
        case 8:
          if (4096 & r3.flags) {
            if (0 === m2) break e;
            S = 0;
            do {
              O = c2[p2 + S++], r3.head && O && r3.length < 65536 && (r3.head.comment += String.fromCharCode(O));
            } while (O && S < m2);
            if (512 & r3.flags && (r3.check = o(r3.check, c2, S, p2)), m2 -= S, p2 += S, O) break e;
          } else r3.head && (r3.head.comment = null);
          r3.mode = 9;
        case 9:
          if (512 & r3.flags) {
            for (; v2 < 16; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            if (b2 !== (65535 & r3.check)) {
              e3.msg = "header crc mismatch", r3.mode = l;
              break;
            }
            b2 = 0, v2 = 0;
          }
          r3.head && (r3.head.hcrc = r3.flags >> 9 & 1, r3.head.done = true), e3.adler = r3.check = 0, r3.mode = h;
          break;
        case 10:
          for (; v2 < 32; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          e3.adler = r3.check = u(b2), b2 = 0, v2 = 0, r3.mode = 11;
        case 11:
          if (0 === r3.havedict) return e3.next_out = g2, e3.avail_out = y2, e3.next_in = p2, e3.avail_in = m2, r3.hold = b2, r3.bits = v2, 2;
          e3.adler = r3.check = 1, r3.mode = h;
        case h:
          if (5 === t4 || 6 === t4) break e;
        case 13:
          if (r3.last) {
            b2 >>>= 7 & v2, v2 -= 7 & v2, r3.mode = 27;
            break;
          }
          for (; v2 < 3; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          switch (r3.last = 1 & b2, v2 -= 1, 3 & (b2 >>>= 1)) {
            case 0:
              r3.mode = 14;
              break;
            case 1:
              if (w(r3), r3.mode = 20, 6 === t4) {
                b2 >>>= 2, v2 -= 2;
                break e;
              }
              break;
            case 2:
              r3.mode = 17;
              break;
            case 3:
              e3.msg = "invalid block type", r3.mode = l;
          }
          b2 >>>= 2, v2 -= 2;
          break;
        case 14:
          for (b2 >>>= 7 & v2, v2 -= 7 & v2; v2 < 32; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if ((65535 & b2) != (b2 >>> 16 ^ 65535)) {
            e3.msg = "invalid stored block lengths", r3.mode = l;
            break;
          }
          if (r3.length = 65535 & b2, b2 = 0, v2 = 0, r3.mode = 15, 6 === t4) break e;
        case 15:
          r3.mode = 16;
        case 16:
          if (S = r3.length) {
            if (S > m2 && (S = m2), S > y2 && (S = y2), 0 === S) break e;
            n2.arraySet(d2, c2, p2, S, g2), m2 -= S, p2 += S, y2 -= S, g2 += S, r3.length -= S;
            break;
          }
          r3.mode = h;
          break;
        case 17:
          for (; v2 < 14; ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if (r3.nlen = 257 + (31 & b2), b2 >>>= 5, v2 -= 5, r3.ndist = 1 + (31 & b2), b2 >>>= 5, v2 -= 5, r3.ncode = 4 + (15 & b2), b2 >>>= 4, v2 -= 4, r3.nlen > 286 || r3.ndist > 30) {
            e3.msg = "too many length or distance symbols", r3.mode = l;
            break;
          }
          r3.have = 0, r3.mode = 18;
        case 18:
          for (; r3.have < r3.ncode; ) {
            for (; v2 < 3; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            r3.lens[z[r3.have++]] = 7 & b2, b2 >>>= 3, v2 -= 3;
          }
          for (; r3.have < 19; ) r3.lens[z[r3.have++]] = 0;
          if (r3.lencode = r3.lendyn, r3.lenbits = 7, U = { bits: r3.lenbits }, T = a(0, r3.lens, 0, 19, r3.lencode, 0, r3.work, U), r3.lenbits = U.bits, T) {
            e3.msg = "invalid code lengths set", r3.mode = l;
            break;
          }
          r3.have = 0, r3.mode = 19;
        case 19:
          for (; r3.have < r3.nlen + r3.ndist; ) {
            for (; k = (N = r3.lencode[b2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, x = 65535 & N, !((R = N >>> 24) <= v2); ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            if (x < 16) b2 >>>= R, v2 -= R, r3.lens[r3.have++] = x;
            else {
              if (16 === x) {
                for (P = R + 2; v2 < P; ) {
                  if (0 === m2) break e;
                  m2--, b2 += c2[p2++] << v2, v2 += 8;
                }
                if (b2 >>>= R, v2 -= R, 0 === r3.have) {
                  e3.msg = "invalid bit length repeat", r3.mode = l;
                  break;
                }
                O = r3.lens[r3.have - 1], S = 3 + (3 & b2), b2 >>>= 2, v2 -= 2;
              } else if (17 === x) {
                for (P = R + 3; v2 < P; ) {
                  if (0 === m2) break e;
                  m2--, b2 += c2[p2++] << v2, v2 += 8;
                }
                v2 -= R, O = 0, S = 3 + (7 & (b2 >>>= R)), b2 >>>= 3, v2 -= 3;
              } else {
                for (P = R + 7; v2 < P; ) {
                  if (0 === m2) break e;
                  m2--, b2 += c2[p2++] << v2, v2 += 8;
                }
                v2 -= R, O = 0, S = 11 + (127 & (b2 >>>= R)), b2 >>>= 7, v2 -= 7;
              }
              if (r3.have + S > r3.nlen + r3.ndist) {
                e3.msg = "invalid bit length repeat", r3.mode = l;
                break;
              }
              for (; S--; ) r3.lens[r3.have++] = O;
            }
          }
          if (r3.mode === l) break;
          if (0 === r3.lens[256]) {
            e3.msg = "invalid code -- missing end-of-block", r3.mode = l;
            break;
          }
          if (r3.lenbits = 9, U = { bits: r3.lenbits }, T = a(1, r3.lens, 0, r3.nlen, r3.lencode, 0, r3.work, U), r3.lenbits = U.bits, T) {
            e3.msg = "invalid literal/lengths set", r3.mode = l;
            break;
          }
          if (r3.distbits = 6, r3.distcode = r3.distdyn, U = { bits: r3.distbits }, T = a(2, r3.lens, r3.nlen, r3.ndist, r3.distcode, 0, r3.work, U), r3.distbits = U.bits, T) {
            e3.msg = "invalid distances set", r3.mode = l;
            break;
          }
          if (r3.mode = 20, 6 === t4) break e;
        case 20:
          r3.mode = 21;
        case 21:
          if (m2 >= 6 && y2 >= 258) {
            e3.next_out = g2, e3.avail_out = y2, e3.next_in = p2, e3.avail_in = m2, r3.hold = b2, r3.bits = v2, s(e3, E), g2 = e3.next_out, d2 = e3.output, y2 = e3.avail_out, p2 = e3.next_in, c2 = e3.input, m2 = e3.avail_in, b2 = r3.hold, v2 = r3.bits, r3.mode === h && (r3.back = -1);
            break;
          }
          for (r3.back = 0; k = (N = r3.lencode[b2 & (1 << r3.lenbits) - 1]) >>> 16 & 255, x = 65535 & N, !((R = N >>> 24) <= v2); ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if (k && 0 == (240 & k)) {
            for (I = R, M = k, F = x; k = (N = r3.lencode[F + ((b2 & (1 << I + M) - 1) >> I)]) >>> 16 & 255, x = 65535 & N, !(I + (R = N >>> 24) <= v2); ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            b2 >>>= I, v2 -= I, r3.back += I;
          }
          if (b2 >>>= R, v2 -= R, r3.back += R, r3.length = x, 0 === k) {
            r3.mode = 26;
            break;
          }
          if (32 & k) {
            r3.back = -1, r3.mode = h;
            break;
          }
          if (64 & k) {
            e3.msg = "invalid literal/length code", r3.mode = l;
            break;
          }
          r3.extra = 15 & k, r3.mode = 22;
        case 22:
          if (r3.extra) {
            for (P = r3.extra; v2 < P; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            r3.length += b2 & (1 << r3.extra) - 1, b2 >>>= r3.extra, v2 -= r3.extra, r3.back += r3.extra;
          }
          r3.was = r3.length, r3.mode = 23;
        case 23:
          for (; k = (N = r3.distcode[b2 & (1 << r3.distbits) - 1]) >>> 16 & 255, x = 65535 & N, !((R = N >>> 24) <= v2); ) {
            if (0 === m2) break e;
            m2--, b2 += c2[p2++] << v2, v2 += 8;
          }
          if (0 == (240 & k)) {
            for (I = R, M = k, F = x; k = (N = r3.distcode[F + ((b2 & (1 << I + M) - 1) >> I)]) >>> 16 & 255, x = 65535 & N, !(I + (R = N >>> 24) <= v2); ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            b2 >>>= I, v2 -= I, r3.back += I;
          }
          if (b2 >>>= R, v2 -= R, r3.back += R, 64 & k) {
            e3.msg = "invalid distance code", r3.mode = l;
            break;
          }
          r3.offset = x, r3.extra = 15 & k, r3.mode = 24;
        case 24:
          if (r3.extra) {
            for (P = r3.extra; v2 < P; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            r3.offset += b2 & (1 << r3.extra) - 1, b2 >>>= r3.extra, v2 -= r3.extra, r3.back += r3.extra;
          }
          if (r3.offset > r3.dmax) {
            e3.msg = "invalid distance too far back", r3.mode = l;
            break;
          }
          r3.mode = 25;
        case 25:
          if (0 === y2) break e;
          if (S = E - y2, r3.offset > S) {
            if ((S = r3.offset - S) > r3.whave && r3.sane) {
              e3.msg = "invalid distance too far back", r3.mode = l;
              break;
            }
            S > r3.wnext ? (S -= r3.wnext, A = r3.wsize - S) : A = r3.wnext - S, S > r3.length && (S = r3.length), C = r3.window;
          } else C = d2, A = g2 - r3.offset, S = r3.length;
          S > y2 && (S = y2), y2 -= S, r3.length -= S;
          do {
            d2[g2++] = C[A++];
          } while (--S);
          0 === r3.length && (r3.mode = 21);
          break;
        case 26:
          if (0 === y2) break e;
          d2[g2++] = r3.length, y2--, r3.mode = 21;
          break;
        case 27:
          if (r3.wrap) {
            for (; v2 < 32; ) {
              if (0 === m2) break e;
              m2--, b2 |= c2[p2++] << v2, v2 += 8;
            }
            if (E -= y2, e3.total_out += E, r3.total += E, E && (e3.adler = r3.check = r3.flags ? o(r3.check, d2, E, g2 - E) : i(r3.check, d2, E, g2 - E)), E = y2, (r3.flags ? b2 : u(b2)) !== r3.check) {
              e3.msg = "incorrect data check", r3.mode = l;
              break;
            }
            b2 = 0, v2 = 0;
          }
          r3.mode = 28;
        case 28:
          if (r3.wrap && r3.flags) {
            for (; v2 < 32; ) {
              if (0 === m2) break e;
              m2--, b2 += c2[p2++] << v2, v2 += 8;
            }
            if (b2 !== (4294967295 & r3.total)) {
              e3.msg = "incorrect length check", r3.mode = l;
              break;
            }
            b2 = 0, v2 = 0;
          }
          r3.mode = 29;
        case 29:
          T = 1;
          break e;
        case l:
          T = -3;
          break e;
        case 31:
          return -4;
        default:
          return f;
      }
      return e3.next_out = g2, e3.avail_out = y2, e3.next_in = p2, e3.avail_in = m2, r3.hold = b2, r3.bits = v2, (r3.wsize || E !== e3.avail_out && r3.mode < l && (r3.mode < 27 || 4 !== t4)) && _(e3, e3.output, e3.next_out, E - e3.avail_out) ? (r3.mode = 31, -4) : (B -= e3.avail_in, E -= e3.avail_out, e3.total_in += B, e3.total_out += E, r3.total += E, r3.wrap && E && (e3.adler = r3.check = r3.flags ? o(r3.check, d2, E, e3.next_out - E) : i(r3.check, d2, E, e3.next_out - E)), e3.data_type = r3.bits + (r3.last ? 64 : 0) + (r3.mode === h ? 128 : 0) + (20 === r3.mode || 15 === r3.mode ? 256 : 0), (0 === B && 0 === E || 4 === t4) && 0 === T && (T = -5), T);
    }, t3.inflateEnd = function(e3) {
      if (!e3 || !e3.state) return f;
      var t4 = e3.state;
      return t4.window && (t4.window = null), e3.state = null, 0;
    }, t3.inflateGetHeader = function(e3, t4) {
      var r3;
      return e3 && e3.state ? 0 == (2 & (r3 = e3.state).wrap) ? f : (r3.head = t4, t4.done = false, 0) : f;
    }, t3.inflateSetDictionary = function(e3, t4) {
      var r3, n3 = t4.length;
      return e3 && e3.state ? 0 !== (r3 = e3.state).wrap && 11 !== r3.mode ? f : 11 === r3.mode && i(1, t4, n3, 0) !== r3.check ? -3 : _(e3, t4, n3, n3) ? (r3.mode = 31, -4) : (r3.havedict = 1, 0) : f;
    }, t3.inflateInfo = "pako inflate (from Nodeca project)";
  }, 9241: (e2, t3, r2) => {
    var n2 = r2(4236), i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], a = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    e2.exports = function(e3, t4, r3, f, h, l, u, c) {
      var d, p, g, m, y, b, v, w, _, B = c.bits, E = 0, S = 0, A = 0, C = 0, R = 0, k = 0, x = 0, I = 0, M = 0, F = 0, O = null, T = 0, U = new n2.Buf16(16), P = new n2.Buf16(16), N = null, L = 0;
      for (E = 0; E <= 15; E++) U[E] = 0;
      for (S = 0; S < f; S++) U[t4[r3 + S]]++;
      for (R = B, C = 15; C >= 1 && 0 === U[C]; C--) ;
      if (R > C && (R = C), 0 === C) return h[l++] = 20971520, h[l++] = 20971520, c.bits = 1, 0;
      for (A = 1; A < C && 0 === U[A]; A++) ;
      for (R < A && (R = A), I = 1, E = 1; E <= 15; E++) if (I <<= 1, (I -= U[E]) < 0) return -1;
      if (I > 0 && (0 === e3 || 1 !== C)) return -1;
      for (P[1] = 0, E = 1; E < 15; E++) P[E + 1] = P[E] + U[E];
      for (S = 0; S < f; S++) 0 !== t4[r3 + S] && (u[P[t4[r3 + S]]++] = S);
      if (0 === e3 ? (O = N = u, b = 19) : 1 === e3 ? (O = i, T -= 257, N = o, L -= 257, b = 256) : (O = s, N = a, b = -1), F = 0, S = 0, E = A, y = l, k = R, x = 0, g = -1, m = (M = 1 << R) - 1, 1 === e3 && M > 852 || 2 === e3 && M > 592) return 1;
      for (; ; ) {
        v = E - x, u[S] < b ? (w = 0, _ = u[S]) : u[S] > b ? (w = N[L + u[S]], _ = O[T + u[S]]) : (w = 96, _ = 0), d = 1 << E - x, A = p = 1 << k;
        do {
          h[y + (F >> x) + (p -= d)] = v << 24 | w << 16 | _ | 0;
        } while (0 !== p);
        for (d = 1 << E - 1; F & d; ) d >>= 1;
        if (0 !== d ? (F &= d - 1, F += d) : F = 0, S++, 0 == --U[E]) {
          if (E === C) break;
          E = t4[r3 + u[S]];
        }
        if (E > R && (F & m) !== g) {
          for (0 === x && (x = R), y += A, I = 1 << (k = E - x); k + x < C && !((I -= U[k + x]) <= 0); ) k++, I <<= 1;
          if (M += 1 << k, 1 === e3 && M > 852 || 2 === e3 && M > 592) return 1;
          h[g = F & m] = R << 24 | k << 16 | y - l | 0;
        }
      }
      return 0 !== F && (h[y + F] = E - x << 24 | 64 << 16 | 0), c.bits = R, 0;
    };
  }, 8898: (e2) => {
    e2.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  }, 342: (e2, t3, r2) => {
    var n2 = r2(4236);
    function i(e3) {
      for (var t4 = e3.length; --t4 >= 0; ) e3[t4] = 0;
    }
    var o = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], s = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], f = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], h = new Array(576);
    i(h);
    var l = new Array(60);
    i(l);
    var u = new Array(512);
    i(u);
    var c = new Array(256);
    i(c);
    var d = new Array(29);
    i(d);
    var p, g, m, y = new Array(30);
    function b(e3, t4, r3, n3, i2) {
      this.static_tree = e3, this.extra_bits = t4, this.extra_base = r3, this.elems = n3, this.max_length = i2, this.has_stree = e3 && e3.length;
    }
    function v(e3, t4) {
      this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t4;
    }
    function w(e3) {
      return e3 < 256 ? u[e3] : u[256 + (e3 >>> 7)];
    }
    function _(e3, t4) {
      e3.pending_buf[e3.pending++] = 255 & t4, e3.pending_buf[e3.pending++] = t4 >>> 8 & 255;
    }
    function B(e3, t4, r3) {
      e3.bi_valid > 16 - r3 ? (e3.bi_buf |= t4 << e3.bi_valid & 65535, _(e3, e3.bi_buf), e3.bi_buf = t4 >> 16 - e3.bi_valid, e3.bi_valid += r3 - 16) : (e3.bi_buf |= t4 << e3.bi_valid & 65535, e3.bi_valid += r3);
    }
    function E(e3, t4, r3) {
      B(e3, r3[2 * t4], r3[2 * t4 + 1]);
    }
    function S(e3, t4) {
      var r3 = 0;
      do {
        r3 |= 1 & e3, e3 >>>= 1, r3 <<= 1;
      } while (--t4 > 0);
      return r3 >>> 1;
    }
    function A(e3, t4, r3) {
      var n3, i2, o2 = new Array(16), s2 = 0;
      for (n3 = 1; n3 <= 15; n3++) o2[n3] = s2 = s2 + r3[n3 - 1] << 1;
      for (i2 = 0; i2 <= t4; i2++) {
        var a2 = e3[2 * i2 + 1];
        0 !== a2 && (e3[2 * i2] = S(o2[a2]++, a2));
      }
    }
    function C(e3) {
      var t4;
      for (t4 = 0; t4 < 286; t4++) e3.dyn_ltree[2 * t4] = 0;
      for (t4 = 0; t4 < 30; t4++) e3.dyn_dtree[2 * t4] = 0;
      for (t4 = 0; t4 < 19; t4++) e3.bl_tree[2 * t4] = 0;
      e3.dyn_ltree[512] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
    }
    function R(e3) {
      e3.bi_valid > 8 ? _(e3, e3.bi_buf) : e3.bi_valid > 0 && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
    }
    function k(e3, t4, r3, n3) {
      var i2 = 2 * t4, o2 = 2 * r3;
      return e3[i2] < e3[o2] || e3[i2] === e3[o2] && n3[t4] <= n3[r3];
    }
    function x(e3, t4, r3) {
      for (var n3 = e3.heap[r3], i2 = r3 << 1; i2 <= e3.heap_len && (i2 < e3.heap_len && k(t4, e3.heap[i2 + 1], e3.heap[i2], e3.depth) && i2++, !k(t4, n3, e3.heap[i2], e3.depth)); ) e3.heap[r3] = e3.heap[i2], r3 = i2, i2 <<= 1;
      e3.heap[r3] = n3;
    }
    function I(e3, t4, r3) {
      var n3, i2, a2, f2, h2 = 0;
      if (0 !== e3.last_lit) do {
        n3 = e3.pending_buf[e3.d_buf + 2 * h2] << 8 | e3.pending_buf[e3.d_buf + 2 * h2 + 1], i2 = e3.pending_buf[e3.l_buf + h2], h2++, 0 === n3 ? E(e3, i2, t4) : (E(e3, (a2 = c[i2]) + 256 + 1, t4), 0 !== (f2 = o[a2]) && B(e3, i2 -= d[a2], f2), E(e3, a2 = w(--n3), r3), 0 !== (f2 = s[a2]) && B(e3, n3 -= y[a2], f2));
      } while (h2 < e3.last_lit);
      E(e3, 256, t4);
    }
    function M(e3, t4) {
      var r3, n3, i2, o2 = t4.dyn_tree, s2 = t4.stat_desc.static_tree, a2 = t4.stat_desc.has_stree, f2 = t4.stat_desc.elems, h2 = -1;
      for (e3.heap_len = 0, e3.heap_max = 573, r3 = 0; r3 < f2; r3++) 0 !== o2[2 * r3] ? (e3.heap[++e3.heap_len] = h2 = r3, e3.depth[r3] = 0) : o2[2 * r3 + 1] = 0;
      for (; e3.heap_len < 2; ) o2[2 * (i2 = e3.heap[++e3.heap_len] = h2 < 2 ? ++h2 : 0)] = 1, e3.depth[i2] = 0, e3.opt_len--, a2 && (e3.static_len -= s2[2 * i2 + 1]);
      for (t4.max_code = h2, r3 = e3.heap_len >> 1; r3 >= 1; r3--) x(e3, o2, r3);
      i2 = f2;
      do {
        r3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], x(e3, o2, 1), n3 = e3.heap[1], e3.heap[--e3.heap_max] = r3, e3.heap[--e3.heap_max] = n3, o2[2 * i2] = o2[2 * r3] + o2[2 * n3], e3.depth[i2] = (e3.depth[r3] >= e3.depth[n3] ? e3.depth[r3] : e3.depth[n3]) + 1, o2[2 * r3 + 1] = o2[2 * n3 + 1] = i2, e3.heap[1] = i2++, x(e3, o2, 1);
      } while (e3.heap_len >= 2);
      e3.heap[--e3.heap_max] = e3.heap[1], (function(e4, t5) {
        var r4, n4, i3, o3, s3, a3, f3 = t5.dyn_tree, h3 = t5.max_code, l2 = t5.stat_desc.static_tree, u2 = t5.stat_desc.has_stree, c2 = t5.stat_desc.extra_bits, d2 = t5.stat_desc.extra_base, p2 = t5.stat_desc.max_length, g2 = 0;
        for (o3 = 0; o3 <= 15; o3++) e4.bl_count[o3] = 0;
        for (f3[2 * e4.heap[e4.heap_max] + 1] = 0, r4 = e4.heap_max + 1; r4 < 573; r4++) (o3 = f3[2 * f3[2 * (n4 = e4.heap[r4]) + 1] + 1] + 1) > p2 && (o3 = p2, g2++), f3[2 * n4 + 1] = o3, n4 > h3 || (e4.bl_count[o3]++, s3 = 0, n4 >= d2 && (s3 = c2[n4 - d2]), a3 = f3[2 * n4], e4.opt_len += a3 * (o3 + s3), u2 && (e4.static_len += a3 * (l2[2 * n4 + 1] + s3)));
        if (0 !== g2) {
          do {
            for (o3 = p2 - 1; 0 === e4.bl_count[o3]; ) o3--;
            e4.bl_count[o3]--, e4.bl_count[o3 + 1] += 2, e4.bl_count[p2]--, g2 -= 2;
          } while (g2 > 0);
          for (o3 = p2; 0 !== o3; o3--) for (n4 = e4.bl_count[o3]; 0 !== n4; ) (i3 = e4.heap[--r4]) > h3 || (f3[2 * i3 + 1] !== o3 && (e4.opt_len += (o3 - f3[2 * i3 + 1]) * f3[2 * i3], f3[2 * i3 + 1] = o3), n4--);
        }
      })(e3, t4), A(o2, h2, e3.bl_count);
    }
    function F(e3, t4, r3) {
      var n3, i2, o2 = -1, s2 = t4[1], a2 = 0, f2 = 7, h2 = 4;
      for (0 === s2 && (f2 = 138, h2 = 3), t4[2 * (r3 + 1) + 1] = 65535, n3 = 0; n3 <= r3; n3++) i2 = s2, s2 = t4[2 * (n3 + 1) + 1], ++a2 < f2 && i2 === s2 || (a2 < h2 ? e3.bl_tree[2 * i2] += a2 : 0 !== i2 ? (i2 !== o2 && e3.bl_tree[2 * i2]++, e3.bl_tree[32]++) : a2 <= 10 ? e3.bl_tree[34]++ : e3.bl_tree[36]++, a2 = 0, o2 = i2, 0 === s2 ? (f2 = 138, h2 = 3) : i2 === s2 ? (f2 = 6, h2 = 3) : (f2 = 7, h2 = 4));
    }
    function O(e3, t4, r3) {
      var n3, i2, o2 = -1, s2 = t4[1], a2 = 0, f2 = 7, h2 = 4;
      for (0 === s2 && (f2 = 138, h2 = 3), n3 = 0; n3 <= r3; n3++) if (i2 = s2, s2 = t4[2 * (n3 + 1) + 1], !(++a2 < f2 && i2 === s2)) {
        if (a2 < h2) do {
          E(e3, i2, e3.bl_tree);
        } while (0 != --a2);
        else 0 !== i2 ? (i2 !== o2 && (E(e3, i2, e3.bl_tree), a2--), E(e3, 16, e3.bl_tree), B(e3, a2 - 3, 2)) : a2 <= 10 ? (E(e3, 17, e3.bl_tree), B(e3, a2 - 3, 3)) : (E(e3, 18, e3.bl_tree), B(e3, a2 - 11, 7));
        a2 = 0, o2 = i2, 0 === s2 ? (f2 = 138, h2 = 3) : i2 === s2 ? (f2 = 6, h2 = 3) : (f2 = 7, h2 = 4);
      }
    }
    i(y);
    var T = false;
    function U(e3, t4, r3, i2) {
      B(e3, 0 + (i2 ? 1 : 0), 3), (function(e4, t5, r4, i3) {
        R(e4), _(e4, r4), _(e4, ~r4), n2.arraySet(e4.pending_buf, e4.window, t5, r4, e4.pending), e4.pending += r4;
      })(e3, t4, r3);
    }
    t3._tr_init = function(e3) {
      T || ((function() {
        var e4, t4, r3, n3, i2, f2 = new Array(16);
        for (r3 = 0, n3 = 0; n3 < 28; n3++) for (d[n3] = r3, e4 = 0; e4 < 1 << o[n3]; e4++) c[r3++] = n3;
        for (c[r3 - 1] = n3, i2 = 0, n3 = 0; n3 < 16; n3++) for (y[n3] = i2, e4 = 0; e4 < 1 << s[n3]; e4++) u[i2++] = n3;
        for (i2 >>= 7; n3 < 30; n3++) for (y[n3] = i2 << 7, e4 = 0; e4 < 1 << s[n3] - 7; e4++) u[256 + i2++] = n3;
        for (t4 = 0; t4 <= 15; t4++) f2[t4] = 0;
        for (e4 = 0; e4 <= 143; ) h[2 * e4 + 1] = 8, e4++, f2[8]++;
        for (; e4 <= 255; ) h[2 * e4 + 1] = 9, e4++, f2[9]++;
        for (; e4 <= 279; ) h[2 * e4 + 1] = 7, e4++, f2[7]++;
        for (; e4 <= 287; ) h[2 * e4 + 1] = 8, e4++, f2[8]++;
        for (A(h, 287, f2), e4 = 0; e4 < 30; e4++) l[2 * e4 + 1] = 5, l[2 * e4] = S(e4, 5);
        p = new b(h, o, 257, 286, 15), g = new b(l, s, 0, 30, 15), m = new b(new Array(0), a, 0, 19, 7);
      })(), T = true), e3.l_desc = new v(e3.dyn_ltree, p), e3.d_desc = new v(e3.dyn_dtree, g), e3.bl_desc = new v(e3.bl_tree, m), e3.bi_buf = 0, e3.bi_valid = 0, C(e3);
    }, t3._tr_stored_block = U, t3._tr_flush_block = function(e3, t4, r3, n3) {
      var i2, o2, s2 = 0;
      e3.level > 0 ? (2 === e3.strm.data_type && (e3.strm.data_type = (function(e4) {
        var t5, r4 = 4093624447;
        for (t5 = 0; t5 <= 31; t5++, r4 >>>= 1) if (1 & r4 && 0 !== e4.dyn_ltree[2 * t5]) return 0;
        if (0 !== e4.dyn_ltree[18] || 0 !== e4.dyn_ltree[20] || 0 !== e4.dyn_ltree[26]) return 1;
        for (t5 = 32; t5 < 256; t5++) if (0 !== e4.dyn_ltree[2 * t5]) return 1;
        return 0;
      })(e3)), M(e3, e3.l_desc), M(e3, e3.d_desc), s2 = (function(e4) {
        var t5;
        for (F(e4, e4.dyn_ltree, e4.l_desc.max_code), F(e4, e4.dyn_dtree, e4.d_desc.max_code), M(e4, e4.bl_desc), t5 = 18; t5 >= 3 && 0 === e4.bl_tree[2 * f[t5] + 1]; t5--) ;
        return e4.opt_len += 3 * (t5 + 1) + 5 + 5 + 4, t5;
      })(e3), i2 = e3.opt_len + 3 + 7 >>> 3, (o2 = e3.static_len + 3 + 7 >>> 3) <= i2 && (i2 = o2)) : i2 = o2 = r3 + 5, r3 + 4 <= i2 && -1 !== t4 ? U(e3, t4, r3, n3) : 4 === e3.strategy || o2 === i2 ? (B(e3, 2 + (n3 ? 1 : 0), 3), I(e3, h, l)) : (B(e3, 4 + (n3 ? 1 : 0), 3), (function(e4, t5, r4, n4) {
        var i3;
        for (B(e4, t5 - 257, 5), B(e4, r4 - 1, 5), B(e4, n4 - 4, 4), i3 = 0; i3 < n4; i3++) B(e4, e4.bl_tree[2 * f[i3] + 1], 3);
        O(e4, e4.dyn_ltree, t5 - 1), O(e4, e4.dyn_dtree, r4 - 1);
      })(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, s2 + 1), I(e3, e3.dyn_ltree, e3.dyn_dtree)), C(e3), n3 && R(e3);
    }, t3._tr_tally = function(e3, t4, r3) {
      return e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t4 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t4, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & r3, e3.last_lit++, 0 === t4 ? e3.dyn_ltree[2 * r3]++ : (e3.matches++, t4--, e3.dyn_ltree[2 * (c[r3] + 256 + 1)]++, e3.dyn_dtree[2 * w(t4)]++), e3.last_lit === e3.lit_bufsize - 1;
    }, t3._tr_align = function(e3) {
      B(e3, 2, 3), E(e3, 256, h), (function(e4) {
        16 === e4.bi_valid ? (_(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : e4.bi_valid >= 8 && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
      })(e3);
    };
  }, 2292: (e2) => {
    e2.exports = function() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
  }, 2587: (e2) => {
    function t3(e3, t4) {
      return Object.prototype.hasOwnProperty.call(e3, t4);
    }
    e2.exports = function(e3, r2, n2, i) {
      r2 = r2 || "&", n2 = n2 || "=";
      var o = {};
      if ("string" != typeof e3 || 0 === e3.length) return o;
      var s = /\+/g;
      e3 = e3.split(r2);
      var a = 1e3;
      i && "number" == typeof i.maxKeys && (a = i.maxKeys);
      var f = e3.length;
      a > 0 && f > a && (f = a);
      for (var h = 0; h < f; ++h) {
        var l, u, c, d, p = e3[h].replace(s, "%20"), g = p.indexOf(n2);
        g >= 0 ? (l = p.substr(0, g), u = p.substr(g + 1)) : (l = p, u = ""), c = decodeURIComponent(l), d = decodeURIComponent(u), t3(o, c) ? Array.isArray(o[c]) ? o[c].push(d) : o[c] = [o[c], d] : o[c] = d;
      }
      return o;
    };
  }, 2361: (e2) => {
    var t3 = function(e3) {
      switch (typeof e3) {
        case "string":
          return e3;
        case "boolean":
          return e3 ? "true" : "false";
        case "number":
          return isFinite(e3) ? e3 : "";
        default:
          return "";
      }
    };
    e2.exports = function(e3, r2, n2, i) {
      return r2 = r2 || "&", n2 = n2 || "=", null === e3 && (e3 = void 0), "object" == typeof e3 ? Object.keys(e3).map((function(i2) {
        var o = encodeURIComponent(t3(i2)) + n2;
        return Array.isArray(e3[i2]) ? e3[i2].map((function(e4) {
          return o + encodeURIComponent(t3(e4));
        })).join(r2) : o + encodeURIComponent(t3(e3[i2]));
      })).join(r2) : i ? encodeURIComponent(t3(i)) + n2 + encodeURIComponent(t3(e3)) : "";
    };
  }, 7673: (e2, t3, r2) => {
    t3.decode = t3.parse = r2(2587), t3.encode = t3.stringify = r2(2361);
  }, 1269: (e2) => {
    class t3 {
      constructor(e3 = {}) {
        if (!(e3.maxSize && e3.maxSize > 0)) throw new TypeError("`maxSize` must be a number greater than 0");
        this.maxSize = e3.maxSize, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(), this._size = 0;
      }
      _set(e3, t4) {
        this.cache.set(e3, t4), this._size++, this._size >= this.maxSize && (this._size = 0, this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map());
      }
      get(e3) {
        if (this.cache.has(e3)) return this.cache.get(e3);
        if (this.oldCache.has(e3)) {
          const t4 = this.oldCache.get(e3);
          return this.oldCache.delete(e3), this._set(e3, t4), t4;
        }
      }
      set(e3, t4) {
        return this.cache.has(e3) ? this.cache.set(e3, t4) : this._set(e3, t4), this;
      }
      has(e3) {
        return this.cache.has(e3) || this.oldCache.has(e3);
      }
      peek(e3) {
        return this.cache.has(e3) ? this.cache.get(e3) : this.oldCache.has(e3) ? this.oldCache.get(e3) : void 0;
      }
      delete(e3) {
        const t4 = this.cache.delete(e3);
        return t4 && this._size--, this.oldCache.delete(e3) || t4;
      }
      clear() {
        this.cache.clear(), this.oldCache.clear(), this._size = 0;
      }
      *keys() {
        for (const [e3] of this) yield e3;
      }
      *values() {
        for (const [, e3] of this) yield e3;
      }
      *[Symbol.iterator]() {
        for (const e3 of this.cache) yield e3;
        for (const e3 of this.oldCache) {
          const [t4] = e3;
          this.cache.has(t4) || (yield e3);
        }
      }
      get size() {
        let e3 = 0;
        for (const t4 of this.oldCache.keys()) this.cache.has(t4) || e3++;
        return this._size + e3;
      }
    }
    e2.exports = t3;
  }, 2511: function(e2, t3, r2) {
    var n2;
    e2 = r2.nmd(e2), (function(i) {
      t3 && t3.nodeType, e2 && e2.nodeType;
      var o = "object" == typeof r2.g && r2.g;
      o.global !== o && o.window !== o && o.self;
      var s, a = 2147483647, f = 36, h = /^xn--/, l = /[^\x20-\x7E]/, u = /[\x2E\u3002\uFF0E\uFF61]/g, c = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, d = Math.floor, p = String.fromCharCode;
      function g(e3) {
        throw RangeError(c[e3]);
      }
      function m(e3, t4) {
        for (var r3 = e3.length, n3 = []; r3--; ) n3[r3] = t4(e3[r3]);
        return n3;
      }
      function y(e3, t4) {
        var r3 = e3.split("@"), n3 = "";
        return r3.length > 1 && (n3 = r3[0] + "@", e3 = r3[1]), n3 + m((e3 = e3.replace(u, ".")).split("."), t4).join(".");
      }
      function b(e3) {
        for (var t4, r3, n3 = [], i2 = 0, o2 = e3.length; i2 < o2; ) (t4 = e3.charCodeAt(i2++)) >= 55296 && t4 <= 56319 && i2 < o2 ? 56320 == (64512 & (r3 = e3.charCodeAt(i2++))) ? n3.push(((1023 & t4) << 10) + (1023 & r3) + 65536) : (n3.push(t4), i2--) : n3.push(t4);
        return n3;
      }
      function v(e3) {
        return m(e3, (function(e4) {
          var t4 = "";
          return e4 > 65535 && (t4 += p((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t4 + p(e4);
        })).join("");
      }
      function w(e3, t4) {
        return e3 + 22 + 75 * (e3 < 26) - ((0 != t4) << 5);
      }
      function _(e3, t4, r3) {
        var n3 = 0;
        for (e3 = r3 ? d(e3 / 700) : e3 >> 1, e3 += d(e3 / t4); e3 > 455; n3 += f) e3 = d(e3 / 35);
        return d(n3 + 36 * e3 / (e3 + 38));
      }
      function B(e3) {
        var t4, r3, n3, i2, o2, s2, h2, l2, u2, c2, p2, m2 = [], y2 = e3.length, b2 = 0, w2 = 128, B2 = 72;
        for ((r3 = e3.lastIndexOf("-")) < 0 && (r3 = 0), n3 = 0; n3 < r3; ++n3) e3.charCodeAt(n3) >= 128 && g("not-basic"), m2.push(e3.charCodeAt(n3));
        for (i2 = r3 > 0 ? r3 + 1 : 0; i2 < y2; ) {
          for (o2 = b2, s2 = 1, h2 = f; i2 >= y2 && g("invalid-input"), ((l2 = (p2 = e3.charCodeAt(i2++)) - 48 < 10 ? p2 - 22 : p2 - 65 < 26 ? p2 - 65 : p2 - 97 < 26 ? p2 - 97 : f) >= f || l2 > d((a - b2) / s2)) && g("overflow"), b2 += l2 * s2, !(l2 < (u2 = h2 <= B2 ? 1 : h2 >= B2 + 26 ? 26 : h2 - B2)); h2 += f) s2 > d(a / (c2 = f - u2)) && g("overflow"), s2 *= c2;
          B2 = _(b2 - o2, t4 = m2.length + 1, 0 == o2), d(b2 / t4) > a - w2 && g("overflow"), w2 += d(b2 / t4), b2 %= t4, m2.splice(b2++, 0, w2);
        }
        return v(m2);
      }
      function E(e3) {
        var t4, r3, n3, i2, o2, s2, h2, l2, u2, c2, m2, y2, v2, B2, E2, S = [];
        for (y2 = (e3 = b(e3)).length, t4 = 128, r3 = 0, o2 = 72, s2 = 0; s2 < y2; ++s2) (m2 = e3[s2]) < 128 && S.push(p(m2));
        for (n3 = i2 = S.length, i2 && S.push("-"); n3 < y2; ) {
          for (h2 = a, s2 = 0; s2 < y2; ++s2) (m2 = e3[s2]) >= t4 && m2 < h2 && (h2 = m2);
          for (h2 - t4 > d((a - r3) / (v2 = n3 + 1)) && g("overflow"), r3 += (h2 - t4) * v2, t4 = h2, s2 = 0; s2 < y2; ++s2) if ((m2 = e3[s2]) < t4 && ++r3 > a && g("overflow"), m2 == t4) {
            for (l2 = r3, u2 = f; !(l2 < (c2 = u2 <= o2 ? 1 : u2 >= o2 + 26 ? 26 : u2 - o2)); u2 += f) E2 = l2 - c2, B2 = f - c2, S.push(p(w(c2 + E2 % B2, 0))), l2 = d(E2 / B2);
            S.push(p(w(l2, 0))), o2 = _(r3, v2, n3 == i2), r3 = 0, ++n3;
          }
          ++r3, ++t4;
        }
        return S.join("");
      }
      s = { version: "1.3.2", ucs2: { decode: b, encode: v }, decode: B, encode: E, toASCII: function(e3) {
        return y(e3, (function(e4) {
          return l.test(e4) ? "xn--" + E(e4) : e4;
        }));
      }, toUnicode: function(e3) {
        return y(e3, (function(e4) {
          return h.test(e4) ? B(e4.slice(4).toLowerCase()) : e4;
        }));
      } }, void 0 === (n2 = (function() {
        return s;
      }).call(t3, r2, t3, e2)) || (e2.exports = n2);
    })();
  }, 8575: (e2, t3, r2) => {
    var n2 = r2(2511), i = r2(2502);
    function o() {
      this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
    }
    t3.parse = v, t3.resolve = function(e3, t4) {
      return v(e3, false, true).resolve(t4);
    }, t3.resolveObject = function(e3, t4) {
      return e3 ? v(e3, false, true).resolveObject(t4) : t4;
    }, t3.format = function(e3) {
      return i.isString(e3) && (e3 = v(e3)), e3 instanceof o ? e3.format() : o.prototype.format.call(e3);
    }, t3.Url = o;
    var s = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, f = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, h = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), l = ["'"].concat(h), u = ["%", "/", "?", ";", "#"].concat(l), c = ["/", "?", "#"], d = /^[+a-z0-9A-Z_-]{0,63}$/, p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, g = { javascript: true, "javascript:": true }, m = { javascript: true, "javascript:": true }, y = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, b = r2(7673);
    function v(e3, t4, r3) {
      if (e3 && i.isObject(e3) && e3 instanceof o) return e3;
      var n3 = new o();
      return n3.parse(e3, t4, r3), n3;
    }
    o.prototype.parse = function(e3, t4, r3) {
      if (!i.isString(e3)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e3);
      var o2 = e3.indexOf("?"), a2 = -1 !== o2 && o2 < e3.indexOf("#") ? "?" : "#", h2 = e3.split(a2);
      h2[0] = h2[0].replace(/\\/g, "/");
      var v2 = e3 = h2.join(a2);
      if (v2 = v2.trim(), !r3 && 1 === e3.split("#").length) {
        var w = f.exec(v2);
        if (w) return this.path = v2, this.href = v2, this.pathname = w[1], w[2] ? (this.search = w[2], this.query = t4 ? b.parse(this.search.substr(1)) : this.search.substr(1)) : t4 && (this.search = "", this.query = {}), this;
      }
      var _ = s.exec(v2);
      if (_) {
        var B = (_ = _[0]).toLowerCase();
        this.protocol = B, v2 = v2.substr(_.length);
      }
      if (r3 || _ || v2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var E = "//" === v2.substr(0, 2);
        !E || _ && m[_] || (v2 = v2.substr(2), this.slashes = true);
      }
      if (!m[_] && (E || _ && !y[_])) {
        for (var S, A, C = -1, R = 0; R < c.length; R++) -1 !== (k = v2.indexOf(c[R])) && (-1 === C || k < C) && (C = k);
        for (-1 !== (A = -1 === C ? v2.lastIndexOf("@") : v2.lastIndexOf("@", C)) && (S = v2.slice(0, A), v2 = v2.slice(A + 1), this.auth = decodeURIComponent(S)), C = -1, R = 0; R < u.length; R++) {
          var k;
          -1 !== (k = v2.indexOf(u[R])) && (-1 === C || k < C) && (C = k);
        }
        -1 === C && (C = v2.length), this.host = v2.slice(0, C), v2 = v2.slice(C), this.parseHost(), this.hostname = this.hostname || "";
        var x = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
        if (!x) for (var I = this.hostname.split(/\./), M = (R = 0, I.length); R < M; R++) {
          var F = I[R];
          if (F && !F.match(d)) {
            for (var O = "", T = 0, U = F.length; T < U; T++) F.charCodeAt(T) > 127 ? O += "x" : O += F[T];
            if (!O.match(d)) {
              var P = I.slice(0, R), N = I.slice(R + 1), L = F.match(p);
              L && (P.push(L[1]), N.unshift(L[2])), N.length && (v2 = "/" + N.join(".") + v2), this.hostname = P.join(".");
              break;
            }
          }
        }
        this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), x || (this.hostname = n2.toASCII(this.hostname));
        var z = this.port ? ":" + this.port : "", D = this.hostname || "";
        this.host = D + z, this.href += this.host, x && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== v2[0] && (v2 = "/" + v2));
      }
      if (!g[B]) for (R = 0, M = l.length; R < M; R++) {
        var q = l[R];
        if (-1 !== v2.indexOf(q)) {
          var j = encodeURIComponent(q);
          j === q && (j = escape(q)), v2 = v2.split(q).join(j);
        }
      }
      var H = v2.indexOf("#");
      -1 !== H && (this.hash = v2.substr(H), v2 = v2.slice(0, H));
      var W = v2.indexOf("?");
      if (-1 !== W ? (this.search = v2.substr(W), this.query = v2.substr(W + 1), t4 && (this.query = b.parse(this.query)), v2 = v2.slice(0, W)) : t4 && (this.search = "", this.query = {}), v2 && (this.pathname = v2), y[B] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        z = this.pathname || "";
        var $2 = this.search || "";
        this.path = z + $2;
      }
      return this.href = this.format(), this;
    }, o.prototype.format = function() {
      var e3 = this.auth || "";
      e3 && (e3 = (e3 = encodeURIComponent(e3)).replace(/%3A/i, ":"), e3 += "@");
      var t4 = this.protocol || "", r3 = this.pathname || "", n3 = this.hash || "", o2 = false, s2 = "";
      this.host ? o2 = e3 + this.host : this.hostname && (o2 = e3 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (o2 += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s2 = b.stringify(this.query));
      var a2 = this.search || s2 && "?" + s2 || "";
      return t4 && ":" !== t4.substr(-1) && (t4 += ":"), this.slashes || (!t4 || y[t4]) && false !== o2 ? (o2 = "//" + (o2 || ""), r3 && "/" !== r3.charAt(0) && (r3 = "/" + r3)) : o2 || (o2 = ""), n3 && "#" !== n3.charAt(0) && (n3 = "#" + n3), a2 && "?" !== a2.charAt(0) && (a2 = "?" + a2), t4 + o2 + (r3 = r3.replace(/[?#]/g, (function(e4) {
        return encodeURIComponent(e4);
      }))) + (a2 = a2.replace("#", "%23")) + n3;
    }, o.prototype.resolve = function(e3) {
      return this.resolveObject(v(e3, false, true)).format();
    }, o.prototype.resolveObject = function(e3) {
      if (i.isString(e3)) {
        var t4 = new o();
        t4.parse(e3, false, true), e3 = t4;
      }
      for (var r3 = new o(), n3 = Object.keys(this), s2 = 0; s2 < n3.length; s2++) {
        var a2 = n3[s2];
        r3[a2] = this[a2];
      }
      if (r3.hash = e3.hash, "" === e3.href) return r3.href = r3.format(), r3;
      if (e3.slashes && !e3.protocol) {
        for (var f2 = Object.keys(e3), h2 = 0; h2 < f2.length; h2++) {
          var l2 = f2[h2];
          "protocol" !== l2 && (r3[l2] = e3[l2]);
        }
        return y[r3.protocol] && r3.hostname && !r3.pathname && (r3.path = r3.pathname = "/"), r3.href = r3.format(), r3;
      }
      if (e3.protocol && e3.protocol !== r3.protocol) {
        if (!y[e3.protocol]) {
          for (var u2 = Object.keys(e3), c2 = 0; c2 < u2.length; c2++) {
            var d2 = u2[c2];
            r3[d2] = e3[d2];
          }
          return r3.href = r3.format(), r3;
        }
        if (r3.protocol = e3.protocol, e3.host || m[e3.protocol]) r3.pathname = e3.pathname;
        else {
          for (var p2 = (e3.pathname || "").split("/"); p2.length && !(e3.host = p2.shift()); ) ;
          e3.host || (e3.host = ""), e3.hostname || (e3.hostname = ""), "" !== p2[0] && p2.unshift(""), p2.length < 2 && p2.unshift(""), r3.pathname = p2.join("/");
        }
        if (r3.search = e3.search, r3.query = e3.query, r3.host = e3.host || "", r3.auth = e3.auth, r3.hostname = e3.hostname || e3.host, r3.port = e3.port, r3.pathname || r3.search) {
          var g2 = r3.pathname || "", b2 = r3.search || "";
          r3.path = g2 + b2;
        }
        return r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
      }
      var v2 = r3.pathname && "/" === r3.pathname.charAt(0), w = e3.host || e3.pathname && "/" === e3.pathname.charAt(0), _ = w || v2 || r3.host && e3.pathname, B = _, E = r3.pathname && r3.pathname.split("/") || [], S = (p2 = e3.pathname && e3.pathname.split("/") || [], r3.protocol && !y[r3.protocol]);
      if (S && (r3.hostname = "", r3.port = null, r3.host && ("" === E[0] ? E[0] = r3.host : E.unshift(r3.host)), r3.host = "", e3.protocol && (e3.hostname = null, e3.port = null, e3.host && ("" === p2[0] ? p2[0] = e3.host : p2.unshift(e3.host)), e3.host = null), _ = _ && ("" === p2[0] || "" === E[0])), w) r3.host = e3.host || "" === e3.host ? e3.host : r3.host, r3.hostname = e3.hostname || "" === e3.hostname ? e3.hostname : r3.hostname, r3.search = e3.search, r3.query = e3.query, E = p2;
      else if (p2.length) E || (E = []), E.pop(), E = E.concat(p2), r3.search = e3.search, r3.query = e3.query;
      else if (!i.isNullOrUndefined(e3.search)) return S && (r3.hostname = r3.host = E.shift(), (x = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = x.shift(), r3.host = r3.hostname = x.shift())), r3.search = e3.search, r3.query = e3.query, i.isNull(r3.pathname) && i.isNull(r3.search) || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.href = r3.format(), r3;
      if (!E.length) return r3.pathname = null, r3.search ? r3.path = "/" + r3.search : r3.path = null, r3.href = r3.format(), r3;
      for (var A = E.slice(-1)[0], C = (r3.host || e3.host || E.length > 1) && ("." === A || ".." === A) || "" === A, R = 0, k = E.length; k >= 0; k--) "." === (A = E[k]) ? E.splice(k, 1) : ".." === A ? (E.splice(k, 1), R++) : R && (E.splice(k, 1), R--);
      if (!_ && !B) for (; R--; R) E.unshift("..");
      !_ || "" === E[0] || E[0] && "/" === E[0].charAt(0) || E.unshift(""), C && "/" !== E.join("/").substr(-1) && E.push("");
      var x, I = "" === E[0] || E[0] && "/" === E[0].charAt(0);
      return S && (r3.hostname = r3.host = I ? "" : E.length ? E.shift() : "", (x = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = x.shift(), r3.host = r3.hostname = x.shift())), (_ = _ || r3.host && E.length) && !I && E.unshift(""), E.length ? r3.pathname = E.join("/") : (r3.pathname = null, r3.path = null), i.isNull(r3.pathname) && i.isNull(r3.search) || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.auth = e3.auth || r3.auth, r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
    }, o.prototype.parseHost = function() {
      var e3 = this.host, t4 = a.exec(e3);
      t4 && (":" !== (t4 = t4[0]) && (this.port = t4.substr(1)), e3 = e3.substr(0, e3.length - t4.length)), e3 && (this.hostname = e3);
    };
  }, 2502: (e2) => {
    e2.exports = { isString: function(e3) {
      return "string" == typeof e3;
    }, isObject: function(e3) {
      return "object" == typeof e3 && null !== e3;
    }, isNull: function(e3) {
      return null === e3;
    }, isNullOrUndefined: function(e3) {
      return null == e3;
    } };
  }, 7067: () => {
  } }, t = {};
  function r(n2) {
    var i = t[n2];
    if (void 0 !== i) return i.exports;
    var o = t[n2] = { id: n2, loaded: false, exports: {} };
    return e[n2].call(o.exports, o, o.exports, r), o.loaded = true, o.exports;
  }
  r.n = (e2) => {
    var t3 = e2 && e2.__esModule ? () => e2.default : () => e2;
    return r.d(t3, { a: t3 }), t3;
  }, r.d = (e2, t3) => {
    for (var n2 in t3) r.o(t3, n2) && !r.o(e2, n2) && Object.defineProperty(e2, n2, { enumerable: true, get: t3[n2] });
  }, r.g = (function() {
    if ("object" == typeof globalThis) return globalThis;
    try {
      return this || new Function("return this")();
    } catch (e2) {
      if ("object" == typeof window) return window;
    }
  })(), r.o = (e2, t3) => Object.prototype.hasOwnProperty.call(e2, t3), r.r = (e2) => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
  }, r.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2);
  var n = r(5590);
  return n;
};
const gmodCRAM = fn();
const READ_STRAND_FLAG = 16;
const MATE_STRAND_FLAG = 32;
const CRAM_MATE_STRAND_FLAG = 1;
class CramReader {
  constructor(config, genome, browser) {
    this.config = config;
    this.browser = browser;
    this.genome = genome;
    this.cramFile = new gmodCRAM.CramFile({
      filehandle: new FileHandler(config.url, config),
      seqFetch: config.seqFetch || seqFetch.bind(this),
      checkSequenceMD5: config.checkSequenceMD5 !== void 0 ? config.checkSequenceMD5 : true
    });
    const indexFileHandle = new FileHandler(config.indexURL, config);
    this.indexedCramFile = new gmodCRAM.IndexedCramFile({
      cram: this.cramFile,
      index: new gmodCRAM.CraiIndex({
        filehandle: indexFileHandle
      }),
      fetchSizeLimit: 3e7
    });
    BamUtils.setReaderDefaults(this, config);
    function seqFetch(seqID, start, end) {
      const sequence = this.genome.sequence;
      const genome2 = this.genome;
      return this.getHeader().then(function(header) {
        const chr = genome2.getChromosomeName(header.chrNames[seqID]);
        return sequence.getSequence(chr, start - 1, end);
      });
    }
  }
  /**
   * Parse the sequence dictionary from the SAM header and build chr name tables.  This function
   * is public so it can be unit tested.
   *
   * @returns {PromiseLike<chrName, chrToIndex, chrAliasTable}>}
   */
  async getHeader() {
    if (!this.header) {
      const genome = this.genome;
      const samHeader = await this.cramFile.getSamHeader();
      const chrToIndex = {};
      const chrNames = [];
      const chrAliasTable = {};
      const readGroups = [];
      for (let line of samHeader) {
        if ("SQ" === line.tag) {
          for (let d of line.data) {
            if (d.tag === "SN") {
              const seq = d.value;
              chrToIndex[seq] = chrNames.length;
              chrNames.push(seq);
              if (genome) {
                const alias = genome.getChromosomeName(seq);
                chrAliasTable[alias] = seq;
              }
              break;
            }
          }
        } else if ("RG" === line.tag) {
          readGroups.push(line.data);
        }
      }
      this.header = {
        chrNames,
        chrToIndex,
        chrAliasTable,
        readGroups
      };
    }
    return this.header;
  }
  async readAlignments(chr, bpStart, bpEnd) {
    this.browser;
    const header = await this.getHeader();
    const queryChr = header.chrAliasTable.hasOwnProperty(chr) ? header.chrAliasTable[chr] : chr;
    const chrIdx = header.chrToIndex[queryChr];
    const alignmentContainer = new AlignmentContainer(chr, bpStart, bpEnd, this.config);
    if (chrIdx === void 0) {
      return alignmentContainer;
    } else {
      try {
        const records = await this.indexedCramFile.getRecordsForRange(chrIdx, bpStart, bpEnd);
        for (let record of records) {
          const refID = record.sequenceId;
          const pos = record.alignmentStart;
          const alignmentEnd = pos + record.lengthOnRef;
          if (refID < 0) {
            continue;
          } else if (refID > chrIdx || pos > bpEnd) {
            return;
          } else if (refID < chrIdx) {
            continue;
          }
          if (alignmentEnd < bpStart) {
            continue;
          }
          const alignment = decodeCramRecord(record, header.chrNames);
          if (this.filter.pass(alignment)) {
            alignmentContainer.push(alignment);
          }
        }
        alignmentContainer.finish();
        return alignmentContainer;
      } catch (error) {
        let message = error.message;
        if (message && message.indexOf("MD5") >= 0) {
          message = "Sequence mismatch. Is this the correct genome for the loaded CRAM?";
        }
        this.browser.alert.present(new Error(message));
        throw error;
      }
    }
    function decodeCramRecord(record, chrNames) {
      const alignment = new BamAlignment();
      alignment.chr = chrNames[record.sequenceId];
      alignment.start = record.alignmentStart - 1;
      alignment.lengthOnRef = record.lengthOnRef;
      alignment.flags = record.flags;
      alignment.strand = !(record.flags & READ_STRAND_FLAG);
      alignment.fragmentLength = record.templateLength || record.templateSize;
      alignment.mq = record.mappingQuality;
      alignment.end = record.alignmentStart + record.lengthOnRef;
      alignment.readGroupId = record.readGroupId;
      if (record.mate && record.mate.sequenceId !== void 0) {
        const strand = record.mate.flags !== void 0 ? !(record.mate.flags & CRAM_MATE_STRAND_FLAG) : !(record.flags & MATE_STRAND_FLAG);
        alignment.mate = {
          chr: chrNames[record.mate.sequenceId],
          position: record.mate.alignmentStart,
          strand
        };
      }
      alignment.seq = record.getReadBases();
      alignment.qual = record.qualityScores;
      alignment.tagDict = record.tags;
      alignment.readName = record.readName;
      makeBlocks2(record, alignment);
      if (alignment.mate && alignment.start > alignment.mate.position && alignment.fragmentLength > 0) {
        alignment.fragmentLength = -alignment.fragmentLength;
      }
      BamUtils.setPairOrientation(alignment);
      return alignment;
    }
    function makeBlocks2(cramRecord, alignment) {
      const blocks = [];
      let insertions;
      let gaps;
      let basesUsed = 0;
      let cigarString = "";
      alignment.scStart = alignment.start;
      alignment.scLengthOnRef = alignment.lengthOnRef;
      if (cramRecord.readFeatures) {
        for (let feature2 of cramRecord.readFeatures) {
          const code = feature2.code;
          const data = feature2.data;
          const readPos = feature2.pos - 1;
          const refPos = feature2.refPos - 1;
          switch (code) {
            case "S":
            case "I":
            case "i":
            case "N":
            case "D":
              if (readPos > basesUsed) {
                const len3 = readPos - basesUsed;
                blocks.push(new AlignmentBlock({
                  start: refPos - len3,
                  seqOffset: basesUsed,
                  len: len3,
                  type: "M"
                }));
                basesUsed += len3;
                cigarString += len3 + "M";
              }
              if ("S" === code) {
                let scPos = refPos;
                alignment.scLengthOnRef += data.length;
                if (readPos === 0) {
                  alignment.scStart -= data.length;
                  scPos -= data.length;
                }
                const len3 = data.length;
                blocks.push(new AlignmentBlock({
                  start: scPos,
                  seqOffset: basesUsed,
                  len: len3,
                  type: "S"
                }));
                basesUsed += len3;
                cigarString += len3 + code;
              } else if ("I" === code || "i" === code) {
                if (insertions === void 0) {
                  insertions = [];
                }
                const len3 = "i" === code ? 1 : data.length;
                insertions.push(new AlignmentBlock({
                  start: refPos,
                  len: len3,
                  seqOffset: basesUsed,
                  type: "I"
                }));
                basesUsed += len3;
                cigarString += len3 + code;
              } else if ("D" === code || "N" === code) {
                if (!gaps) {
                  gaps = [];
                }
                gaps.push({
                  start: refPos,
                  len: data,
                  type: code
                });
                cigarString += data + code;
              }
              break;
            case "H":
            case "P":
              cigarString += data + code;
              break;
          }
        }
      }
      const len2 = cramRecord.readLength - basesUsed;
      if (len2 > 0) {
        blocks.push(new AlignmentBlock({
          start: cramRecord.alignmentStart + cramRecord.lengthOnRef - len2 - 1,
          seqOffset: basesUsed,
          len: len2,
          type: "M"
        }));
        cigarString += len2 + "M";
      }
      alignment.blocks = blocks;
      alignment.insertions = insertions;
      alignment.gaps = gaps;
      alignment.cigar = cigarString;
    }
  }
}
class FileHandler {
  constructor(source, config) {
    this.position = 0;
    this.url = source;
    this.config = config;
    this.cache = new BufferCache({
      fetch: (start, length) => this._fetch(start, length)
    });
  }
  async _fetch(position, length) {
    const loadRange = { start: position, size: length };
    this._stat = { size: void 0 };
    const arrayBuffer = await igvxhr.loadArrayBuffer(this.url, buildOptions$1(this.config, { range: loadRange }));
    return Buffer.from(arrayBuffer);
  }
  async read(buffer, offset2 = 0, length = Infinity, position = 0) {
    let readPosition = position;
    if (readPosition === null) {
      readPosition = this.position;
      this.position += length;
    }
    return this.cache.get(buffer, offset2, length, position);
  }
  async readFile() {
    const arrayBuffer = await igvxhr.loadArrayBuffer(this.url, buildOptions$1(this.config));
    return Buffer.from(arrayBuffer);
  }
  async stat() {
    if (!this._stat) {
      const buf = Buffer.allocUnsafe(10);
      await this.read(buf, 0, 10, 0);
      if (!this._stat)
        throw new Error(`unable to determine size of file at ${this.url}`);
    }
    return this._stat;
  }
}
class BufferCache {
  constructor({ fetch: fetch2, size = 1e7, chunkSize = 32768 }) {
    this.fetch = fetch2;
    this.chunkSize = chunkSize;
    this.lruCache = new QuickLRU({ maxSize: Math.floor(size / chunkSize) });
  }
  async get(outputBuffer, offset2, length, position) {
    if (outputBuffer.length < offset2 + length)
      throw new Error("output buffer not big enough for request");
    const firstChunk = Math.floor(position / this.chunkSize);
    const lastChunk = Math.floor((position + length) / this.chunkSize);
    const fetches = new Array(lastChunk - firstChunk + 1);
    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {
      fetches[chunk - firstChunk] = this._getChunk(chunk).then((data) => ({
        data,
        chunkNumber: chunk
      }));
    }
    const chunks = await Promise.all(fetches);
    const chunksOffset = position - chunks[0].chunkNumber * this.chunkSize;
    chunks.forEach(({ data, chunkNumber }) => {
      const chunkPositionStart = chunkNumber * this.chunkSize;
      let copyStart = 0;
      let copyEnd = this.chunkSize;
      let copyOffset = offset2 + (chunkNumber - firstChunk) * this.chunkSize - chunksOffset;
      if (chunkNumber === firstChunk) {
        copyOffset = offset2;
        copyStart = chunksOffset;
      }
      if (chunkNumber === lastChunk) {
        copyEnd = position + length - chunkPositionStart;
      }
      data.copy(outputBuffer, copyOffset, copyStart, copyEnd);
    });
  }
  _getChunk(chunkNumber) {
    const cachedPromise = this.lruCache.get(chunkNumber);
    if (cachedPromise) return cachedPromise;
    const freshPromise = this.fetch(
      chunkNumber * this.chunkSize,
      this.chunkSize
    );
    this.lruCache.set(chunkNumber, freshPromise);
    return freshPromise;
  }
}
class QuickLRU {
  constructor(options2 = {}) {
    if (!(options2.maxSize && options2.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    this.maxSize = options2.maxSize;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      const value = this.oldCache.get(key);
      this._set(key, value);
      return value;
    }
  }
  set(key, value) {
    if (this.cache.has(key)) {
      this.cache.set(key, value);
    } else {
      this._set(key, value);
    }
    return this;
  }
  has(key) {
    return this.cache.has(key) || this.oldCache.has(key);
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }
    if (this.oldCache.has(key)) {
      return this.oldCache.get(key);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      yield item;
    }
    for (const item of this.oldCache) {
      const [key] = item;
      if (!this.cache.has(key)) {
        yield item;
      }
    }
  }
  get size() {
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return this._size + oldCacheSize;
  }
}
var CigarOperationTable = {
  "ALIGNMENT_MATCH": "M",
  "INSERT": "I",
  "DELETE": "D",
  "SKIP": "N",
  "CLIP_SOFT": "S",
  "CLIP_HARD": "H",
  "PAD": "P",
  "SEQUENCE_MATCH": "=",
  "SEQUENCE_MISMATCH": "X"
};
const Ga4ghAlignmentReader = function(config, genome) {
  this.config = config;
  this.genome = genome;
  this.url = config.url;
  this.filter = new BamFilter(config.filter);
  this.readGroupSetIds = config.readGroupSetIds;
  this.authKey = config.authKey;
  this.samplingWindowSize = config.samplingWindowSize === void 0 ? 100 : config.samplingWindowSize;
  this.samplingDepth = config.samplingDepth === void 0 ? 1e3 : config.samplingDepth;
  if (config.viewAsPairs) {
    this.pairsSupported = true;
  } else {
    this.pairsSupported = config.pairsSupported === void 0 ? true : config.pairsSupported;
  }
};
Ga4ghAlignmentReader.prototype.readAlignments = function(chr, bpStart, bpEnd) {
  const genome = this.genome;
  const self2 = this;
  return getChrAliasTable().then(function(chrAliasTable) {
    var queryChr = chrAliasTable.hasOwnProperty(chr) ? chrAliasTable[chr] : chr, readURL = self2.url + "/reads/search";
    return ga4ghSearch({
      url: readURL,
      body: {
        "readGroupSetIds": [self2.readGroupSetIds],
        "referenceName": queryChr,
        "start": bpStart,
        "end": bpEnd,
        "pageSize": "10000"
      },
      decode: decodeGa4ghReads,
      results: new AlignmentContainer(chr, bpStart, bpEnd, self2.config)
    });
  });
  function getChrAliasTable() {
    if (self2.chrAliasTable) {
      return Promise.resolve(self2.chrAliasTable);
    } else {
      return self2.readMetadata().then(function(json) {
        self2.chrAliasTable = {};
        if (genome && json.readGroups && json.readGroups.length > 0) {
          var referenceSetId = json.readGroups[0].referenceSetId;
          if (referenceSetId) {
            var readURL = self2.url + "/references/search";
            return ga4ghSearch({
              url: readURL,
              body: {
                "referenceSetId": referenceSetId
              },
              decode: function(j) {
                return j.references;
              }
            }).then(function(references) {
              references.forEach(function(ref) {
                var refName = ref.name, alias = genome.getChromosomeName(refName);
                self2.chrAliasTable[alias] = refName;
              });
              return self2.chrAliasTable;
            });
          } else {
            populateChrAliasTable(self2.chrAliasTable, self2.config.datasetId);
            return self2.chrAliasTable;
          }
        } else {
          return self2.chrAliasTable;
        }
      });
    }
  }
  function decodeGa4ghReads(j) {
    var i, jsonRecords = j.alignments, len2 = jsonRecords.length, alignment, jsonAlignment, cigarDecoded, alignments = [], mate, blocks;
    for (i = 0; i < len2; i++) {
      let record = jsonRecords[i];
      alignment = new BamAlignment();
      alignment.readName = record.fragmentName;
      alignment.properPlacement = record.properPlacement;
      alignment.duplicateFragment = record.duplicateFragment;
      alignment.numberReads = record.numberReads;
      alignment.fragmentLength = record.fragmentLength;
      alignment.readNumber = record.readNumber;
      alignment.failedVendorQualityChecks = record.failedVendorQualityChecks;
      alignment.secondaryAlignment = record.secondaryAlignment;
      alignment.supplementaryAlignment = record.supplementaryAlignment;
      alignment.seq = record.alignedSequence;
      alignment.qual = record.alignedQuality;
      alignment.matePos = record.nextMatePosition;
      alignment.tagDict = record.info;
      alignment.flags = encodeFlags();
      jsonAlignment = record.alignment;
      if (jsonAlignment) {
        alignment.mapped = true;
        alignment.chr = record.alignment.position.referenceName;
        if (genome) alignment.chr = genome.getChromosomeName(alignment.chr);
        alignment.start = parseInt(record.alignment.position.position);
        alignment.strand = !record.alignment.position.reverseStrand;
        alignment.mq = record.alignment.mappingQuality;
        alignment.cigar = encodeCigar(record.alignment.cigar);
        cigarDecoded = translateCigar(record.alignment.cigar);
        alignment.lengthOnRef = cigarDecoded.lengthOnRef;
        blocks = makeBlocks2(alignment, cigarDecoded.array);
        alignment.blocks = blocks.blocks;
        alignment.insertions = blocks.insertions;
      } else {
        alignment.mapped = false;
      }
      mate = record.nextMatePosition;
      if (mate) {
        alignment.mate = {
          chr: mate.referenceFrame,
          position: parseInt(mate.position),
          strand: !mate.reverseStrand
        };
      }
      if (self2.filter.pass(alignment)) {
        alignments.push(alignment);
      }
    }
    return alignments;
    function encodeCigar(cigarArray) {
      var cigarString = "";
      cigarArray.forEach(function(cigarUnit) {
        var op = CigarOperationTable[cigarUnit.operation], len3 = cigarUnit.operationLength;
        cigarString = cigarString + (len3 + op);
      });
      return cigarString;
    }
    function encodeFlags(json) {
      return 0;
    }
    function translateCigar(cigar) {
      var cigarUnit, opLen, opLtr, lengthOnRef = 0, cigarArray = [], i2;
      for (i2 = 0; i2 < cigar.length; i2++) {
        cigarUnit = cigar[i2];
        opLtr = CigarOperationTable[cigarUnit.operation];
        opLen = parseInt(cigarUnit.operationLength);
        if (opLtr === "M" || opLtr === "EQ" || opLtr === "X" || opLtr === "D" || opLtr === "N" || opLtr === "=")
          lengthOnRef += opLen;
        cigarArray.push({ len: opLen, ltr: opLtr });
      }
      return { lengthOnRef, array: cigarArray };
    }
    function makeBlocks2(record, cigarArray) {
      var blocks2 = [], gaps, insertions, seqOffset = 0, pos = record.start, len3 = cigarArray.length, gapType;
      for (var i2 = 0; i2 < len3; i2++) {
        var c = cigarArray[i2];
        switch (c.ltr) {
          case "H":
            break;
          // ignore hard clips
          case "P":
            break;
          // ignore pads
          case "S":
            seqOffset += c.len;
            gapType = "S";
            break;
          // soft clip read bases
          case "N":
          case "D":
            if (gaps === void 0) {
              gaps = [];
            }
            gaps.push({
              start: pos,
              len: c.len,
              type: c.ltr
            });
            pos += c.len;
            break;
          case "I":
            if (insertions === void 0) insertions = [];
            insertions.push(new AlignmentBlock({
              start: pos,
              len: c.len,
              seqOffset
            }));
            seqOffset += c.len;
            break;
          case "M":
          case "EQ":
          case "=":
          case "X":
            blocks2.push(
              new AlignmentBlock({
                start: pos,
                len: c.len,
                seqOffset,
                gapType
              })
            );
            seqOffset += c.len;
            pos += c.len;
            break;
          default:
            console.log("Error processing cigar element: " + c.len + c.ltr);
        }
      }
      return { blocks: blocks2, insertions, gaps };
    }
  }
};
Ga4ghAlignmentReader.prototype.readMetadata = function() {
  return ga4ghGet({
    url: this.url,
    entity: "readgroupsets",
    entityId: this.readGroupSetIds
  });
};
function populateChrAliasTable(chrAliasTable, datasetId) {
  var i;
  if ("461916304629" === datasetId || "337315832689" === datasetId) {
    for (i = 1; i < 23; i++) {
      chrAliasTable["chr" + i] = i;
    }
    chrAliasTable["chrX"] = "X";
    chrAliasTable["chrY"] = "Y";
    chrAliasTable["chrM"] = "MT";
  }
}
class BamSource {
  constructor(config, browser) {
    const genome = browser.genome;
    this.config = config;
    this.genome = genome;
    if (isDataURL(config.url)) {
      this.config.indexed = false;
    }
    if ("ga4gh" === config.sourceType) {
      this.bamReader = new Ga4ghAlignmentReader(config, genome);
    } else if ("pysam" === config.sourceType) {
      this.bamReader = new BamWebserviceReader(config, genome);
    } else if ("htsget" === config.sourceType) {
      this.bamReader = new HtsgetBamReader(config, genome);
    } else if ("shardedBam" === config.sourceType) {
      this.bamReader = new ShardedBamReader(config, genome);
    } else if ("cram" === config.format) {
      this.bamReader = new CramReader(config, genome, browser);
    } else {
      if (!this.config.indexURL && config.indexed !== false) {
        if (isString$2(this.config.url)) {
          const inferIndexPath$1 = inferIndexPath(this.config.url, "bai");
          if (inferIndexPath$1) {
            console.error(`Warning: no indexURL specified for ${this.config.url}.  Guessing ${this.baiPath}`);
            this.config.indexURL = inferIndexPath$1;
          } else {
            console.error(`Warning: no indexURL specified for ${this.config.url}.`);
            this.config.indexed = false;
          }
        } else {
          console.error(`Warning: no indexURL specified for ${this.config.name}.`);
          this.config.indexed = false;
        }
      }
      if (this.config.indexed !== false) {
        this.bamReader = new BamReader(config, genome);
      } else {
        this.bamReader = new BamReaderNonIndexed(config, genome);
      }
    }
    this.viewAsPairs = config.viewAsPairs;
    this.showSoftClips = config.showSoftClips;
  }
  setViewAsPairs(bool) {
    this.viewAsPairs = bool;
  }
  setShowSoftClips(bool) {
    this.showSoftClips = bool;
  }
  async getAlignments(chr, bpStart, bpEnd) {
    const genome = this.genome;
    const showSoftClips = this.showSoftClips;
    const alignmentContainer = await this.bamReader.readAlignments(chr, bpStart, bpEnd);
    let alignments = alignmentContainer.alignments;
    if (!this.viewAsPairs) {
      alignments = unpairAlignments([{ alignments }]);
    }
    const hasAlignments = alignments.length > 0;
    alignmentContainer.packedAlignmentRows = packAlignmentRows(alignments, alignmentContainer.start, alignmentContainer.end, showSoftClips);
    this.alignmentContainer = alignmentContainer;
    if (hasAlignments) {
      const sequence = await genome.sequence.getSequence(chr, alignmentContainer.start, alignmentContainer.end);
      if (sequence) {
        alignmentContainer.coverageMap.refSeq = sequence;
        alignmentContainer.sequence = sequence;
        return alignmentContainer;
      } else {
        console.error("No sequence for: " + chr + ":" + alignmentContainer.start + "-" + alignmentContainer.end);
      }
    }
    return alignmentContainer;
  }
}
function paintAxis(ctx2, pixelWidth, pixelHeight) {
  var x1, x2, y1, y2, a, b, reference, shim, font = {
    "font": "normal 10px Arial",
    "textAlign": "right",
    "strokeStyle": "black"
  };
  if (void 0 === this.dataRange || void 0 === this.dataRange.max || void 0 === this.dataRange.min) {
    return;
  }
  let flipAxis = void 0 === this.flipAxis ? false : this.flipAxis;
  IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
  reference = 0.95 * pixelWidth;
  x1 = reference - 8;
  x2 = reference;
  shim = 0.01;
  y1 = y2 = shim * pixelHeight;
  a = { x: x2, y: y1 };
  IGVGraphics.strokeLine(ctx2, x1, y1, x2, y2, font);
  IGVGraphics.fillText(ctx2, prettyPrint2(flipAxis ? this.dataRange.min : this.dataRange.max), x1 + 4, y1 + 12, font);
  y1 = y2 = (1 - shim) * pixelHeight;
  b = { x: x2, y: y1 };
  IGVGraphics.strokeLine(ctx2, x1, y1, x2, y2, font);
  IGVGraphics.fillText(ctx2, prettyPrint2(flipAxis ? this.dataRange.max : this.dataRange.min), x1 + 4, y1 - 4, font);
  IGVGraphics.strokeLine(ctx2, a.x, a.y, b.x, b.y, font);
  function prettyPrint2(number) {
    if (number === 0) {
      return "0";
    } else if (Math.abs(number) >= 10) {
      return number.toFixed();
    } else if (Math.abs(number) >= 1) {
      return number.toFixed(1);
    } else {
      return number.toFixed(2);
    }
  }
}
class Locus {
  constructor({ chr, start, end }) {
    this.chr = chr;
    this.start = start;
    this.end = end;
  }
  contains(locus) {
    return locus.chr === this.chr && locus.start >= this.start && locus.end <= this.end;
  }
  overlaps(locus) {
    return locus.chr === this.chr && !(locus.end < this.start || locus.start > this.end);
  }
  extend(l) {
    if (l.chr !== this.chr) return;
    this.start = Math.min(l.start, this.start);
    this.end = Math.max(l.end, this.end);
  }
  getLocusString() {
    if ("all" === this.chr) {
      return "all";
    } else {
      const ss = numberFormatter$1(Math.floor(this.start) + 1);
      const ee = numberFormatter$1(Math.round(this.end));
      return `${this.chr}:${ss}-${ee}`;
    }
  }
  static fromLocusString(str) {
    if ("all" === str) {
      return new Locus({ chr: "all" });
    }
    const parts = str.split(":");
    const chr = parts[0];
    const se = parts[1].split("-");
    const start = Number.parseInt(se[0].replace(/,/g, "")) - 1;
    const end = Number.parseInt(se[1].replace(/,/g, ""));
    return new Locus({ chr, start, end });
  }
}
/*!
 * vanilla-picker v2.12.1
 * https://vanilla-picker.js.org
 *
 * Copyright 2017-2021 Andreas Borgen (https://github.com/Sphinxxxx), Adam Brooks (https://github.com/dissimulate)
 * Released under the ISC license.
 */
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = /* @__PURE__ */ (function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
})();
var slicedToArray = /* @__PURE__ */ (function() {
  function sliceIterator(arr2, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr2[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err2) {
      _d = true;
      _e = err2;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function(arr2, i) {
    if (Array.isArray(arr2)) {
      return arr2;
    } else if (Symbol.iterator in Object(arr2)) {
      return sliceIterator(arr2, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
})();
String.prototype.startsWith = String.prototype.startsWith || function(needle) {
  return this.indexOf(needle) === 0;
};
String.prototype.padStart = String.prototype.padStart || function(len2, pad) {
  var str = this;
  while (str.length < len2) {
    str = pad + str;
  }
  return str;
};
var colorNames = { cb: "0f8ff", tqw: "aebd7", q: "-ffff", qmrn: "7fffd4", zr: "0ffff", bg: "5f5dc", bsq: "e4c4", bck: "---", nch: "ebcd", b: "--ff", bvt: "8a2be2", brwn: "a52a2a", brw: "deb887", ctb: "5f9ea0", hrt: "7fff-", chcT: "d2691e", cr: "7f50", rnw: "6495ed", crns: "8dc", crms: "dc143c", cn: "-ffff", Db: "--8b", Dcn: "-8b8b", Dgnr: "b8860b", Dgr: "a9a9a9", Dgrn: "-64-", Dkhk: "bdb76b", Dmgn: "8b-8b", Dvgr: "556b2f", Drng: "8c-", Drch: "9932cc", Dr: "8b--", Dsmn: "e9967a", Dsgr: "8fbc8f", DsTb: "483d8b", DsTg: "2f4f4f", Dtrq: "-ced1", Dvt: "94-d3", ppnk: "1493", pskb: "-bfff", mgr: "696969", grb: "1e90ff", rbrc: "b22222", rwht: "af0", stg: "228b22", chs: "-ff", gnsb: "dcdcdc", st: "8f8ff", g: "d7-", gnr: "daa520", gr: "808080", grn: "-8-0", grnw: "adff2f", hnw: "0fff0", htpn: "69b4", nnr: "cd5c5c", ng: "4b-82", vr: "0", khk: "0e68c", vnr: "e6e6fa", nrb: "0f5", wngr: "7cfc-", mnch: "acd", Lb: "add8e6", Lcr: "08080", Lcn: "e0ffff", Lgnr: "afad2", Lgr: "d3d3d3", Lgrn: "90ee90", Lpnk: "b6c1", Lsmn: "a07a", Lsgr: "20b2aa", Lskb: "87cefa", LsTg: "778899", Lstb: "b0c4de", Lw: "e0", m: "-ff-", mgrn: "32cd32", nn: "af0e6", mgnt: "-ff", mrn: "8--0", mqm: "66cdaa", mmb: "--cd", mmrc: "ba55d3", mmpr: "9370db", msg: "3cb371", mmsT: "7b68ee", "": "-fa9a", mtr: "48d1cc", mmvt: "c71585", mnLb: "191970", ntc: "5fffa", mstr: "e4e1", mccs: "e4b5", vjw: "dead", nv: "--80", c: "df5e6", v: "808-0", vrb: "6b8e23", rng: "a5-", rngr: "45-", rch: "da70d6", pgnr: "eee8aa", pgrn: "98fb98", ptrq: "afeeee", pvtr: "db7093", ppwh: "efd5", pchp: "dab9", pr: "cd853f", pnk: "c0cb", pm: "dda0dd", pwrb: "b0e0e6", prp: "8-080", cc: "663399", r: "--", sbr: "bc8f8f", rb: "4169e1", sbrw: "8b4513", smn: "a8072", nbr: "4a460", sgrn: "2e8b57", ssh: "5ee", snn: "a0522d", svr: "c0c0c0", skb: "87ceeb", sTb: "6a5acd", sTgr: "708090", snw: "afa", n: "-ff7f", stb: "4682b4", tn: "d2b48c", t: "-8080", thst: "d8bfd8", tmT: "6347", trqs: "40e0d0", vt: "ee82ee", whT: "5deb3", wht: "", hts: "5f5f5", w: "-", wgrn: "9acd32" };
function printNum(num) {
  var decs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var str = decs > 0 ? num.toFixed(decs).replace(/0+$/, "").replace(/\.$/, "") : num.toString();
  return str || "0";
}
var Color = (function() {
  function Color2(r, g, b, a) {
    classCallCheck(this, Color2);
    var that = this;
    function parseString(input) {
      if (input.startsWith("hsl")) {
        var _input$match$map = input.match(/([\-\d\.e]+)/g).map(Number), _input$match$map2 = slicedToArray(_input$match$map, 4), h = _input$match$map2[0], s = _input$match$map2[1], l = _input$match$map2[2], _a = _input$match$map2[3];
        if (_a === void 0) {
          _a = 1;
        }
        h /= 360;
        s /= 100;
        l /= 100;
        that.hsla = [h, s, l, _a];
      } else if (input.startsWith("rgb")) {
        var _input$match$map3 = input.match(/([\-\d\.e]+)/g).map(Number), _input$match$map4 = slicedToArray(_input$match$map3, 4), _r = _input$match$map4[0], _g = _input$match$map4[1], _b = _input$match$map4[2], _a2 = _input$match$map4[3];
        if (_a2 === void 0) {
          _a2 = 1;
        }
        that.rgba = [_r, _g, _b, _a2];
      } else {
        if (input.startsWith("#")) {
          that.rgba = Color2.hexToRgb(input);
        } else {
          that.rgba = Color2.nameToRgb(input) || Color2.hexToRgb(input);
        }
      }
    }
    if (r === void 0) ;
    else if (Array.isArray(r)) {
      this.rgba = r;
    } else if (b === void 0) {
      var color = r && "" + r;
      if (color) {
        parseString(color.toLowerCase());
      }
    } else {
      this.rgba = [r, g, b, a === void 0 ? 1 : a];
    }
  }
  createClass(Color2, [{
    key: "printRGB",
    value: function printRGB(alpha) {
      var rgb = alpha ? this.rgba : this.rgba.slice(0, 3), vals = rgb.map(function(x, i) {
        return printNum(x, i === 3 ? 3 : 0);
      });
      return alpha ? "rgba(" + vals + ")" : "rgb(" + vals + ")";
    }
  }, {
    key: "printHSL",
    value: function printHSL(alpha) {
      var mults = [360, 100, 100, 1], suff = ["", "%", "%", ""];
      var hsl = alpha ? this.hsla : this.hsla.slice(0, 3), vals = hsl.map(function(x, i) {
        return printNum(x * mults[i], i === 3 ? 3 : 1) + suff[i];
      });
      return alpha ? "hsla(" + vals + ")" : "hsl(" + vals + ")";
    }
  }, {
    key: "printHex",
    value: function printHex(alpha) {
      var hex = this.hex;
      return alpha ? hex : hex.substring(0, 7);
    }
  }, {
    key: "rgba",
    get: function get() {
      if (this._rgba) {
        return this._rgba;
      }
      if (!this._hsla) {
        throw new Error("No color is set");
      }
      return this._rgba = Color2.hslToRgb(this._hsla);
    },
    set: function set(rgb) {
      if (rgb.length === 3) {
        rgb[3] = 1;
      }
      this._rgba = rgb;
      this._hsla = null;
    }
  }, {
    key: "rgbString",
    get: function get() {
      return this.printRGB();
    }
  }, {
    key: "rgbaString",
    get: function get() {
      return this.printRGB(true);
    }
  }, {
    key: "hsla",
    get: function get() {
      if (this._hsla) {
        return this._hsla;
      }
      if (!this._rgba) {
        throw new Error("No color is set");
      }
      return this._hsla = Color2.rgbToHsl(this._rgba);
    },
    set: function set(hsl) {
      if (hsl.length === 3) {
        hsl[3] = 1;
      }
      this._hsla = hsl;
      this._rgba = null;
    }
  }, {
    key: "hslString",
    get: function get() {
      return this.printHSL();
    }
  }, {
    key: "hslaString",
    get: function get() {
      return this.printHSL(true);
    }
  }, {
    key: "hex",
    get: function get() {
      var rgb = this.rgba, hex = rgb.map(function(x, i) {
        return i < 3 ? x.toString(16) : Math.round(x * 255).toString(16);
      });
      return "#" + hex.map(function(x) {
        return x.padStart(2, "0");
      }).join("");
    },
    set: function set(hex) {
      this.rgba = Color2.hexToRgb(hex);
    }
  }], [{
    key: "hexToRgb",
    value: function hexToRgb(input) {
      var hex = (input.startsWith("#") ? input.slice(1) : input).replace(/^(\w{3})$/, "$1F").replace(/^(\w)(\w)(\w)(\w)$/, "$1$1$2$2$3$3$4$4").replace(/^(\w{6})$/, "$1FF");
      if (!hex.match(/^([0-9a-fA-F]{8})$/)) {
        throw new Error("Unknown hex color; " + input);
      }
      var rgba = hex.match(/^(\w\w)(\w\w)(\w\w)(\w\w)$/).slice(1).map(function(x) {
        return parseInt(x, 16);
      });
      rgba[3] = rgba[3] / 255;
      return rgba;
    }
  }, {
    key: "nameToRgb",
    value: function nameToRgb(input) {
      var hash = input.toLowerCase().replace("at", "T").replace(/[aeiouyldf]/g, "").replace("ght", "L").replace("rk", "D").slice(-5, 4), hex = colorNames[hash];
      return hex === void 0 ? hex : Color2.hexToRgb(hex.replace(/\-/g, "00").padStart(6, "f"));
    }
  }, {
    key: "rgbToHsl",
    value: function rgbToHsl(_ref) {
      var _ref2 = slicedToArray(_ref, 4), r = _ref2[0], g = _ref2[1], b = _ref2[2], a = _ref2[3];
      r /= 255;
      g /= 255;
      b /= 255;
      var max = Math.max(r, g, b), min = Math.min(r, g, b);
      var h = void 0, s = void 0, l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return [h, s, l, a];
    }
  }, {
    key: "hslToRgb",
    value: function hslToRgb(_ref3) {
      var _ref4 = slicedToArray(_ref3, 4), h = _ref4[0], s = _ref4[1], l = _ref4[2], a = _ref4[3];
      var r = void 0, g = void 0, b = void 0;
      if (s === 0) {
        r = g = b = l;
      } else {
        var hue2rgb = function hue2rgb2(p2, q2, t) {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
          if (t < 1 / 2) return q2;
          if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
          return p2;
        };
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      var rgba = [r * 255, g * 255, b * 255].map(Math.round);
      rgba[3] = a;
      return rgba;
    }
  }]);
  return Color2;
})();
var EventBucket = (function() {
  function EventBucket2() {
    classCallCheck(this, EventBucket2);
    this._events = [];
  }
  createClass(EventBucket2, [{
    key: "add",
    value: function add(target, type, handler) {
      target.addEventListener(type, handler, false);
      this._events.push({
        target,
        type,
        handler
      });
    }
  }, {
    key: "remove",
    value: function remove2(target, type, handler) {
      this._events = this._events.filter(function(e) {
        var isMatch = true;
        if (target && target !== e.target) {
          isMatch = false;
        }
        if (type && type !== e.type) {
          isMatch = false;
        }
        if (handler && handler !== e.handler) {
          isMatch = false;
        }
        if (isMatch) {
          EventBucket2._doRemove(e.target, e.type, e.handler);
        }
        return !isMatch;
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._events.forEach(function(e) {
        return EventBucket2._doRemove(e.target, e.type, e.handler);
      });
      this._events = [];
    }
  }], [{
    key: "_doRemove",
    value: function _doRemove(target, type, handler) {
      target.removeEventListener(type, handler, false);
    }
  }]);
  return EventBucket2;
})();
function parseHTML(htmlString) {
  var div2 = document.createElement("div");
  div2.innerHTML = htmlString;
  return div2.firstElementChild;
}
function dragTrack(eventBucket, area, callback) {
  var dragging = false;
  function clamp(val, min, max) {
    return Math.max(min, Math.min(val, max));
  }
  function onMove(e, info, starting) {
    if (starting) {
      dragging = true;
    }
    if (!dragging) {
      return;
    }
    e.preventDefault();
    var bounds = area.getBoundingClientRect(), w = bounds.width, h = bounds.height, x = info.clientX, y = info.clientY;
    var relX = clamp(x - bounds.left, 0, w), relY = clamp(y - bounds.top, 0, h);
    callback(relX / w, relY / h);
  }
  function onMouse(e, starting) {
    var button = e.buttons === void 0 ? e.which : e.buttons;
    if (button === 1) {
      onMove(e, e, starting);
    } else {
      dragging = false;
    }
  }
  function onTouch(e, starting) {
    if (e.touches.length === 1) {
      onMove(e, e.touches[0], starting);
    } else {
      dragging = false;
    }
  }
  eventBucket.add(area, "mousedown", function(e) {
    onMouse(e, true);
  });
  eventBucket.add(area, "touchstart", function(e) {
    onTouch(e, true);
  });
  eventBucket.add(window, "mousemove", onMouse);
  eventBucket.add(area, "touchmove", onTouch);
  eventBucket.add(window, "mouseup", function(e) {
    dragging = false;
  });
  eventBucket.add(area, "touchend", function(e) {
    dragging = false;
  });
  eventBucket.add(area, "touchcancel", function(e) {
    dragging = false;
  });
}
var BG_TRANSP = "linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0 / 2em 2em,\n                   linear-gradient(45deg, lightgrey 25%,       white 25%,       white 75%, lightgrey 75%) 1em 1em / 2em 2em";
var HUES = 360;
var EVENT_KEY = "keydown", EVENT_CLICK_OUTSIDE = "mousedown", EVENT_TAB_MOVE = "focusin";
function $(selector, context) {
  return (context || document).querySelector(selector);
}
function stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}
function onKey(bucket, target, keys, handler, stop) {
  bucket.add(target, EVENT_KEY, function(e) {
    if (keys.indexOf(e.key) >= 0) {
      handler(e);
    }
  });
}
var Picker = (function() {
  function Picker2(options2) {
    classCallCheck(this, Picker2);
    this.settings = {
      popup: "right",
      layout: "default",
      alpha: true,
      editor: true,
      editorFormat: "hex",
      cancelButton: false,
      defaultColor: "#0cf"
    };
    this._events = new EventBucket();
    this.onChange = null;
    this.onDone = null;
    this.onOpen = null;
    this.onClose = null;
    this.setOptions(options2);
  }
  createClass(Picker2, [{
    key: "setOptions",
    value: function setOptions(options2) {
      var _this = this;
      if (!options2) {
        return;
      }
      var settings = this.settings;
      function transfer(source, target, skipKeys) {
        for (var key in source) {
          target[key] = source[key];
        }
      }
      if (options2 instanceof HTMLElement) {
        settings.parent = options2;
      } else {
        if (settings.parent && options2.parent && settings.parent !== options2.parent) {
          this._events.remove(settings.parent);
          this._popupInited = false;
        }
        transfer(options2, settings);
        if (options2.onChange) {
          this.onChange = options2.onChange;
        }
        if (options2.onDone) {
          this.onDone = options2.onDone;
        }
        if (options2.onOpen) {
          this.onOpen = options2.onOpen;
        }
        if (options2.onClose) {
          this.onClose = options2.onClose;
        }
        var col = options2.color || options2.colour;
        if (col) {
          this._setColor(col);
        }
      }
      var parent = settings.parent;
      if (parent && settings.popup && !this._popupInited) {
        var openProxy = function openProxy2(e) {
          return _this.openHandler(e);
        };
        this._events.add(parent, "click", openProxy);
        onKey(this._events, parent, [" ", "Spacebar", "Enter"], openProxy);
        this._popupInited = true;
      } else if (options2.parent && !settings.popup) {
        this.show();
      }
    }
  }, {
    key: "openHandler",
    value: function openHandler(e) {
      if (this.show()) {
        e && e.preventDefault();
        this.settings.parent.style.pointerEvents = "none";
        var toFocus = e && e.type === EVENT_KEY ? this._domEdit : this.domElement;
        setTimeout(function() {
          return toFocus.focus();
        }, 100);
        if (this.onOpen) {
          this.onOpen(this.colour);
        }
      }
    }
  }, {
    key: "closeHandler",
    value: function closeHandler(e) {
      var event = e && e.type;
      var doHide = false;
      if (!e) {
        doHide = true;
      } else if (event === EVENT_CLICK_OUTSIDE || event === EVENT_TAB_MOVE) {
        var knownTime = (this.__containedEvent || 0) + 100;
        if (e.timeStamp > knownTime) {
          doHide = true;
        }
      } else {
        stopEvent(e);
        doHide = true;
      }
      if (doHide && this.hide()) {
        this.settings.parent.style.pointerEvents = "";
        if (event !== EVENT_CLICK_OUTSIDE) {
          this.settings.parent.focus();
        }
        if (this.onClose) {
          this.onClose(this.colour);
        }
      }
    }
  }, {
    key: "movePopup",
    value: function movePopup(options2, open) {
      this.closeHandler();
      this.setOptions(options2);
      if (open) {
        this.openHandler();
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color, silent) {
      this._setColor(color, { silent });
    }
  }, {
    key: "_setColor",
    value: function _setColor(color, flags) {
      if (typeof color === "string") {
        color = color.trim();
      }
      if (!color) {
        return;
      }
      flags = flags || {};
      var c = void 0;
      try {
        c = new Color(color);
      } catch (ex) {
        if (flags.failSilently) {
          return;
        }
        throw ex;
      }
      if (!this.settings.alpha) {
        var hsla = c.hsla;
        hsla[3] = 1;
        c.hsla = hsla;
      }
      this.colour = this.color = c;
      this._setHSLA(null, null, null, null, flags);
    }
  }, {
    key: "setColour",
    value: function setColour(colour, silent) {
      this.setColor(colour, silent);
    }
  }, {
    key: "show",
    value: function show2() {
      var parent = this.settings.parent;
      if (!parent) {
        return false;
      }
      if (this.domElement) {
        var toggled = this._toggleDOM(true);
        this._setPosition();
        return toggled;
      }
      var html2 = this.settings.template || '<div class="picker_wrapper" tabindex="-1"><div class="picker_arrow"></div><div class="picker_hue picker_slider"><div class="picker_selector"></div></div><div class="picker_sl"><div class="picker_selector"></div></div><div class="picker_alpha picker_slider"><div class="picker_selector"></div></div><div class="picker_editor"><input aria-label="Type a color name or hex value"/></div><div class="picker_sample"></div><div class="picker_done"><button>Ok</button></div><div class="picker_cancel"><button>Cancel</button></div></div>';
      var wrapper = parseHTML(html2);
      this.domElement = wrapper;
      this._domH = $(".picker_hue", wrapper);
      this._domSL = $(".picker_sl", wrapper);
      this._domA = $(".picker_alpha", wrapper);
      this._domEdit = $(".picker_editor input", wrapper);
      this._domSample = $(".picker_sample", wrapper);
      this._domOkay = $(".picker_done button", wrapper);
      this._domCancel = $(".picker_cancel button", wrapper);
      wrapper.classList.add("layout_" + this.settings.layout);
      if (!this.settings.alpha) {
        wrapper.classList.add("no_alpha");
      }
      if (!this.settings.editor) {
        wrapper.classList.add("no_editor");
      }
      if (!this.settings.cancelButton) {
        wrapper.classList.add("no_cancel");
      }
      this._ifPopup(function() {
        return wrapper.classList.add("popup");
      });
      this._setPosition();
      if (this.colour) {
        this._updateUI();
      } else {
        this._setColor(this.settings.defaultColor);
      }
      this._bindEvents();
      return true;
    }
  }, {
    key: "hide",
    value: function hide2() {
      return this._toggleDOM(false);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this._events.destroy();
      if (this.domElement) {
        this.settings.parent.removeChild(this.domElement);
      }
    }
  }, {
    key: "_bindEvents",
    value: function _bindEvents() {
      var _this2 = this;
      var that = this, dom = this.domElement, events = this._events;
      function addEvent(target, type, handler) {
        events.add(target, type, handler);
      }
      addEvent(dom, "click", function(e) {
        return e.preventDefault();
      });
      dragTrack(events, this._domH, function(x, y) {
        return that._setHSLA(x);
      });
      dragTrack(events, this._domSL, function(x, y) {
        return that._setHSLA(null, x, 1 - y);
      });
      if (this.settings.alpha) {
        dragTrack(events, this._domA, function(x, y) {
          return that._setHSLA(null, null, null, 1 - y);
        });
      }
      var editInput = this._domEdit;
      {
        addEvent(editInput, "input", function(e) {
          that._setColor(this.value, { fromEditor: true, failSilently: true });
        });
        addEvent(editInput, "focus", function(e) {
          var input = this;
          if (input.selectionStart === input.selectionEnd) {
            input.select();
          }
        });
      }
      this._ifPopup(function() {
        var popupCloseProxy = function popupCloseProxy2(e) {
          return _this2.closeHandler(e);
        };
        addEvent(window, EVENT_CLICK_OUTSIDE, popupCloseProxy);
        addEvent(window, EVENT_TAB_MOVE, popupCloseProxy);
        onKey(events, dom, ["Esc", "Escape"], popupCloseProxy);
        var timeKeeper = function timeKeeper2(e) {
          _this2.__containedEvent = e.timeStamp;
        };
        addEvent(dom, EVENT_CLICK_OUTSIDE, timeKeeper);
        addEvent(dom, EVENT_TAB_MOVE, timeKeeper);
        addEvent(_this2._domCancel, "click", popupCloseProxy);
      });
      var onDoneProxy = function onDoneProxy2(e) {
        _this2._ifPopup(function() {
          return _this2.closeHandler(e);
        });
        if (_this2.onDone) {
          _this2.onDone(_this2.colour);
        }
      };
      addEvent(this._domOkay, "click", onDoneProxy);
      onKey(events, dom, ["Enter"], onDoneProxy);
    }
  }, {
    key: "_setPosition",
    value: function _setPosition() {
      var parent = this.settings.parent, elm = this.domElement;
      if (parent !== elm.parentNode) {
        parent.appendChild(elm);
      }
      this._ifPopup(function(popup) {
        if (getComputedStyle(parent).position === "static") {
          parent.style.position = "relative";
        }
        var cssClass = popup === true ? "popup_right" : "popup_" + popup;
        ["popup_top", "popup_bottom", "popup_left", "popup_right"].forEach(function(c) {
          if (c === cssClass) {
            elm.classList.add(c);
          } else {
            elm.classList.remove(c);
          }
        });
        elm.classList.add(cssClass);
      });
    }
  }, {
    key: "_setHSLA",
    value: function _setHSLA(h, s, l, a, flags) {
      flags = flags || {};
      var col = this.colour, hsla = col.hsla;
      [h, s, l, a].forEach(function(x, i) {
        if (x || x === 0) {
          hsla[i] = x;
        }
      });
      col.hsla = hsla;
      this._updateUI(flags);
      if (this.onChange && !flags.silent) {
        this.onChange(col);
      }
    }
  }, {
    key: "_updateUI",
    value: function _updateUI(flags) {
      if (!this.domElement) {
        return;
      }
      flags = flags || {};
      var col = this.colour, hsl = col.hsla, cssHue = "hsl(" + hsl[0] * HUES + ", 100%, 50%)", cssHSL = col.hslString, cssHSLA = col.hslaString;
      var uiH = this._domH, uiSL = this._domSL, uiA = this._domA, thumbH = $(".picker_selector", uiH), thumbSL = $(".picker_selector", uiSL), thumbA = $(".picker_selector", uiA);
      function posX(parent, child, relX) {
        child.style.left = relX * 100 + "%";
      }
      function posY(parent, child, relY) {
        child.style.top = relY * 100 + "%";
      }
      posX(uiH, thumbH, hsl[0]);
      this._domSL.style.backgroundColor = this._domH.style.color = cssHue;
      posX(uiSL, thumbSL, hsl[1]);
      posY(uiSL, thumbSL, 1 - hsl[2]);
      uiSL.style.color = cssHSL;
      posY(uiA, thumbA, 1 - hsl[3]);
      var opaque = cssHSL, transp = opaque.replace("hsl", "hsla").replace(")", ", 0)"), bg = "linear-gradient(" + [opaque, transp] + ")";
      this._domA.style.background = bg + ", " + BG_TRANSP;
      if (!flags.fromEditor) {
        var format2 = this.settings.editorFormat, alpha = this.settings.alpha;
        var value = void 0;
        switch (format2) {
          case "rgb":
            value = col.printRGB(alpha);
            break;
          case "hsl":
            value = col.printHSL(alpha);
            break;
          default:
            value = col.printHex(alpha);
        }
        this._domEdit.value = value;
      }
      this._domSample.style.color = cssHSLA;
    }
  }, {
    key: "_ifPopup",
    value: function _ifPopup(actionIf, actionElse) {
      if (this.settings.parent && this.settings.popup) {
        actionIf && actionIf(this.settings.popup);
      } else {
        actionElse && actionElse();
      }
    }
  }, {
    key: "_toggleDOM",
    value: function _toggleDOM(toVisible) {
      var dom = this.domElement;
      if (!dom) {
        return false;
      }
      var displayStyle = toVisible ? "" : "none", toggle = dom.style.display !== displayStyle;
      if (toggle) {
        dom.style.display = displayStyle;
      }
      return toggle;
    }
  }]);
  return Picker2;
})();
{
  var style = document.createElement("style");
  style.textContent = '.picker_wrapper.no_alpha .picker_alpha{display:none}.picker_wrapper.no_editor .picker_editor{position:absolute;z-index:-1;opacity:0}.picker_wrapper.no_cancel .picker_cancel{display:none}.layout_default.picker_wrapper{display:flex;flex-flow:row wrap;justify-content:space-between;align-items:stretch;font-size:10px;width:25em;padding:.5em}.layout_default.picker_wrapper input,.layout_default.picker_wrapper button{font-size:1rem}.layout_default.picker_wrapper>*{margin:.5em}.layout_default.picker_wrapper::before{content:"";display:block;width:100%;height:0;order:1}.layout_default .picker_slider,.layout_default .picker_selector{padding:1em}.layout_default .picker_hue{width:100%}.layout_default .picker_sl{flex:1 1 auto}.layout_default .picker_sl::before{content:"";display:block;padding-bottom:100%}.layout_default .picker_editor{order:1;width:6.5rem}.layout_default .picker_editor input{width:100%;height:100%}.layout_default .picker_sample{order:1;flex:1 1 auto}.layout_default .picker_done,.layout_default .picker_cancel{order:1}.picker_wrapper{box-sizing:border-box;background:#f2f2f2;box-shadow:0 0 0 1px silver;cursor:default;font-family:sans-serif;color:#444;pointer-events:auto}.picker_wrapper:focus{outline:none}.picker_wrapper button,.picker_wrapper input{box-sizing:border-box;border:none;box-shadow:0 0 0 1px silver;outline:none}.picker_wrapper button:focus,.picker_wrapper button:active,.picker_wrapper input:focus,.picker_wrapper input:active{box-shadow:0 0 2px 1px #1e90ff}.picker_wrapper button{padding:.4em .6em;cursor:pointer;background-color:#f5f5f5;background-image:linear-gradient(0deg, gainsboro, transparent)}.picker_wrapper button:active{background-image:linear-gradient(0deg, transparent, gainsboro)}.picker_wrapper button:hover{background-color:#fff}.picker_selector{position:absolute;z-index:1;display:block;-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%);border:2px solid #fff;border-radius:100%;box-shadow:0 0 3px 1px #67b9ff;background:currentColor;cursor:pointer}.picker_slider .picker_selector{border-radius:2px}.picker_hue{position:relative;background-image:linear-gradient(90deg, red, yellow, lime, cyan, blue, magenta, red);box-shadow:0 0 0 1px silver}.picker_sl{position:relative;box-shadow:0 0 0 1px silver;background-image:linear-gradient(180deg, white, rgba(255, 255, 255, 0) 50%),linear-gradient(0deg, black, rgba(0, 0, 0, 0) 50%),linear-gradient(90deg, #808080, rgba(128, 128, 128, 0))}.picker_alpha,.picker_sample{position:relative;background:linear-gradient(45deg, lightgrey 25%, transparent 25%, transparent 75%, lightgrey 75%) 0 0/2em 2em,linear-gradient(45deg, lightgrey 25%, white 25%, white 75%, lightgrey 75%) 1em 1em/2em 2em;box-shadow:0 0 0 1px silver}.picker_alpha .picker_selector,.picker_sample .picker_selector{background:none}.picker_editor input{font-family:monospace;padding:.2em .4em}.picker_sample::before{content:"";position:absolute;display:block;width:100%;height:100%;background:currentColor}.picker_arrow{position:absolute;z-index:-1}.picker_wrapper.popup{position:absolute;z-index:2;margin:1.5em}.picker_wrapper.popup,.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{background:#f2f2f2;box-shadow:0 0 10px 1px rgba(0,0,0,.4)}.picker_wrapper.popup .picker_arrow{width:3em;height:3em;margin:0}.picker_wrapper.popup .picker_arrow::before,.picker_wrapper.popup .picker_arrow::after{content:"";display:block;position:absolute;top:0;left:0;z-index:-99}.picker_wrapper.popup .picker_arrow::before{width:100%;height:100%;-webkit-transform:skew(45deg);transform:skew(45deg);-webkit-transform-origin:0 100%;transform-origin:0 100%}.picker_wrapper.popup .picker_arrow::after{width:150%;height:150%;box-shadow:none}.popup.popup_top{bottom:100%;left:0}.popup.popup_top .picker_arrow{bottom:0;left:0;-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.popup.popup_bottom{top:100%;left:0}.popup.popup_bottom .picker_arrow{top:0;left:0;-webkit-transform:rotate(90deg) scale(1, -1);transform:rotate(90deg) scale(1, -1)}.popup.popup_left{top:0;right:100%}.popup.popup_left .picker_arrow{top:0;right:0;-webkit-transform:scale(-1, 1);transform:scale(-1, 1)}.popup.popup_right{top:0;left:100%}.popup.popup_right .picker_arrow{top:0;left:0}';
  document.documentElement.firstElementChild.appendChild(style);
  Picker.StyleElement = style;
}
function getChrColor$1(chr) {
  if (chrColorMap$1[chr]) {
    return chrColorMap$1[chr];
  } else if (chrColorMap$1["chr" + chr]) {
    const color = chrColorMap$1["chr" + chr];
    chrColorMap$1[chr] = color;
    return color;
  } else {
    const color = randomRGB();
    chrColorMap$1[chr] = color;
    return color;
  }
}
function randomRGB(min, max) {
  var r = Math.round(Math.random() * 255).toString(10);
  var g = Math.round(Math.random() * 255).toString(10);
  var b = Math.round(Math.random() * 255).toString(10);
  return "rgb(" + r + "," + g + "," + b + ")";
}
const chrColorMap$1 = {
  "chrX": "rgb(204, 153, 0)",
  "chrY": "rgb(153, 204, 0",
  "chrUn": "rgb(50, 50, 50)",
  "chr1": "rgb(80, 80, 255)",
  "chrI": "rgb(139, 155, 187)",
  "chr2": "rgb(206, 61, 50)",
  "chrII": "rgb(206, 61, 50)",
  "chr2a": "rgb(216, 71, 60)",
  "chr2b": "rgb(226, 81, 70)",
  "chr3": "rgb(116, 155, 88)",
  "chrIII": "rgb(116, 155, 88)",
  "chr4": "rgb(240, 230, 133)",
  "chrIV": "rgb(240, 230, 133)",
  "chr5": "rgb(70, 105, 131)",
  "chr6": "rgb(186, 99, 56)",
  "chr7": "rgb(93, 177, 221)",
  "chr8": "rgb(128, 34, 104)",
  "chr9": "rgb(107, 215, 107)",
  "chr10": "rgb(213, 149, 167)",
  "chr11": "rgb(146, 72, 34)",
  "chr12": "rgb(131, 123, 141)",
  "chr13": "rgb(199, 81, 39)",
  "chr14": "rgb(213, 143, 92)",
  "chr15": "rgb(122, 101, 165)",
  "chr16": "rgb(228, 175, 105)",
  "chr17": "rgb(59, 27, 83)",
  "chr18": "rgb(205, 222, 183)",
  "chr19": "rgb(97, 42, 121)",
  "chr20": "rgb(174, 31, 99)",
  "chr21": "rgb(231, 199, 111)",
  "chr22": "rgb(90, 101, 94)",
  "chr23": "rgb(204, 153, 0)",
  "chr24": "rgb(153, 204, 0)",
  "chr25": "rgb(51, 204, 0)",
  "chr26": "rgb(0, 204, 51)",
  "chr27": "rgb(0, 204, 153)",
  "chr28": "rgb(0, 153, 204)",
  "chr29": "rgb(10, 71, 255)",
  "chr30": "rgb(71, 117, 255)",
  "chr31": "rgb(255, 194, 10)",
  "chr32": "rgb(255, 209, 71)",
  "chr33": "rgb(153, 0, 51)",
  "chr34": "rgb(153, 26, 0)",
  "chr35": "rgb(153, 102, 0)",
  "chr36": "rgb(128, 153, 0)",
  "chr37": "rgb(51, 153, 0)",
  "chr38": "rgb(0, 153, 26)",
  "chr39": "rgb(0, 153, 102)",
  "chr40": "rgb(0, 128, 153)",
  "chr41": "rgb(0, 51, 153)",
  "chr42": "rgb(26, 0, 153)",
  "chr43": "rgb(102, 0, 153)",
  "chr44": "rgb(153, 0, 128)",
  "chr45": "rgb(214, 0, 71)",
  "chr46": "rgb(255, 20, 99)",
  "chr47": "rgb(0, 214, 143)",
  "chr48": "rgb(20, 255, 177)"
};
class ChordSetManager {
  constructor(config) {
    this.tracks = [];
    this.chordSets = [];
  }
  addChordSet(chordSet) {
    this.chordSets = this.chordSets.filter((g) => g.name !== chordSet.name);
    this.chordSets.push(chordSet);
    let track = this.tracks.find((t) => chordSet.trackName === t.name);
    if (track) {
      track.chordSets = track.chordSets.filter((cs) => cs.name !== chordSet.name);
      track.chordSets.push(chordSet);
    }
    if (!track) {
      track = new IGVTrack(chordSet);
      this.tracks.push(track);
    }
  }
  clearChords() {
    this.tracks = [];
    this.chordSets = [];
  }
  getTrack(name2) {
    return this.tracks.find((t) => name2 === t.name);
  }
  getChordSet(name2) {
    return this.chordSets.find((cs) => name2 === cs.name);
  }
}
class IGVTrack {
  constructor(chordSet) {
    this.name = chordSet.trackName;
    this.color = chordSet.trackColor;
    this.visible = true;
    this.chordSets = [chordSet];
    this.id = guid$1();
  }
  get chords() {
    if (this.chordSets.length === 1) {
      return this.chordSets[0].chords;
    }
    const chords = [];
    for (let cs of this.chordSets) {
      for (let c of cs.chords) {
        chords.push(c);
      }
    }
    return chords;
  }
}
function guid$1() {
  return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
}
const EXP5 = Math.exp(5);
class CircularView {
  static isInstalled() {
    return window["JBrowseReactCircularGenomeView"] !== void 0 && window["React"] !== void 0 && window["ReactDOM"] !== void 0;
  }
  /**
   * Create a new CircularView
   *
   * @param parent
   * @param config - configuration options
   *   {
   *       assembly: {name: string, id: string, chromosomes: [{name: string, bpLength: integer, color: string}]
   *       onChordClick: function called upon chord click with chord feature as argument
   *   }
   */
  constructor(parent, config) {
    config = config || {};
    this.config = config;
    if (CircularView.isInstalled()) {
      this.parent = parent;
      this.groupByTrack = config.groupByTrack === true;
      this.chordManager = new ChordSetManager(config);
      const wrapper = document.createElement("div");
      wrapper.className = "igv-circview-container";
      parent.appendChild(wrapper);
      this.createControls(wrapper);
      this.resetControlPanel();
      const element = document.createElement("div");
      element.className = "igv-circview-circular-genome-view";
      wrapper.appendChild(element);
      this.container = element;
      if (config.assembly) {
        this.setAssembly(config.assembly);
      }
      this.width = config.width || 500;
      this.height = config.height || 500;
      this.setSize(this.width, this.height);
    } else {
      console.error("JBrowse circular view is not installed");
    }
  }
  createControls(parent) {
    const toolbarDiv = document.createElement("div");
    toolbarDiv.className = "igv-circview-toolbar";
    parent.appendChild(toolbarDiv);
    this.toolbar = toolbarDiv;
    const controlPanelDiv = document.createElement("div");
    controlPanelDiv.className = "igv-circview-track-panel";
    parent.appendChild(controlPanelDiv);
    this.controlPanel = controlPanelDiv;
    this.controlPanel.style.display = "none";
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "igv-circview-toolbar-button-container";
    this.toolbar.appendChild(buttonContainer);
    this.showControlsButton = document.createElement("div");
    this.showControlsButton.className = "igv-circview-button";
    buttonContainer.appendChild(this.showControlsButton);
    this.showControlsButton.innerText = "none" === this.controlPanel.style.display ? "Show Controls" : "Hide Controls";
    this.showControlsButton.addEventListener("click", (event) => {
      const panelRows = this.controlPanel.querySelectorAll("div");
      if (panelRows.length > 0) {
        if ("none" === this.controlPanel.style.display) {
          this.controlPanel.style.display = "flex";
          event.target.innerText = "Hide Controls";
        } else {
          this.controlPanel.style.display = "none";
          event.target.innerText = "Show Controls";
        }
      }
    });
    let button = document.createElement("div");
    button.className = "igv-circview-button";
    buttonContainer.appendChild(button);
    button.innerText = "Clear All";
    button.addEventListener("click", () => {
      this.clearChords();
    });
    if (false !== this.config.showCloseButton) {
      button = document.createElement("div");
      button.className = "igv-circview-button";
      buttonContainer.appendChild(button);
      button.innerText = "Close";
      button.addEventListener("click", () => {
        this.visible = false;
      });
    }
  }
  resetControlPanel() {
    this.controlPanel.innerHTML = "";
    this.controlPanel.appendChild(this.createGroupByCB());
    const chordSets = this.groupByTrack ? this.chordManager.tracks : this.chordManager.chordSets;
    for (let cs of chordSets) {
      this.addToControlPanel(cs);
    }
  }
  createGroupByCB() {
    const groupByCB = document.createElement("input");
    groupByCB.type = "checkbox";
    groupByCB.id = "groupByCB";
    groupByCB.style.width = "1.4em";
    groupByCB.style.height = "1.4em";
    groupByCB.checked = this.groupByTrack;
    groupByCB.onclick = (evt) => {
      this.groupByTrack = evt.target.checked;
      this.resetControlPanel();
      this.render();
    };
    const groupByLabel = document.createElement("label");
    groupByLabel.for = "groupByCB";
    groupByLabel.innerText = "Group by track";
    groupByLabel.style.color = "black";
    groupByLabel.style.paddingLeft = "10px";
    const trackPanelRow = document.createElement("div");
    trackPanelRow.style.width = "100%";
    trackPanelRow.style.paddingTop = "5px";
    trackPanelRow.style.paddingBottom = "5px";
    trackPanelRow.style.background = "rgb(216, 230, 234)";
    trackPanelRow.appendChild(groupByCB);
    trackPanelRow.appendChild(groupByLabel);
    return trackPanelRow;
  }
  addToControlPanel(chordSet) {
    const row = document.createElement("div");
    this.controlPanel.appendChild(row);
    const hideShowButton = document.createElement("div");
    hideShowButton.className = "igv-circview-button";
    row.appendChild(hideShowButton);
    hideShowButton.innerText = true === chordSet.visible ? "Hide" : "Show";
    hideShowButton.addEventListener("click", (event) => {
      if (true === chordSet.visible) {
        this.hideChordSet(chordSet.name);
        event.target.innerText = "Show";
      } else {
        this.showChordSet(chordSet.name);
        event.target.innerText = "Hide";
      }
    });
    const alphaSlider = document.createElement("input");
    const valueToAlpha = (value) => Math.exp(value / 200) / EXP5;
    const alphaToValue = (alpha) => 200 * Math.log(alpha * EXP5);
    const colorPickerButton = document.createElement("div");
    colorPickerButton.className = "igv-circview-button";
    colorPickerButton.innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;";
    row.appendChild(colorPickerButton);
    colorPickerButton.style.backgroundColor = setAlpha(chordSet.color, 1);
    const pickerConfig = {
      parent: colorPickerButton,
      popup: "right",
      editorFormat: "rgb",
      color: chordSet.color,
      onChange: ({ rgbaString }) => {
        colorPickerButton.style.backgroundColor = setAlpha(rgbaString, 1);
        this.setColor(chordSet.name, rgbaString);
        alphaSlider.value = alphaToValue(getAlpha(chordSet.color));
      }
    };
    const picker = new Picker(pickerConfig);
    alphaSlider.setAttribute("title", "Adjust transparency of arcs");
    alphaSlider.type = "range";
    alphaSlider.style.width = "100px";
    alphaSlider.style.marginRight = "10px";
    alphaSlider.setAttribute("class", "range");
    alphaSlider.setAttribute("min", "0");
    alphaSlider.setAttribute("max", "1000");
    alphaSlider.value = alphaToValue(getAlpha(chordSet.color));
    alphaSlider.oninput = () => {
      const v = valueToAlpha(alphaSlider.value);
      this.setColor(chordSet.name, setAlpha(chordSet.color, v));
      picker.setColor(chordSet.color);
    };
    row.appendChild(alphaSlider);
    const trackNameDive = document.createElement("div");
    trackNameDive.style.color = "black";
    row.appendChild(trackNameDive);
    trackNameDive.innerText = trackNameDive.title = chordSet.name;
  }
  /**
   * Reset view with a new set of chromosomes.
   *
   * @param igvGenome {name: string, id: string, chromosomes: [{name: string, bpLength: integer, color: string}
   */
  setAssembly(igvGenome) {
    const id = this.genomeId || guid$3();
    if (this.genomeId === id) {
      return;
    }
    this.chordManager.clearChords();
    this.genomeId = id;
    this.chrNames = new Set(igvGenome.chromosomes.map((chr) => shortChrName$1(chr.name)));
    const regions = [];
    const colors = [];
    for (let chr of igvGenome.chromosomes) {
      const shortName = shortChrName$1(chr.name);
      colors.push(chr.color || getChrColor$1(shortName));
      regions.push(
        {
          refName: shortName,
          uniqueId: shortName,
          start: 0,
          end: chr.bpLength
        }
      );
    }
    this.assembly = {
      name: igvGenome.name,
      sequence: {
        trackId: id,
        type: "ReferenceSequenceTrack",
        adapter: {
          type: "FromConfigSequenceAdapter",
          features: regions
        }
      },
      refNameColors: colors
    };
    this.render();
  }
  /**
   * Append or replace current set of chords to the global set or a specific track.
   *
   * @param newChords array of chord feature objects.  Example:
   * [
   *   {
   *     "uniqueId": "chr1:129763372-129763376_chr1:129806775-129806790",
   *     "color": "rgba(0, 0, 255, 0.1)",
   *     "refName": "1",
   *     "start": 129763372,
   *     "end": 129763376,
   *     "mate": {
   *       "refName": "2",
   *       "start": 129806775,
   *       "end": 129806790
   *     }
   *   }
   * ]
   * @param options {
   *     name: string,    // Track name
   *     color: string,   // Track color
   *     append: boolean  // Replace or append chords to current set.  Default is append (true)
   * }
   */
  addChords(newChords, options2 = {}) {
    const tmp = options2.name || options2.track || "*";
    const trackName = tmp.split(" ")[0].replaceAll("%20", " ");
    const chordSetName = tmp.replaceAll("%20", " ");
    const chordSet = {
      name: chordSetName,
      trackName,
      chords: newChords,
      color: options2.color || "black",
      trackColor: options2.trackColor || options2.color || "black",
      visible: true,
      id: options2.id || guid$3()
    };
    this.chordManager.addChordSet(chordSet);
    this.resetControlPanel();
    this.render();
  }
  /**
   * Set the nominal size of the view in pixels.  Size is reduced some aribtrary amount to account for borders and margins
   */
  setSize(width, height) {
    height = height || width;
    this.width = width;
    this.height = height;
    if (this.viewState) {
      const view = this.viewState.session.view;
      view.setWidth(width);
      view.setHeight(
        height
        /* this is the height of the area inside the border in pixels */
      );
      view.setBpPerPx(view.minBpPerPx);
    }
  }
  getSize() {
    return Math.min(this.width, this.height);
  }
  clearChords() {
    this.chordManager.clearChords();
    this.resetControlPanel();
    this.render();
  }
  clearSelection() {
    this.viewState.pluginManager.rootModel.session.clearSelection();
  }
  /**
   * Deprecated, use "visible" property
   */
  show() {
    this.parent.style.display = "block";
  }
  /**
   * Deprecated, use "visible" property
   */
  hide() {
    this.parent.style.display = "none";
  }
  get visible() {
    return this.parent.style.display !== "none";
  }
  set visible(isVisible) {
    this.parent.style.display = isVisible ? "block" : "none";
  }
  hideChordSet(trackName) {
    let cs = this.getChordSet(trackName);
    if (cs) {
      cs.visible = false;
      this.render();
    } else {
      console.warn(`No track with name: ${name}`);
    }
  }
  showChordSet(name2) {
    let cs = this.getChordSet(name2);
    if (cs) {
      cs.visible = true;
      this.render();
    } else {
      console.warn(`No track with name: ${name2}`);
    }
  }
  // showTrack(trackID) {
  //     let idx = this.tracks.findIndex(t => trackID === t.id)
  //     if (idx >= 0) {
  //         const track = this.tracks[idx]
  //         track.visible = true
  //         this.tracks.splice(idx, 1)   // Change z-order
  //         this.tracks.push(track)
  //         this.render()
  //     } else {
  //         console.warn(`No track with name: ${name}`)
  //     }
  // }
  // TODO -- remove corresponding row from track panel
  deleteTrack(trackID) {
    let idx = this.tracks.findIndex((t) => trackID === t.name);
    if (idx >= 0) {
      this.tracks.splice(idx, 1);
    }
    this.render();
  }
  getChordSet(name2) {
    return this.groupByTrack ? this.chordManager.getTrack(name2) : this.chordManager.getChordSet(name2);
  }
  setColor(name2, color) {
    const t = this.getChordSet(name2);
    if (t) {
      t.color = color;
      const trackID = t.id;
      for (let jbrowseTrack of this.viewState.config.tracks) {
        if (trackID === jbrowseTrack.trackId) {
          jbrowseTrack.displays[0].renderer.strokeColor.set(color);
          break;
        }
      }
    }
  }
  /**
   * The main render function.  Render here means build the React DOM.  Trying to change react state dynamically
   * has been buggy, so we completely rebuild the DOM ("render") on any state change.
   */
  render() {
    const {
      createViewState,
      JBrowseCircularGenomeView
    } = JBrowseReactCircularGenomeView;
    ReactDOM.unmountComponentAtNode(this.container);
    const visibleChordSets = (this.groupByTrack ? this.chordManager.tracks : this.chordManager.chordSets).filter((t) => t.visible);
    const jbrowseTracks = [];
    const colors = [];
    for (let chordSet of visibleChordSets) {
      jbrowseTracks.push({
        trackId: chordSet.id,
        name: chordSet.name,
        assemblyNames: ["forIGV"],
        type: "VariantTrack",
        adapter: {
          type: "FromConfigAdapter",
          features: chordSet.chords
        }
      });
      colors.push(chordSet.color);
    }
    this.viewState = createViewState({
      assembly: this.assembly,
      tracks: jbrowseTracks
    });
    for (let i = 0; i < visibleChordSets.length; i++) {
      this.viewState.config.tracks[i].displays[0].renderer.strokeColor.set(colors[i]);
    }
    this.element = React.createElement(JBrowseCircularGenomeView, { viewState: this.viewState });
    this.setSize(this.width, this.height);
    ReactDOM.render(this.element, this.container);
    const onChordClick = this.config.onChordClick || defaultOnChordClick;
    for (let i = 0; i < visibleChordSets.length; i++) {
      this.viewState.session.view.showTrack(this.viewState.config.tracks[i].trackId);
      if (onChordClick) {
        this.viewState.pluginManager.jexl.addFunction("onChordClick", onChordClick);
        this.viewState.config.tracks[i].displays[0].onChordClick.set(
          "jexl:onChordClick(feature, track, pluginManager)"
        );
      }
    }
  }
}
function setAlpha(rgba, alpha) {
  const [a, b, c, ignore] = rgba.split(",");
  return `${a},${b},${c},${alpha})`;
}
function getAlpha(rgba) {
  if (rgba.startsWith("rgba(")) {
    return Number(rgba.split(",")[3].replace(")", ""));
  } else {
    return 1;
  }
}
function shortChrName$1(chrName) {
  return chrName.startsWith("chr") ? chrName.substring(3) : chrName;
}
function defaultOnChordClick(feature2, chordTrack, pluginManager) {
  console.log(feature2);
}
function guid$3() {
  return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
}
function embedCSS$1() {
  const css = '.igv-circview-container {\n  width: fit-content;\n  height: fit-content;\n  box-sizing: content-box;\n  color: dimgray;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  background-color: white;\n  border-color: dimgray;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n\n.igv-circview-toolbar {\n  position: relative;\n  width: 100%;\n  height: 32px;\n  background-color: lightgrey;\n  border-bottom-style: solid;\n  border-bottom-color: dimgray;\n  border-bottom-width: thin;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.igv-circview-toolbar-button-container {\n  height: 100%;\n  width: fit-content;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-circview-toolbar-button-container > div {\n  margin: 4px;\n}\n\n.igv-circview-track-panel {\n  z-index: 1024;\n  position: absolute;\n  top: 33px;\n  left: 0;\n  width: 100%;\n  height: fit-content;\n  border-bottom-style: solid;\n  border-bottom-color: dimgray;\n  border-bottom-width: thin;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n}\n.igv-circview-track-panel > div {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-circview-track-panel > div > div {\n  margin: 4px;\n}\n\n.igv-circview-swatch-button {\n  cursor: pointer;\n  padding: 5px;\n  width: 8px;\n  height: 8px;\n  border: 1px solid #8d8b8b;\n  border-radius: 16px;\n}\n\n.igv-circview-button {\n  cursor: pointer;\n  padding: 5px;\n  color: #444;\n  vertical-align: middle;\n  text-align: center;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  border: 1px solid #8d8b8b;\n  border-radius: 4px;\n  background: #efefef;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.2);\n}\n\n.igv-circview-button:hover {\n  background: #efefef;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.6);\n}\n\n.igv-circview-button:active {\n  color: #007bff;\n  box-shadow: 0 0 5px -1px rgba(0, 0, 0, 0.6);\n}\n\n/*# sourceMappingURL=circular-view.css.map */\n';
  const style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css;
  document.head.insertBefore(style, document.head.childNodes[document.head.childNodes.length - 1]);
}
if (typeof document !== "undefined") {
  let stylesheetExists = function(stylesheetName) {
    for (let ss of document.styleSheets) {
      ss = ss.href ? ss.href.replace(/^.*[\\\/]/, "") : "";
      if (ss === stylesheetName) {
        return true;
      }
    }
    return false;
  };
  if (!stylesheetExists("circular-view.css")) {
    embedCSS$1();
  }
}
const MINIMUM_SV_LENGTH = 1e6;
const shortChrName = (chrName) => {
  return chrName.startsWith("chr") ? chrName.substring(3) : chrName;
};
const makePairedAlignmentChords = (alignments) => {
  const chords = [];
  for (let a of alignments) {
    if (a.paired) {
      if (a.firstAlignment && a.secondAlignment) {
        chords.push({
          uniqueId: a.readName,
          refName: shortChrName(a.firstAlignment.chr),
          start: a.firstAlignment.start,
          end: a.firstAlignment.end,
          mate: {
            refName: shortChrName(a.secondAlignment.chr),
            start: a.secondAlignment.start,
            end: a.secondAlignment.end
          }
        });
      }
    } else {
      const mate = a.mate;
      if (mate && mate.chr && mate.position) {
        chords.push({
          uniqueId: a.readName,
          refName: shortChrName(a.chr),
          start: a.start,
          end: a.end,
          mate: {
            refName: shortChrName(mate.chr),
            start: mate.position - 1,
            end: mate.position
          }
        });
      }
    }
  }
  return chords;
};
const makeSupplementalAlignmentChords = (alignments) => {
  const makeChords = (a) => {
    const sa = a.tags()["SA"];
    const supAl = createSupplementaryAlignments(sa);
    let n = 0;
    for (let s of supAl) {
      if (s.start !== a.start) {
        chords.push({
          uniqueId: `${a.readName}_${n++}`,
          refName: shortChrName(a.chr),
          start: a.start,
          end: a.end,
          mate: {
            refName: shortChrName(s.chr),
            start: s.start,
            end: s.start + s.lenOnRef
          }
        });
      }
    }
  };
  const chords = [];
  for (let a of alignments) {
    if (a.paired) {
      makeChords(a.firstAlignment);
      if (a.secondAlignment) {
        makeChords(a.secondAlignment);
      }
    } else {
      makeChords(a);
    }
  }
  return chords;
};
const makeBedPEChords = (features) => {
  return features.map((v) => {
    const f = v._f || v;
    return {
      uniqueId: `${f.chr1}:${f.start1}-${f.end1}_${f.chr2}:${f.start2}-${f.end2}`,
      refName: shortChrName(f.chr1),
      start: f.start1,
      end: f.end1,
      mate: {
        refName: shortChrName(f.chr2),
        start: f.start2,
        end: f.end2
      }
    };
  });
};
const makeVCFChords = (features) => {
  const svFeatures = features.filter((v) => {
    const f = v._f || v;
    const isLargeEnough = f.info && f.info.CHR2 && f.info.END && (f.info.CHR2 !== f.chr || Math.abs(Number.parseInt(f.info.END) - f.pos) > MINIMUM_SV_LENGTH);
    return isLargeEnough;
  });
  return svFeatures.map((v) => {
    const f = v._f || v;
    const pos2 = Number.parseInt(f.info.END);
    const start2 = pos2 - 100;
    const end2 = pos2 + 100;
    return {
      uniqueId: `${f.chr}:${f.start}-${f.end}_${f.info.CHR2}:${f.info.END}`,
      refName: shortChrName(f.chr),
      start: f.start,
      end: f.end,
      mate: {
        refName: shortChrName(f.info.CHR2),
        start: start2,
        end: end2
      }
    };
  });
};
function makeCircViewChromosomes(genome) {
  const regions = [];
  const colors = [];
  for (let chrName of genome.wgChromosomeNames) {
    const chr = genome.getChromosome(chrName);
    colors.push(getChrColor(chr.name));
    regions.push(
      {
        name: chr.name,
        bpLength: chr.bpLength
      }
    );
  }
  return regions;
}
function sendChords(chords, track, refFrame, alpha) {
  const baseColor = track.color || "rgb(0,0,255)";
  const chordSetColor = IGVColor.addAlpha("all" === refFrame.chr ? baseColor : getChrColor(refFrame.chr), alpha);
  const trackColor = IGVColor.addAlpha(baseColor, alpha);
  const encodedName = track.name.replaceAll(" ", "%20");
  const chordSetName = "all" === refFrame.chr ? encodedName : `${encodedName}  ${refFrame.chr}:${refFrame.start}-${refFrame.end}`;
  track.browser.circularView.addChords(chords, { track: chordSetName, color: chordSetColor, trackColor });
  if (!track.browser.circularViewVisible) track.browser.circularViewVisible = true;
}
function createCircularView(el, browser) {
  const circularView = new CircularView(el, {
    onChordClick: (feature2, chordTrack, pluginManager) => {
      const f1 = feature2.data;
      const f2 = f1.mate;
      addFrameForFeature(f1);
      addFrameForFeature(f2);
      function addFrameForFeature(feature3) {
        feature3.chr = browser.genome.getChromosomeName(feature3.refName);
        let frameFound = false;
        for (let referenceFrame of browser.referenceFrameList) {
          const l = Locus.fromLocusString(referenceFrame.getLocusString());
          if (l.contains(feature3)) {
            frameFound = true;
            break;
          } else if (l.overlaps(feature3)) {
            referenceFrame.extend(feature3);
            frameFound = true;
            break;
          }
        }
        if (!frameFound) {
          const flanking = 2e3;
          const center = (feature3.start + feature3.end) / 2;
          browser.addMultiLocusPanel(feature3.chr, center - flanking, center + flanking);
        }
      }
    }
  });
  return circularView;
}
class PairedEndStats {
  constructor(alignments, { minTLENPercentile, maxTLENPercentile }) {
    this.totalCount = 0;
    this.frCount = 0;
    this.rfCount = 0;
    this.ffCount = 0;
    this.sumF = 0;
    this.sumF2 = 0;
    this.lp = minTLENPercentile === void 0 ? 0.1 : minTLENPercentile;
    this.up = maxTLENPercentile === void 0 ? 99.5 : maxTLENPercentile;
    this.isizes = [];
    this.compute(alignments);
  }
  compute(alignments) {
    for (let alignment of alignments) {
      if (alignment.isProperPair()) {
        var tlen = Math.abs(alignment.fragmentLength);
        this.sumF += tlen;
        this.sumF2 += tlen * tlen;
        this.isizes.push(tlen);
        var po = alignment.pairOrientation;
        if (typeof po === "string" && po.length === 4) {
          var tmp = "" + po.charAt(0) + po.charAt(2);
          switch (tmp) {
            case "FF":
            case "RR":
              this.ffCount++;
              break;
            case "FR":
              this.frCount++;
              break;
            case "RF":
              this.rfCount++;
          }
        }
        this.totalCount++;
      }
    }
    if (this.ffCount / this.totalCount > 0.9) this.orienation = "ff";
    else if (this.frCount / this.totalCount > 0.9) this.orienation = "fr";
    else if (this.rfCount / this.totalCount > 0.9) this.orienation = "rf";
    this.minTLEN = this.lp === 0 ? 0 : percentile(this.isizes, this.lp);
    this.maxTLEN = percentile(this.isizes, this.up);
  }
}
function percentile(array, p) {
  if (array.length === 0) return void 0;
  var k = Math.floor(array.length * (p / 100));
  array.sort(function(a, b) {
    return a - b;
  });
  return array[k];
}
const GtexUtils = {
  getTissueInfo: function(datasetId, baseURL) {
    datasetId = datasetId || "gtex_v8";
    baseURL = baseURL || "https://gtexportal.org/rest/v1";
    let url = baseURL + "/dataset/tissueInfo?datasetId=" + datasetId;
    return igvxhr.loadJson(url, {});
  },
  //https://gtexportal.org/rest/v1/association/singleTissueEqtlByLocation?chromosome=7&start=98358766&end=101523798&tissueName=Liver&datasetId=gtex_v7
  //https://gtexportal.org/rest/v1/association/singleTissueEqtlByLocation?chromosome=7&start=98358766&end=101523798&tissueSiteDetailId=Liver&datasetId=gtex_v8
  trackConfiguration: function(tissueSummary, baseURL) {
    baseURL = baseURL || "https://gtexportal.org/rest/v1";
    return {
      type: "eqtl",
      sourceType: "gtex-ws",
      url: baseURL + "/association/singleTissueEqtlByLocation",
      tissueSiteDetailId: tissueSummary.tissueSiteDetailId,
      name: tissueSummary.tissueSiteDetailId.split("_").join(" "),
      visibilityWindow: 25e4
    };
  }
};
function calculateFeatureCoordinates(feature2, bpStart, xScale) {
  let px = (feature2.start - bpStart) / xScale;
  let px1 = (feature2.end - bpStart) / xScale;
  let pw = px1 - px;
  if (pw < 3) {
    pw = 3;
    px -= 1.5;
  }
  return {
    px,
    px1,
    pw
  };
}
function renderFeature(feature2, bpStart, xScale, pixelHeight, ctx2, options2) {
  try {
    ctx2.save();
    ctx2.fillStyle = this.color;
    ctx2.strokeStyle = this.color;
    const color = this.getColorForFeature(feature2);
    ctx2.fillStyle = color;
    ctx2.strokeStyle = color;
    let h;
    let py;
    if (this.displayMode === "SQUISHED" && feature2.row !== void 0) {
      h = this.featureHeight / 2;
      py = this.margin + this.squishedRowHeight * feature2.row;
    } else if (this.displayMode === "EXPANDED" && feature2.row !== void 0) {
      h = this.featureHeight;
      py = this.margin + this.expandedRowHeight * feature2.row;
    } else {
      h = this.featureHeight;
      py = this.margin;
    }
    const pixelWidth = options2.pixelWidth;
    const cy = py + h / 2;
    const h2 = h / 2;
    const py2 = cy - h2 / 2;
    const exonCount = feature2.exons ? feature2.exons.length : 0;
    const coord = calculateFeatureCoordinates(feature2, bpStart, xScale);
    const step = this.arrowSpacing;
    const direction = feature2.strand === "+" ? 1 : feature2.strand === "-" ? -1 : 0;
    if (exonCount === 0) {
      const xLeft = Math.max(0, coord.px);
      const xRight = Math.min(pixelWidth, coord.px1);
      const width = xRight - xLeft;
      ctx2.fillRect(xLeft, py, width, h);
      if (direction !== 0) {
        ctx2.fillStyle = "white";
        ctx2.strokeStyle = "white";
        for (let x = xLeft + step / 2; x < xRight; x += step) {
          IGVGraphics.strokeLine(ctx2, x - direction * 2, cy - 2, x, cy);
          IGVGraphics.strokeLine(ctx2, x - direction * 2, cy + 2, x, cy);
        }
        ctx2.fillStyle = color;
        ctx2.strokeStyle = color;
      }
    } else {
      IGVGraphics.strokeLine(ctx2, coord.px + 1, cy, coord.px1 - 1, cy);
      const xLeft = Math.max(0, coord.px) + step / 2;
      const xRight = Math.min(pixelWidth, coord.px1);
      for (let x = xLeft; x < xRight; x += step) {
        IGVGraphics.strokeLine(ctx2, x - direction * 2, cy - 2, x, cy);
        IGVGraphics.strokeLine(ctx2, x - direction * 2, cy + 2, x, cy);
      }
      for (let e = 0; e < exonCount; e++) {
        const exon = feature2.exons[e];
        let ePx = Math.round((exon.start - bpStart) / xScale);
        let ePx1 = Math.round((exon.end - bpStart) / xScale);
        let ePw = Math.max(1, ePx1 - ePx);
        let ePxU;
        if (ePx + ePw < 0) {
          continue;
        }
        if (ePx > pixelWidth) {
          break;
        }
        if (exon.utr) {
          ctx2.fillRect(ePx, py2, ePw, h2);
        } else {
          if (exon.cdStart) {
            ePxU = Math.round((exon.cdStart - bpStart) / xScale);
            ctx2.fillRect(ePx, py2, ePxU - ePx, h2);
            ePw -= ePxU - ePx;
            ePx = ePxU;
          }
          if (exon.cdEnd) {
            ePxU = Math.round((exon.cdEnd - bpStart) / xScale);
            ctx2.fillRect(ePxU, py2, ePx1 - ePxU, h2);
            ePw -= ePx1 - ePxU;
            ePx1 = ePxU;
          }
          ePw = Math.max(ePw, 1);
          ctx2.fillRect(ePx, py, ePw, h);
          if (ePw > step + 5 && direction !== 0) {
            ctx2.fillStyle = "white";
            ctx2.strokeStyle = "white";
            for (let x = ePx + step / 2; x < ePx1; x += step) {
              IGVGraphics.strokeLine(ctx2, x - direction * 2, cy - 2, x, cy);
              IGVGraphics.strokeLine(ctx2, x - direction * 2, cy + 2, x, cy);
            }
            ctx2.fillStyle = color;
            ctx2.strokeStyle = color;
          }
        }
      }
    }
    if (options2.drawLabel && this.displayMode !== "SQUISHED") {
      renderFeatureLabel.call(this, ctx2, feature2, coord.px, coord.px1, py, options2.referenceFrame, options2);
    }
  } finally {
    ctx2.restore();
  }
}
function renderFeatureLabel(ctx2, feature2, featureX, featureX1, featureY, referenceFrame, options2) {
  try {
    ctx2.save();
    let name2 = feature2.name;
    if (name2 === void 0 && feature2.gene) name2 = feature2.gene.name;
    if (name2 === void 0) name2 = feature2.id || feature2.ID;
    if (!name2 || name2 === ".") return;
    let centerX = (featureX + featureX1) / 2;
    let transform;
    if (this.displayMode === "COLLAPSED" && this.labelDisplayMode === "SLANT") {
      transform = { rotate: { angle: 45 } };
    }
    const labelY = getFeatureLabelY(featureY, transform);
    let color = this.getColorForFeature(feature2);
    let geneColor;
    let gtexSelection = false;
    if (referenceFrame.selection && GtexUtils.gtexLoaded) {
      gtexSelection = true;
      geneColor = referenceFrame.selection.colorForGene(name2);
    }
    const geneFontStyle = {
      textAlign: "SLANT" === this.labelDisplayMode ? void 0 : "center",
      fillStyle: geneColor || color,
      strokeStyle: geneColor || color
    };
    const textBox = ctx2.measureText(name2);
    const xleft = centerX - textBox.width / 2;
    const xright = centerX + textBox.width / 2;
    const lastLabelX = options2.rowLastLabelX[feature2.row] || -Number.MAX_SAFE_INTEGER;
    if (options2.labelAllFeatures || xleft > lastLabelX || gtexSelection) {
      options2.rowLastLabelX[feature2.row] = xright;
      if ("y" === options2.axis) {
        ctx2.save();
        IGVGraphics.labelTransformWithContext(ctx2, centerX);
        IGVGraphics.fillText(ctx2, name2, centerX, labelY, geneFontStyle, transform);
        ctx2.restore();
      } else {
        IGVGraphics.fillText(ctx2, name2, centerX, labelY, geneFontStyle, transform);
      }
    }
  } finally {
    ctx2.restore();
  }
}
function getFeatureLabelY(featureY, transform) {
  return transform ? featureY + 20 : featureY + 25;
}
const codingNonSynonSet = /* @__PURE__ */ new Set(["nonsense", "missense", "stop-loss", "frameshift", "cds-indel"]);
const codingSynonSet = /* @__PURE__ */ new Set(["coding-synon"]);
const spliceSiteSet = /* @__PURE__ */ new Set(["splice-3", "splice-5"]);
const untranslatedSet = /* @__PURE__ */ new Set(["untranslated-5", "untranslated-3"]);
function renderSnp(snp, bpStart, xScale, pixelHeight, ctx2) {
  var coord = calculateFeatureCoordinates(snp, bpStart, xScale), py = this.margin, h, colorArrLength = this.snpColors.length, colorPriority;
  h = this.displayMode === "squished" ? this.squishedRowHeight : this.expandedRowHeight;
  switch (this.colorBy) {
    case "function":
      colorPriority = colorByFunc(snp.func);
      break;
    case "class":
      colorPriority = colorByClass(snp["class"]);
  }
  ctx2.fillStyle = this.snpColors[colorPriority];
  ctx2.fillRect(coord.px, py, coord.pw, h);
  function colorByFunc(theFunc) {
    var priorities;
    var funcArray = theFunc.split(",");
    priorities = funcArray.map(function(func) {
      if (codingNonSynonSet.has(func) || spliceSiteSet.has(func)) {
        return colorArrLength - 1;
      } else if (codingSynonSet.has(func)) {
        return colorArrLength - 2;
      } else if (untranslatedSet.has(func)) {
        return colorArrLength - 3;
      } else {
        return 0;
      }
    });
    return priorities.reduce(function(a, b) {
      return Math.max(a, b);
    });
  }
  function colorByClass(cls) {
    if (cls === "deletion") {
      return colorArrLength - 1;
    } else if (cls === "mnp") {
      return colorArrLength - 2;
    } else if (cls === "microsatellite" || cls === "named") {
      return colorArrLength - 3;
    } else {
      return 0;
    }
  }
}
function renderFusionJuncSpan(feature2, bpStart, xScale, pixelHeight, ctx2) {
  const rowHeight = this.displayMode === "EXPANDED" ? this.expandedRowHeight : this.squishedRowHeight;
  let py = this.margin;
  if (this.displayMode !== "COLLAPSED" && feature2.row !== void 0) {
    py += feature2.row * rowHeight;
  }
  const cy = py + 0.5 * rowHeight;
  const topY = cy - 0.5 * rowHeight;
  const bottomY = cy + 0.5 * rowHeight;
  const junctionLeftPx = Math.round((feature2.junction_left - bpStart) / xScale);
  const junctionRightPx = Math.round((feature2.junction_right - bpStart) / xScale);
  ctx2.beginPath();
  ctx2.moveTo(junctionLeftPx, cy);
  ctx2.bezierCurveTo(junctionLeftPx, topY, junctionRightPx, topY, junctionRightPx, cy);
  ctx2.lineWidth = 1 + Math.log(feature2.num_junction_reads) / Math.log(2);
  ctx2.strokeStyle = "blue";
  ctx2.stroke();
  const spanningCoords = feature2.spanning_frag_coords;
  for (let i = 0; i < spanningCoords.length; i++) {
    const spanningInfo = spanningCoords[i];
    const spanLeftPx = Math.round((spanningInfo.left - bpStart) / xScale);
    const spanRightPx = Math.round((spanningInfo.right - bpStart) / xScale);
    ctx2.beginPath();
    ctx2.moveTo(spanLeftPx, cy);
    ctx2.bezierCurveTo(spanLeftPx, bottomY, spanRightPx, bottomY, spanRightPx, cy);
    ctx2.lineWidth = 1;
    ctx2.strokeStyle = "purple";
    ctx2.stroke();
  }
}
const DEFAULT_COLOR$2 = "rgb(0, 0, 150)";
class FeatureTrack extends TrackBase {
  static defaults = {
    type: "annotation",
    maxRows: 1e3,
    // protects against pathological feature packing cases (# of rows of overlapping feaures)
    displayMode: "EXPANDED",
    // COLLAPSED | EXPANDED | SQUISHED
    margin: 10,
    featureHeight: 14,
    autoHeight: false,
    useScore: false
  };
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.labelDisplayMode = config.labelDisplayMode;
    if (config._featureSource) {
      this.featureSource = config._featureSource;
      delete config._featureSource;
    } else {
      this.featureSource = config.featureSource ? config.featureSource : FeatureSource(config, this.browser.genome);
    }
    if ("FusionJuncSpan" === config.type) {
      this.render = config.render || renderFusionJuncSpan;
      this.squishedRowHeight = config.squishedRowHeight || 50;
      this.expandedRowHeight = config.expandedRowHeight || 50;
      this.height = config.height || this.margin + 2 * this.expandedRowHeight;
    } else if ("snp" === config.type) {
      this.render = config.render || renderSnp;
      this.snpColors = ["rgb(0,0,0)", "rgb(0,0,255)", "rgb(0,255,0)", "rgb(255,0,0)"];
      this.colorBy = "function";
      this.expandedRowHeight = config.expandedRowHeight || 10;
      this.squishedRowHeight = config.squishedRowHeight || 5;
      this.height = config.height || 30;
    } else {
      this.render = config.render || renderFeature;
      this.arrowSpacing = 30;
      monitorTrackDrag(this);
      this.squishedRowHeight = config.squishedRowHeight || 15;
      this.expandedRowHeight = config.expandedRowHeight || 30;
      this.height = config.height || this.margin + 2 * this.expandedRowHeight;
      if (config.colorBy) {
        if (config.colorBy.field) {
          config.colorTable = config.colorBy.pallete || config.colorBy.palette;
          config.colorBy = config.colorBy.field;
        }
        this.colorBy = config.colorBy;
        if (config.colorTable) {
          this.colorTable = new ColorTable(config.colorTable);
        } else {
          this.colorTable = new PaletteColorTable("Set1");
        }
      }
    }
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
    }
    if (this.header) {
      this.setTrackProperties(this.header);
    }
    if (this.visibilityWindow === void 0 && typeof this.featureSource.defaultVisibilityWindow === "function") {
      this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
    }
    return this;
  }
  get supportsWholeGenome() {
    if (this.config.supportsWholeGenome !== void 0) {
      return this.config.supportsWholeGenome;
    } else if (this.featureSource && typeof this.featureSource.supportsWholeGenome === "function") {
      return this.featureSource.supportsWholeGenome();
    } else {
      if (this.visibilityWindow === void 0 && (this.config.indexed === false || !this.config.indexURL)) {
        return true;
      }
    }
  }
  async getFeatures(chr, start, end, bpPerPixel) {
    const visibilityWindow = this.visibilityWindow;
    return this.featureSource.getFeatures({ chr, start, end, bpPerPixel, visibilityWindow });
  }
  /**
   * The required height in pixels required for the track content.   This is not the visible track height, which
   * can be smaller (with a scrollbar) or larger.
   *
   * @param features
   * @returns {*}
   */
  computePixelHeight(features) {
    if (this.displayMode === "COLLAPSED") {
      return this.margin + this.expandedRowHeight;
    } else {
      let maxRow = 0;
      if (features && typeof features.forEach === "function") {
        for (let feature2 of features) {
          if (feature2.row && feature2.row > maxRow) {
            maxRow = feature2.row;
          }
        }
      }
      const height = this.margin + (maxRow + 1) * ("SQUISHED" === this.displayMode ? this.squishedRowHeight : this.expandedRowHeight);
      return height;
    }
  }
  draw(options2) {
    const featureList = options2.features;
    const ctx2 = options2.context;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    if (!this.config.isMergedTrack) {
      IGVGraphics.fillRect(ctx2, 0, options2.pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    }
    if (featureList) {
      const rowFeatureCount = [];
      options2.rowLastX = [];
      options2.rowLastLabelX = [];
      for (let feature2 of featureList) {
        if (feature2.start > bpStart && feature2.end < bpEnd) {
          const row = this.displayMode === "COLLAPSED" ? 0 : feature2.row || 0;
          if (rowFeatureCount[row] === void 0) {
            rowFeatureCount[row] = 1;
          } else {
            rowFeatureCount[row]++;
          }
          options2.rowLastX[row] = -Number.MAX_SAFE_INTEGER;
          options2.rowLastLabelX[row] = -Number.MAX_SAFE_INTEGER;
        }
      }
      const maxFeatureCount = Math.max(1, Math.max(...rowFeatureCount));
      const pixelsPerFeature = pixelWidth / maxFeatureCount;
      let lastPxEnd = [];
      for (let feature2 of featureList) {
        if (feature2.end < bpStart) continue;
        if (feature2.start > bpEnd) break;
        const row = this.displayMode === "COLLAPSED" ? 0 : feature2.row;
        options2.drawLabel = options2.labelAllFeatures || pixelsPerFeature > 10;
        const pxEnd = Math.ceil((feature2.end - bpStart) / bpPerPixel);
        const last = lastPxEnd[row];
        if (!last || pxEnd > last) {
          this.render.call(this, feature2, bpStart, bpPerPixel, pixelHeight, ctx2, options2);
          const pxStart = Math.floor((feature2.start - bpStart) / bpPerPixel);
          if (last && pxStart - last <= 0) {
            ctx2.globalAlpha = 0.5;
            IGVGraphics.strokeLine(ctx2, pxStart, 0, pxStart, pixelHeight, { "strokeStyle": "rgb(255, 255, 255)" });
            ctx2.globalAlpha = 1;
          }
          lastPxEnd[row] = pxEnd;
        }
      }
    } else {
      console.log("No feature list");
    }
  }
  clickedFeatures(clickState) {
    const y = clickState.y - this.margin;
    const allFeatures = super.clickedFeatures(clickState);
    let row;
    switch (this.displayMode) {
      case "SQUISHED":
        row = Math.floor(y / this.squishedRowHeight);
        break;
      case "EXPANDED":
        row = Math.floor(y / this.expandedRowHeight);
        break;
      default:
        row = void 0;
    }
    return allFeatures.filter(function(feature2) {
      return row === void 0 || feature2.row === void 0 || row === feature2.row;
    });
  }
  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    const genomicLocation = clickState.genomicLocation;
    const data = [];
    for (let feature2 of features) {
      const f = feature2._f || feature2;
      const featureData = typeof f.popupData === "function" ? f.popupData(genomicLocation) : this.extractPopupData(f);
      if (featureData) {
        if (data.length > 0) {
          data.push("<hr/><hr/>");
        }
        const infoURL = this.infoURL || this.config.infoURL;
        for (let fd of featureData) {
          data.push(fd);
          if (infoURL && fd.name && fd.name.toLowerCase() === "name" && fd.value && isString$2(fd.value) && !fd.value.startsWith("<")) {
            const href = infoURL.replace("$$", feature2.name);
            fd.value = `<a target=_blank href=${href}>${fd.value}</a>`;
          }
        }
        const isGFF = "gff" === this.config.format || "gff3" === this.config.format || "gtf" === this.config.format;
        if (f.exons) {
          for (let i = 0; i < f.exons.length; i++) {
            const exon = f.exons[i];
            if (genomicLocation >= exon.start && genomicLocation <= exon.end) {
              const exonNumber = isGFF ? exon.number : f.strand === "-" ? f.exons.length - i : i + 1;
              if (exonNumber) {
                data.push("<hr/>");
                data.push({ name: "Exon Number", value: exonNumber });
              }
              break;
            }
          }
        }
      }
    }
    return data;
  }
  menuItemList() {
    const menuItems = [];
    if (this.render === renderSnp) {
      menuItems.push("<hr/>");
      for (let colorScheme of ["function", "class"]) {
        menuItems.push({
          object: $$1(createCheckbox$2("Color by " + colorScheme, colorScheme === this.colorBy)),
          click: () => {
            this.colorBy = colorScheme;
            this.trackView.repaintViews();
          }
        });
      }
    }
    menuItems.push("<hr/>");
    for (let displayMode of ["COLLAPSED", "SQUISHED", "EXPANDED"]) {
      const lut = {
        "COLLAPSED": "Collapse",
        "SQUISHED": "Squish",
        "EXPANDED": "Expand"
      };
      menuItems.push(
        {
          object: $$1(createCheckbox$2(lut[displayMode], displayMode === this.displayMode)),
          click: () => {
            this.displayMode = displayMode;
            this.config.displayMode = displayMode;
            this.trackView.checkContentHeight();
            this.trackView.repaintViews();
          }
        }
      );
    }
    return menuItems;
  }
  contextMenuItemList(clickState) {
    const features = this.clickedFeatures(clickState);
    if (void 0 === features || 0 === features.length) {
      return void 0;
    }
    if (features.length > 1) {
      features.sort((a, b) => b.end - b.start - (a.end - a.start));
    }
    const f = features[0];
    if (f.end - f.start <= 1e6) {
      const list = [{
        label: "View feature sequence",
        click: async () => {
          let seq = await this.browser.genome.getSequence(f.chr, f.start, f.end);
          if (!seq) {
            seq = "Unknown sequence";
          } else if (f.strand === "-") {
            seq = reverseComplementSequence(seq);
          }
          this.browser.alert.present(seq);
        }
      }];
      if (isSecureContext() && navigator.clipboard !== void 0) {
        list.push(
          {
            label: "Copy feature sequence",
            click: async () => {
              let seq = await this.browser.genome.getSequence(f.chr, f.start, f.end);
              if (!seq) {
                seq = "Unknown sequence";
              } else if (f.strand === "-") {
                seq = reverseComplementSequence(seq);
              }
              try {
                await navigator.clipboard.writeText(seq);
              } catch (e) {
                console.error(e);
                this.browser.alert.present(`error copying sequence to clipboard ${e}`);
              }
            }
          }
        );
      }
      list.push("<hr/>");
      return list;
    } else {
      return void 0;
    }
  }
  description() {
    if (renderSnp === this.render) {
      let desc = "<html>" + this.name + "<hr/>";
      desc += "<em>Color By Function:</em><br>";
      desc += '<span style="color:red">Red</span>: Coding-Non-Synonymous, Splice Site<br>';
      desc += '<span style="color:green">Green</span>: Coding-Synonymous<br>';
      desc += '<span style="color:blue">Blue</span>: Untranslated<br>';
      desc += '<span style="color:black">Black</span>: Intron, Locus, Unknown<br><br>';
      desc += "<em>Color By Class:</em><br>";
      desc += '<span style="color:red">Red</span>: Deletion<br>';
      desc += '<span style="color:green">Green</span>: MNP<br>';
      desc += '<span style="color:blue">Blue</span>: Microsatellite, Named<br>';
      desc += '<span style="color:black">Black</span>: Indel, Insertion, SNP';
      desc += "</html>";
      return desc;
    } else {
      return super.description();
    }
  }
  /**
   * Return color for feature.
   * @param feature
   * @returns {string}
   */
  getColorForFeature(feature2) {
    let color;
    if (this.altColor && "-" === feature2.strand) {
      color = typeof this.altColor === "function" ? this.altColor(feature2) : this.altColor;
    } else if (this.color) {
      color = typeof this.color === "function" ? this.color(feature2) : this.color;
    } else if (this.colorBy) {
      const value = feature2.getAttributeValue ? feature2.getAttributeValue(this.colorBy) : feature2[this.colorBy];
      color = this.colorTable.getColor(value);
    } else if (feature2.color) {
      color = feature2.color;
    }
    if (!color) {
      color = DEFAULT_COLOR$2;
    }
    if (feature2.alpha && feature2.alpha !== 1) {
      color = IGVColor.addAlpha(color, feature2.alpha);
    } else if (this.useScore && feature2.score && !Number.isNaN(feature2.score)) {
      const min = this.config.min ? this.config.min : this.viewLimitMin ? this.viewLimitMin : 0;
      const max = this.config.max ? this.config.max : this.viewLimitMax ? this.viewLimitMax : 1e3;
      const alpha = getAlpha2(min, max, feature2.score);
      feature2.alpha = alpha;
      color = IGVColor.addAlpha(color, alpha);
    }
    function getAlpha2(min, max, score) {
      const binWidth = (max - min) / 9;
      const binNumber = Math.floor((score - min) / binWidth);
      return Math.min(1, 0.2 + binNumber * 0.8 / 9);
    }
    return color;
  }
  /**
   * Called when the track is removed.  Do any needed cleanup here
   */
  dispose() {
    this.trackView = void 0;
  }
}
function monitorTrackDrag(track) {
  if (track.browser.on) {
    track.browser.on("trackdragend", onDragEnd);
    track.browser.on("trackremoved", unSubscribe);
  }
  function onDragEnd() {
    if (track.trackView && track.displayMode !== "SQUISHED") {
      track.trackView.updateViews();
    }
  }
  function unSubscribe(removedTrack) {
    if (track.browser.un && track === removedTrack) {
      track.browser.un("trackdragend", onDragEnd);
      track.browser.un("trackremoved", unSubscribe);
    }
  }
}
class RegionTableBase {
  constructor(config) {
    this.config = config;
    this.browser = config.browser;
    this.columnFormat = config.columnFormat;
    this.tableRowSelectionList = [];
    this.tableDOM = domUtils$1.div({ class: "igv-roi-table" });
    config.parent.appendChild(this.tableDOM);
    this.headerDOM = config;
    this.tableColumnTitles = this.tableDOM;
    this.tableRowContainer = this.tableDOM;
    this.footerDOM = config.gotoButtonHandler;
  }
  set headerDOM({ browser, parent, headerTitle, dismissHandler }) {
    const dom = domUtils$1.div();
    this.tableDOM.appendChild(dom);
    const div2 = domUtils$1.div();
    dom.appendChild(div2);
    div2.innerHTML = headerTitle;
    const dismiss = domUtils$1.div();
    dom.appendChild(dismiss);
    dismiss.appendChild(icons$1$1.createIcon("times"));
    this.boundDismissHandler = mouseClickHandler.bind(this);
    dismiss.addEventListener("click", this.boundDismissHandler);
    function mouseClickHandler(event) {
      event.stopPropagation();
      dismissHandler();
    }
    const { y: y_root } = browser.root.getBoundingClientRect();
    const { y: y_parent } = parent.getBoundingClientRect();
    const constraint = -(y_parent - y_root);
    makeDraggable$1(this.tableDOM, dom, { minX: 0, minY: constraint });
    this.tableDOM.style.display = "none";
    this._headerDOM = dom;
  }
  set tableColumnTitles(tableDOM) {
    const tblColumnTitles = domUtils$1.div({ class: "igv-roi-table-column-titles" });
    tableDOM.appendChild(tblColumnTitles);
    for (const { label, width } of this.columnFormat) {
      const col = domUtils$1.div();
      tblColumnTitles.appendChild(col);
      col.style.width = width;
      col.innerText = label;
    }
    this._tableColumnTitlesDOM = tblColumnTitles;
  }
  get tableColumnTitles() {
    return this._tableColumnTitlesDOM;
  }
  set tableRowContainer(container) {
    const tblRowContainer = domUtils$1.div({ class: "igv-roi-table-row-container" });
    container.appendChild(tblRowContainer);
    this._tableRowContainerDOM = tblRowContainer;
  }
  get tableRowContainer() {
    return this._tableRowContainerDOM;
  }
  set footerDOM(gotoButtonHandler) {
    const dom = domUtils$1.div();
    this.tableDOM.appendChild(dom);
    const gotoButton = domUtils$1.div({ class: "igv-roi-table-button" });
    dom.appendChild(gotoButton);
    gotoButton.id = "igv-roi-table-view-button";
    gotoButton.textContent = "Go To";
    gotoButton.style.pointerEvents = "none";
    this._footerDOM = dom;
    this.gotoButton = gotoButton;
    this.boundGotoButtonHandler = gotoButtonHandler.bind(this);
    this.gotoButton.addEventListener("click", this.boundGotoButtonHandler);
  }
  tableRowDOMHelper(dom) {
    dom.addEventListener("mousedown", (event) => {
      event.stopPropagation();
      dom.classList.toggle("igv-roi-table-row-selected");
      dom.classList.contains("igv-roi-table-row-selected") ? dom.classList.remove("igv-roi-table-row-hover") : dom.classList.add("igv-roi-table-row-hover");
      this.setTableRowSelectionState(dom.classList.contains("igv-roi-table-row-selected"));
    });
    dom.addEventListener("mouseover", (e) => {
      dom.classList.contains("igv-roi-table-row-selected") ? dom.classList.remove("igv-roi-table-row-hover") : dom.classList.add("igv-roi-table-row-hover");
    });
    dom.addEventListener("mouseout", (e) => {
      dom.classList.remove("igv-roi-table-row-hover");
    });
  }
  clearTable() {
    const elements = this.tableRowContainer.querySelectorAll(".igv-roi-table-row");
    for (let el of elements) {
      el.remove();
    }
  }
  setTableRowSelectionState(isTableRowSelected) {
    isTableRowSelected ? this.tableRowSelectionList.push(1) : this.tableRowSelectionList.pop();
    this.gotoButton.style.pointerEvents = this.tableRowSelectionList.length > 0 ? "auto" : "none";
  }
  present() {
    this.tableDOM.style.left = `${0}px`;
    const { y: y_root } = this.browser.root.getBoundingClientRect();
    const { y: y_parent } = this.config.parent.getBoundingClientRect();
    this.tableDOM.style.top = `${y_root - y_parent}px`;
    this.tableDOM.style.display = "flex";
  }
  dismiss() {
    this.tableDOM.style.display = "none";
  }
  dispose() {
    this.tableDOM.innerHTML = "";
    this.tableDOM.remove();
    for (const key of Object.keys(this)) {
      this[key] = void 0;
    }
    document.removeEventListener("click", this.boundDismissHandler);
  }
}
class BlatTable extends RegionTableBase {
  constructor(config) {
    const cooked = Object.assign({ "width": "1024px" }, config);
    super(cooked);
    this.descriptionDOM = config;
  }
  set descriptionDOM(config) {
    if (config.description) {
      let dom;
      dom = domUtils$1.div({ class: "igv-roi-table-description" });
      this.tableDOM.insertBefore(dom, this.tableColumnTitles);
      dom.style.height = "auto";
      dom.innerHTML = `BLAT result for query sequence:`;
      dom = domUtils$1.div({ class: "igv-roi-table-description" });
      this.tableDOM.insertBefore(dom, this.tableColumnTitles);
      dom.style.height = "auto";
      dom.style.maxHeight = "128px";
      dom.innerHTML = config.description;
      dom = domUtils$1.div({ class: "igv-roi-table-goto-explainer" });
      this.tableDOM.insertBefore(dom, this.tableColumnTitles);
      dom.innerHTML = `Select one or more rows and click Go To to view the regions`;
    }
  }
  tableRowDOM(record) {
    const dom = domUtils$1.div({ class: "igv-roi-table-row" });
    const pretty = record.map((item) => isFinite(item) ? numberFormatter$1(item) : item);
    for (let i = 0; i < pretty.length; i++) {
      const el = domUtils$1.div();
      dom.appendChild(el);
      const format2 = this.columnFormat[i];
      el.style.width = format2.width || "fit-content";
      el.innerText = pretty[i];
    }
    this.tableRowDOMHelper(dom);
    return dom;
  }
  renderTable(records) {
    Array.from(this.tableRowContainer.querySelectorAll(".igv-roi-table-row")).forEach((el) => el.remove());
    if (records.length > 0) {
      for (let record of records) {
        const row = this.tableRowDOM(record);
        this.tableRowContainer.appendChild(row);
      }
    }
  }
  static getColumnFormatConfiguration() {
    return [
      { label: "chr", width: "7%" },
      { label: "start", width: "12%" },
      { label: "end", width: "12%" },
      { label: "strand", width: "5%" },
      { label: "score", width: "5%" },
      { label: "match", width: "5%" },
      { label: "mis-match", width: "7%" },
      { label: "rep. match", width: "7%" },
      { label: "N's", width: "3%" },
      { label: "Q gap count", width: "9%" },
      { label: "Q gap bases", width: "9%" },
      { label: "T gap count", width: "9%" },
      { label: "T gap bases", width: "9%" }
    ];
  }
  static gotoButtonHandler(event) {
    event.stopPropagation();
    const selectedRows = this.tableDOM.querySelectorAll(".igv-roi-table-row-selected");
    const loci = [];
    for (const row of selectedRows) {
      const record = [];
      row.querySelectorAll("div").forEach((el) => record.push(el.innerText));
      const [chr, start, end] = record;
      loci.push(`${chr}:${start}-${end}`);
    }
    for (const el of this.tableDOM.querySelectorAll(".igv-roi-table-row")) {
      el.classList.remove("igv-roi-table-row-selected");
    }
    this.setTableRowSelectionState(false);
    this.browser.search(loci.join(" "));
  }
}
const defaultBlatServer = "https://igv.org/services/blatUCSC.php";
async function blat({ url, userSeq, db }) {
  url = url || defaultBlatServer;
  const results = await postData(url, userSeq, db);
  results.fields;
  const features = results.blat.map(decodePSL);
  return features;
}
async function postData(url = "", userSeq, db) {
  const data = new URLSearchParams();
  data.append("userSeq", userSeq);
  data.append("db", db);
  const response = await fetch(url, { method: "post", body: data });
  return response.json();
}
const maxSequenceSize = 25e3;
class BlatTrack extends FeatureTrack {
  constructor(config, browser) {
    super(config, browser);
    if (!this.name) {
      this.name = "Blat Results";
    }
    this.sequence = config.sequence;
    this.table = void 0;
  }
  openTableView() {
    if (void 0 === this.table) {
      const rows = this.config.features.map((f) => [
        f.chr,
        f.start + 1,
        f.end,
        f.strand,
        f.score,
        f.matches,
        f.misMatches,
        f.repMatches,
        f.nCount,
        f.qNumInsert,
        f.qBaseInsert,
        f.tNumInsert,
        f.tBaseInsert
      ]);
      const config = {
        browser: this.browser,
        parent: this.browser.parent,
        headerTitle: this.config.title,
        description: this.sequence,
        dismissHandler: () => {
          this.table.dismiss();
          this.table.dispose();
          this.table = void 0;
        },
        columnFormat: BlatTable.getColumnFormatConfiguration(),
        gotoButtonHandler: BlatTable.gotoButtonHandler
      };
      this.table = new BlatTable(config);
      this.table.renderTable(rows);
    }
    this.table.present();
  }
  menuItemList() {
    const menuItems = super.menuItemList();
    menuItems.push("<hr/>");
    menuItems.push({
      label: "Open table view",
      click: () => this.openTableView()
    });
    return menuItems;
  }
  /**
   * Track has been permanently removed.  Release resources and other cleanup
   */
  dispose() {
    super.dispose();
    if (this.table) {
      this.table.popover.parentElement.removeChild(this.table.popover);
    }
  }
}
async function createBlatTrack({ sequence, browser, name: name2, title }) {
  if (sequence.length > maxSequenceSize) {
    browser.alert.present(`Sequence size exceeds maximum allowed length (${sequence.length} > ${maxSequenceSize})`);
    return;
  }
  const db = browser.genome.id;
  const url = browser.config["blatServerURL"];
  try {
    const features = await blat({ url, userSeq: sequence, db });
    const trackConfig = {
      type: "blat",
      name: name2 || "blat results",
      title: title || "blat results",
      sequence,
      altColor: "rgb(176, 176, 236)",
      color: "rgb(236, 176, 176)",
      features
    };
    const track = await browser.loadTrack(trackConfig);
    track.openTableView();
  } catch (e) {
    browser.alert.present(`Error performing blat search:  ${e}`);
  }
}
const alignmentStartGap = 5;
const downsampleRowHeight = 5;
const DEFAULT_ALIGNMENT_COLOR = "rgb(185, 185, 185)";
const DEFAULT_COVERAGE_COLOR = "rgb(150, 150, 150)";
const DEFAULT_CONNECTOR_COLOR = "rgb(200, 200, 200)";
const MINIMUM_BLAT_LENGTH = 20;
class BAMTrack extends TrackBase {
  static defaults = {
    alleleFreqThreshold: 0.2,
    visibilityWindow: 3e4,
    showCoverage: true,
    showAlignments: true,
    viewAsPairs: false,
    pairsSupported: true,
    showSoftClips: false,
    showAllBases: false,
    showInsertions: true,
    showMismatches: true,
    height: 300,
    coverageTrackHeight: 50
  };
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    this.type = "alignment";
    this.featureSource = new BamSource(config, this.browser);
    this.coverageTrack = new CoverageTrack(config, this);
    this.alignmentTrack = new AlignmentTrack(config, this);
    super.init(config);
    this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage);
    if (!this.showAlignments) {
      this._height = this.coverageTrackHeight;
    }
    if (config.sort) {
      if (Array.isArray(config.sort)) {
        this.assignSort(config.sort[0]);
      } else {
        this.assignSort(config.sort);
      }
    }
  }
  set height(h) {
    this._height = h;
    if (this.showAlignments) {
      this.alignmentTrack.height = this.showCoverage ? h - this.coverageTrackHeight : h;
    }
  }
  get height() {
    return this._height;
  }
  get minTemplateLength() {
    const configMinTLEN = this.config.minTLEN !== void 0 ? this.config.minTLEN : this.config.minFragmentLength;
    return configMinTLEN !== void 0 ? configMinTLEN : this._pairedEndStats ? this._pairedEndStats.minTLEN : 0;
  }
  get maxTemplateLength() {
    const configMaxTLEN = this.config.maxTLEN !== void 0 ? this.config.maxTLEN : this.config.maxFragmentLength;
    return configMaxTLEN !== void 0 ? configMaxTLEN : this._pairedEndStats ? this._pairedEndStats.maxTLEN : 1e3;
  }
  sort(options2) {
    options2 = this.assignSort(options2);
    for (let vp of this.trackView.viewports) {
      if (vp.containsPosition(options2.chr, options2.position)) {
        const alignmentContainer = vp.cachedFeatures;
        if (alignmentContainer) {
          alignmentContainer.sortRows(options2);
          vp.repaint();
        }
      }
    }
  }
  /**
   * Fix syntax problems for sort options.
   * @param options
   */
  assignSort(options2) {
    if (options2.locus) {
      const range = parseLocusString$1(options2.locus);
      options2.chr = range.chr;
      options2.position = range.start;
    } else {
      options2.position--;
    }
    options2.direction = options2.direction === "ASC" || options2.direction === true;
    options2.chr = this.browser.genome.getChromosomeName(options2.chr);
    this.sortObject = options2;
    return this.sortObject;
  }
  async getFeatures(chr, bpStart, bpEnd, bpPerPixel, viewport) {
    const alignmentContainer = await this.featureSource.getAlignments(chr, bpStart, bpEnd);
    if (alignmentContainer.paired && !this._pairedEndStats && !this.config.maxFragmentLength) {
      const pairedEndStats = new PairedEndStats(alignmentContainer.alignments, this.config);
      if (pairedEndStats.totalCount > 99) {
        this._pairedEndStats = pairedEndStats;
      }
    }
    alignmentContainer.alignments = void 0;
    const sort = this.sortObject;
    if (sort) {
      if (sort.chr === chr && sort.position >= bpStart && sort.position <= bpEnd) {
        alignmentContainer.sortRows(sort);
      }
    }
    return alignmentContainer;
  }
  /**
   * Compute the pixel height required to display all content.  This is not the same as the viewport height
   * (track.height) which might include a scrollbar.
   *
   * @param alignmentContainer
   * @returns {number}
   */
  computePixelHeight(alignmentContainer) {
    return (this.showCoverage ? this.coverageTrackHeight : 0) + (this.showAlignments ? this.alignmentTrack.computePixelHeight(alignmentContainer) : 0);
  }
  draw(options2) {
    IGVGraphics.fillRect(options2.context, 0, options2.pixelTop, options2.pixelWidth, options2.pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    if (true === this.showCoverage && this.coverageTrackHeight > 0) {
      this.trackView.axisCanvas.style.display = "block";
      this.coverageTrack.draw(options2);
    } else {
      this.trackView.axisCanvas.style.display = "none";
    }
    if (true === this.showAlignments) {
      this.alignmentTrack.setTop(this.coverageTrack, this.showCoverage);
      this.alignmentTrack.draw(options2);
    }
  }
  paintAxis(ctx2, pixelWidth, pixelHeight) {
    this.coverageTrack.paintAxis(ctx2, pixelWidth, this.coverageTrackHeight);
  }
  contextMenuItemList(config) {
    return this.alignmentTrack.contextMenuItemList(config);
  }
  popupData(clickState) {
    if (true === this.showCoverage && clickState.y >= this.coverageTrack.top && clickState.y < this.coverageTrackHeight) {
      return this.coverageTrack.popupData(clickState);
    } else {
      return this.alignmentTrack.popupData(clickState);
    }
  }
  /**
   * Return the features (alignment, coverage, downsampled interval) clicked on.  Needed for "onclick" event.
   * @param clickState
   * @param features
   */
  clickedFeatures(clickState) {
    let clickedObject;
    if (true === this.showCoverage && clickState.y >= this.coverageTrack.top && clickState.y < this.coverageTrackHeight) {
      clickedObject = this.coverageTrack.getClickedObject(clickState);
    } else {
      clickedObject = this.alignmentTrack.getClickedObject(clickState);
    }
    return clickedObject ? [clickedObject] : void 0;
  }
  hoverText(clickState) {
    if (true === this.showCoverage && clickState.y >= this.coverageTrack.top && clickState.y < this.coverageTrackHeight) {
      const clickedObject = this.coverageTrack.getClickedObject(clickState);
      if (clickedObject) {
        return clickedObject.hoverText();
      }
    }
  }
  menuItemList() {
    let menuItems = [];
    menuItems = menuItems.concat(MenuUtils$1.numericDataMenuItems(this.trackView));
    menuItems.push("<hr/>");
    const $e = $$1('<div class="igv-track-menu-category">');
    $e.text("Color by:");
    menuItems.push({ name: void 0, object: $e, click: void 0, init: void 0 });
    const colorByMenuItems = [{ key: "strand", label: "read strand" }];
    if (this.alignmentTrack.hasPairs) {
      colorByMenuItems.push({ key: "firstOfPairStrand", label: "first-of-pair strand" });
      colorByMenuItems.push({ key: "pairOrientation", label: "pair orientation" });
      colorByMenuItems.push({ key: "tlen", label: "insert size (TLEN)" });
      colorByMenuItems.push({ key: "unexpectedPair", label: "pair orientation & insert size (TLEN)" });
    }
    const tagLabel = "tag" + (this.alignmentTrack.colorByTag ? " (" + this.alignmentTrack.colorByTag + ")" : "");
    colorByMenuItems.push({ key: "tag", label: tagLabel });
    for (let item of colorByMenuItems) {
      const selected = this.alignmentTrack.colorBy === item.key;
      menuItems.push(this.colorByCB(item, selected));
    }
    const adjustTrackHeight = () => {
      if (!this.autoHeight) {
        const h = (this.showCoverage ? this.coverageTrackHeight : 0) + (this.showAlignments ? this.alignmentTrack.height : 0);
        this.trackView.setTrackHeight(h);
      }
    };
    menuItems.push("<hr/>");
    menuItems.push({
      object: $$1(createCheckbox$2("Show Coverage", this.showCoverage)),
      click: () => {
        this.showCoverage = !this.showCoverage;
        adjustTrackHeight();
        this.trackView.checkContentHeight();
        this.trackView.repaintViews();
      }
    });
    menuItems.push({
      object: $$1(createCheckbox$2("Show Alignments", this.showAlignments)),
      click: () => {
        this.showAlignments = !this.showAlignments;
        adjustTrackHeight();
        this.trackView.checkContentHeight();
        this.trackView.repaintViews();
      }
    });
    menuItems.push("<hr/>");
    menuItems.push({
      object: $$1(createCheckbox$2("Show all bases", this.showAllBases)),
      click: () => {
        this.showAllBases = !this.showAllBases;
        this.config.showAllBases = this.showAllBases;
        this.trackView.repaintViews();
      }
    });
    menuItems.push("<hr/>");
    menuItems.push({
      object: $$1(createCheckbox$2("Show mismatches", this.showMismatches)),
      click: () => {
        this.showMismatches = !this.showMismatches;
        this.config.showMismatches = this.showMismatches;
        this.trackView.repaintViews();
      }
    });
    menuItems.push({
      object: $$1(createCheckbox$2("Show insertions", this.showInsertions)),
      click: () => {
        this.showInsertions = !this.showInsertions;
        this.config.showInsertions = this.showInsertions;
        this.getCachedAlignmentContainers();
        this.trackView.repaintViews();
      }
    });
    menuItems.push({
      object: $$1(createCheckbox$2("Show soft clips", this.showSoftClips)),
      click: () => {
        this.showSoftClips = !this.showSoftClips;
        this.config.showSoftClips = this.showSoftClips;
        this.featureSource.setShowSoftClips(this.showSoftClips);
        const alignmentContainers = this.getCachedAlignmentContainers();
        for (let ac of alignmentContainers) {
          ac.setShowSoftClips(this.showSoftClips);
        }
        this.trackView.repaintViews();
      }
    });
    if (this.pairsSupported && this.alignmentTrack.hasPairs) {
      menuItems.push("<hr/>");
      menuItems.push({
        object: $$1(createCheckbox$2("View as pairs", this.viewAsPairs)),
        click: () => {
          this.viewAsPairs = !this.viewAsPairs;
          this.config.viewAsPairs = this.viewAsPairs;
          this.featureSource.setViewAsPairs(this.viewAsPairs);
          const alignmentContainers = this.getCachedAlignmentContainers();
          for (let ac of alignmentContainers) {
            ac.setViewAsPairs(this.viewAsPairs);
          }
          this.trackView.repaintViews();
        }
      });
    }
    if (this.browser.circularView && (this.alignmentTrack.hasPairs || this.alignmentTrack.hasSupplemental)) {
      menuItems.push("<hr/>");
      if (this.alignmentTrack.hasPairs) {
        menuItems.push({
          label: "Add discordant pairs to circular view",
          click: () => {
            for (let viewport of this.trackView.viewports) {
              this.addPairedChordsForViewport(viewport);
            }
          }
        });
      }
      if (this.alignmentTrack.hasSupplemental) {
        menuItems.push({
          label: "Add split reads to circular view",
          click: () => {
            for (let viewport of this.trackView.viewports) {
              this.addSplitChordsForViewport(viewport);
            }
          }
        });
      }
    }
    menuItems.push("<hr/>");
    const $dml = $$1('<div class="igv-track-menu-category">');
    $dml.text("Display mode:");
    menuItems.push({ name: void 0, object: $dml, click: void 0, init: void 0 });
    menuItems.push({
      object: $$1(createCheckbox$2("expand", this.alignmentTrack.displayMode === "EXPANDED")),
      click: () => {
        this.alignmentTrack.displayMode = "EXPANDED";
        this.config.displayMode = "EXPANDED";
        this.trackView.checkContentHeight();
        this.trackView.repaintViews();
      }
    });
    menuItems.push({
      object: $$1(createCheckbox$2("squish", this.alignmentTrack.displayMode === "SQUISHED")),
      click: () => {
        this.alignmentTrack.displayMode = "SQUISHED";
        this.config.displayMode = "SQUISHED";
        this.trackView.checkContentHeight();
        this.trackView.repaintViews();
      }
    });
    return menuItems;
  }
  /**
   * Create a "color by" checkbox menu item, optionally initially checked
   * @param menuItem
   * @param showCheck
   * @returns {{init: undefined, name: undefined, click: clickHandler, object: (jQuery|HTMLElement|jQuery.fn.init)}}
   */
  colorByCB(menuItem, showCheck) {
    const $e = $$1(createCheckbox$2(menuItem.label, showCheck));
    const clickHandler = (ev) => {
      if (menuItem.key !== "tag") {
        if (menuItem.key === this.alignmentTrack.colorBy) {
          this.alignmentTrack.colorBy = "none";
          this.config.colorBy = "none";
          this.trackView.repaintViews();
        } else {
          this.alignmentTrack.colorBy = menuItem.key;
          this.config.colorBy = menuItem.key;
          this.trackView.repaintViews();
        }
      } else {
        this.browser.inputDialog.present({
          label: "Tag Name",
          value: this.alignmentTrack.colorByTag ? this.alignmentTrack.colorByTag : "",
          callback: (tag) => {
            if (tag) {
              this.alignmentTrack.colorBy = "tag";
              this.alignmentTrack.colorByTag = tag;
              if (!this.alignmentTrack.tagColors) {
                this.alignmentTrack.tagColors = new PaletteColorTable("Set1");
              }
            } else {
              this.alignmentTrack.colorBy = "none";
              this.alignmentTrack.colorByTag = "";
            }
            this.trackView.repaintViews();
          }
        }, ev);
      }
    };
    return { name: void 0, object: $e, click: clickHandler, init: void 0 };
  }
  /**
   * Return the current state of the track.  Used to create sessions and bookmarks.
   *
   * @returns {*|{}}
   */
  getState() {
    const config = super.getState();
    if (this.sortObject) {
      config.sort = {
        chr: this.sortObject.chr,
        position: this.sortObject.position + 1,
        option: this.sortObject.option,
        direction: this.sortObject.direction ? "ASC" : "DESC"
      };
    }
    return config;
  }
  getCachedAlignmentContainers() {
    return this.trackView.viewports.map((vp) => vp.cachedFeatures);
  }
  get dataRange() {
    return this.coverageTrack.dataRange;
  }
  set dataRange(dataRange) {
    this.coverageTrack.dataRange = dataRange;
  }
  get logScale() {
    return this.coverageTrack.logScale;
  }
  set logScale(logScale) {
    this.coverageTrack.logScale = logScale;
  }
  get autoscale() {
    return this.coverageTrack.autoscale;
  }
  set autoscale(autoscale2) {
    this.coverageTrack.autoscale = autoscale2;
  }
  /**
   * Add chords to the circular view for the given viewport, represented by its reference frame
   * @param refFrame
   */
  addPairedChordsForViewport(viewport) {
    const maxTemplateLength = this.maxTemplateLength;
    const inView = [];
    const refFrame = viewport.referenceFrame;
    for (let a of viewport.cachedFeatures.allAlignments()) {
      if (a.end >= refFrame.start && a.start <= refFrame.end) {
        if (a.paired) {
          if (a.end - a.start > maxTemplateLength) {
            inView.push(a);
          }
        } else {
          if (a.mate && a.mate.chr && (a.mate.chr !== a.chr || Math.max(a.fragmentLength) > maxTemplateLength)) {
            inView.push(a);
          }
        }
      }
    }
    const chords = makePairedAlignmentChords(inView);
    sendChords(chords, this, refFrame, 0.02);
  }
  addSplitChordsForViewport(viewport) {
    const inView = [];
    const refFrame = viewport.referenceFrame;
    for (let a of viewport.cachedFeatures.allAlignments()) {
      const sa = a.hasTag("SA");
      if (a.end >= refFrame.start && a.start <= refFrame.end && sa) {
        inView.push(a);
      }
    }
    const chords = makeSupplementalAlignmentChords(inView);
    sendChords(chords, this, refFrame, 0.02);
  }
}
class CoverageTrack {
  constructor(config, parent) {
    this.parent = parent;
    this.featureSource = parent.featureSource;
    this.paintAxis = paintAxis;
    this.top = 0;
    this.autoscale = config.autoscale || config.max === void 0;
    if (!this.autoscale) {
      this.dataRange = {
        min: config.min || 0,
        max: config.max
      };
    }
  }
  get height() {
    return this.parent.coverageTrackHeight;
  }
  draw(options2) {
    const pixelTop = options2.pixelTop;
    pixelTop + options2.pixelHeight;
    const nucleotideColors = this.parent.browser.nucleotideColors;
    if (pixelTop > this.height) {
      return;
    }
    const ctx2 = options2.context;
    const alignmentContainer = options2.features;
    const coverageMap = alignmentContainer.coverageMap;
    let sequence;
    if (coverageMap.refSeq) {
      sequence = coverageMap.refSeq.toUpperCase();
    }
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const pixelWidth = options2.pixelWidth;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    let color;
    if (this.parent.coverageColor) {
      color = this.parent.coverageColor;
    } else if (this.parent.color && typeof this.parent.color !== "function") {
      color = IGVColor.darkenLighten(this.parent.color, -35);
    } else {
      color = DEFAULT_COVERAGE_COLOR;
    }
    IGVGraphics.setProperties(ctx2, {
      fillStyle: color,
      strokeStyle: color
    });
    const w = Math.max(1, Math.ceil(1 / bpPerPixel));
    for (let i = 0, len2 = coverageMap.coverage.length; i < len2; i++) {
      const bp = coverageMap.bpStart + i;
      if (bp < bpStart) continue;
      if (bp > bpEnd) break;
      const item = coverageMap.coverage[i];
      if (!item) continue;
      const h = Math.round(item.total / this.dataRange.max * this.height);
      const y = this.height - h;
      const x = Math.floor((bp - bpStart) / bpPerPixel);
      IGVGraphics.fillRect(ctx2, x, y, w, h);
    }
    if (sequence) {
      for (let i = 0, len2 = coverageMap.coverage.length; i < len2; i++) {
        const bp = coverageMap.bpStart + i;
        if (bp < bpStart) continue;
        if (bp > bpEnd) break;
        const item = coverageMap.coverage[i];
        if (!item) continue;
        const h = item.total / this.dataRange.max * this.height;
        let y = this.height - h;
        const x = Math.floor((bp - bpStart) / bpPerPixel);
        const refBase = sequence[i];
        if (item.isMismatch(refBase)) {
          IGVGraphics.setProperties(ctx2, { fillStyle: nucleotideColors[refBase] });
          IGVGraphics.fillRect(ctx2, x, y, w, h);
          let accumulatedHeight = 0;
          for (let nucleotide of ["A", "C", "T", "G"]) {
            const count = item["pos" + nucleotide] + item["neg" + nucleotide];
            const hh = count / this.dataRange.max * this.height;
            y = this.height - hh - accumulatedHeight;
            accumulatedHeight += hh;
            IGVGraphics.setProperties(ctx2, { fillStyle: nucleotideColors[nucleotide] });
            IGVGraphics.fillRect(ctx2, x, y, w, hh);
          }
        }
      }
    }
  }
  getClickedObject(clickState) {
    let features = clickState.viewport.cachedFeatures;
    if (!features || features.length === 0) return;
    const genomicLocation = Math.floor(clickState.genomicLocation);
    const coverageMap = features.coverageMap;
    const coverageMapIndex = Math.floor(genomicLocation - coverageMap.bpStart);
    return coverageMap.coverage[coverageMapIndex];
  }
  popupData(clickState) {
    const nameValues = [];
    const coverage = this.getClickedObject(clickState);
    if (coverage) {
      const genomicLocation = Math.floor(clickState.genomicLocation);
      const referenceFrame = clickState.viewport.referenceFrame;
      nameValues.push(referenceFrame.chr + ":" + numberFormatter$1(1 + genomicLocation));
      nameValues.push({ name: "Total Count", value: coverage.total });
      let tmp = coverage.posA + coverage.negA;
      if (tmp > 0) tmp = tmp.toString() + " (" + Math.round(tmp / coverage.total * 100) + "%, " + coverage.posA + "+, " + coverage.negA + "- )";
      nameValues.push({ name: "A", value: tmp });
      tmp = coverage.posC + coverage.negC;
      if (tmp > 0) tmp = tmp.toString() + " (" + Math.round(tmp / coverage.total * 100) + "%, " + coverage.posC + "+, " + coverage.negC + "- )";
      nameValues.push({ name: "C", value: tmp });
      tmp = coverage.posG + coverage.negG;
      if (tmp > 0) tmp = tmp.toString() + " (" + Math.round(tmp / coverage.total * 100) + "%, " + coverage.posG + "+, " + coverage.negG + "- )";
      nameValues.push({ name: "G", value: tmp });
      tmp = coverage.posT + coverage.negT;
      if (tmp > 0) tmp = tmp.toString() + " (" + Math.round(tmp / coverage.total * 100) + "%, " + coverage.posT + "+, " + coverage.negT + "- )";
      nameValues.push({ name: "T", value: tmp });
      tmp = coverage.posN + coverage.negN;
      if (tmp > 0) tmp = tmp.toString() + " (" + Math.round(tmp / coverage.total * 100) + "%, " + coverage.posN + "+, " + coverage.negN + "- )";
      nameValues.push({ name: "N", value: tmp });
      nameValues.push("<HR/>");
      nameValues.push({ name: "DEL", value: coverage.del.toString() });
      nameValues.push({ name: "INS", value: coverage.ins.toString() });
    }
    return nameValues;
  }
}
class AlignmentTrack {
  constructor(config, parent) {
    this.parent = parent;
    this.browser = parent.browser;
    this.featureSource = parent.featureSource;
    this.top = 0 === config.coverageTrackHeight ? 0 : config.coverageTrackHeight + 5;
    this.displayMode = config.displayMode || "EXPANDED";
    this.alignmentRowHeight = config.alignmentRowHeight || 14;
    this.squishedRowHeight = config.squishedRowHeight || 3;
    this.negStrandColor = config.negStrandColor || "rgba(150, 150, 230, 0.75)";
    this.posStrandColor = config.posStrandColor || "rgba(230, 150, 150, 0.75)";
    this.insertionColor = config.insertionColor || "rgb(138, 94, 161)";
    this.insertionTextColor = config.insertionTextColor || "white";
    this.showInsertionText = config.showInsertionText === void 0 ? false : !!config.showInsertionText;
    this.deletionColor = config.deletionColor || "black";
    this.deletionTextColor = config.deletionTextColor || "black";
    this.showDeletionText = config.showDeletionText === void 0 ? false : !!config.showDeletionText;
    this.skippedColor = config.skippedColor || "rgb(150, 170, 170)";
    this.pairConnectorColor = config.pairConnectorColor;
    this.smallTLENColor = config.smallTLENColor || config.smallFragmentLengthColor || "rgb(0, 0, 150)";
    this.largeTLENColor = config.largeTLENColor || config.largeFragmentLengthColor || "rgb(200, 0, 0)";
    this.pairOrientation = config.pairOrienation || "fr";
    this.pairColors = {};
    this.pairColors["RL"] = config.rlColor || "rgb(0, 150, 0)";
    this.pairColors["RR"] = config.rrColor || "rgb(20, 50, 200)";
    this.pairColors["LL"] = config.llColor || "rgb(0, 150, 150)";
    this.colorBy = config.colorBy || "unexpectedPair";
    this.colorByTag = config.colorByTag ? config.colorByTag.toUpperCase() : void 0;
    this.bamColorTag = config.bamColorTag === void 0 ? "YC" : config.bamColorTag;
    this.hideSmallIndels = config.hideSmallIndels;
    this.indelSizeThreshold = config.indelSizeThreshold || 1;
    this.hasPairs = false;
    this.hasSupplemental = false;
  }
  setTop(coverageTrack, showCoverage) {
    this.top = 0 === coverageTrack.height || false === showCoverage ? 0 : 5 + coverageTrack.height;
  }
  /**
   * Compute the pixel height required to display all content.
   *
   * @param alignmentContainer
   * @returns {number|*}
   */
  computePixelHeight(alignmentContainer) {
    if (alignmentContainer.packedAlignmentRows) {
      const h = alignmentContainer.hasDownsampledIntervals() ? downsampleRowHeight + alignmentStartGap : 0;
      const alignmentRowHeight = this.displayMode === "SQUISHED" ? this.squishedRowHeight : this.alignmentRowHeight;
      return h + alignmentRowHeight * alignmentContainer.packedAlignmentRows.length + 5;
    } else {
      return 0;
    }
  }
  draw(options2) {
    const alignmentContainer = options2.features;
    const ctx2 = options2.context;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const pixelWidth = options2.pixelWidth;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    const showSoftClips = this.parent.showSoftClips;
    const showAllBases = this.parent.showAllBases;
    const nucleotideColors = this.browser.nucleotideColors;
    const packedAlignmentRows = alignmentContainer.packedAlignmentRows;
    ctx2.save();
    let referenceSequence = alignmentContainer.sequence;
    if (referenceSequence) {
      referenceSequence = referenceSequence.toUpperCase();
    }
    let alignmentRowYInset = 0;
    let pixelTop = options2.pixelTop;
    if (this.top) {
      ctx2.translate(0, this.top);
    }
    const pixelBottom = pixelTop + options2.pixelHeight;
    if (alignmentContainer.hasDownsampledIntervals()) {
      alignmentRowYInset = downsampleRowHeight + alignmentStartGap;
      alignmentContainer.downsampledIntervals.forEach(function(interval) {
        var xBlockStart = (interval.start - bpStart) / bpPerPixel, xBlockEnd = (interval.end - bpStart) / bpPerPixel;
        if (xBlockEnd - xBlockStart > 5) {
          xBlockStart += 1;
          xBlockEnd -= 1;
        }
        IGVGraphics.fillRect(ctx2, xBlockStart, 2, xBlockEnd - xBlockStart, downsampleRowHeight - 2, { fillStyle: "black" });
      });
    } else {
      alignmentRowYInset = 0;
    }
    this.alignmentsYOffset = alignmentRowYInset;
    const alignmentRowHeight = this.displayMode === "SQUISHED" ? this.squishedRowHeight : this.alignmentRowHeight;
    if (packedAlignmentRows) {
      const nRows = packedAlignmentRows.length;
      for (let rowIndex = 0; rowIndex < nRows; rowIndex++) {
        const alignmentRow = packedAlignmentRows[rowIndex];
        const alignmentY = alignmentRowYInset + alignmentRowHeight * rowIndex;
        const alignmentHeight = alignmentRowHeight <= 4 ? alignmentRowHeight : alignmentRowHeight - 2;
        if (alignmentY > pixelBottom) {
          break;
        } else if (alignmentY + alignmentHeight < pixelTop) {
          continue;
        }
        for (let alignment of alignmentRow.alignments) {
          this.hasPairs = this.hasPairs || alignment.isPaired();
          if (this.browser.circularView) {
            this.hasSupplemental = this.hasSupplemental || alignment.hasTag("SA");
          }
          if (alignment.start + alignment.lengthOnRef < bpStart) continue;
          if (alignment.start > bpEnd) break;
          if (true === alignment.hidden) {
            continue;
          }
          if (alignment instanceof PairedAlignment) {
            drawPairConnector.call(this, alignment, alignmentY, alignmentHeight);
            drawSingleAlignment.call(this, alignment.firstAlignment, alignmentY, alignmentHeight);
            if (alignment.secondAlignment) {
              drawSingleAlignment.call(this, alignment.secondAlignment, alignmentY, alignmentHeight);
            }
          } else {
            drawSingleAlignment.call(this, alignment, alignmentY, alignmentHeight);
          }
        }
      }
    }
    ctx2.restore();
    function drawPairConnector(alignment, yRect, alignmentHeight) {
      var connectorColor = this.getConnectorColor(alignment.firstAlignment), xBlockStart = (alignment.connectingStart - bpStart) / bpPerPixel, xBlockEnd = (alignment.connectingEnd - bpStart) / bpPerPixel, yStrokedLine = yRect + alignmentHeight / 2;
      if (alignment.connectingEnd < bpStart || alignment.connectingStart > bpEnd) {
        return;
      }
      if (alignment.mq <= 0) {
        connectorColor = IGVColor.addAlpha(connectorColor, 0.15);
      }
      IGVGraphics.setProperties(ctx2, { fillStyle: connectorColor, strokeStyle: connectorColor });
      IGVGraphics.strokeLine(ctx2, xBlockStart, yStrokedLine, xBlockEnd, yStrokedLine);
    }
    function drawSingleAlignment(alignment, yRect, alignmentHeight) {
      if (alignment.start + alignment.lengthOnRef < bpStart || alignment.start > bpEnd) {
        return;
      }
      const blocks = showSoftClips ? alignment.blocks : alignment.blocks.filter((b) => "S" !== b.type);
      let alignmentColor = this.getAlignmentColor(alignment);
      const outlineColor = alignmentColor;
      if (alignment.mq <= 0) {
        alignmentColor = IGVColor.addAlpha(alignmentColor, 0.15);
      }
      IGVGraphics.setProperties(ctx2, { fillStyle: alignmentColor, strokeStyle: outlineColor });
      const basesToDraw = [];
      for (let b = 0; b < blocks.length; b++) {
        const block = blocks[b];
        if (b !== blocks.length - 1 && blocks[b + 1].start < bpStart) continue;
        basesToDraw.push(...drawBlock.call(this, block, b));
        if (block.start + block.len > bpEnd) {
          break;
        }
      }
      if (alignment.gaps) {
        const yStrokedLine = yRect + alignmentHeight / 2;
        for (let gap of alignment.gaps) {
          const sPixel = (gap.start - bpStart) / bpPerPixel;
          const ePixel = (gap.start + gap.len - bpStart) / bpPerPixel;
          const lineWidth = ePixel - sPixel;
          const gapLenText = gap.len.toString();
          const gapTextWidth = gapLenText.length * 6;
          const gapCenter = sPixel + lineWidth / 2;
          const color = "D" === gap.type ? this.deletionColor : this.skippedColor;
          IGVGraphics.strokeLine(ctx2, sPixel, yStrokedLine, ePixel, yStrokedLine, {
            strokeStyle: color,
            lineWidth: 2
          });
          if (this.showDeletionText && gap.len > 1 && lineWidth >= gapTextWidth + 8) {
            const textStart = gapCenter - gapTextWidth / 2;
            IGVGraphics.fillRect(ctx2, textStart - 1, yRect - 1, gapTextWidth + 2, 12, { fillStyle: "white" });
            IGVGraphics.fillText(ctx2, gapLenText, textStart, yRect + 10, {
              "font": "normal 10px monospace",
              "fillStyle": this.deletionTextColor
            });
          }
        }
      }
      if (alignment.insertions && this.parent.showInsertions) {
        let lastXBlockStart = -1;
        for (let insertionBlock of alignment.insertions) {
          if (this.hideSmallIndels && insertionBlock.len <= this.indelSizeThreshold) {
            continue;
          }
          if (insertionBlock.start < bpStart) {
            continue;
          }
          if (insertionBlock.start > bpEnd) {
            break;
          }
          const refOffset = insertionBlock.start - bpStart;
          const insertLenText = insertionBlock.len.toString();
          const textPixelWidth = 2 + insertLenText.length * 6;
          const basePixelWidth = !this.showInsertionText || insertionBlock.len === 1 ? 2 : Math.round(insertionBlock.len / bpPerPixel);
          const widthBlock = Math.max(Math.min(textPixelWidth, basePixelWidth), 2);
          const xBlockStart = refOffset / bpPerPixel - widthBlock / 2;
          if (xBlockStart - lastXBlockStart > 2) {
            const props = { fillStyle: this.insertionColor };
            IGVGraphics.fillRect(ctx2, xBlockStart - 2, yRect, widthBlock + 4, 2, props);
            IGVGraphics.fillRect(ctx2, xBlockStart, yRect + 2, widthBlock, alignmentHeight - 4, props);
            IGVGraphics.fillRect(ctx2, xBlockStart - 2, yRect + alignmentHeight - 2, widthBlock + 4, 2, props);
            if (this.showInsertionText && insertionBlock.len > 1 && basePixelWidth > textPixelWidth) {
              IGVGraphics.fillText(ctx2, insertLenText, xBlockStart + 1, yRect + 10, {
                "font": "normal 10px monospace",
                "fillStyle": this.insertionTextColor
              });
            }
            lastXBlockStart = xBlockStart;
          }
        }
      }
      basesToDraw.forEach(({ bbox: bbox2, baseColor, readChar }) => {
        renderBlockOrReadChar(ctx2, bpPerPixel, bbox2, baseColor, readChar);
      });
      function drawBlock(block, b) {
        const blockBasesToDraw = [];
        const offsetBP = block.start - alignmentContainer.start;
        const blockStartPixel = (block.start - bpStart) / bpPerPixel;
        const blockEndPixel = (block.start + block.len - bpStart) / bpPerPixel;
        const blockWidthPixel = Math.max(1, blockEndPixel - blockStartPixel);
        const nomPixelWidthOnRef = 100 / bpPerPixel;
        const arrowHeadWidthPixel = Math.min(alignmentRowHeight / 2, nomPixelWidthOnRef / 6);
        const isSoftClip = "S" === block.type;
        const strokeOutline = alignment.mq <= 0 || this.highlightedAlignmentReadNamed === alignment.readName || isSoftClip;
        let blockOutlineColor = outlineColor;
        if (this.highlightedAlignmentReadNamed === alignment.readName) blockOutlineColor = "red";
        else if (isSoftClip) blockOutlineColor = "rgb(50,50,50)";
        const lastBlockPositiveStrand = true === alignment.strand && b === blocks.length - 1;
        const lastBlockReverseStrand = false === alignment.strand && b === 0;
        const lastBlock = lastBlockPositiveStrand | lastBlockReverseStrand;
        if (lastBlock) {
          let xListPixel;
          let yListPixel;
          if (lastBlockPositiveStrand) {
            xListPixel = [
              blockStartPixel,
              blockEndPixel,
              blockEndPixel + arrowHeadWidthPixel,
              blockEndPixel,
              blockStartPixel,
              blockStartPixel
            ];
            yListPixel = [
              yRect,
              yRect,
              yRect + alignmentHeight / 2,
              yRect + alignmentHeight,
              yRect + alignmentHeight,
              yRect
            ];
          } else if (lastBlockReverseStrand) {
            xListPixel = [
              blockEndPixel,
              blockStartPixel,
              blockStartPixel - arrowHeadWidthPixel,
              blockStartPixel,
              blockEndPixel,
              blockEndPixel
            ];
            yListPixel = [
              yRect,
              yRect,
              yRect + alignmentHeight / 2,
              yRect + alignmentHeight,
              yRect + alignmentHeight,
              yRect
            ];
          }
          IGVGraphics.fillPolygon(ctx2, xListPixel, yListPixel, { fillStyle: alignmentColor });
          if (strokeOutline) {
            IGVGraphics.strokePolygon(ctx2, xListPixel, yListPixel, { strokeStyle: blockOutlineColor });
          }
        } else {
          IGVGraphics.fillRect(ctx2, blockStartPixel, yRect, blockWidthPixel, alignmentHeight, { fillStyle: alignmentColor });
          if (strokeOutline) {
            ctx2.save();
            ctx2.strokeStyle = blockOutlineColor;
            ctx2.strokeRect(blockStartPixel, yRect, blockWidthPixel, alignmentHeight);
            ctx2.restore();
          }
        }
        if (isSoftClip || showAllBases || this.parent.showMismatches && (referenceSequence && alignment.seq && alignment.seq !== "*")) {
          const seq = alignment.seq ? alignment.seq.toUpperCase() : void 0;
          const qual = alignment.qual;
          const seqOffset = block.seqOffset;
          const widthPixel = Math.max(1, 1 / bpPerPixel);
          for (let i = 0, len2 = block.len; i < len2; i++) {
            const xPixel = (block.start + i - bpStart) / bpPerPixel;
            if (xPixel + widthPixel < 0) continue;
            if (xPixel > pixelWidth) break;
            let readChar = seq ? seq.charAt(seqOffset + i) : "";
            const refChar = offsetBP + i >= 0 ? referenceSequence.charAt(offsetBP + i) : "";
            if (readChar === "=") {
              readChar = refChar;
            }
            if (readChar === "X" || refChar !== readChar || isSoftClip || showAllBases) {
              let baseColor;
              if (!isSoftClip && qual !== void 0 && qual.length > seqOffset + i) {
                const readQual = qual[seqOffset + i];
                baseColor = shadedBaseColor(readQual, nucleotideColors[readChar]);
              } else {
                baseColor = nucleotideColors[readChar];
              }
              if (baseColor) {
                blockBasesToDraw.push({
                  bbox: {
                    x: xPixel,
                    y: yRect,
                    width: widthPixel,
                    height: alignmentHeight
                  },
                  baseColor,
                  readChar
                });
              }
            }
          }
        }
        return blockBasesToDraw;
      }
      function renderBlockOrReadChar(context, bpp, bbox2, color, char) {
        var threshold, center;
        threshold = 1 / 10;
        if (bpp <= threshold && bbox2.height >= 8) {
          const fontHeight = Math.min(10, bbox2.height);
          context.font = "" + fontHeight + "px sans-serif";
          center = bbox2.x + bbox2.width / 2;
          IGVGraphics.strokeText(context, char, center - context.measureText(char).width / 2, fontHeight - 1 + bbox2.y, { strokeStyle: color });
        } else {
          IGVGraphics.fillRect(context, bbox2.x, bbox2.y, bbox2.width, bbox2.height, { fillStyle: color });
        }
      }
    }
  }
  popupData(clickState) {
    const clickedObject = this.getClickedObject(clickState);
    return clickedObject ? clickedObject.popupData(clickState.genomicLocation) : void 0;
  }
  contextMenuItemList(clickState) {
    const viewport = clickState.viewport;
    const list = [];
    const sortByOption = (option) => {
      const cs = this.parent.sortObject;
      const direction = cs && cs.position === Math.floor(clickState.genomicLocation) ? !cs.direction : true;
      const newSortObject = {
        chr: viewport.referenceFrame.chr,
        position: Math.floor(clickState.genomicLocation),
        option,
        direction
      };
      this.parent.sortObject = newSortObject;
      viewport.cachedFeatures.sortRows(newSortObject);
      viewport.repaint();
    };
    list.push("<b>Sort by...</b>");
    list.push({ label: "&nbsp; base", click: () => sortByOption("BASE") });
    list.push({ label: "&nbsp; read strand", click: () => sortByOption("STRAND") });
    list.push({ label: "&nbsp; insert size", click: () => sortByOption("INSERT_SIZE") });
    list.push({ label: "&nbsp; gap size", click: () => sortByOption("GAP_SIZE") });
    list.push({ label: "&nbsp; chromosome of mate", click: () => sortByOption("MATE_CHR") });
    list.push({ label: "&nbsp; mapping quality", click: () => sortByOption("MQ") });
    list.push({ label: "&nbsp; read name", click: () => sortByOption("READ_NAME") });
    list.push({ label: "&nbsp; aligned read length", click: () => sortByOption("ALIGNED_READ_LENGTH") });
    list.push({
      label: "&nbsp; tag",
      click: () => {
        const cs = this.parent.sortObject;
        const direction = cs && cs.position === Math.floor(clickState.genomicLocation) ? !cs.direction : true;
        const config = {
          label: "Tag Name",
          value: this.sortByTag ? this.sortByTag : "",
          callback: (tag) => {
            if (tag) {
              const newSortObject = {
                chr: viewport.referenceFrame.chr,
                position: Math.floor(clickState.genomicLocation),
                option: "TAG",
                tag,
                direction
              };
              this.sortByTag = tag;
              this.parent.sortObject = newSortObject;
              viewport.cachedFeatures.sortRows(newSortObject);
              viewport.repaint();
            }
          }
        };
        this.browser.inputDialog.present(config, clickState.event);
      }
    });
    list.push("<hr/>");
    const clickedObject = this.getClickedObject(clickState);
    if (clickedObject) {
      const showSoftClips = this.parent.showSoftClips;
      const clickedAlignment = typeof clickedObject.alignmentContaining === "function" ? clickedObject.alignmentContaining(clickState.genomicLocation, showSoftClips) : clickedObject;
      if (clickedAlignment) {
        if (clickedAlignment.isPaired() && clickedAlignment.isMateMapped()) {
          list.push({
            label: "View mate in split screen",
            click: () => {
              if (clickedAlignment.mate) {
                const referenceFrame = clickState.viewport.referenceFrame;
                if (this.browser.genome.getChromosome(clickedAlignment.mate.chr)) {
                  this.highlightedAlignmentReadNamed = clickedAlignment.readName;
                  const bpWidth = referenceFrame.end - referenceFrame.start;
                  const frameStart = clickedAlignment.mate.position - bpWidth / 2;
                  const frameEnd = clickedAlignment.mate.position + bpWidth / 2;
                  this.browser.addMultiLocusPanel(clickedAlignment.mate.chr, frameStart, frameEnd, referenceFrame);
                } else {
                  this.browser.alert.present(`Reference does not contain chromosome: ${clickedAlignment.mate.chr}`);
                }
              }
            },
            init: void 0
          });
        }
        list.push({
          label: "View read sequence",
          click: () => {
            const seqstring2 = clickedAlignment.seq;
            if (!seqstring2 || "*" === seqstring2) {
              this.browser.alert.present("Read sequence: *");
            } else {
              this.browser.alert.present(seqstring2);
            }
          }
        });
        if (isSecureContext()) {
          list.push({
            label: "Copy read sequence",
            click: async () => {
              const seq = clickedAlignment.seq;
              try {
                await navigator.clipboard.writeText(seq);
              } catch (e) {
                console.error(e);
                this.browser.alert.present(`error copying sequence to clipboard ${e}`);
              }
            }
          });
        }
        const seqstring = clickedAlignment.seq;
        if (seqstring && "*" != seqstring) {
          if (seqstring.length < maxSequenceSize) {
            list.push({
              label: "BLAT read sequence",
              click: () => {
                const sequence = clickedAlignment.isNegativeStrand() ? reverseComplementSequence(seqstring) : seqstring;
                const name2 = `${clickedAlignment.readName} - blat`;
                const title = `${this.parent.name} - ${name2}`;
                createBlatTrack({ sequence, browser: this.browser, name: name2, title });
              }
            });
          }
          const softClips = clickedAlignment.softClippedBlocks();
          if (softClips.left && softClips.left.len > MINIMUM_BLAT_LENGTH && softClips.left.len < maxSequenceSize) {
            list.push({
              label: "BLAT left soft-clipped sequence",
              click: () => {
                const clippedSequence = seqstring.substr(softClips.left.seqOffset, softClips.left.len);
                const sequence = clickedAlignment.isNegativeStrand() ? reverseComplementSequence(clippedSequence) : clippedSequence;
                const name2 = `${clickedAlignment.readName} - blat left clip`;
                const title = `${this.parent.name} - ${name2}`;
                createBlatTrack({ sequence, browser: this.browser, name: name2, title });
              }
            });
          }
          if (softClips.right && softClips.right.len > MINIMUM_BLAT_LENGTH && softClips.right.len < maxSequenceSize) {
            list.push({
              label: "BLAT right soft-clipped sequence",
              click: () => {
                const clippedSequence = seqstring.substr(softClips.right.seqOffset, softClips.right.len);
                const sequence = clickedAlignment.isNegativeStrand() ? reverseComplementSequence(clippedSequence) : clippedSequence;
                const name2 = `${clickedAlignment.readName} - blat right clip`;
                const title = `${this.parent.name} - ${name2}`;
                createBlatTrack({ sequence, browser: this.browser, name: name2, title });
              }
            });
          }
        }
        list.push("<hr/>");
      }
    }
    if (this.browser.circularView && (this.hasPairs || this.hasSupplemental)) {
      if (this.hasPairs) {
        list.push({
          label: "Add discordant pairs to circular view",
          click: () => {
            this.parent.addPairedChordsForViewport(viewport);
          }
        });
      }
      if (this.hasSupplemental) {
        list.push({
          label: "Add split reads to circular view",
          click: () => {
            this.parent.addSplitChordsForViewport(viewport);
          }
        });
      }
      list.push("<hr/>");
    }
    return list;
  }
  getClickedObject(clickState) {
    const viewport = clickState.viewport;
    const y = clickState.y;
    const genomicLocation = clickState.genomicLocation;
    const showSoftClips = this.parent.showSoftClips;
    let features = viewport.cachedFeatures;
    if (!features || features.length === 0) return;
    let packedAlignmentRows = features.packedAlignmentRows;
    let downsampledIntervals = features.downsampledIntervals;
    const alignmentRowHeight = this.displayMode === "SQUISHED" ? this.squishedRowHeight : this.alignmentRowHeight;
    let packedAlignmentsIndex = Math.floor((y - this.top - this.alignmentsYOffset) / alignmentRowHeight);
    if (packedAlignmentsIndex < 0) {
      for (let i = 0; i < downsampledIntervals.length; i++) {
        if (downsampledIntervals[i].start <= genomicLocation && downsampledIntervals[i].end >= genomicLocation) {
          return downsampledIntervals[i];
        }
      }
    } else if (packedAlignmentsIndex < packedAlignmentRows.length) {
      const alignmentRow = packedAlignmentRows[packedAlignmentsIndex];
      const clicked = alignmentRow.alignments.filter((alignment) => alignment.containsLocation(genomicLocation, showSoftClips));
      if (clicked.length > 0) return clicked[0];
    }
    return void 0;
  }
  /**
   * Return the color for connectors in paired alignment view.   If explicitly set return that, otherwise return
   * the alignment color, unless the color option can result in split colors (separte color for each mate).
   *
   * @param alignment
   * @returns {string}
   */
  getConnectorColor(alignment) {
    if (this.pairConnectorColor) {
      return this.pairConnectorColor;
    }
    switch (this.colorBy) {
      case "strand":
      case "firstOfPairStrand":
      case "pairOrientation":
      case "tag":
        if (this.parent.color) {
          return typeof this.parent.color === "function" ? this.parent.color(alignment) : this.parent.color;
        } else {
          return DEFAULT_CONNECTOR_COLOR;
        }
      default:
        return this.getAlignmentColor(alignment);
    }
  }
  getAlignmentColor(alignment) {
    let color = DEFAULT_ALIGNMENT_COLOR;
    if (this.parent.color) {
      color = typeof this.parent.color === "function" ? this.parent.color(alignment) : this.parent.color;
    } else {
      color = DEFAULT_ALIGNMENT_COLOR;
    }
    const option = this.colorBy;
    switch (option) {
      case "strand":
        color = alignment.strand ? this.posStrandColor : this.negStrandColor;
        break;
      case "firstOfPairStrand":
        if (alignment instanceof PairedAlignment) {
          color = alignment.firstOfPairStrand() ? this.posStrandColor : this.negStrandColor;
        } else if (alignment.isPaired()) {
          if (alignment.isFirstOfPair()) {
            color = alignment.strand ? this.posStrandColor : this.negStrandColor;
          } else if (alignment.isSecondOfPair()) {
            color = alignment.strand ? this.negStrandColor : this.posStrandColor;
          } else {
            console.error("ERROR. Paired alignments are either first or second.");
          }
        }
        break;
      case "unexpectedPair":
      case "pairOrientation":
        if (this.pairOrientation && alignment.pairOrientation) {
          const oTypes = orientationTypes[this.pairOrientation];
          if (oTypes) {
            const pairColor = this.pairColors[oTypes[alignment.pairOrientation]];
            if (pairColor) {
              color = pairColor;
              break;
            }
          }
        }
        if ("pairOrientation" === option) {
          break;
        }
      case "tlen":
      case "fragmentLength":
        if (alignment.mate && alignment.isMateMapped()) {
          if (alignment.mate.chr !== alignment.chr) {
            color = getChrColor(alignment.mate.chr);
          } else if (this.parent.minTemplateLength && Math.abs(alignment.fragmentLength) < this.parent.minTemplateLength) {
            color = this.smallTLENColor;
          } else if (this.parent.maxTemplateLength && Math.abs(alignment.fragmentLength) > this.parent.maxTemplateLength) {
            color = this.largeTLENColor;
          }
        }
        break;
      case "tag":
        const tagValue = alignment.tags()[this.colorByTag];
        if (tagValue !== void 0) {
          if (this.bamColorTag === this.colorByTag) {
            color = "rgb(" + tagValue + ")";
          } else {
            if (!this.tagColors) {
              this.tagColors = new PaletteColorTable("Set1");
            }
            color = this.tagColors.getColor(tagValue);
          }
        }
        break;
    }
    return color;
  }
}
function shadedBaseColor(qual, baseColor) {
  const minQ = 5;
  const maxQ = 20;
  let alpha;
  if (qual < minQ) {
    alpha = 0.1;
  } else {
    alpha = Math.max(0.1, Math.min(1, 0.1 + 0.9 * (qual - minQ) / (maxQ - minQ)));
  }
  alpha = Math.round(alpha * 10) / 10;
  if (alpha < 1) {
    baseColor = IGVColor.addAlpha(baseColor, alpha);
  }
  return baseColor;
}
const orientationTypes = {
  "fr": {
    "F1R2": "LR",
    "F2R1": "LR",
    "F1F2": "LL",
    "F2F1": "LL",
    "R1R2": "RR",
    "R2R1": "RR",
    "R1F2": "RL",
    "R2F1": "RL"
  },
  "rf": {
    "R1F2": "LR",
    "R2F1": "LR",
    "R1R2": "LL",
    "R2R1": "LL",
    "F1F2": "RR",
    "F2F1": "RR",
    "F1R2": "RL",
    "F2R1": "RL"
  },
  "ff": {
    "F2F1": "LR",
    "R1R2": "LR",
    "F2R1": "LL",
    "R1F2": "LL",
    "R2F1": "RR",
    "F1R2": "RR",
    "R2R1": "RL",
    "F1F2": "RL"
  }
};
function getChrColor(chr) {
  if (chrColorMap[chr]) {
    return chrColorMap[chr];
  } else if (chrColorMap["chr" + chr]) {
    const color = chrColorMap["chr" + chr];
    chrColorMap[chr] = color;
    return color;
  } else {
    const color = IGVColor.randomRGB(0, 255);
    chrColorMap[chr] = color;
    return color;
  }
}
const chrColorMap = {
  "chrX": "rgb(204, 153, 0)",
  "chrY": "rgb(153, 204, 0)",
  "chrUn": "rgb(50, 50, 50)",
  "chr1": "rgb(80, 80, 255)",
  "chrI": "rgb(139, 155, 187)",
  "chr2": "rgb(206, 61, 50)",
  "chrII": "rgb(206, 61, 50)",
  "chr2a": "rgb(216, 71, 60)",
  "chr2b": "rgb(226, 81, 70)",
  "chr3": "rgb(116, 155, 88)",
  "chrIII": "rgb(116, 155, 88)",
  "chr4": "rgb(240, 230, 133)",
  "chrIV": "rgb(240, 230, 133)",
  "chr5": "rgb(70, 105, 131)",
  "chr6": "rgb(186, 99, 56)",
  "chr7": "rgb(93, 177, 221)",
  "chr8": "rgb(128, 34, 104)",
  "chr9": "rgb(107, 215, 107)",
  "chr10": "rgb(213, 149, 167)",
  "chr11": "rgb(146, 72, 34)",
  "chr12": "rgb(131, 123, 141)",
  "chr13": "rgb(199, 81, 39)",
  "chr14": "rgb(213, 143, 92)",
  "chr15": "rgb(122, 101, 165)",
  "chr16": "rgb(228, 175, 105)",
  "chr17": "rgb(59, 27, 83)",
  "chr18": "rgb(205, 222, 183)",
  "chr19": "rgb(97, 42, 121)",
  "chr20": "rgb(174, 31, 99)",
  "chr21": "rgb(231, 199, 111)",
  "chr22": "rgb(90, 101, 94)",
  "chr23": "rgb(204, 153, 0)",
  "chr24": "rgb(153, 204, 0)",
  "chr25": "rgb(51, 204, 0)",
  "chr26": "rgb(0, 204, 51)",
  "chr27": "rgb(0, 204, 153)",
  "chr28": "rgb(0, 153, 204)",
  "chr29": "rgb(10, 71, 255)",
  "chr30": "rgb(71, 117, 255)",
  "chr31": "rgb(255, 194, 10)",
  "chr32": "rgb(255, 209, 71)",
  "chr33": "rgb(153, 0, 51)",
  "chr34": "rgb(153, 26, 0)",
  "chr35": "rgb(153, 102, 0)",
  "chr36": "rgb(128, 153, 0)",
  "chr37": "rgb(51, 153, 0)",
  "chr38": "rgb(0, 153, 26)",
  "chr39": "rgb(0, 153, 102)",
  "chr40": "rgb(0, 128, 153)",
  "chr41": "rgb(0, 51, 153)",
  "chr42": "rgb(26, 0, 153)",
  "chr43": "rgb(102, 0, 153)",
  "chr44": "rgb(153, 0, 128)",
  "chr45": "rgb(214, 0, 71)",
  "chr46": "rgb(255, 20, 99)",
  "chr47": "rgb(0, 214, 143)",
  "chr48": "rgb(20, 255, 177)"
};
let timer;
let currentViewport = void 0;
const toolTipTimeout = 1e4;
class RulerViewport extends TrackViewport {
  constructor(trackView, $viewportColumn, referenceFrame, width) {
    super(trackView, $viewportColumn, referenceFrame, width);
  }
  get contentDiv() {
    return this.$viewport.get(0);
  }
  initializationHelper() {
    this.$multiLocusCloseButton = $$1("<div>", { class: "igv-multi-locus-close-button" });
    this.$viewport.append(this.$multiLocusCloseButton);
    this.$multiLocusCloseButton.get(0).appendChild(icons$1$1.createIcon("times-circle"));
    this.$multiLocusCloseButton.click(() => {
      this.browser.removeMultiLocusPanel(this.referenceFrame);
    });
    this.$rulerLabel = $$1("<div>", { class: "igv-multi-locus-ruler-label" });
    this.$viewport.append(this.$rulerLabel);
    let div2;
    div2 = document.createElement("div");
    this.$rulerLabel.append($$1(div2));
    this.$rulerLabel.get(0).addEventListener("click", async (event) => {
      event.stopPropagation();
      await this.browser.gotoMultilocusPanel(this.referenceFrame);
    });
    this.$tooltip = $$1("<div>", { class: "igv-ruler-tooltip" });
    this.$tooltip.height(this.$viewport.height());
    this.$viewport.append(this.$tooltip);
    this.$tooltipContent = $$1("<div>");
    this.$tooltip.append(this.$tooltipContent);
    this.rulerSweeper = new RulerSweeper(this, this.$viewport.get(0).parentElement, this.browser, this.referenceFrame);
    this.attachMouseHandlers(GenomeUtils.isWholeGenomeView(this.referenceFrame.chr));
    this.$tooltip.hide();
    this.dismissLocusLabel();
  }
  presentLocusLabel(viewportWidth) {
    this.$multiLocusCloseButton.show();
    this.$rulerLabel.show();
    this.$rulerLabel.get(0).style.backgroundColor = getChrColor(this.referenceFrame.chr);
    const textDiv = this.$rulerLabel.get(0).querySelector("div");
    const { width } = this.$rulerLabel.get(0).getBoundingClientRect();
    textDiv.innerHTML = `${this.referenceFrame.getMultiLocusLabel(viewportWidth)}`;
    const { width: textDivWidth } = textDiv.getBoundingClientRect();
    if (textDivWidth / width > 0.5) {
      textDiv.innerHTML = `${this.referenceFrame.getMultiLocusLabelBPLengthOnly(viewportWidth)}`;
    }
  }
  // Use in conjuction with .igv-multi-locus-ruler-label-square-dot css class (_dom-misc.scss)
  dismissLocusLabel() {
    this.$rulerLabel.hide();
    this.$multiLocusCloseButton.hide();
  }
  attachMouseHandlers(isWholeGenomeView) {
    this.namespace = `.ruler_track_viewport_${this.browser.referenceFrameList.indexOf(this.referenceFrame)}`;
    this.$viewport.off(this.namespace);
    if (true === isWholeGenomeView) {
      const index2 = this.browser.referenceFrameList.indexOf(this.referenceFrame);
      const click = `click${this.namespace}`;
      this.$viewport.on(click, (e) => {
        const { x: pixel } = domUtils$1.translateMouseCoordinates(e, this.$viewport.get(0));
        const bp = Math.round(this.referenceFrame.start + this.referenceFrame.toBP(pixel));
        let searchString;
        const { chr } = this.browser.genome.getChromosomeCoordinate(bp);
        if (1 === this.browser.referenceFrameList.length) {
          searchString = chr;
        } else {
          let loci = this.browser.referenceFrameList.map(({ locusSearchString }) => locusSearchString);
          loci[index2] = chr;
          searchString = loci.join(" ");
        }
        this.browser.search(searchString);
      });
      this.$viewport.get(0).style.cursor = "pointer";
    } else {
      this.$viewport.get(0).style.cursor = "default";
    }
  }
  mouseMove(event) {
    if (true === this.browser.cursorGuideVisible) {
      if (void 0 === currentViewport) {
        currentViewport = this;
        this.$tooltip.show();
      } else if (currentViewport.guid !== this.guid) {
        if (currentViewport.$tooltip) {
          currentViewport.$tooltip.hide();
        }
        this.$tooltip.show();
        currentViewport = this;
      } else {
        this.$tooltip.show();
      }
      const isWholeGenome = this.browser.isMultiLocusWholeGenomeView() || GenomeUtils.isWholeGenomeView(this.referenceFrame.chr);
      if (isWholeGenome) {
        this.$tooltip.hide();
        return;
      }
      const { x } = domUtils$1.translateMouseCoordinates(event, this.$viewport.get(0));
      const { start, bpPerPixel } = this.referenceFrame;
      const bp = Math.round(0.5 + start + Math.max(0, x) * bpPerPixel);
      this.$tooltipContent.text(numberFormatter$1(bp));
      const { width: ww } = this.$tooltipContent.get(0).getBoundingClientRect();
      const { width: w } = this.$viewport.get(0).getBoundingClientRect();
      this.$tooltip.css({ left: `${IGVMath.clamp(x, 0, w - ww)}px` });
      clearTimeout(timer);
      timer = setTimeout(() => {
        if (this.$tooltip) this.$tooltip.hide();
      }, toolTipTimeout);
    }
  }
  startSpinner() {
  }
  stopSpinner() {
  }
  dispose() {
    this.rulerSweeper.dispose();
    super.dispose();
  }
}
class IdeogramViewport extends TrackViewport {
  constructor(trackView, viewportColumn, referenceFrame, width) {
    super(trackView, viewportColumn, referenceFrame, width);
  }
  initializationHelper() {
    this.canvas = document.createElement("canvas");
    this.canvas.className = "igv-ideogram-canvas";
    this.$viewport.append($$1(this.canvas));
    this.ideogram_ctx = this.canvas.getContext("2d");
    this.addMouseHandlers();
  }
  addMouseHandlers() {
    this.addViewportClickHandler(this.$viewport.get(0));
  }
  addViewportClickHandler(viewport) {
    this.boundClickHandler = clickHandler.bind(this);
    viewport.addEventListener("click", this.boundClickHandler);
    function clickHandler(event) {
      const { xNormalized, width } = domUtils$1.translateMouseCoordinates(event, this.ideogram_ctx.canvas);
      const { bpLength } = this.browser.genome.getChromosome(this.referenceFrame.chr);
      const locusLength = this.referenceFrame.bpPerPixel * width;
      const chrCoveragePercentage = locusLength / bpLength;
      let xPercentage = xNormalized;
      if (xPercentage - chrCoveragePercentage / 2 < 0) {
        xPercentage = chrCoveragePercentage / 2;
      }
      if (xPercentage + chrCoveragePercentage / 2 > 1) {
        xPercentage = 1 - chrCoveragePercentage / 2;
      }
      const ss = Math.round((xPercentage - chrCoveragePercentage / 2) * bpLength);
      const ee = Math.round((xPercentage + chrCoveragePercentage / 2) * bpLength);
      this.referenceFrame.start = ss;
      this.referenceFrame.end = ee;
      this.referenceFrame.bpPerPixel = (ee - ss) / width;
      this.browser.updateViews(this.referenceFrame, this.browser.trackViews, true);
    }
  }
  setWidth(width) {
    this.$viewport.width(width);
  }
  drawSVGWithContext(context, width, height, id, x, y, yClipOffset) {
    context.saveWithTranslationAndClipRect(id, x, y, width, height, yClipOffset);
    this.trackView.track.draw({
      context,
      referenceFrame: this.referenceFrame,
      pixelWidth: width,
      pixelHeight: height
    });
    context.restore();
  }
  repaint() {
    this.draw({ referenceFrame: this.referenceFrame });
  }
  draw({ referenceFrame }) {
    IGVGraphics.configureHighDPICanvas(this.ideogram_ctx, this.$viewport.width(), this.$viewport.height());
    this.trackView.track.draw({
      context: this.ideogram_ctx,
      referenceFrame,
      pixelWidth: this.$viewport.width(),
      pixelHeight: this.$viewport.height()
    });
  }
  startSpinner() {
  }
  stopSpinner() {
  }
}
function createViewport(trackView, column, referenceFrame, width) {
  if ("ruler" === trackView.track.type) {
    return new RulerViewport(trackView, column, referenceFrame, width);
  } else if ("ideogram" === trackView.track.id) {
    return new IdeogramViewport(trackView, column, referenceFrame, width);
  } else {
    const viewportObject = new TrackViewport(trackView, column, referenceFrame, width);
    return viewportObject;
  }
}
const maxFontSize = 10;
const fontConfigureTemplate = {
  // font: '2pt sans-serif',
  textAlign: "start",
  textBaseline: "bottom",
  strokeStyle: "black",
  fillStyle: "black"
};
class SampleNameViewport {
  constructor(trackView, column, unused, width) {
    this.guid = domUtils$1.guid();
    this.trackView = trackView;
    this.browser = trackView.browser;
    this.viewport = domUtils$1.div({ class: "igv-viewport" });
    column.appendChild(this.viewport);
    if (trackView.track.height) {
      this.viewport.style.height = `${trackView.track.height}px`;
    }
    this.canvas = document.createElement("canvas");
    this.viewport.appendChild(this.canvas);
    this.ctx = this.canvas.getContext("2d");
    this.trackScrollDelta = 0;
    this.contentTop = 0;
    this.setWidth(width);
    if (false === this.browser.showSampleNames) {
      this.hide();
    }
    this.addMouseHandlers();
  }
  checkCanvas() {
    const dpi = window.devicePixelRatio;
    const requiredHeight = this.viewport.clientHeight;
    const requiredWidth = this.browser.sampleNameViewportWidth;
    if (this.canvas.width !== requiredWidth * dpi || this.canvas.height !== requiredHeight * dpi) {
      const canvas = this.canvas;
      canvas.width = requiredWidth * dpi;
      canvas.height = requiredHeight * dpi;
      canvas.style.width = `${requiredWidth}px`;
      canvas.style.height = `${requiredHeight}px`;
      this.ctx = this.canvas.getContext("2d");
      this.ctx.scale(dpi, dpi);
    }
  }
  setTop(contentTop) {
    if (typeof this.trackView.track.getSamples === "function") {
      this.contentTop = contentTop;
      const samples = this.trackView.track.getSamples();
      this.repaint(samples);
    }
  }
  setWidth(width) {
    this.viewport.innerWidth = width;
    this.checkCanvas();
  }
  show() {
    this.viewport.style.display = "block";
  }
  hide() {
    this.viewport.style.display = "none";
  }
  async repaint(samples) {
    this.checkCanvas();
    this.draw({ context: this.ctx, samples });
  }
  draw({ context, samples }) {
    if (!samples || samples.names.length === 0) {
      return;
    }
    configureFont(context, fontConfigureTemplate, samples.height);
    const sampleNameXShim = 4;
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.fillStyle = appleCrayonRGB("lead");
    const viewportHeight = this.viewport.getBoundingClientRect().height;
    let y = (samples.yOffset || 0) + this.contentTop;
    for (let name2 of samples.names) {
      if (y > viewportHeight) {
        break;
      }
      if (y + samples.height > 0) {
        const text2 = name2;
        const yFont = getYFont(context, text2, y, samples.height);
        context.fillText(text2, sampleNameXShim, yFont);
      }
      y += samples.height;
    }
  }
  renderSVGContext(context, { deltaX, deltaY }) {
    if (typeof this.trackView.track.getSamples === "function") {
      const samples = this.trackView.track.getSamples();
      const yScrollDelta = 0;
      const { width, height } = this.viewport.getBoundingClientRect();
      const str = (this.trackView.track.name || this.trackView.track.id).replace(/\W/g, "");
      const id = `${str}_sample_names_guid_${domUtils$1.guid()}`;
      context.saveWithTranslationAndClipRect(id, deltaX, deltaY + yScrollDelta, width, height, -yScrollDelta);
      this.draw({ context, samples });
      context.restore();
    }
  }
  addMouseHandlers() {
    this.addViewportContextMenuHandler(this.viewport);
  }
  removeMouseHandlers() {
    this.removeViewportContextMenuHandler(this.viewport);
  }
  addViewportContextMenuHandler(viewport) {
    this.boundContextMenuHandler = contextMenuHandler.bind(this);
    viewport.addEventListener("contextmenu", this.boundContextMenuHandler);
    function contextMenuHandler(event) {
      event.preventDefault();
      event.stopPropagation();
      const config = {
        label: "Name Panel Width",
        value: this.browser.sampleNameViewportWidth,
        callback: (newWidth) => {
          this.browser.sampleNameViewportWidth = parseInt(newWidth);
          for (let { sampleNameViewport } of this.browser.trackViews) {
            sampleNameViewport.setWidth(this.browser.sampleNameViewportWidth);
          }
          this.browser.layoutChange();
        }
      };
      this.browser.inputDialog.present(config, event);
    }
  }
  removeViewportContextMenuHandler(viewport) {
    viewport.removeEventListener("contextmenu", this.boundContextMenuHandler);
  }
  dispose() {
    this.removeMouseHandlers();
    this.viewport.remove();
  }
}
function getYFont(context, text2, y, height) {
  return y + height - getSampleNameYShim(context, text2, height);
}
function getSampleNameYShim(context, text2, h) {
  const { actualBoundingBoxAscent, actualBoundingBoxDescent } = context.measureText(text2);
  return (h - (actualBoundingBoxAscent + actualBoundingBoxDescent)) / 2;
}
function configureFont(ctx2, { textAlign, textBaseline, strokeStyle, fillStyle }, sampleHeight) {
  const pixels = Math.min(sampleHeight, maxFontSize);
  ctx2.font = `${pixels}px sans-serif`;
  ctx2.textAlign = textAlign;
  ctx2.textBaseline = textBaseline;
  ctx2.fillStyle = fillStyle;
}
const MenuPopup = function(parent) {
  this.popover = domUtils$1.div({ class: "igv-menu-popup" });
  parent.appendChild(this.popover);
  const header = domUtils$1.div({ class: "igv-menu-popup-header" });
  this.popover.appendChild(header);
  uiUtils$1.attachDialogCloseHandlerWithParent(header, () => this.hide());
  this.popoverContent = domUtils$1.div();
  this.popover.appendChild(this.popoverContent);
  makeDraggable$1(this.popover, header);
  header.addEventListener("click", (e) => {
    e.stopPropagation();
    e.preventDefault();
  });
  this.hide();
};
MenuPopup.prototype.hide = function() {
  this.popover.style.display = "none";
};
MenuPopup.prototype.presentMenuList = function(menuList) {
  hideAllMenuPopups();
  if (menuList.length > 0) {
    this.popoverContent.innerHTML = "";
    menuList = MenuUtils$1.trackMenuItemListHelper(menuList, this);
    for (let item of menuList) {
      if (item.init) {
        item.init();
      }
      let $e = item.object;
      if (0 === menuList.indexOf(item)) {
        $e.removeClass("igv-track-menu-border-top");
      }
      if ($e.hasClass("igv-track-menu-border-top") || $e.hasClass("igv-menu-popup-check-container")) ;
      else if ($e.is("div")) {
        $e.addClass("igv-menu-popup-shim");
      }
      this.popoverContent.appendChild($e.get(0));
    }
    this.popover.style.display = "flex";
    const { width } = this.popover.getBoundingClientRect();
    this.popover.style.left = `${-width}px`;
    this.popover.style.top = `${0}px`;
  }
};
MenuPopup.prototype.presentTrackContextMenu = function(e, menuItems) {
  this.popoverContent.innerHTML = "";
  const menuElements = createMenuElements(menuItems, this.popover);
  for (let { el } of menuElements) {
    this.popoverContent.appendChild(el);
  }
  present(e, this.popover);
};
MenuPopup.prototype.dispose = function() {
  this.popoverContent.innerHTML = "";
  this.popover.innerHTML = "";
  Object.keys(this).forEach(function(key) {
    this[key] = void 0;
  });
};
function createMenuElements(itemList, popover) {
  return itemList.map((item) => {
    let el;
    if (typeof item === "string" && "<hr/>" === item) {
      el = document.createElement("hr");
    } else if (typeof item === "string") {
      el = domUtils$1.div({ class: "context-menu" });
      el.innerHTML = item;
    } else if (typeof item === "Node") {
      el = item;
    } else {
      if (typeof item.init === "function") {
        item.init();
      }
      if ("checkbox" === item.type) {
        el = createCheckbox$2("Show all bases", item.value);
      } else if ("color" === item.type) {
        const colorPicker = new GenericColorPicker({ parent: popover.parentElement, width: 364 });
        colorPicker.configure(void 0, { color: (color) => item.click(color) });
        el = domUtils$1.div({ class: "context-menu" });
        if (typeof item.label === "string") {
          el.innerHTML = item.label;
        }
        const clickHandler = (e) => {
          colorPicker.show();
          domUtils$1.hide(popover);
          e.preventDefault();
          e.stopPropagation();
        };
        el.addEventListener("click", clickHandler);
        el.addEventListener("touchend", clickHandler);
        el.addEventListener("mouseup", function(e) {
          e.preventDefault();
          e.stopPropagation();
        });
      } else {
        el = domUtils$1.div({ class: "context-menu" });
        if (typeof item.label === "string") {
          el.innerHTML = item.label;
        }
      }
      if (item.click && "color" !== item.type) {
        let handleClick = function(e) {
          item.click();
          domUtils$1.hide(popover);
          e.preventDefault();
          e.stopPropagation();
        };
        el.addEventListener("click", handleClick);
        el.addEventListener("touchend", handleClick);
        el.addEventListener("mouseup", function(e) {
          e.preventDefault();
          e.stopPropagation();
        });
      }
    }
    return { el, init: item.init };
  });
}
function present(e, popover) {
  popover.style.display = "flex";
  const { x, y } = domUtils$1.translateMouseCoordinates(e, popover.parentNode);
  const { width } = popover.getBoundingClientRect();
  const xmax = x + width;
  const { width: parentWidth } = popover.parentNode.getBoundingClientRect();
  popover.style.left = `${xmax > parentWidth ? x - (xmax - parentWidth) : x}px`;
  popover.style.top = `${y}px`;
}
const hideAllMenuPopups = () => {
  const menus = document.querySelectorAll(".igv-menu-popup");
  for (let i = 0; i < menus.length; i++) {
    menus[i].style.display = "none";
  }
};
const igv_axis_column_width = 50;
const scrollbarExclusionTypes = /* @__PURE__ */ new Set(["ruler", "ideogram"]);
const colorPickerExclusionTypes = /* @__PURE__ */ new Set(["ruler", "sequence", "ideogram"]);
class TrackView {
  constructor(browser, columnContainer, track) {
    this.browser = browser;
    this.track = track;
    track.trackView = this;
    this.addDOMToColumnContainer(browser, columnContainer, browser.referenceFrameList);
  }
  /**
   * Start a spinner for the track on any of its viewports.  In practice this is called during initialization
   * when there is only one.
   */
  startSpinner() {
    if (this.viewports && this.viewports.length > 0) {
      this.viewports[0].startSpinner();
    }
  }
  stopSpinner() {
    if (this.viewports && this.viewports.length > 0) {
      this.viewports[0].stopSpinner();
    }
  }
  addDOMToColumnContainer(browser, columnContainer, referenceFrameList) {
    this.axis = this.createAxis(browser, this.track);
    this.viewports = [];
    const viewportWidth = browser.calculateViewportWidth(referenceFrameList.length);
    const viewportColumns = columnContainer.querySelectorAll(".igv-column");
    for (let i = 0; i < viewportColumns.length; i++) {
      const viewport = createViewport(this, viewportColumns[i], referenceFrameList[i], viewportWidth);
      this.viewports.push(viewport);
    }
    this.sampleNameViewport = new SampleNameViewport(this, browser.columnContainer.querySelector(".igv-sample-name-column"), void 0, browser.sampleNameViewportWidth);
    this.createTrackScrollbar(browser);
    this.createTrackDragHandle(browser);
    this.createTrackGearPopup(browser);
  }
  createAxis(browser, track) {
    const axis = domUtils$1.div();
    browser.columnContainer.querySelector(".igv-axis-column").appendChild(axis);
    axis.style.height = `${track.height}px`;
    if (typeof track.paintAxis === "function") {
      if (track.dataRange) {
        axis.addEventListener("click", () => {
          browser.dataRangeDialog.configure(this);
          browser.dataRangeDialog.present($$1(browser.columnContainer));
        });
      }
      const { width, height } = axis.getBoundingClientRect();
      this.axisCanvas = document.createElement("canvas");
      this.axisCanvas.style.width = `${width}px`;
      this.axisCanvas.style.height = `${height}px`;
      axis.appendChild(this.axisCanvas);
    }
    return axis;
  }
  resizeAxisCanvas(width, height) {
    this.axis.style.width = `${width}px`;
    this.axis.style.height = `${height}px`;
    if (typeof this.track.paintAxis === "function") {
      this.axisCanvas.style.width = `${width}px`;
      this.axisCanvas.style.height = `${height}px`;
    }
  }
  removeDOMFromColumnContainer() {
    if (this.boundAxisClickHander) {
      this.removeAxisEventListener(this.axis);
    }
    this.axis.remove();
    for (let viewport of this.viewports) {
      viewport.$viewport.remove();
    }
    this.sampleNameViewport.dispose();
    this.removeTrackScrollMouseHandlers();
    this.outerScroll.remove();
    this.removeTrackDragMouseHandlers();
    this.dragHandle.remove();
    this.removeTrackGearMouseHandlers();
    this.gearContainer.remove();
  }
  renderSVGContext(context, { deltaX, deltaY }) {
    renderSVGAxis(context, this.track, this.axisCanvas, deltaX, deltaY);
    const { width: axisWidth } = this.axis.getBoundingClientRect();
    const { y } = this.viewports[0].$viewport.get(0).getBoundingClientRect();
    let delta = {
      deltaX: axisWidth + deltaX,
      deltaY: y + deltaY
    };
    for (let viewport of this.viewports) {
      viewport.renderSVGContext(context, delta);
      const { width } = viewport.$viewport.get(0).getBoundingClientRect();
      delta.deltaX += width;
    }
    if (true === this.browser.showSampleNames) {
      this.sampleNameViewport.renderSVGContext(context, delta);
    }
  }
  dataRange() {
    return this.track.dataRange ? this.track.dataRange : void 0;
  }
  setDataRange(min, max) {
    if (min !== void 0) {
      this.track.dataRange.min = min;
    }
    if (max !== void 0) {
      this.track.dataRange.max = max;
    }
    this.track.autoscale = false;
    this.repaintViews();
  }
  presentColorPicker(key) {
    if (false === colorPickerExclusionTypes.has(this.track.type)) {
      const trackColors = [];
      const color = this.track.color || this.track.defaultColor;
      if (isString$2(color)) {
        trackColors.push(color);
      }
      if (this.track.altColor && isString$2(this.track.altColor)) {
        trackColors.push(this.track.altColor);
      }
      const defaultColors = trackColors.map((c) => c.startsWith("#") ? c : c.startsWith("rgb(") ? IGVColor.rgbToHex(c) : IGVColor.colorNameToHex(c));
      const colorHandlers = {
        color: (color2) => {
          this.track.color = color2;
          this.repaintViews();
        },
        altColor: (color2) => {
          this.track.altColor = color2;
          this.repaintViews();
        }
      };
      this.browser.genericColorPicker.configure(defaultColors, colorHandlers);
      this.browser.genericColorPicker.setActiveColorHandler(key);
      this.browser.genericColorPicker.show();
    }
  }
  setTrackHeight(newHeight, force) {
    if (!force) {
      if (this.track.minHeight) {
        newHeight = Math.max(this.track.minHeight, newHeight);
      }
      if (this.track.maxHeight) {
        newHeight = Math.min(this.track.maxHeight, newHeight);
      }
    }
    this.track.height = newHeight;
    this.resizeAxisCanvas(this.axis.clientWidth, this.track.height);
    if (typeof this.track.paintAxis === "function") {
      this.paintAxis();
    }
    for (let { $viewport } of this.viewports) {
      $viewport.height(newHeight);
    }
    this.sampleNameViewport.viewport.style.height = `${newHeight}px`;
    if (typeof this.track.computePixelHeight !== "function") {
      for (let vp of this.viewports) {
        vp.setContentHeight(newHeight);
      }
    }
    this.repaintViews();
    if (false === scrollbarExclusionTypes.has(this.track.type)) {
      this.updateScrollbar();
    }
    this.dragHandle.style.height = `${newHeight}px`;
    this.gearContainer.style.height = `${newHeight}px`;
  }
  updateScrollbar() {
    const viewportHeight = this.viewports[0].$viewport.height();
    this.outerScroll.style.height = `${viewportHeight}px`;
    const viewportContentHeight = this.maxViewportContentHeight();
    const innerScrollHeight = Math.round(viewportHeight / viewportContentHeight * viewportHeight);
    if (viewportContentHeight > viewportHeight) {
      this.innerScroll.style.display = "block";
      this.innerScroll.style.height = `${innerScrollHeight}px`;
    } else {
      this.innerScroll.style.display = "none";
    }
  }
  moveScroller(delta) {
    const y = $$1(this.innerScroll).position().top + delta;
    const top = Math.min(Math.max(0, y), this.outerScroll.clientHeight - this.innerScroll.clientHeight);
    $$1(this.innerScroll).css("top", `${top}px`);
    const contentHeight = this.maxViewportContentHeight();
    const contentTop = -Math.round(top * (contentHeight / this.viewports[0].$viewport.height()));
    for (let viewport of this.viewports) {
      viewport.setTop(contentTop);
    }
    this.sampleNameViewport.trackScrollDelta = delta;
    this.sampleNameViewport.setTop(contentTop);
  }
  isLoading() {
    for (let viewport of this.viewports) {
      if (viewport.isLoading()) return true;
    }
  }
  /**
   * Repaint all viewports without loading any new data.   Use this for events that change visual aspect of data,
   * e.g. color, sort order, etc, but do not change the genomic state.
   */
  repaintViews() {
    for (let viewport of this.viewports) {
      if (viewport.isVisible()) {
        viewport.repaint();
      }
    }
    if (typeof this.track.paintAxis === "function") {
      this.paintAxis();
    }
    this.repaintSamples();
  }
  repaintSamples() {
    if (typeof this.track.getSamples === "function") {
      const samples = this.track.getSamples();
      this.sampleNameViewport.repaint(samples);
    }
  }
  // track labels
  setTrackLabelName(name2) {
    this.viewports.forEach((viewport) => viewport.setTrackLabel(name2));
  }
  /**
   * Called in response to a window resize event, change in # of multilocus panels, or other event that changes
   * the width of the track view.
   *
   * @param viewportWidth  The width of each viewport in this track view.
   */
  resize(viewportWidth) {
    for (let viewport of this.viewports) {
      viewport.setWidth(viewportWidth);
    }
  }
  /**
   * Update viewports to reflect current genomic state, possibly loading additional data.
   *
   * @param force - if true, force a repaint even if no new data is loaded
   * @returns {Promise<void>}
   */
  async updateViews() {
    if (!(this.browser && this.browser.referenceFrameList)) return;
    const visibleViewports = this.viewports.filter((viewport) => viewport.isVisible());
    visibleViewports.forEach((viewport) => viewport.shift());
    if (this.browser.dragObject) {
      return;
    }
    const viewportsToRepaint = visibleViewports.filter((vp) => vp.needsRepaint()).filter((viewport) => viewport.checkZoomIn());
    const viewportsToReload = viewportsToRepaint.filter((viewport) => viewport.needsReload());
    for (let viewport of viewportsToReload) {
      await viewport.loadFeatures();
    }
    if (this.disposed) return;
    if (this.track && typeof this.track.variantRowCount === "function" && viewportsToReload.length > 0) {
      let maxRow = 0;
      for (let viewport of this.viewports) {
        if (viewport.featureCache && viewport.featureCache.features) {
          maxRow = Math.max(maxRow, viewport.featureCache.features.reduce((a, f) => Math.max(a, f.row || 0), 0));
        }
      }
      const current = this.track.nVariantRows;
      if (current !== maxRow + 1) {
        this.track.variantRowCount(maxRow + 1);
        for (let viewport of this.viewports) {
          viewport.checkContentHeight();
        }
      }
    }
    if (this.track.autoscale) {
      let allFeatures = [];
      for (let visibleViewport of visibleViewports) {
        const referenceFrame = visibleViewport.referenceFrame;
        const start = referenceFrame.start;
        const end = start + referenceFrame.toBP(visibleViewport.getWidth());
        if (visibleViewport.featureCache && visibleViewport.featureCache.features) {
          if (typeof visibleViewport.featureCache.features.getMax === "function") {
            const max = visibleViewport.featureCache.features.getMax(start, end);
            allFeatures.push({ value: max });
          } else {
            const viewFeatures = FeatureUtils.findOverlapping(visibleViewport.featureCache.features, start, end);
            for (let f of viewFeatures) {
              allFeatures.push(f);
            }
          }
        }
      }
      if (typeof this.track.doAutoscale === "function") {
        this.track.dataRange = this.track.doAutoscale(allFeatures);
      } else {
        this.track.dataRange = doAutoscale$1(allFeatures);
      }
    }
    const refreshView = this.track.autoscale || this.track.autoscaleGroup || this.track.type === "ruler";
    for (let vp of visibleViewports) {
      if (viewportsToRepaint.includes(vp)) {
        vp.repaint();
      } else if (refreshView) {
        vp.refresh();
      }
    }
    this.adjustTrackHeight();
    this.repaintSamples();
    this.updateRulerViewportLabels();
  }
  clearCachedFeatures() {
    for (let viewport of this.viewports) {
      viewport.clearCache();
    }
  }
  updateRulerViewportLabels() {
    const viewportWidth = this.browser.calculateViewportWidth(this.viewports.length);
    for (let viewport of this.viewports) {
      if ("ruler" === this.track.type) {
        if (this.viewports.length > 1) {
          viewport.presentLocusLabel(viewportWidth);
        } else {
          viewport.dismissLocusLabel();
        }
      }
    }
  }
  /**
   * Return a promise to get all in-view features across all viewports.  Used for group autoscaling.
   */
  async getInViewFeatures() {
    if (!(this.browser && this.browser.referenceFrameList)) {
      return [];
    }
    let allFeatures = [];
    const visibleViewports = this.viewports.filter((viewport) => viewport.isVisible());
    for (let vp of visibleViewports) {
      const referenceFrame = vp.referenceFrame;
      const { chr, start, bpPerPixel } = vp.referenceFrame;
      const end = start + referenceFrame.toBP(vp.getWidth());
      const needsReload = !vp.featureCache || !vp.featureCache.containsRange(chr, start, end, bpPerPixel);
      if (needsReload) {
        await vp.loadFeatures();
      }
      if (vp.featureCache && vp.featureCache.features) {
        if (typeof vp.featureCache.features.getMax === "function") {
          const max = vp.featureCache.features.getMax(start, end);
          allFeatures.push({ value: max });
        } else {
          const vpFeatures = typeof vp.featureCache.queryFeatures === "function" ? vp.featureCache.queryFeatures(chr, start, end) : FeatureUtils.findOverlapping(vp.featureCache.features, start, end);
          allFeatures = allFeatures.concat(vpFeatures);
        }
      }
    }
    return allFeatures;
  }
  checkContentHeight() {
    for (let viewport of this.viewports) {
      viewport.checkContentHeight();
    }
    this.adjustTrackHeight();
  }
  adjustTrackHeight() {
    var contentHeight = this.maxViewportContentHeight();
    if (this.track.autoHeight) {
      this.setTrackHeight(contentHeight, false);
    } else if (this.track.paintAxis) {
      this.paintAxis();
    }
    if (false === scrollbarExclusionTypes.has(this.track.type)) {
      const currentTop = this.viewports[0].getContentTop();
      const viewportHeight = this.viewports[0].$viewport.height();
      const minTop = Math.min(0, viewportHeight - contentHeight);
      if (currentTop < minTop) {
        for (let viewport of this.viewports) {
          viewport.setTop(minTop);
        }
      }
      this.updateScrollbar();
    }
  }
  createTrackScrollbar(browser) {
    const outerScroll = domUtils$1.div();
    browser.columnContainer.querySelector(".igv-scrollbar-column").appendChild(outerScroll);
    outerScroll.style.height = `${this.track.height}px`;
    this.outerScroll = outerScroll;
    if (false === scrollbarExclusionTypes.has(this.track.type)) {
      const innerScroll = domUtils$1.div();
      outerScroll.appendChild(innerScroll);
      this.innerScroll = innerScroll;
      this.addTrackScrollMouseHandlers(browser);
    }
  }
  createTrackDragHandle(browser) {
    const className = "ideogram" === this.track.type || "ruler" === this.track.type ? "igv-track-drag-shim" : "igv-track-drag-handle";
    this.dragHandle = domUtils$1.div({ class: className });
    browser.columnContainer.querySelector(".igv-track-drag-column").appendChild(this.dragHandle);
    this.dragHandle.style.height = `${this.track.height}px`;
    this.addTrackDragMouseHandlers(browser);
  }
  createTrackGearPopup(browser) {
    this.gearContainer = domUtils$1.div();
    browser.columnContainer.querySelector(".igv-gear-menu-column").appendChild(this.gearContainer);
    this.gearContainer.style.height = `${this.track.height}px`;
    if (true === this.track.ignoreTrackMenu) ;
    else {
      this.gear = domUtils$1.div();
      this.gearContainer.appendChild(this.gear);
      this.gear.appendChild(icons$1$1.createIcon("cog"));
      this.trackGearPopup = new MenuPopup(this.gear);
      this.addTrackGearMouseHandlers();
    }
  }
  addAxisEventListener(axis) {
    this.boundAxisClickHander = axisClickHandler.bind(this);
    axis.addEventListener("click", this.boundAxisClickHander);
    function axisClickHandler(event) {
      this.browser.dataRangeDialog.configure(this);
      this.browser.dataRangeDialog.present($$1(this.browser.columnContainer));
    }
  }
  removeAxisEventListener(axis) {
    axis.removeEventListener("click", this.boundAxisClickHander);
  }
  addTrackScrollMouseHandlers(browser) {
    this.boundTrackScrollMouseDownHandler = trackScrollMouseDownHandler.bind(this);
    this.innerScroll.addEventListener("mousedown", this.boundTrackScrollMouseDownHandler);
    function trackScrollMouseDownHandler(event) {
      event.stopPropagation();
      const { y } = domUtils$1.pageCoordinates(event);
      $$1(this.innerScroll).data("yDown", y.toString());
      this.boundColumnContainerMouseMoveHandler = columnContainerMouseMoveHandler.bind(this);
      browser.columnContainer.addEventListener("mousemove", this.boundColumnContainerMouseMoveHandler);
      function columnContainerMouseMoveHandler(event2) {
        event2.stopPropagation();
        const { y: y2 } = domUtils$1.pageCoordinates(event2);
        this.moveScroller(y2 - parseInt($$1(this.innerScroll).data("yDown")));
        $$1(this.innerScroll).data("yDown", y2.toString());
      }
    }
    this.boundColumnContainerMouseUpHandler = columnContainerMouseUpHandler.bind(this);
    browser.columnContainer.addEventListener("mouseup", this.boundColumnContainerMouseUpHandler);
    function columnContainerMouseUpHandler(event) {
      browser.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler);
    }
  }
  removeTrackScrollMouseHandlers() {
    if (false === scrollbarExclusionTypes.has(this.track.type)) {
      this.innerScroll.removeEventListener("mousedown", this.boundTrackScrollMouseDownHandler);
      this.browser.columnContainer.removeEventListener("mouseup", this.boundColumnContainerMouseUpHandler);
      this.browser.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler);
    }
  }
  addTrackDragMouseHandlers(browser) {
    if ("ideogram" === this.track.id || "ruler" === this.track.id) ;
    else {
      let trackDragMouseDownHandler = function(event) {
        event.preventDefault();
        currentDragHandle = event.target;
        currentDragHandle.classList.add("igv-track-drag-handle-hover");
        browser.startTrackDrag(this);
      }, documentTrackDragMouseUpHandler = function(event) {
        browser.endTrackDrag();
        if (currentDragHandle && event.target !== currentDragHandle) {
          currentDragHandle.classList.remove("igv-track-drag-handle-hover");
        }
        currentDragHandle = void 0;
      }, trackDragMouseEnterHandler = function(event) {
        event.preventDefault();
        if (void 0 === currentDragHandle) {
          event.target.classList.add("igv-track-drag-handle-hover");
        }
        browser.updateTrackDrag(this);
      }, trackDragMouseOutHandler = function(event) {
        event.preventDefault();
        if (void 0 === currentDragHandle) {
          event.target.classList.remove("igv-track-drag-handle-hover");
        }
      };
      let currentDragHandle = void 0;
      this.boundTrackDragMouseDownHandler = trackDragMouseDownHandler.bind(this);
      this.dragHandle.addEventListener("mousedown", this.boundTrackDragMouseDownHandler);
      this.boundDocumentTrackDragMouseUpHandler = documentTrackDragMouseUpHandler.bind(this);
      document.addEventListener("mouseup", this.boundDocumentTrackDragMouseUpHandler);
      this.boundTrackDragMouseEnterHandler = trackDragMouseEnterHandler.bind(this);
      this.dragHandle.addEventListener("mouseenter", this.boundTrackDragMouseEnterHandler);
      this.dragHandle.addEventListener("mouseout", (e) => {
        e.preventDefault();
        if (void 0 === currentDragHandle) {
          e.target.classList.remove("igv-track-drag-handle-hover");
        }
      });
      this.boundTrackDragMouseOutHandler = trackDragMouseOutHandler.bind(this);
      this.dragHandle.addEventListener("mouseout", this.boundTrackDragMouseOutHandler);
    }
  }
  removeTrackDragMouseHandlers() {
    if ("ideogram" === this.track.id || "ruler" === this.track.id) ;
    else {
      this.dragHandle.removeEventListener("mousedown", this.boundTrackDragMouseDownHandler);
      document.removeEventListener("mouseup", this.boundDocumentTrackDragMouseUpHandler);
      this.dragHandle.removeEventListener("mouseup", this.boundTrackDragMouseEnterHandler);
      this.dragHandle.removeEventListener("mouseout", this.boundTrackDragMouseOutHandler);
    }
  }
  addTrackGearMouseHandlers() {
    if (true === this.track.ignoreTrackMenu) ;
    else {
      let trackGearClickHandler = function(event) {
        event.preventDefault();
        event.stopPropagation();
        this.trackGearPopup.presentMenuList(MenuUtils$1.trackMenuItemList(this));
      };
      this.boundTrackGearClickHandler = trackGearClickHandler.bind(this);
      this.gear.addEventListener("click", this.boundTrackGearClickHandler);
    }
  }
  removeTrackGearMouseHandlers() {
    if (true === this.track.ignoreTrackMenu) ;
    else {
      this.gear.removeEventListener("click", this.boundTrackGearClickHandler);
    }
  }
  /**
   * Do any cleanup here
   */
  dispose() {
    this.removeAxisEventListener(this.axis);
    this.axis.remove();
    for (let viewport of this.viewports) {
      viewport.dispose();
    }
    this.sampleNameViewport.dispose();
    this.removeTrackScrollMouseHandlers();
    this.outerScroll.remove();
    this.removeTrackDragMouseHandlers();
    this.dragHandle.remove();
    this.removeTrackGearMouseHandlers();
    this.gearContainer.remove();
    if (typeof this.track.dispose === "function") {
      this.track.dispose();
    }
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
    if (this.alert) {
      this.alert.container.remove();
    }
    this.disposed = true;
  }
  paintAxis() {
    if (typeof this.track.paintAxis === "function") {
      const { width, height } = this.axisCanvas.getBoundingClientRect();
      const dpi = window.devicePixelRatio || 1;
      this.axisCanvas.height = dpi * height;
      this.axisCanvas.width = dpi * width;
      const axisCanvasContext = this.axisCanvas.getContext("2d");
      axisCanvasContext.scale(dpi, dpi);
      this.track.paintAxis(axisCanvasContext, width, height);
    }
  }
  maxViewportContentHeight() {
    return Math.max(this.viewports.map((viewport) => viewport.getContentHeight()));
  }
}
function renderSVGAxis(context, track, axisCanvas, deltaX, deltaY) {
  if (typeof track.paintAxis === "function") {
    const { y, width, height } = axisCanvas.getBoundingClientRect();
    const str = (track.name || track.id).replace(/\W/g, "");
    const id = `${str}_axis_guid_${domUtils$1.guid()}`;
    context.saveWithTranslationAndClipRect(id, deltaX, y + deltaY, width, height, 0);
    track.paintAxis(context, width, height);
    context.restore();
  }
}
const DEFAULT_COLOR$1 = "rgb(150, 150, 150)";
class WigTrack extends TrackBase {
  static defaults = {
    height: 50,
    flipAxis: false,
    logScale: false,
    windowFunction: "mean",
    graphType: "bar",
    autoscale: true,
    normalize: void 0,
    scaleFactor: void 0
  };
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.type = "wig";
    this.featureType = "numeric";
    this.paintAxis = paintAxis;
    const format2 = config.format ? config.format.toLowerCase() : config.format;
    if (config.featureSource) {
      this.featureSource = config.featureSource;
      delete config.featureSource;
    } else if ("bigwig" === format2) {
      this.featureSource = new BWSource(config, this.browser.genome);
    } else if ("tdf" === format2) {
      this.featureSource = new TDFSource(config, this.browser.genome);
    } else {
      this.featureSource = FeatureSource(config, this.browser.genome);
    }
    if (config.max === void 0 || config.autoscale === true) {
      this.autoscale = true;
    } else {
      this.dataRange = {
        min: config.min || 0,
        max: config.max
      };
    }
  }
  async postInit() {
    const header = await this.getHeader();
    if (this.disposed) return;
    if (header) this.setTrackProperties(header);
  }
  async getFeatures(chr, start, end, bpPerPixel) {
    const features = await this.featureSource.getFeatures({
      chr,
      start,
      end,
      bpPerPixel,
      visibilityWindow: this.visibilityWindow,
      windowFunction: this.windowFunction
    });
    if (this.normalize && this.featureSource.normalizationFactor) {
      const scaleFactor = this.featureSource.normalizationFactor;
      for (let f of features) {
        f.value *= scaleFactor;
      }
    }
    if (this.scaleFactor) {
      const scaleFactor = this.scaleFactor;
      for (let f of features) {
        f.value *= scaleFactor;
      }
    }
    return features;
  }
  menuItemList() {
    let items = [];
    if (this.flipAxis !== void 0) {
      items.push("<hr>");
      items.push({
        label: "Flip y-axis",
        click: () => {
          this.flipAxis = !this.flipAxis;
          this.trackView.repaintViews();
        }
      });
    }
    items = items.concat(MenuUtils$1.numericDataMenuItems(this.trackView));
    return items;
  }
  async getHeader() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
    }
    return this.header;
  }
  // TODO: refactor to igvUtils.js
  getScaleFactor(min, max, height, logScale) {
    const scale = logScale ? height / (Math.log10(max + 1) - (min <= 0 ? 0 : Math.log10(min + 1))) : height / (max - min);
    return scale;
  }
  computeYPixelValue(yValue, yScaleFactor) {
    return (this.flipAxis ? yValue - this.dataRange.min : this.dataRange.max - yValue) * yScaleFactor;
  }
  computeYPixelValueInLogScale(yValue, yScaleFactor) {
    let maxValue = this.dataRange.max;
    let minValue = this.dataRange.min;
    if (maxValue <= 0) return 0;
    if (minValue <= -1) minValue = 0;
    minValue = minValue <= 0 ? 0 : Math.log10(minValue + 1);
    maxValue = Math.log10(maxValue + 1);
    yValue = Math.log10(yValue + 1);
    return (this.flipAxis ? yValue - minValue : maxValue - yValue) * yScaleFactor;
  }
  draw(options2) {
    const features = options2.features;
    const ctx2 = options2.context;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const pixelWidth = options2.pixelWidth;
    options2.pixelHeight;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    const posColor = this.color || DEFAULT_COLOR$1;
    let baselineColor;
    if (typeof posColor === "string" && posColor.startsWith("rgb(")) {
      baselineColor = IGVColor.addAlpha(posColor, 0.1);
    }
    const scaleFactor = this.getScaleFactor(this.dataRange.min, this.dataRange.max, options2.pixelHeight, this.logScale);
    const yScale = (yValue) => this.logScale ? this.computeYPixelValueInLogScale(yValue, scaleFactor) : this.computeYPixelValue(yValue, scaleFactor);
    if (features && features.length > 0) {
      if (this.dataRange.min === void 0) this.dataRange.min = 0;
      if (this.dataRange.max > this.dataRange.min) {
        let lastPixelEnd = -1;
        let lastY;
        const y0 = yScale(0);
        for (let f of features) {
          if (f.end < bpStart) continue;
          if (f.start > bpEnd) break;
          const x = Math.floor((f.start - bpStart) / bpPerPixel);
          if (isNaN(x)) continue;
          let y = yScale(f.value);
          const rectEnd = Math.ceil((f.end - bpStart) / bpPerPixel);
          const width = Math.max(1, rectEnd - x);
          const color = this.getColorForFeature(f);
          if (this.graphType === "points") {
            const pointSize = this.config.pointSize || 3;
            const px = x + width / 2;
            IGVGraphics.fillCircle(ctx2, px, y, pointSize / 2, { "fillStyle": color, "strokeStyle": color });
          } else if (this.graphType === "line") {
            if (lastY != void 0) {
              IGVGraphics.strokeLine(ctx2, lastPixelEnd, lastY, x, y, {
                "fillStyle": color,
                "strokeStyle": color
              });
            }
            IGVGraphics.strokeLine(ctx2, x, y, x + width, y, { "fillStyle": color, "strokeStyle": color });
          } else {
            const height = y - y0;
            IGVGraphics.fillRect(ctx2, x, y0, width, height, { fillStyle: color });
          }
          lastPixelEnd = x + width;
          lastY = y;
        }
        if (this.dataRange.min < 0) {
          const basepx = this.dataRange.max / (this.dataRange.max - this.dataRange.min) * options2.pixelHeight;
          IGVGraphics.strokeLine(ctx2, 0, basepx, options2.pixelWidth, basepx, { strokeStyle: baselineColor });
        }
      }
    }
    if (this.config.hasOwnProperty("guideLines")) {
      for (let line of this.config.guideLines) {
        if (line.hasOwnProperty("color") && line.hasOwnProperty("y") && line.hasOwnProperty("dotted")) {
          let y = yScale(line.y);
          let props = {
            "strokeStyle": line["color"],
            "strokeWidth": 2
          };
          if (line["dotted"]) IGVGraphics.dashedLine(options2.context, 0, y, options2.pixelWidth, y, 5, props);
          else IGVGraphics.strokeLine(options2.context, 0, y, options2.pixelWidth, y, props);
        }
      }
    }
  }
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    if (features && features.length > 0) {
      const genomicLocation = clickState.genomicLocation;
      const popupData = [];
      features.sort(function(a, b) {
        const distA = Math.abs((a.start + a.end) / 2 - genomicLocation);
        const distB = Math.abs((b.start + b.end) / 2 - genomicLocation);
        return distA - distB;
      });
      const displayFeatures = features.length > 10 ? features.slice(0, 10) : features;
      displayFeatures.sort(function(a, b) {
        return a.start - b.start;
      });
      for (let selectedFeature of displayFeatures) {
        if (selectedFeature) {
          if (popupData.length > 0) {
            popupData.push("<hr/>");
          }
          let posString = selectedFeature.end - selectedFeature.start === 1 ? numberFormatter$1(selectedFeature.start + 1) : numberFormatter$1(selectedFeature.start + 1) + "-" + numberFormatter$1(selectedFeature.end);
          popupData.push({ name: "Position:", value: posString });
          popupData.push({
            name: "Value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;",
            value: numberFormatter$1(selectedFeature.value)
          });
        }
      }
      if (displayFeatures.length < features.length) {
        popupData.push("<hr/>...");
      }
      return popupData;
    } else {
      return [];
    }
  }
  get supportsWholeGenome() {
    return !this.config.indexURL && this.config.supportsWholeGenome !== false;
  }
  /**
   * Return color for feature.
   * @param feature
   * @returns {string}
   */
  getColorForFeature(f) {
    let c = f.value < 0 && this.altColor ? this.altColor : this.color || DEFAULT_COLOR$1;
    return typeof c === "function" ? c(f.value) : c;
  }
  /**
   * Called when the track is removed.  Do any needed cleanup here
   */
  dispose() {
    this.trackView = void 0;
  }
}
function BinnedColorScale(cs) {
  this.thresholds = cs.thresholds;
  this.colors = cs.colors;
}
BinnedColorScale.prototype.getColor = function(value) {
  for (let threshold of this.thresholds) {
    if (value < threshold) {
      return this.colors[this.thresholds.indexOf(threshold)];
    }
  }
  return this.colors[this.colors.length - 1];
};
function GradientColorScale(scale) {
  this.scale = scale;
  this.lowColor = "rgb(" + scale.lowR + "," + scale.lowG + "," + scale.lowB + ")";
  this.highColor = "rgb(" + scale.highR + "," + scale.highG + "," + scale.highB + ")";
  this.diff = scale.high - scale.low;
}
GradientColorScale.prototype.getColor = function(value) {
  var scale = this.scale, r, g, b, frac;
  if (value <= scale.low) return this.lowColor;
  else if (value >= scale.high) return this.highColor;
  frac = (value - scale.low) / this.diff;
  r = Math.floor(scale.lowR + frac * (scale.highR - scale.lowR));
  g = Math.floor(scale.lowG + frac * (scale.highG - scale.lowG));
  b = Math.floor(scale.lowB + frac * (scale.highB - scale.lowB));
  return "rgb(" + r + "," + g + "," + b + ")";
};
class ConstantColorScale {
  constructor(color) {
    this.color = color;
  }
  getColor() {
    return this.color;
  }
}
class SegTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.type = config.type || "seg";
    if (this.type === "maf") this.type = "mut";
    this.isLog = config.isLog;
    this.displayMode = config.displayMode || "EXPANDED";
    this.height = config.height || 300;
    this.maxHeight = config.maxHeight || 500;
    this.squishedRowHeight = config.sampleSquishHeight || config.squishedRowHeight || 2;
    this.expandedRowHeight = config.sampleExpandHeight || config.expandedRowHeight || 13;
    this.sampleHeight = this.squishedRowHeight;
    if (config.color) {
      this.color = config.color;
    } else {
      this.posColorScale = config.posColorScale || new GradientColorScale({
        low: 0.1,
        lowR: 255,
        lowG: 255,
        lowB: 255,
        high: 1.5,
        highR: 255,
        highG: 0,
        highB: 0
      });
      this.negColorScale = config.negColorScale || new GradientColorScale({
        low: -1.5,
        lowR: 0,
        lowG: 0,
        lowB: 255,
        high: -0.1,
        highR: 255,
        highG: 255,
        highB: 255
      });
      if (this.type === "mut") {
        this.colorTable = new ColorTable(config.colorTable || MUT_COLORS);
      }
    }
    this.sampleKeys = [];
    this.sampleNames = /* @__PURE__ */ new Map();
    if (config.samples) {
      for (let s of config.samples) {
        this.sampleKeys.push(s);
        this.sampleNames.set(s, s);
      }
      this.explicitSamples = true;
    }
    const configCopy = Object.assign({}, this.config);
    configCopy.maxWGCount = configCopy.maxWGCount || Number.MAX_SAFE_INTEGER;
    this.featureSource = FeatureSource(configCopy, this.browser.genome);
    this.initialSort = config.sort;
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
    }
    if (this.header) {
      this.setTrackProperties(this.header);
    }
  }
  menuItemList() {
    const menuItems = [];
    const lut = {
      "SQUISHED": "Squish",
      "EXPANDED": "Expand",
      "FILL": "Fill"
    };
    menuItems.push("<hr/>");
    menuItems.push("DisplayMode:");
    const displayOptions = this.type === "seg" ? ["SQUISHED", "EXPANDED", "FILL"] : ["SQUISHED", "EXPANDED"];
    for (let displayMode of displayOptions) {
      const checkBox = createCheckbox$2(lut[displayMode], displayMode === this.displayMode);
      menuItems.push(
        {
          object: $$1(checkBox),
          click: () => {
            this.displayMode = displayMode;
            this.config.displayMode = displayMode;
            this.trackView.checkContentHeight();
            this.trackView.repaintViews();
            this.trackView.moveScroller(this.trackView.sampleNameViewport.trackScrollDelta);
          }
        }
      );
    }
    return menuItems;
  }
  hasSamples() {
    return true;
  }
  getSamples() {
    return {
      names: this.sampleKeys.map((key) => this.sampleNames.get(key)),
      height: this.sampleHeight,
      yOffset: 0
    };
  }
  async getFeatures(chr, start, end) {
    const features = await this.featureSource.getFeatures({ chr, start, end });
    if (this.initialSort) {
      const sort = this.initialSort;
      this.sortSamples(sort.chr, sort.start, sort.end, sort.direction, features);
      this.initialSort = void 0;
    }
    return features;
  }
  draw({ context, renderSVG, pixelTop, pixelWidth, pixelHeight, features, bpPerPixel, bpStart }) {
    IGVGraphics.fillRect(context, 0, pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    if (features && features.length > 0) {
      this.checkForLog(features);
      this.updateSampleKeys(features);
      const samples = {};
      this.sampleKeys.forEach(function(id, index2) {
        samples[id] = index2;
      });
      let border;
      switch (this.displayMode) {
        case "FILL":
          this.sampleHeight = pixelHeight / this.sampleKeys.length;
          border = 0;
          break;
        case "SQUISHED":
          this.sampleHeight = this.squishedRowHeight;
          border = 0;
          break;
        default:
          this.sampleHeight = this.expandedRowHeight;
          border = 1;
      }
      const rowHeight = this.sampleHeight;
      for (let segment of features) {
        segment.pixelRect = void 0;
      }
      const pixelBottom = pixelTop + pixelHeight;
      const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
      const xScale = bpPerPixel;
      this.sampleYStart = void 0;
      for (let f of features) {
        if (f.end < bpStart) continue;
        if (f.start > bpEnd) break;
        const sampleKey = f.sampleKey || f.sample;
        f.row = samples[sampleKey];
        const y = f.row * rowHeight + border;
        if (void 0 === this.sampleYStart) {
          this.sampleYStart = y;
        }
        const bottom = y + rowHeight;
        if (bottom < pixelTop || y > pixelBottom) {
          continue;
        }
        const segmentStart = Math.max(f.start, bpStart);
        let x = Math.round((segmentStart - bpStart) / xScale);
        const segmentEnd = Math.min(f.end, bpEnd);
        const x1 = Math.round((segmentEnd - bpStart) / xScale);
        let w = Math.max(1, x1 - x);
        let color;
        if (this.color) {
          if (typeof this.color === "function") {
            color = this.color(f);
          } else {
            color = this.color;
          }
        } else if (this.colorTable) {
          color = this.colorTable.getColor(f.value.toLowerCase());
        }
        let h;
        if ("mut" === this.type) {
          h = rowHeight - 2 * border;
          if (w < 3) {
            w = 3;
            x -= 1;
          }
        } else {
          let value = f.value;
          if (!this.isLog) {
            value = IGVMath.log2(value / 2);
          }
          if (value < -0.1) {
            color = this.negColorScale.getColor(value);
          } else if (value > 0.1) {
            color = this.posColorScale.getColor(value);
          } else {
            color = "white";
          }
          let sh = rowHeight;
          if (rowHeight < 0.25) {
            const f2 = 0.1 + 2 * Math.abs(value);
            sh = Math.min(1, f2 * rowHeight);
          }
          h = sh - 2 * border;
        }
        f.pixelRect = { x, y, w, h };
        context.fillStyle = color;
        context.fillRect(x, y, w, h);
      }
    }
  }
  checkForLog(features) {
    if (this.isLog === void 0) {
      this.isLog = false;
      for (let feature2 of features) {
        if (feature2.value < 0) {
          this.isLog = true;
          return;
        }
      }
    }
  }
  /**
   * Optional method to compute pixel height to accomodate the list of features.  The implementation below
   * has side effects (modifiying the samples hash).  This is unfortunate, but harmless.
   *
   * Note displayMode "FILL" is handled by the viewport
   *
   * @param features
   * @returns {number}
   */
  computePixelHeight(features) {
    if (!features) return 0;
    const sampleHeight = "SQUISHED" === this.displayMode ? this.squishedRowHeight : this.expandedRowHeight;
    this.updateSampleKeys(features);
    return this.sampleKeys.length * sampleHeight;
  }
  /**
   * Sort samples by the average value over the genomic range in the direction indicated (1 = ascending, -1 descending)
   */
  async sortSamples(chr, start, end, direction, featureList) {
    if (!featureList) {
      featureList = await this.featureSource.getFeatures({ chr, start, end });
    }
    if (!featureList) return;
    this.updateSampleKeys(featureList);
    const scores = {};
    const d2 = direction === "ASC" ? 1 : -1;
    const sortSeg = () => {
      const bpLength = end - start + 1;
      for (let segment of featureList) {
        if (segment.end < start) continue;
        if (segment.start > end) break;
        const min = Math.max(start, segment.start);
        const max = Math.min(end, segment.end);
        const f = (max - min) / bpLength;
        const sampleKey = segment.sampleKey || segment.sample;
        const s = scores[sampleKey] || 0;
        scores[sampleKey] = s + f * segment.value;
      }
      this.sampleKeys.sort(function(a, b) {
        let s1 = scores[a];
        let s2 = scores[b];
        if (!s1) s1 = d2 * Number.MAX_VALUE;
        if (!s2) s2 = d2 * Number.MAX_VALUE;
        if (s1 === s2) return 0;
        else if (s1 > s2) return d2;
        else return d2 * -1;
      });
    };
    const sortMut = () => {
      for (let segment of featureList) {
        if (segment.end < start) continue;
        if (segment.start > end) break;
        const sampleKey = segment.sampleKey || segment.sample;
        if (!scores.hasOwnProperty(sampleKey) || segment.value.localeCompare(scores[sampleKey]) > 0) {
          scores[sampleKey] = segment.value;
        }
      }
      this.sampleKeys.sort(function(a, b) {
        let sa = scores[a] || "";
        let sb = scores[b] || "";
        return d2 * sa.localeCompare(sb);
      });
    };
    if ("mut" === this.type) {
      sortMut();
    } else {
      sortSeg();
    }
    this.trackView.repaintViews();
  }
  clickedFeatures(clickState) {
    const allFeatures = super.clickedFeatures(clickState);
    const y = clickState.y;
    return allFeatures.filter(function(feature2) {
      const rect = feature2.pixelRect;
      return rect && y >= rect.y && y <= rect.y + rect.h;
    });
  }
  hoverText(clickState) {
    const features = this.clickedFeatures(clickState);
    if (features && features.length > 0) {
      return `${features[0].sample}: ${features[0].value}`;
    }
  }
  popupData(clickState, featureList) {
    if (featureList === void 0) featureList = this.clickedFeatures(clickState);
    const items = [];
    for (let feature2 of featureList) {
      if (items.length > 0) {
        items.push("<hr/>");
        items.push("<hr/>");
      }
      const f = feature2._f || feature2;
      const data = typeof f.popupData === "function" ? f.popupData(this.type, this.browser.genome.id) : this.extractPopupData(f);
      Array.prototype.push.apply(items, data);
    }
    return items;
  }
  contextMenuItemList(clickState) {
    const referenceFrame = clickState.viewport.referenceFrame;
    const genomicLocation = clickState.genomicLocation;
    const sortDirection = this.config.sort ? this.config.sort.direction === "ASC" ? "DESC" : "ASC" : (
      // Toggle from previous sort
      "DESC"
    );
    const bpWidth = referenceFrame.toBP(2.5);
    const sortHandler = (sort) => {
      const viewport = clickState.viewport;
      const features = viewport.cachedFeatures;
      this.sortSamples(sort.chr, sort.start, sort.end, sort.direction, features);
    };
    const sortLabel = this.type === "seg" ? "Sort by value" : "Sort by type";
    return [
      {
        label: sortLabel,
        click: (e) => {
          const sort = {
            direction: sortDirection,
            chr: clickState.viewport.referenceFrame.chr,
            start: genomicLocation - bpWidth,
            end: genomicLocation + bpWidth
          };
          sortHandler(sort);
          this.config.sort = sort;
        }
      }
    ];
  }
  get supportsWholeGenome() {
    return (this.config.indexed === false || !this.config.indexURL) && this.config.supportsWholeGenome !== false;
  }
  updateSampleKeys(featureList) {
    if (this.explicitSamples) return;
    for (let feature2 of featureList) {
      const sampleKey = feature2.sampleKey || feature2.sample;
      if (!this.sampleNames.has(sampleKey)) {
        this.sampleNames.set(sampleKey, feature2.sample);
        this.sampleKeys.push(sampleKey);
      }
    }
  }
}
const MUT_COLORS = {
  "indel": "rgb(0,200,0)",
  "targeted region": "rgb(236,155,43)",
  "truncating": "rgb(	150,0,0)",
  "non-coding transcript": "rgb(0,0,150)",
  // Colors from https://www.nature.com/articles/nature11404
  "synonymous": "rgb(109,165,95)",
  "silent": "rgb(109,135,80)",
  "missense_mutation": "rgb(72,130,187)",
  "missense": "rgb(72,130,187)",
  "splice site": "rgb(143,83,155)",
  "splice_region": "rgb(143,83,155)",
  "nonsense": "rgb(216, 57,81)",
  "nonsense_mutation": "rgb(216, 57,81)",
  "frame_shift_del": "rgb(226,135,65)",
  "frame_shift_ins": "rgb(226,135,65)",
  "in_frame_del": "rgb(247,235,94)",
  "in_frame_ins": "rgb(247,235,94)",
  "*other*": "rgb(159,91,50)"
  //
  // 3'Flank
  // 3'UTR
  // 5'Flank
  // 5'UTR
  // Frame_Shift_Del
  // Frame_Shift_Ins
  // IGR
  // In_Frame_Del
  // In_Frame_Ins
  // Intron
  // Missense_Mutation
  // Nonsense_Mutation
  // Nonstop_Mutation
  // RNA
  // Silent
  // Splice_Region
  // Splice_Site
  // Translation_Start_Site
  // Variant_Classification
};
class MergedTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
    this.type = "merged";
    this.featureType = "numeric";
    this.paintAxis = paintAxis;
    this.graphType = config.graphType;
  }
  init(config) {
    if (!config.tracks) {
      throw Error("Error: no tracks defined for merged track" + config);
    }
    super.init(config);
  }
  async postInit() {
    this.tracks = [];
    const p = [];
    for (let tconf of this.config.tracks) {
      tconf.isMergedTrack = true;
      const t = await this.browser.createTrack(tconf);
      if (t) {
        t.autoscale = false;
        this.tracks.push(t);
      } else {
        console.warn("Could not create track " + tconf);
      }
      if (typeof t.postInit === "function") {
        p.push(t.postInit());
      }
    }
    this.flipAxis = this.config.flipAxis ? this.config.flipAxis : false;
    this.logScale = this.config.logScale ? this.config.logScale : false;
    this.autoscale = this.config.autoscale || this.config.max === void 0;
    if (!this.autoscale) {
      this.dataRange = {
        min: this.config.min || 0,
        max: this.config.max
      };
    }
    for (let t of this.tracks) {
      t.autoscale = false;
      t.dataRange = this.dataRange;
    }
    this.height = this.config.height || 50;
    return Promise.all(p);
  }
  get height() {
    return this._height;
  }
  set height(h) {
    this._height = h;
    if (this.tracks) {
      for (let t of this.tracks) {
        t.height = h;
        t.config.height = h;
      }
    }
  }
  menuItemList() {
    let items = [];
    if (this.flipAxis !== void 0) {
      items.push({
        label: "Flip y-axis",
        click: () => {
          this.flipAxis = !this.flipAxis;
          this.trackView.repaintViews();
        }
      });
    }
    items = items.concat(MenuUtils$1.numericDataMenuItems(this.trackView));
    return items;
  }
  /**
   * Returns a MergedFeatureCollection containing an array of features for the specified range, 1 for each track.
   */
  async getFeatures(chr, bpStart, bpEnd, bpPerPixel) {
    const promises = this.tracks.map((t) => t.getFeatures(chr, bpStart, bpEnd, bpPerPixel));
    const featureArrays = await Promise.all(promises);
    return new MergedFeatureCollection(featureArrays);
  }
  draw(options2) {
    const mergedFeatures = options2.features;
    for (let i = 0, len2 = this.tracks.length; i < len2; i++) {
      const trackOptions = Object.assign({}, options2);
      trackOptions.features = mergedFeatures.featureArrays[i];
      this.tracks[i].dataRange = this.dataRange;
      this.tracks[i].flipAxis = this.flipAxis;
      this.tracks[i].logScale = this.logScale;
      if (this.graphType) {
        this.tracks[i].graphType = this.graphType;
      }
      this.tracks[i].draw(trackOptions);
    }
  }
  popupData(clickState) {
    if (clickState.viewport && clickState.viewport.cachedFeatures) {
      const featuresArray = clickState.viewport.cachedFeatures.featureArrays;
      if (featuresArray && featuresArray.length === this.tracks.length) {
        const popupData = [];
        for (let i = 0; i < this.tracks.length; i++) {
          if (i > 0) popupData.push("<hr/>");
          popupData.push(`<div style=background-color:rgb(245,245,245);border-bottom-style:dashed;border-bottom-width:1px;padding-bottom:5px;padding-top:10px;font-weight:bold;font-size:larger >${this.tracks[i].name}</div>`);
          const trackPopupData = this.tracks[i].popupData(clickState, featuresArray[i]);
          popupData.push(...trackPopupData);
        }
        return popupData;
      }
    }
  }
  clickedFeatures(clickState) {
    const mergedFeaturesCollection = clickState.viewport.cachedFeatures;
    if (!mergedFeaturesCollection) {
      return [];
    }
    const genomicLocation = clickState.genomicLocation;
    const clickedFeatures = [];
    for (let features of mergedFeaturesCollection.featureArrays) {
      const tolerance = clickState.referenceFrame.bpPerPixel > 0.2 ? 3 * clickState.referenceFrame.bpPerPixel : 0.2;
      const ss = genomicLocation - tolerance;
      const ee = genomicLocation + tolerance;
      const tmp = FeatureUtils.findOverlapping(features, ss, ee);
      for (let f of tmp) {
        clickedFeatures.push(f);
      }
    }
    return clickedFeatures;
  }
  get supportsWholeGenome() {
    return this.tracks.every((track) => track.supportsWholeGenome);
  }
}
class MergedFeatureCollection {
  constructor(featureArrays) {
    this.featureArrays = featureArrays;
  }
  getMax(start, end) {
    let max = -Number.MAX_VALUE;
    for (let a of this.featureArrays) {
      for (let f of a) {
        if (typeof f.value !== "undefined" && !Number.isNaN(f.value)) {
          if (f.end < start) {
            continue;
          }
          if (f.start > end) {
            break;
          }
          max = Math.max(max, f.value);
        }
      }
    }
    return max;
  }
}
function getArcType(config) {
  if (!config.arcType) {
    return "nested";
  }
  switch (config.arcType) {
    case "chiapet":
      return "inView";
    case "chiapetoutbound":
      return "partialInView";
    default:
      return config.arcType;
  }
}
const DEFAULT_ARC_COLOR = "rgb(180,25,137)";
class InteractionTrack extends TrackBase {
  static defaults = {
    height: 250,
    theta: Math.PI / 4,
    arcOrientation: true,
    showBlocks: true,
    blockHeight: 3,
    thickness: 1,
    alpha: 0.02,
    logScale: true
  };
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.sinTheta = Math.sin(this.theta);
    this.cosTheta = Math.cos(this.theta);
    this.arcType = getArcType(config);
    this.alpha = config.alpha || 0.02;
    this.painter = { flipAxis: !this.arcOrientation, dataRange: this.dataRange, paintAxis };
    if (config.valueColumn) {
      this.valueColumn = config.valueColumn;
      this.hasValue = true;
    } else if (config.useScore) {
      this.hasValue = true;
      this.valueColumn = "score";
    }
    if (config.max) {
      this.dataRange = {
        min: config.min || 0,
        max: config.max
      };
      this.autoscale = false;
    } else {
      this.autoscale = true;
    }
    if (config.featureSource) {
      this.featureSource = config.featureSource;
      delete config._featureSource;
    } else {
      this.featureSource = FeatureSource(config, this.browser.genome);
      this.featureSource.getWGFeatures = getWGFeatures;
    }
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
    }
    if (this.header) {
      this.setTrackProperties(this.header);
    }
    if (this.visibilityWindow === void 0 && typeof this.featureSource.defaultVisibilityWindow === "function") {
      this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
      this.featureSource.visibilityWindow = this.visibilityWindow;
    }
    return this;
  }
  get supportsWholeGenome() {
    return true;
  }
  async getFeatures(chr, start, end) {
    const visibilityWindow = this.visibilityWindow;
    const features = await this.featureSource.getFeatures({ chr, start, end, visibilityWindow });
    if (this.hasValue === void 0 && features && features.length > 0) {
      this.hasValue = features[0].score !== void 0;
    }
    return features;
  }
  draw(options2) {
    if (this.arcType === "proportional") {
      this.drawProportional(options2);
    } else if (this.arcType === "inView" || this.arcType === "partialInView") {
      this.drawProportional(options2);
    } else {
      this.drawNested(options2);
    }
  }
  drawNested(options2) {
    const ctx2 = options2.context;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    const viewportWidth = options2.viewportWidth;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const xScale = bpPerPixel;
    IGVGraphics.fillRect(ctx2, 0, options2.pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    const featureList = options2.features;
    if (featureList) {
      autoscaleNested.call(this);
      const y = this.arcOrientation ? options2.pixelHeight : 0;
      const direction = this.arcOrientation;
      ctx2.font = "8px sans-serif";
      ctx2.textAlign = "center";
      for (let feature2 of featureList) {
        feature2.drawState = void 0;
        let color;
        if (typeof this.color === "function") {
          color = this.color(feature2);
        } else {
          color = this.color || feature2.color || DEFAULT_ARC_COLOR;
          if (color && this.config.useScore) {
            color = getAlphaColor(color, scoreShade(feature2.score));
          }
        }
        ctx2.lineWidth = feature2.thickness || this.thickness || 1;
        if (feature2.chr1 === feature2.chr2 || feature2.chr === "all") {
          const { m1, m2 } = getMidpoints(feature2, this.browser.genome);
          let pixelStart = Math.round((m1 - bpStart) / xScale);
          let pixelEnd = Math.round((m2 - bpStart) / xScale);
          if (pixelEnd < 0 || pixelStart > pixelWidth) continue;
          let w = pixelEnd - pixelStart;
          if (w < 3) {
            w = 3;
            pixelStart--;
          }
          const a = w / 2;
          const r = a / this.sinTheta;
          const b = this.cosTheta * r;
          const xc = pixelStart + a;
          let yc, startAngle, endAngle;
          if (direction) {
            yc = this.height + b;
            startAngle = Math.PI + Math.PI / 2 - this.theta;
            endAngle = Math.PI + Math.PI / 2 + this.theta;
          } else {
            yc = -b;
            startAngle = Math.PI / 2 - this.theta;
            endAngle = Math.PI / 2 + this.theta;
          }
          if (this.showBlocks && feature2.chr !== "all") {
            const s1 = (feature2.start1 - bpStart) / xScale;
            const e1 = (feature2.end1 - bpStart) / xScale;
            const s2 = (feature2.start2 - bpStart) / xScale;
            const e2 = (feature2.end2 - bpStart) / xScale;
            const hb = this.arcOrientation ? -this.blockHeight : this.blockHeight;
            ctx2.fillRect(s1, y, e1 - s1, hb);
            ctx2.fillRect(s2, y, e2 - s2, hb);
          }
          if (color && !this.config.useScore && w > viewportWidth) {
            color = getAlphaColor(color, this.alpha);
          }
          ctx2.strokeStyle = color;
          ctx2.fillStyle = color;
          ctx2.beginPath();
          ctx2.arc(xc, yc, r, startAngle, endAngle, false);
          ctx2.stroke();
          feature2.drawState = { xc, yc, r };
        } else {
          let pixelStart = Math.round((feature2.start - bpStart) / xScale);
          let pixelEnd = Math.round((feature2.end - bpStart) / xScale);
          if (pixelEnd < 0 || pixelStart > pixelWidth) continue;
          let w = pixelEnd - pixelStart;
          if (w < 3) {
            w = 3;
            pixelStart--;
          }
          const otherChr = feature2.chr === feature2.chr1 ? feature2.chr2 : feature2.chr1;
          ctx2.strokeStyle = color;
          ctx2.fillStyle = getAlphaColor(getChrColor(otherChr), 0.5);
          if (direction) {
            ctx2.fillRect(pixelStart, this.height / 2, w, this.height / 2);
            ctx2.fillText(otherChr, pixelStart + w / 2, this.height / 2 - 5);
            feature2.drawState = { x: pixelStart, y: this.height / 2, w, h: this.height / 2 };
          } else {
            ctx2.fillRect(pixelStart, 0, w, this.height / 2);
            ctx2.fillText(otherChr, pixelStart + w / 2, this.height / 2 + 13);
            feature2.drawState = { x: pixelStart, y: 0, w, h: this.height / 2 };
          }
        }
      }
    }
    function autoscaleNested() {
      let max = 0;
      for (let feature2 of featureList) {
        let pixelStart = (feature2.start - bpStart) / xScale;
        let pixelEnd = (feature2.end - bpStart) / xScale;
        if (pixelStart >= 0 && pixelEnd <= pixelWidth) {
          max = Math.max(max, pixelEnd - pixelStart);
        }
      }
      let a = Math.min(viewportWidth, max) / 2;
      if (max > 0) {
        let coa = (pixelHeight - 10) / a;
        this.theta = estimateTheta(coa);
        this.sinTheta = Math.sin(this.theta);
        this.cosTheta = Math.cos(this.theta);
      }
    }
  }
  getScaleFactor(min, max, height, logScale) {
    const scale = logScale ? height / (Math.log10(max + 1) - (min <= 0 ? 0 : Math.log10(min + 1))) : height / (max - min);
    return scale;
  }
  drawProportional(options2) {
    const ctx2 = options2.context;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const xScale = bpPerPixel;
    const refStart = options2.referenceFrame.start;
    const refEnd = options2.referenceFrame.end;
    IGVGraphics.fillRect(ctx2, 0, options2.pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    const featureList = options2.features;
    if (featureList && featureList.length > 0) {
      const effectiveMin = 0;
      const yScale = this.getScaleFactor(effectiveMin, this.dataRange.max, options2.pixelHeight - 1, this.logScale);
      const y = this.arcOrientation ? options2.pixelHeight : 0;
      for (let feature2 of featureList) {
        feature2.drawState = void 0;
        const value = this.valueColumn ? feature2[this.valueColumn] : feature2.score;
        if (value === void 0 || Number.isNaN(value)) continue;
        const radiusY = Math.round((this.logScale ? Math.log10(value + 1) : value) * yScale);
        if (feature2.chr1 === feature2.chr2 || feature2.chr === "all") {
          const { m1, m2 } = getMidpoints(feature2, this.browser.genome);
          let pixelStart = Math.round((m1 - bpStart) / xScale);
          let pixelEnd = Math.round((m2 - bpStart) / xScale);
          let w = pixelEnd - pixelStart;
          if (w < 3) {
            w = 3;
            pixelStart--;
          }
          if (value < this.dataRange.min || value > this.dataRange.max) continue;
          if ("proportional" !== this.arcType) {
            const showOutbound = this.arcType === "partialInView";
            const within = m1 >= refStart && m2 <= refEnd;
            let outBound = false;
            let inBound = false;
            if (!within && showOutbound) {
              outBound = refStart <= m1 && m1 <= refEnd;
              if (!outBound) inBound = refStart <= m2 && m2 <= refEnd;
            }
            if (!(within || outBound || inBound)) continue;
          }
          const radiusX = w / 2;
          const xc = pixelStart + w / 2;
          feature2.drawState = { xc, yc: y, radiusX, radiusY };
          const counterClockwise = this.arcOrientation ? true : false;
          const color = feature2.color || this.color;
          ctx2.strokeStyle = color;
          ctx2.lineWidth = feature2.thickness || this.thickness || 1;
          if (true === ctx2.isSVG) {
            ctx2.strokeEllipse(xc, y, radiusX, radiusY, 0, 0, Math.PI, counterClockwise);
          } else {
            ctx2.beginPath();
            ctx2.ellipse(xc, y, radiusX, radiusY, 0, 0, Math.PI, counterClockwise);
            ctx2.stroke();
          }
          if (this.alpha) {
            ctx2.fillStyle = getAlphaColor(color, this.alpha);
            if (true === ctx2.isSVG) {
              ctx2.fillEllipse(xc, y, radiusX, radiusY, 0, 0, Math.PI, counterClockwise);
            } else {
              ctx2.fill();
            }
          }
          if (this.showBlocks && feature2.chr !== "all") {
            ctx2.fillStyle = color;
            const s1 = (feature2.start1 - bpStart) / xScale;
            const e1 = (feature2.end1 - bpStart) / xScale;
            const s2 = (feature2.start2 - bpStart) / xScale;
            const e2 = (feature2.end2 - bpStart) / xScale;
            const hb = this.arcOrientation ? -this.blockHeight : this.blockHeight;
            ctx2.fillRect(s1, y, e1 - s1, hb);
            ctx2.fillRect(s2, y, e2 - s2, hb);
          }
        } else {
          let pixelStart = Math.round((feature2.start - bpStart) / xScale);
          let pixelEnd = Math.round((feature2.end - bpStart) / xScale);
          if (pixelEnd < 0 || pixelStart > pixelWidth || value < this.dataRange.min || value > this.dataRange.max) continue;
          const h = Math.min(radiusY, this.height - 13);
          let w = pixelEnd - pixelStart;
          if (w < 3) {
            w = 3;
            pixelStart--;
          }
          const otherChr = feature2.chr === feature2.chr1 ? feature2.chr2 : feature2.chr1;
          ctx2.font = "8px sans-serif";
          ctx2.textAlign = "center";
          ctx2.fillStyle = getAlphaColor(getChrColor(otherChr), 0.5);
          if (this.arcOrientation) {
            const y2 = this.height - h;
            ctx2.fillRect(pixelStart, y2, w, h);
            ctx2.fillText(otherChr, pixelStart + w / 2, y2 - 5);
            feature2.drawState = { x: pixelStart, y: y2, w, h };
          } else {
            ctx2.fillRect(pixelStart, 0, w, h);
            ctx2.fillText(otherChr, pixelStart + w / 2, h + 13);
            feature2.drawState = { x: pixelStart, y: 0, w, h };
          }
        }
      }
    }
  }
  clearAxis(ctx2, pixelWidth, pixelHeight) {
    IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
  }
  paintAxis(ctx2, pixelWidth, pixelHeight) {
    const axisRange = { min: 0, max: this.dataRange.max };
    if (this.arcType === "proportional") {
      this.painter.flipAxis = !this.arcOrientation;
      this.painter.dataRange = axisRange;
      this.painter.paintAxis(ctx2, pixelWidth, pixelHeight);
    } else if (this.arcType === "inView" || this.arcType === "partialInView") {
      this.painter.flipAxis = !this.arcOrientation;
      this.painter.dataRange = axisRange;
      this.painter.paintAxis(ctx2, pixelWidth, pixelHeight);
    } else {
      this.clearAxis(ctx2, pixelWidth, pixelHeight);
    }
  }
  menuItemList() {
    let items = [];
    if (this.hasValue) {
      items.push("<hr/>");
      const lut = {
        "nested": "Nested",
        "proportional": "Proportional - All",
        "inView": "Proportional - Both Ends in View",
        "partialInView": "Proportional - One End in View"
      };
      items.push("<b>Arc Type</b>");
      for (let arcType of ["nested", "proportional", "inView", "partialInView"]) {
        items.push(
          {
            object: $$1(createCheckbox$2(lut[arcType], arcType === this.arcType)),
            click: () => {
              this.arcType = arcType;
              this.trackView.repaintViews();
            }
          }
        );
      }
    }
    items.push("<hr/>");
    items.push({
      name: "Toggle arc direction",
      click: () => {
        this.arcOrientation = !this.arcOrientation;
        this.trackView.repaintViews();
      }
    });
    items.push({
      name: this.showBlocks ? "Hide Blocks" : "Show Blocks",
      click: () => {
        this.showBlocks = !this.showBlocks;
        this.trackView.repaintViews();
      }
    });
    if (this.arcType === "proportional" || this.arcType === "inView" || this.arcType === "partialInView") {
      items = items.concat(MenuUtils$1.numericDataMenuItems(this.trackView));
    }
    if (this.browser.circularView) {
      items.push("<hr/>");
      items.push({
        label: "Add interactions to circular view",
        click: () => {
          for (let viewport of this.trackView.viewports) {
            this.addChordsForViewport(viewport.referenceFrame);
          }
        }
      });
    }
    return items;
  }
  contextMenuItemList(clickState) {
    if (this.browser.circularView) {
      const viewport = clickState.viewport;
      const list = [];
      list.push({
        label: "Add interactions to circular view",
        click: () => {
          const refFrame = viewport.referenceFrame;
          this.addChordsForViewport(refFrame);
        }
      });
      list.push("<hr/>");
      return list;
    }
  }
  /**
   * Add chords to the circular view for the given viewport, represented by its reference frame
   * @param refFrame
   */
  addChordsForViewport(refFrame) {
    const cachedFeatures = "all" === refFrame.chr ? this.featureSource.getAllFeatures() : this.featureSource.featureCache.queryFeatures(refFrame.chr, refFrame.start, refFrame.end);
    const inView = cachedFeatures.filter((f) => f.drawState);
    if (inView.length === 0) return;
    const chords = makeBedPEChords(inView);
    sendChords(chords, this, refFrame, 0.5);
  }
  doAutoscale(features) {
    let max = 0;
    if (features) {
      for (let f of features) {
        const v = this.valueColumn ? f[this.valueColumn] : f.score;
        if (!Number.isNaN(v)) {
          max = Math.max(max, v);
        }
      }
    }
    return { min: 0, max };
  }
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    const data = [];
    for (let feature2 of features) {
      const f = feature2._ || feature2;
      data.push({ name: "Region 1", value: positionString(f.chr1, f.start1, f.end1, f.strand1) });
      data.push({ name: "Region 2", value: positionString(f.chr2, f.start2, f.end2, f.strand2) });
      if (f.name) {
        data.push({ name: "Name", value: f.name });
      }
      if (f.value !== void 0) {
        data.push({ name: "Value", value: f.value });
      }
      if (f.score !== void 0) {
        data.push({ name: "Score", value: f.score });
      }
      if (f.extras && this.header && this.header.columnNames) {
        const columnNames = this.header.columnNames;
        const stdColumns = this.header.hiccups ? 6 : 10;
        for (let i = stdColumns; i < columnNames.length; i++) {
          if (this.header.colorColumn === i) continue;
          if (columnNames[i] === "info") {
            extractInfoColumn(data, f.extras[i - stdColumns]);
          } else {
            data.push({ name: columnNames[i], value: f.extras[i - stdColumns] });
          }
        }
      }
      break;
    }
    return data;
  }
  clickedFeatures(clickState) {
    const featureList = clickState.viewport.cachedFeatures;
    const candidates = [];
    if (featureList) {
      const proportional = this.arcType === "proportional" || this.arcType === "inView" || this.arcType === "partialInView";
      for (let feature2 of featureList) {
        if (!feature2.drawState) continue;
        if (feature2.chr1 === feature2.chr2 || feature2.chr === "all") {
          if (proportional) {
            const { xc, yc, radiusX, radiusY } = feature2.drawState;
            const dx = clickState.canvasX - xc;
            const dy = clickState.canvasY - yc;
            const score = dx / radiusX * (dx / radiusX) + dy / radiusY * (dy / radiusY);
            if (score <= 1) {
              candidates.push({ score: 1 / score, feature: feature2 });
            }
          } else {
            const { xc, yc, r } = feature2.drawState;
            const dx = clickState.canvasX - xc;
            const dy = clickState.canvasY - yc;
            const score = Math.abs(Math.sqrt(dx * dx + dy * dy) - r);
            if (score < 5) {
              candidates.push({ score, feature: feature2 });
            }
          }
        } else {
          const { x, y, w, h } = feature2.drawState;
          const tolerance = 5;
          if (clickState.canvasX >= x - tolerance && clickState.canvasX <= x + w + tolerance && clickState.canvasY >= y && clickState.canvasY <= y + h) {
            const score = -Math.abs(clickState.canvasX - (x + w / 2));
            candidates.push({ score, feature: feature2 });
            break;
          }
        }
      }
    }
    if (candidates.length > 1) {
      candidates.sort((a, b) => a.score - b.score);
    }
    return candidates.map((c) => c.feature);
  }
}
function getMidpoints(feature2, genome) {
  let m1 = (feature2.start1 + feature2.end1) / 2;
  let m2 = (feature2.start2 + feature2.end2) / 2;
  if (feature2.chr === "all") {
    m1 = genome.getGenomeCoordinate(feature2.chr1, m1);
    m2 = genome.getGenomeCoordinate(feature2.chr2, m2);
  }
  if (m1 > m2) {
    const tmp = m1;
    m1 = m2;
    m2 = tmp;
  }
  return { m1, m2 };
}
function positionString(chr, start, end, strand) {
  return strand && strand !== "." ? `${chr}:${numberFormatter$1(start + 1)}-${numberFormatter$1(end)} (${strand})` : `${chr}:${numberFormatter$1(start + 1)}-${numberFormatter$1(end)}`;
}
function estimateTheta(x) {
  let coa = [0.01570925532366355, 0.15838444032453644, 0.3249196962329063, 0.5095254494944288, 0.7265425280053609, 0.9999999999999999];
  let theta = [0.031415926535897934, 0.3141592653589793, 0.6283185307179586, 0.9424777960769379, 1.2566370614359172, 1.5707963267948966];
  let idx;
  for (idx = 0; idx < coa.length; idx++) {
    if (coa[idx] > x) {
      break;
    }
  }
  let left = idx === 0 ? 0 : coa[idx - 1];
  let right = idx < coa.length ? coa[idx] : 1;
  let r = (x - left) / (right - left);
  let thetaLeft = idx === 0 ? 0 : theta[idx - 1];
  let thetaRight = idx < theta.length ? theta[idx] : Math.PI / 2;
  return Math.min(Math.PI / 2, thetaLeft + r * (thetaRight - thetaLeft));
}
const colorAlphaCache = /* @__PURE__ */ new Map();
function getAlphaColor(color, alpha) {
  const key = `${color}_${alpha}`;
  let c = colorAlphaCache.get(key);
  if (!c) {
    c = IGVColor.addAlpha(color, alpha);
    colorAlphaCache.set(key, c);
  }
  return c;
}
function getWGFeatures(allFeatures) {
  const makeWGFeature = (f) => {
    const wg = Object.assign({}, f);
    wg.chr = "all";
    wg.start = genome.getGenomeCoordinate(f.chr1, f.start1);
    wg.end = genome.getGenomeCoordinate(f.chr2, f.end2);
    return wg;
  };
  const genome = this.genome;
  let maxScoreFeature;
  let totalFeatureCount = 0;
  for (let c of genome.wgChromosomeNames) {
    let chrFeatures = allFeatures[c];
    if (chrFeatures) {
      for (let f of chrFeatures) {
        if (!f.dup) {
          totalFeatureCount++;
          if (f.score && (!maxScoreFeature || f.score > maxScoreFeature.score)) {
            maxScoreFeature = f;
          }
        }
      }
    }
  }
  const maxCount = this.maxWGCount;
  const nBins = maxScoreFeature && maxScoreFeature.score > 0 && totalFeatureCount > maxCount ? 5 : 1;
  const featuresPerBin = Math.floor(maxCount / nBins);
  const binSize = maxScoreFeature && maxScoreFeature.score > 0 ? Math.log(maxScoreFeature.score) / nBins : Number.MAX_SAFE_INTEGER;
  let binnedFeatures = [];
  let counts = [];
  for (let i = 0; i < nBins; i++) {
    counts.push([0]);
    binnedFeatures.push([]);
  }
  for (let c of genome.wgChromosomeNames) {
    let chrFeatures = allFeatures[c];
    if (chrFeatures) {
      for (let f of chrFeatures) {
        if (!f.dup) {
          const bin = f.score ? Math.max(0, Math.min(nBins - 1, Math.floor(Math.log(f.score) / binSize))) : 0;
          if (binnedFeatures[bin].length < featuresPerBin) {
            binnedFeatures[bin].push(makeWGFeature(f));
          } else {
            const samplingProb = featuresPerBin / (counts[bin] + 1);
            if (Math.random() < samplingProb) {
              const idx = Math.floor(Math.random() * (featuresPerBin - 1));
              binnedFeatures[bin][idx] = makeWGFeature(f);
            }
          }
          counts[bin]++;
        }
      }
    }
  }
  let wgFeatures;
  if (nBins === 1) {
    wgFeatures = binnedFeatures[0];
  } else {
    wgFeatures = [];
    for (let bf of binnedFeatures) {
      for (let f of bf) wgFeatures.push(f);
    }
    if (maxScoreFeature) {
      wgFeatures.push(makeWGFeature(maxScoreFeature));
    }
    wgFeatures.sort(function(a, b) {
      return a.start - b.start;
    });
    console.log(wgFeatures.length);
  }
  return wgFeatures;
}
function extractInfoColumn(data, str) {
  const kvs = str.split(";");
  for (let t of kvs) {
    const kv = t.split("=");
    if (kv.length === 2) {
      data.push({ name: kv[0], value: kv[1] });
    }
  }
}
const isString = isString$2;
const DEFAULT_COLOR = "rgb(0,0,150)";
const DEFAULT_VISIBILITY_WINDOW = 1e6;
const TOP_MARGIN = 10;
const STANDARD_FIELDS = /* @__PURE__ */ new Map([["REF", "referenceBases"], ["ALT", "alternateBases"], ["QUAL", "quality"], ["FILTER", "filter"]]);
class VariantTrack extends TrackBase {
  static defaults = {
    displayMode: "EXPANDED",
    sortDirection: "ASC",
    showGenotypes: true,
    squishedVariantHeight: 2,
    squishedCallHeight: 1,
    expandedCallHeight: 10,
    expandedVGap: 2,
    squishedVGap: 1,
    expandedGroupGap: 10,
    squishedGroupGap: 5,
    featureHeight: 14,
    noGenotypeColor: "rgb(200,180,180)",
    noCallColor: "rgb(225, 225, 225)",
    nonRefColor: "rgb(200, 200, 215)",
    mixedColor: "rgb(200, 220, 200)",
    homrefColor: "rgb(200, 200, 200)",
    homvarColor: "rgb(17,248,254)",
    hetvarColor: "rgb(34,12,253)",
    colorBy: void 0,
    visibilityWindow: void 0,
    labelDisplayMode: void 0,
    type: "variant"
  };
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.expandedVariantHeight = config.expandedVariantHeight || config.variantHeight || 10;
    this.featureSource = FeatureSource(config, this.browser.genome);
    this._initColorBy = config.colorBy;
    if (config.colorTable) {
      this.colorTables = /* @__PURE__ */ new Map();
      this.colorTables.set(config.colorBy, new ColorTable(config.colorTable));
    }
    this._color = config.color;
    this._strokecolor = config.strokecolor;
    this._context_hook = config.context_hook;
    this.variantRowCount(1);
  }
  async postInit() {
    this.header = await this.getHeader();
    if (this.disposed) return;
    if (void 0 === this.visibilityWindow && this.config.indexed !== false) {
      const fn2 = isFile$1(this.config.url) ? this.config.url.name : this.config.url;
      if (isString(fn2) && fn2.toLowerCase().includes("gnomad")) {
        this.visibilityWindow = 1e3;
      } else if (typeof this.featureSource.defaultVisibilityWindow === "function") {
        this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
      } else {
        this.visibilityWindow = DEFAULT_VISIBILITY_WINDOW;
      }
    }
    return this;
  }
  get supportsWholeGenome() {
    return this.config.indexed === false || this.config.supportsWholeGenome === true;
  }
  get color() {
    return this._color || DEFAULT_COLOR;
  }
  set color(c) {
    this._color = c;
    this.colorBy = void 0;
  }
  async getHeader() {
    if (!this.header) {
      if (typeof this.featureSource.getHeader === "function") {
        const header = await this.featureSource.getHeader();
        if (header) {
          this.callSets = header.callSets || [];
        }
        this.header = header;
      }
      this.sampleNames = this.callSets ? this.callSets.map((cs) => cs.name) : [];
    }
    return this.header;
  }
  getCallsetsLength() {
    return this.callSets ? this.callSets.length : 0;
  }
  async getFeatures(chr, start, end, bpPerPixel) {
    if (this.header === void 0) {
      this.header = await this.getHeader();
    }
    return this.featureSource.getFeatures({ chr, start, end, bpPerPixel, visibilityWindow: this.visibilityWindow });
  }
  hasSamples() {
    return this.getCallsetsLength() > 0;
  }
  getSamples() {
    return {
      yOffset: this.sampleYOffset,
      names: this.sampleNames,
      height: this.sampleHeight
    };
  }
  /**
   * The required height in pixels required for the track content.   This is not the visible track height, which
   * can be smaller (with a scrollbar) or larger.
   *
   * @param features
   * @returns {*}
   */
  computePixelHeight(features) {
    if (!features || features.length == 0) return TOP_MARGIN;
    const nVariantRows = this.displayMode === "COLLAPSED" ? 1 : this.nVariantRows;
    const vGap = this.displayMode === "SQUISHED" ? this.squishedVGap : this.expandedVGap;
    const variantHeight = this.displayMode === "SQUISHED" ? this.squishedVariantHeight : this.expandedVariantHeight;
    const callHeight = this.displayMode === "SQUISHED" ? this.squishedCallHeight : this.expandedCallHeight;
    const nCalls = this.showGenotypes === false ? 0 : this.getCallsetsLength() * nVariantRows;
    const h = TOP_MARGIN + nVariantRows * (variantHeight + vGap);
    return h + vGap + (nCalls + 1) * (callHeight + vGap);
  }
  variantRowCount(count) {
    this.nVariantRows = count;
  }
  draw({ context, pixelWidth, pixelHeight, bpPerPixel, bpStart, pixelTop, features }) {
    IGVGraphics.fillRect(context, 0, pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    const vGap = "SQUISHED" === this.displayMode ? this.squishedVGap : this.expandedVGap;
    const rowCount = "COLLAPSED" === this.displayMode ? 1 : this.nVariantRows;
    const variantHeight = "SQUISHED" === this.displayMode ? this.squishedVariantHeight : this.expandedVariantHeight;
    this.variantBandHeight = TOP_MARGIN + rowCount * (variantHeight + vGap);
    let callSets = this.callSets;
    if (!callSets && this._f) {
      callSets = this._f.callSets;
    }
    const nCalls = this.getCallsetsLength();
    if (callSets && nCalls > 0 && this.showGenotypes !== false) {
      IGVGraphics.strokeLine(context, 0, this.variantBandHeight, pixelWidth, this.variantBandHeight, { strokeStyle: "rgb(224,224,224) " });
    }
    if (features) {
      const callHeight = "SQUISHED" === this.displayMode ? this.squishedCallHeight : this.expandedCallHeight;
      const vGap2 = "SQUISHED" === this.displayMode ? this.squishedVGap : this.expandedVGap;
      const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
      for (let variant of features) {
        if (variant.end < bpStart) continue;
        if (variant.start > bpEnd) break;
        const variantHeight2 = "SQUISHED" === this.displayMode ? this.squishedVariantHeight : this.expandedVariantHeight;
        const y = TOP_MARGIN + ("COLLAPSED" === this.displayMode ? 0 : variant.row * (variantHeight2 + vGap2));
        const h = variantHeight2;
        let x = Math.round((variant.start - bpStart) / bpPerPixel);
        let x1 = Math.round((variant.end - bpStart) / bpPerPixel);
        let w = Math.max(1, x1 - x);
        if (w < 3) {
          w = 3;
          x -= 1;
        } else if (w > 5) {
          x += 1;
          w -= 2;
        }
        context.fillStyle = this.getColorForFeature(variant);
        context.fillRect(x, y, w, h);
        let strokecolor = this.getVariantStrokecolor(variant);
        if (strokecolor) {
          context.strokeStyle = strokecolor;
          context.strokeRect(x, y, w, h);
        }
        this.callContextHook(variant, context, x, y, w, h);
        variant.pixelRect = { x, y, w, h };
        if (nCalls > 0 && this.showGenotypes !== false) {
          const nVariantRows = "COLLAPSED" === this.displayMode ? 1 : this.nVariantRows;
          this.sampleYOffset = this.variantBandHeight + vGap2;
          this.sampleHeight = nVariantRows * (callHeight + vGap2);
          let sampleNumber = 0;
          if (callSets && variant.calls) {
            for (let callSet of callSets) {
              const call = variant.calls[callSet.id];
              if (call) {
                const row = "COLLAPSED" === this.displayMode ? 0 : variant.row;
                const py = this.sampleYOffset + sampleNumber * this.sampleHeight + row * (callHeight + vGap2);
                let allVar = true;
                let allRef = true;
                let noCall = false;
                if (call.genotype) {
                  for (let g of call.genotype) {
                    if ("." === g) {
                      noCall = true;
                      break;
                    } else {
                      if (g !== 0) allRef = false;
                      if (g === 0) allVar = false;
                    }
                  }
                }
                if (!call.genotype) {
                  context.fillStyle = this.noGenotypeColor;
                } else if (noCall) {
                  context.fillStyle = this.noCallColor;
                } else if (allRef) {
                  context.fillStyle = this.homrefColor;
                } else if (allVar) {
                  context.fillStyle = this.homvarColor;
                } else {
                  context.fillStyle = this.hetvarColor;
                }
                context.fillRect(x, py, w, callHeight);
                callSet.pixelRect = { x, y: py, w, h: callHeight };
              }
              sampleNumber++;
            }
          }
        }
      }
    } else {
      console.log("No feature list");
    }
  }
  getColorForFeature(variant) {
    const v = variant._f || variant;
    let variantColor;
    if (this.colorBy) {
      const colorBy = this.colorBy;
      let value;
      if (v.info.hasOwnProperty(colorBy)) {
        value = v.info[colorBy];
      } else if (STANDARD_FIELDS.has(colorBy)) {
        const key = STANDARD_FIELDS.get(colorBy);
        value = v[key];
      }
      variantColor = this.getVariantColorTable(colorBy).getColor(value);
      if (!variantColor) {
        variantColor = "gray";
      }
    } else if (this._color) {
      variantColor = typeof this._color === "function" ? this._color(variant) : this._color;
    } else if ("NONVARIANT" === v.type) {
      variantColor = this.nonRefColor;
    } else if ("MIXED" === v.type) {
      variantColor = this.mixedColor;
    } else {
      variantColor = this.color;
    }
    return variantColor;
  }
  getVariantStrokecolor(variant) {
    const v = variant._f || variant;
    let variantStrokeColor;
    if (this._strokecolor) {
      variantStrokeColor = typeof this._strokecolor === "function" ? this._strokecolor(v) : this._strokecolor;
    } else {
      variantStrokeColor = void 0;
    }
    return variantStrokeColor;
  }
  callContextHook(variant, context, x, y, w, h) {
    if (this._context_hook) {
      if (typeof this._context_hook === "function") {
        const v = variant._f || variant;
        context.save();
        this._context_hook(v, context, x, y, w, h);
        context.restore();
      }
    }
  }
  clickedFeatures(clickState) {
    let featureList = super.clickedFeatures(clickState);
    const vGap = this.displayMode === "EXPANDED" ? this.expandedVGap : this.squishedVGap;
    const callHeight = vGap + ("SQUISHED" === this.displayMode ? this.squishedCallHeight : this.expandedCallHeight);
    const yOffset = clickState.y;
    if (yOffset <= this.variantBandHeight) {
      const variantHeight = "SQUISHED" === this.displayMode ? this.squishedVariantHeight : this.expandedVariantHeight;
      const variantRow = Math.floor((yOffset - TOP_MARGIN) / (variantHeight + vGap));
      if ("COLLAPSED" !== this.displayMode) {
        featureList = featureList.filter((f) => f.row === variantRow);
      }
    } else if (this.callSets) {
      const callSets = this.callSets;
      const sampleY = yOffset - this.variantBandHeight;
      const sampleRow = Math.floor(sampleY / this.sampleHeight);
      if (sampleRow >= 0 && sampleRow < callSets.length) {
        const variantRow = Math.floor((sampleY - sampleRow * this.sampleHeight) / callHeight);
        const variants = "COLLAPSED" === this.displayMode ? featureList : featureList.filter((f) => f.row === variantRow);
        const cs = callSets[sampleRow];
        featureList = variants.map((v) => {
          const call = v.calls[cs.id];
          expandGenotype(call, v);
          return call;
        });
      }
    }
    return featureList;
  }
  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, featureList) {
    if (featureList === void 0) featureList = this.clickedFeatures(clickState);
    const genomicLocation = clickState.genomicLocation;
    const genomeID = this.browser.genome.id;
    const sampleInformation = this.browser.sampleInformation;
    let popupData = [];
    for (let v of featureList) {
      const f = v._f || v;
      if (popupData.length > 0) {
        popupData.push({ html: '<hr style="border-top-width:2px ;border-color: #c9c3ba" />' });
      }
      if (typeof f.popupData === "function") {
        const v2 = f.popupData(genomicLocation, genomeID);
        Array.prototype.push.apply(popupData, v2);
      } else {
        const call = f;
        if (call.callSetName !== void 0) {
          popupData.push({ name: "Name", value: call.callSetName });
        }
        if (call.genotypeName) {
          popupData.push({ name: "Genotype", value: call.genotypeName });
        }
        if (call.phaseset !== void 0) {
          popupData.push({ name: "Phase set", value: call.phaseset });
        }
        if (call.genotypeLikelihood !== void 0) {
          popupData.push({ name: "genotypeLikelihood", value: call.genotypeLikelihood.toString() });
        }
        if (sampleInformation) {
          var attr = sampleInformation.getAttributes(call.callSetName);
          if (attr) {
            Object.keys(attr).forEach(function(attrName) {
              var displayText = attrName.replace(/([A-Z])/g, " $1");
              displayText = displayText.charAt(0).toUpperCase() + displayText.slice(1);
              popupData.push({ name: displayText, value: attr[attrName] });
            });
          }
        }
        var infoKeys = Object.keys(call.info);
        if (infoKeys.length) {
          popupData.push("<hr/>");
        }
        infoKeys.forEach(function(key) {
          popupData.push({ name: key, value: decodeURIComponent(call.info[key]) });
        });
      }
    }
    return popupData;
  }
  // VariantTrack.prototype.contextMenuItemList = function (clickState) {
  //
  //     const self = this;
  //     const menuItems = [];
  //
  //     const featureList = this.clickedFeatures(clickState);
  //
  //     if (this.callSets && featureList && featureList.length > 0) {
  //
  //         featureList.forEach(function (variant) {
  //
  //             if ('str' === variant.type) {
  //
  //                 menuItems.push({
  //                     label: 'Sort by allele length',
  //                     click: function () {
  //                         sortCallSetsByAlleleLength(self.callSets, variant, self.sortDirection);
  //                         self.sortDirection = (self.sortDirection === "ASC") ? "DESC" : "ASC";
  //                         self.trackView.repaintViews();
  //                     }
  //                 });
  //
  //             }
  //
  //         });
  //     }
  //
  //
  //     function sortCallSetsByAlleleLength(callSets, variant, direction) {
  //         var d = (direction === "DESC") ? 1 : -1;
  //         Object.keys(callSets).forEach(function (property) {
  //             callSets[property].sort(function (a, b) {
  //                 var aNan = isNaN(variant.calls[a.id].genotype[0]);
  //                 var bNan = isNaN(variant.calls[b.id].genotype[0]);
  //                 if (aNan && bNan) {
  //                     return 0;
  //                 } else if (aNan) {
  //                     return 1;
  //                 } else if (bNan) {
  //                     return -1;
  //                 } else {
  //                     var a0 = getAlleleString(variant.calls[a.id], variant, 0);
  //                     var a1 = getAlleleString(variant.calls[a.id], variant, 1);
  //                     var b0 = getAlleleString(variant.calls[b.id], variant, 0);
  //                     var b1 = getAlleleString(variant.calls[b.id], variant, 1);
  //                     var result = Math.max(b0.length, b1.length) - Math.max(a0.length, a1.length);
  //                     if (result === 0) {
  //                         result = Math.min(b0.length, b1.length) - Math.min(a0.length, a1.length);
  //                     }
  //                     return d * result;
  //                 }
  //             });
  //         });
  //     }
  //
  //
  //     return menuItems;
  //
  // };
  menuItemList() {
    const menuItems = [];
    if (this.header.INFO) {
      if (this.header.INFO) {
        const stringInfoKeys = this.header.INFO.SVTYPE ? ["SVTYPE"] : [];
        if (this._initColorBy && this._initColorBy !== "SVTYPE") {
          stringInfoKeys.push(this._initColorBy);
        }
        if (stringInfoKeys.length > 0) {
          menuItems.push("<hr/>");
          const $e = $$1('<div class="igv-track-menu-category igv-track-menu-border-top">');
          $e.text("Color by:");
          menuItems.push({ name: void 0, object: $e, click: void 0, init: void 0 });
          stringInfoKeys.sort();
          for (let item of stringInfoKeys) {
            const selected = this.colorBy === item;
            const label = item ? item : "None";
            menuItems.push(this.colorByCB({ key: item, label }, selected));
          }
          menuItems.push(this.colorByCB({ key: void 0, label: "None" }, this.colorBy === void 0));
          menuItems.push("<hr/>");
        }
      }
    }
    if (this.getCallsetsLength() > 0) {
      menuItems.push({ object: $$1('<div class="igv-track-menu-border-top">') });
      menuItems.push({
        object: $$1(createCheckbox$2("Show Genotypes", this.showGenotypes)),
        click: () => {
          this.showGenotypes = !this.showGenotypes;
          this.trackView.checkContentHeight();
          this.trackView.repaintViews();
        }
      });
    }
    menuItems.push({ object: $$1('<div class="igv-track-menu-border-top">') });
    for (let displayMode of ["COLLAPSED", "SQUISHED", "EXPANDED"]) {
      var lut = {
        "COLLAPSED": "Collapse",
        "SQUISHED": "Squish",
        "EXPANDED": "Expand"
      };
      menuItems.push(
        {
          object: $$1(createCheckbox$2(lut[displayMode], displayMode === this.displayMode)),
          click: () => {
            this.displayMode = displayMode;
            this.trackView.checkContentHeight();
            this.trackView.repaintViews();
          }
        }
      );
    }
    if (this.browser.circularView) {
      menuItems.push("<hr>");
      menuItems.push({
        label: "Add SVs to circular view",
        click: () => {
          for (let viewport of this.trackView.viewports) {
            this.sendChordsForViewport(viewport);
          }
        }
      });
    }
    return menuItems;
  }
  contextMenuItemList(clickState) {
    if (this.browser.circularView) {
      const viewport = clickState.viewport;
      const list = [];
      list.push({
        label: "Add SVs to Circular View",
        click: () => {
          this.sendChordsForViewport(viewport);
        }
      });
      list.push("<hr/>");
      return list;
    }
  }
  sendChordsForViewport(viewport) {
    const refFrame = viewport.referenceFrame;
    let inView;
    if ("all" === refFrame.chr) {
      const all = this.featureSource.getAllFeatures();
      const arrays = Object.keys(all).map((k) => all[k]);
      inView = [].concat(...arrays);
    } else {
      inView = this.featureSource.featureCache.queryFeatures(refFrame.chr, refFrame.start, refFrame.end);
    }
    const chords = makeVCFChords(inView);
    sendChords(chords, this, refFrame, 0.5);
  }
  /**
   * Create a "color by" checkbox menu item, optionally initially checked
   * @param menuItem
   * @param showCheck
   * @returns {{init: undefined, name: undefined, click: clickHandler, object: (jQuery|HTMLElement|jQuery.fn.init)}}
   */
  colorByCB(menuItem, showCheck) {
    const $e = $$1(createCheckbox$2(menuItem.label, showCheck));
    const clickHandler = () => {
      if (menuItem.key === this.colorBy) {
        this.colorBy = void 0;
        delete this.config.colorBy;
        this.trackView.repaintViews();
      } else {
        this.colorBy = menuItem.key;
        this.config.colorBy = menuItem.key;
        this.trackView.repaintViews();
      }
    };
    return { name: void 0, object: $e, click: clickHandler, init: void 0 };
  }
  getState() {
    const config = super.getState();
    if (this._color && typeof this._color !== "function") {
      config.color = this._color;
    }
    return config;
  }
  getVariantColorTable(key) {
    if (!this.colorTables) {
      this.colorTables = /* @__PURE__ */ new Map();
    }
    if (!this.colorTables.has(key)) {
      let tbl;
      switch (key) {
        case "SVTYPE":
          tbl = SV_COLOR_TABLE;
          break;
        default:
          tbl = new PaletteColorTable("Set1");
      }
      this.colorTables.set(key, tbl);
    }
    return this.colorTables.get(key);
  }
}
function expandGenotype(call, variant) {
  if (call.genotype) {
    let gt = "";
    if (variant.alternateBases === ".") {
      gt = "No Call";
    } else {
      const altArray = variant.alternateBases.split(",");
      for (let allele of call.genotype) {
        if (gt.length > 0) {
          gt += "|";
        }
        if ("." === allele) {
          gt += ".";
        } else if (allele === 0) {
          gt += variant.referenceBases;
        } else {
          let alt = altArray[allele - 1].replace("<", "&lt;");
          gt += alt;
        }
      }
    }
    call.genotypeName = gt;
  }
}
const SV_COLOR_TABLE = new ColorTable({
  "DEL": "#ff2101",
  "INS": "#001888",
  "DUP": "#028401",
  "INV": "#008688",
  "CNV": "#8931ff",
  "BND": "#891100",
  "*": "#002eff"
});
class EqtlTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.name = config.name;
    this.pValueField = config.pValueField || "pValue";
    this.geneField = config.geneField || "geneSymbol";
    this.snpField = config.snpField || "snp";
    const min = config.minLogP || config.min;
    const max = config.maxLogP || config.max;
    this.dataRange = {
      min: min || 3.5,
      max: max || 25
    };
    if (!max) {
      this.autoscale = true;
    } else {
      this.autoscale = config.autoscale;
    }
    this.autoscalePercentile = config.autoscalePercentile === void 0 ? 98 : config.autoscalePercentile;
    this.background = config.background;
    this.divider = config.divider || "rgb(225,225,225)";
    this.dotSize = config.dotSize || 2;
    this.height = config.height || 100;
    this.autoHeight = false;
    this.disableButtons = config.disableButtons;
    this.visibilityWindow = config.visibilityWindow === void 0 ? 2e6 : config.visibilityWindow >= 0 ? Math.min(2e6, config.visibilityWindow) : 2e6;
    this.featureSource = FeatureSource(config, this.browser.genome);
    GtexUtils.gtexLoaded = true;
  }
  paintAxis(ctx2, pixelWidth, pixelHeight) {
    const yScale = (this.dataRange.max - this.dataRange.min) / pixelHeight;
    const font = {
      "font": "normal 10px Arial",
      "textAlign": "right",
      "strokeStyle": "black"
    };
    IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    const n = Math.ceil((this.dataRange.max - this.dataRange.min) * 10 / pixelHeight);
    for (let p = 4; p <= this.dataRange.max; p += n) {
      const ref = 0.85 * pixelWidth;
      const x1 = ref - 5;
      const x2 = ref;
      const y = pixelHeight - (p - this.dataRange.min) / yScale;
      IGVGraphics.strokeLine(ctx2, x1, y, x2, y, font);
      if (y > 8) {
        IGVGraphics.fillText(ctx2, p, x1 - 1, y + 2, font);
      }
    }
    font["textAlign"] = "center";
    IGVGraphics.fillText(ctx2, "-log10(pvalue)", pixelWidth / 4, pixelHeight / 2, font, { rotate: { angle: -90 } });
  }
  async getFeatures(chr, start, end) {
    const pValueField = this.pValueField;
    const visibilityWindow = this.visibilityWindow;
    const features = await this.featureSource.getFeatures({ chr, start, end, visibilityWindow });
    features.forEach(function(f) {
      f.value = f[pValueField];
    });
    return features;
  }
  draw(options2) {
    const ctx2 = options2.context;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    if (this.background) {
      IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": this.background });
    }
    IGVGraphics.strokeLine(ctx2, 0, pixelHeight - 1, pixelWidth, pixelHeight - 1, { "strokeStyle": this.divider });
    const drawEqtls = (drawSelected) => {
      const radius = drawSelected ? 2 * this.dotSize : this.dotSize;
      const bpStart = options2.bpStart;
      const yScale = (this.dataRange.max - this.dataRange.min) / pixelHeight;
      const selection = options2.referenceFrame.selection;
      for (let eqtl of options2.features) {
        const px = (eqtl.start - bpStart + 0.5) / options2.bpPerPixel;
        if (px < 0) continue;
        else if (px > pixelWidth) break;
        const snp = eqtl.snp.toUpperCase();
        const geneName = eqtl[this.geneField].toUpperCase();
        const isSelected = selection && (selection.snp === snp || selection.gene === geneName);
        if (!drawSelected || isSelected) {
          if (selection && selection.snp === snp) {
            selection.addGene(geneName);
          }
          var mLogP = -Math.log(eqtl[this.pValueField]) / Math.LN10;
          if (mLogP >= this.dataRange.min) {
            let capped;
            if (mLogP > this.dataRange.max) {
              mLogP = this.dataRange.max;
              capped = true;
            } else {
              capped = false;
            }
            const py = Math.max(0 + radius, pixelHeight - Math.round((mLogP - this.dataRange.min) / yScale));
            eqtl.px = px;
            eqtl.py = py;
            eqtl.radius = radius;
            let color;
            if (drawSelected && selection) {
              color = selection.colorForGene(geneName);
              IGVGraphics.setProperties(ctx2, { fillStyle: color, strokeStyle: "black" });
            } else {
              color = capped ? "rgb(150, 150, 150)" : "rgb(180, 180, 180)";
              IGVGraphics.setProperties(ctx2, { fillStyle: color, strokeStyle: color });
            }
            IGVGraphics.fillCircle(ctx2, px, py, radius);
            IGVGraphics.strokeCircle(ctx2, px, py, radius);
          }
        }
      }
    };
    drawEqtls(false);
    drawEqtls(true);
  }
  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, features) {
    if (features === void 0) features = clickState.viewport.cachedFeatures;
    if (!features || features.length === 0) return [];
    const tolerance = 3;
    const tissue = this.name;
    const popupData = [];
    for (let feature2 of features) {
      if (Math.abs(feature2.px - clickState.canvasX) < feature2.radius + tolerance && Math.abs(feature2.py - clickState.canvasY) < feature2.radius + tolerance) {
        if (popupData.length > 0) {
          popupData.push("<hr/>");
        }
        popupData.push(
          { name: "snp id", value: feature2.snp },
          { name: "gene id", value: feature2.geneId },
          { name: "gene name", value: feature2.geneName },
          { name: "p value", value: feature2.pValue },
          { name: "tissue", value: tissue }
        );
      }
    }
    return popupData;
  }
  menuItemList() {
    return MenuUtils$1.numericDataMenuItems(this.trackView);
  }
  doAutoscale(featureList) {
    if (featureList.length > 0) {
      var values = featureList.map(function(eqtl) {
        return -Math.log(eqtl.value) / Math.LN10;
      });
      this.dataRange.max = IGVMath.percentile(values, this.autoscalePercentile);
    } else {
      const max = this.config.maxLogP || this.config.max;
      this.dataRange.max = max || 25;
    }
    return this.dataRange;
  }
}
const GWASColors = {
  "X": "rgb(204, 153, 0)",
  "Y": "rgb(153, 204, 0)",
  "Un": "darkGray)",
  "1": "rgb(80, 80, 255)",
  "2": "rgb(206, 61, 50)",
  "2a": "rgb(210, 65, 55)",
  "2b": "rgb(215, 70, 60)",
  "3": "rgb(116, 155, 88)",
  "4": "rgb(240, 230, 133)",
  "5": "rgb(70, 105, 131)",
  "6": "rgb(186, 99, 56)",
  "7": "rgb(93, 177, 221)",
  "8": "rgb(128, 34, 104)",
  "9": "rgb(107, 215, 107)",
  "10": "rgb(213, 149, 167)",
  "11": "rgb(146, 72, 34)",
  "12": "rgb(131, 123, 141)",
  "13": "rgb(199, 81, 39)",
  "14": "rgb(213, 143, 92)",
  "15": "rgb(122, 101, 165)",
  "16": "rgb(228, 175, 105)",
  "17": "rgb(59, 27, 83)",
  "18": "rgb(205, 222, 183)",
  "19": "rgb(97, 42, 121)",
  "20": "rgb(174, 31, 99)",
  "21": "rgb(231, 199, 111)",
  "22": "rgb(90, 101, 94)",
  "23": "rgb(204, 153, 0)",
  "24": "rgb(153, 204, 0)",
  "25": "rgb(51, 204, 0)",
  "26": "rgb(0, 204, 51)",
  "27": "rgb(0, 204, 153)",
  "28": "rgb(0, 153, 204)",
  "29": "rgb(10, 71, 255)",
  "30": "rgb(71, 117, 255)",
  "31": "rgb(255, 194, 10)",
  "32": "rgb(255, 209, 71)",
  "33": "rgb(153, 0, 51)",
  "34": "rgb(153, 26, 0)",
  "35": "rgb(153, 102, 0)",
  "36": "rgb(128, 153, 0)",
  "37": "rgb(51, 153, 0)",
  "38": "rgb(0, 153, 26)",
  "39": "rgb(0, 153, 102)",
  "40": "rgb(0, 128, 153)",
  "41": "rgb(0, 51, 153)",
  "42": "rgb(26, 0, 153)",
  "43": "rgb(102, 0, 153)",
  "44": "rgb(153, 0, 128)",
  "45": "rgb(214, 0, 71)",
  "46": "rgb(255, 20, 99)",
  "47": "rgb(0, 214, 143)",
  "48": "rgb(20, 255, 177)"
};
for (let key of Object.keys(GWASColors)) {
  const altName = "chr" + key;
  GWASColors[altName] = GWASColors[key];
}
for (let a = 1; a <= 48; a++) {
  if (a === 10) continue;
  const roman = romanize(a);
  GWASColors[roman] = GWASColors[a.toString()];
}
function romanize(num) {
  if (!+num) return false;
  var digits = String(+num).split("");
  var key = [
    "",
    "C",
    "CC",
    "CCC",
    "CD",
    "D",
    "DC",
    "DCC",
    "DCCC",
    "CM",
    "",
    "X",
    "XX",
    "XXX",
    "XL",
    "L",
    "LX",
    "LXX",
    "LXXX",
    "XC",
    "",
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX"
  ];
  var roman = "", i = 3;
  while (i--) roman = (key[+digits.pop() + i * 10] || "") + roman;
  return Array(+digits.join("") + 1).join("M") + roman;
}
const DEFAULT_POPOVER_WINDOW = 1e8;
class GWASTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.useChrColors = config.useChrColors === void 0 ? true : config.useChrColors;
    this.trait = config.trait;
    this.posteriorProbability = config.posteriorProbability;
    this.valueProperty = "bed" === config.format ? "score" : "value";
    this.height = config.height || 100;
    this.autoscale = config.autoscale;
    this.autoscalePercentile = config.autoscalePercentile === void 0 ? 98 : config.autoscalePercentile;
    this.background = config.background;
    this.divider = config.divider || "rgb(225,225,225)";
    this.dotSize = config.dotSize || 3;
    this.popoverWindow = config.popoverWindow === void 0 ? DEFAULT_POPOVER_WINDOW : config.popoverWindow;
    if (this.useChrColors) {
      this.colorScale = new ColorTable(config.colorTable || GWASColors);
    } else if (config.color) {
      this.colorScale = new ConstantColorScale(config.color);
    } else {
      this.colorScale = new BinnedColorScale(config.colorScale || {
        thresholds: [5e-8, 5e-4, 0.5],
        colors: ["rgb(255,50,50)", "rgb(251,100,100)", "rgb(251,170,170)", "rgb(227,238,249)"]
      });
    }
    this.featureSource = FeatureSource(config, this.browser.genome);
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
    }
    if (this.header) {
      this.setTrackProperties(this.header);
    }
    if (!this.autoscale) {
      if (this.posteriorProbability) {
        this.dataRange = {
          min: this.config.min === void 0 ? 0 : this.config.min,
          max: this.config.max === void 0 ? 1 : this.config.max
        };
      } else {
        this.dataRange = {
          min: this.config.min === void 0 ? 0 : this.config.min,
          max: this.config.max === void 0 ? 25 : this.config.max
        };
      }
    }
    return this;
  }
  get supportsWholeGenome() {
    return true;
  }
  async getFeatures(chr, start, end) {
    const visibilityWindow = this.visibilityWindow;
    return this.featureSource.getFeatures({ chr, start, end, visibilityWindow });
  }
  draw(options2) {
    const featureList = options2.features;
    const ctx2 = options2.context;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    if (this.background) {
      IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": this.background });
    }
    IGVGraphics.strokeLine(ctx2, 0, pixelHeight - 1, pixelWidth, pixelHeight - 1, { "strokeStyle": this.divider });
    if (featureList) {
      const bpPerPixel = options2.bpPerPixel;
      const bpStart = options2.bpStart;
      const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
      for (let variant of featureList) {
        const pos = variant.start;
        if (pos < bpStart) continue;
        if (pos > bpEnd) break;
        let val;
        if (this.posteriorProbability) {
          val = variant[this.valueProperty];
        } else {
          const pvalue = variant[this.valueProperty];
          if (!pvalue) continue;
          val = -Math.log10(pvalue);
        }
        const colorKey = this.useChrColors ? variant._f ? variant._f.chr : variant.chr : val;
        const color = this.colorScale.getColor(colorKey);
        const yScale = (this.dataRange.max - this.dataRange.min) / pixelHeight;
        const px = Math.round((pos - bpStart) / bpPerPixel);
        const py = Math.max(this.dotSize, pixelHeight - Math.round((val - this.dataRange.min) / yScale));
        if (color) {
          IGVGraphics.setProperties(ctx2, { fillStyle: color, strokeStyle: "black" });
        }
        IGVGraphics.fillCircle(ctx2, px, py, this.dotSize);
        variant.px = px;
        variant.py = py;
      }
    }
  }
  paintAxis(ctx2, pixelWidth, pixelHeight) {
    IGVGraphics.fillRect(ctx2, 0, 0, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    var font = {
      "font": "normal 10px Arial",
      "textAlign": "right",
      "strokeStyle": "black"
    };
    const yScale = (this.dataRange.max - this.dataRange.min) / pixelHeight;
    if (this.posteriorProbability) {
      const n = 0.1;
      for (let p = this.dataRange.min; p < this.dataRange.max; p += n) {
        const yp = pixelHeight - Math.round((p - this.dataRange.min) / yScale);
        IGVGraphics.strokeLine(ctx2, 45, yp - 2, 50, yp - 2, font);
        IGVGraphics.fillText(ctx2, p.toFixed(1), 44, yp + 2, font);
      }
    } else {
      const n = Math.ceil((this.dataRange.max - this.dataRange.min) * 10 / pixelHeight);
      for (let p = this.dataRange.min; p < this.dataRange.max; p += n) {
        const yp = pixelHeight - Math.round((p - this.dataRange.min) / yScale);
        IGVGraphics.strokeLine(ctx2, 45, yp, 50, yp, font);
        IGVGraphics.fillText(ctx2, Math.floor(p), 44, yp + 4, font);
      }
    }
    font["textAlign"] = "center";
    if (this.posteriorProbability) {
      IGVGraphics.fillText(ctx2, "PPA", pixelWidth / 2, pixelHeight / 2, font, { rotate: { angle: -90 } });
    } else {
      IGVGraphics.fillText(ctx2, "-log10(pvalue)", pixelWidth / 2, pixelHeight / 2, font, { rotate: { angle: -90 } });
    }
  }
  popupData(clickState, features) {
    if (features === void 0) features = clickState.viewport.cachedFeatures;
    let data = [];
    const track = clickState.viewport.trackView.track;
    if (features) {
      let count = 0;
      for (let f of features) {
        const xDelta = Math.abs(clickState.canvasX - f.px);
        const yDelta = Math.abs(clickState.canvasY - f.py);
        const value = f[this.valueProperty];
        if (xDelta < this.dotSize && yDelta < this.dotSize) {
          if (count > 0) {
            data.push("<HR/>");
          }
          if (count == 5) {
            data.push("...");
            break;
          }
          if (typeof f.popupData === "function") {
            data = data.concat(f.popupData());
          } else {
            const chr = f.realChr || f.chr;
            const pos = (f.realStart || f.start) + 1;
            data.push({ name: "chromosome", value: chr });
            data.push({ name: "position", value: pos });
            data.push({ name: "name", value: f.name });
            if (track.posteriorProbability) {
              data.push({ name: "posterior probability", value });
            } else {
              data.push({ name: "pValue", value });
            }
          }
          count++;
        }
      }
    }
    return data;
  }
  menuItemList() {
    return MenuUtils$1.numericDataMenuItems(this.trackView);
  }
  doAutoscale(featureList) {
    if (featureList.length > 0) {
      const valueProperty = this.valueProperty;
      const posterior = this.posteriorProbability;
      const features = featureList.map(function(feature2) {
        const v = feature2[valueProperty];
        return { value: posterior ? v : -Math.log(v) / Math.LN10 };
      });
      this.dataRange = doAutoscale$1(features);
    } else {
      if (this.posteriorProbability) {
        this.dataRange = { min: this.config.min || 0, max: this.config.max || 1 };
      } else {
        this.dataRange = { min: this.config.max || 25, max: this.config.min || 0 };
      }
    }
    return this.dataRange;
  }
}
const X_PIXEL_DIFF_THRESHOLD = 1;
class GCNVTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.autoscale = config.autoscale || config.max === void 0;
    this.dataRange = {
      min: config.min || 0,
      max: config.max
    };
    this.windowFunction = config.windowFunction || "mean";
    this.paintAxis = paintAxis;
    this.graphType = config.graphType || "bar";
    if (config._featureSource) {
      this.featureSource = config._featureSource;
      delete config._featureSource;
    } else {
      this.featureSource = FeatureSource(this.config, this.browser.genome);
    }
    this.visibilityWindow = -1;
    this.featureSource.visibilityWindow = this.visibilityWindow;
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
      this.sampleNames = this.header.columnNames.slice(3);
      this.setTrackProperties(this.header);
      if (this.header.hasOwnProperty("clickToHighlight")) {
        let colour = this.header["clickToHighlight"];
        this.config.clickToHighlight = colour;
        this.config.samplesClickedToHighlight = {};
      }
      if (this.header.hasOwnProperty("highlight")) {
        this.config.highlightSamples = {};
        let v = this.header["highlight"];
        if (!Array.isArray(v)) v = [v];
        for (let h of v) {
          const tokens = h.split(";");
          if (tokens.length === 2) {
            this.config.highlightSamples[tokens[0]] = tokens[1];
          }
        }
      }
    }
  }
  menuItemList() {
    return MenuUtils$1.numericDataMenuItems(this.trackView);
  }
  async getFeatures(chr, start, end) {
    const chrFeatures = await this.featureSource.getFeatures({
      chr,
      start: 0,
      end: Number.MAX_SAFE_INTEGER,
      visibilityWindow: this.visibilityWindow
    });
    let prevIndex = void 0;
    let nextIndex = void 0;
    for (let i = 1; i < chrFeatures.length - 1; i++) {
      if (prevIndex === void 0 && chrFeatures[i].end > start) {
        prevIndex = i - 1;
      }
      if (nextIndex === void 0 && chrFeatures[i].start > end) {
        nextIndex = i + 1;
        break;
      }
    }
    if (prevIndex === void 0) prevIndex = 0;
    if (nextIndex === void 0) nextIndex = chrFeatures.length;
    return chrFeatures.slice(prevIndex, nextIndex);
  }
  draw(options2) {
    const { features, context, bpPerPixel, bpStart, pixelWidth, pixelHeight } = options2;
    const yScale = (yValue) => {
      return (this.dataRange.max - yValue) / (this.dataRange.max - this.dataRange.min) * pixelHeight;
    };
    const getX = function(bpPosition) {
      let x = Math.floor((bpPosition - bpStart) / bpPerPixel);
      if (isNaN(x)) console.warn("isNaN(x). feature start " + numberFormatter$1(bpPosition) + " bp start " + numberFormatter$1(bpStart));
      return x;
    };
    const drawGuideLines = (options3) => {
      if (this.config.hasOwnProperty("guideLines")) {
        for (let line of this.config.guideLines) {
          if (line.hasOwnProperty("color") && line.hasOwnProperty("y") && line.hasOwnProperty("dotted")) {
            let y = yScale(line.y);
            let props = {
              "strokeStyle": line["color"],
              "strokeWidth": 2
            };
            if (line["dotted"]) IGVGraphics.dashedLine(options3.context, 0, y, options3.pixelWidth, y, 5, props);
            else IGVGraphics.strokeLine(options3.context, 0, y, options3.pixelWidth, y, props);
          }
        }
      }
    };
    if (features && features.length > 0) {
      if (this.dataRange.min === void 0) this.dataRange.min = 0;
      if (this.dataRange.max > this.dataRange.min) {
        const highlightSamples = this.config.highlightSamples;
        const onlyHandleClicksForHighlightedSamples = this.config.onlyHandleClicksForHighlightedSamples;
        const clickToHighlight = this.config.clickToHighlight;
        let previousEnd = -1;
        let previousValues = {};
        let highlightConnectorLines = [];
        let highlightFeatureLines = [];
        this.clickDetectorCache = {};
        for (let feature2 of features) {
          const x1 = getX(feature2.start);
          const x2 = getX(feature2.end);
          const previousX = previousEnd >= 0 ? getX(previousEnd) : x1;
          if (isNaN(x1) || isNaN(x2)) continue;
          this.clickDetectorCache[x1] = [];
          this.clickDetectorCache[x2] = [];
          for (let i = 0; i < feature2.values.length; i++) {
            const sampleName = this.sampleNames[i];
            const value = feature2.values[i];
            const y = yScale(value);
            if (x1 - previousX >= X_PIXEL_DIFF_THRESHOLD) {
              const previousValue = previousValues[sampleName];
              const previousY = yScale(previousValue);
              const highlightColor = highlightSamples && highlightSamples[sampleName];
              if (highlightColor) {
                highlightConnectorLines.push([previousX, previousY, x1, y, highlightColor]);
              } else if (clickToHighlight && sampleName in this.config.samplesClickedToHighlight) {
                highlightConnectorLines.push([previousX, previousY, x1, y, this.config.samplesClickedToHighlight[sampleName]]);
              } else {
                IGVGraphics.strokeLine(context, previousX, previousY, x1, y, { strokeStyle: "#D9D9D9" });
              }
              if (!onlyHandleClicksForHighlightedSamples || sampleName in highlightSamples) {
                this.clickDetectorCache[x1].push([previousX, previousY, x1, y, sampleName, highlightColor || "gray"]);
              }
            }
            if (x2 - x1 >= X_PIXEL_DIFF_THRESHOLD) {
              const highlightColor = highlightSamples && highlightSamples[sampleName];
              if (highlightColor) {
                highlightFeatureLines.push([x1, y, x2, y, highlightColor]);
              } else if (clickToHighlight && sampleName in this.config.samplesClickedToHighlight) {
                highlightFeatureLines.push([x1, y, x2, y, this.config.samplesClickedToHighlight[sampleName]]);
              } else {
                IGVGraphics.strokeLine(context, x1, y, x2, y, { strokeStyle: "gray" });
              }
              if (!onlyHandleClicksForHighlightedSamples || sampleName in highlightSamples) {
                this.clickDetectorCache[x2].push([x1, y, x2, y, sampleName, highlightColor || "gray"]);
              }
            }
            previousValues[sampleName] = value;
          }
          previousEnd = feature2.end;
        }
        for (let f of highlightConnectorLines) {
          IGVGraphics.strokeLine(context, f[0], f[1], f[2], f[3], { strokeStyle: f[4], lineWidth: 1.3 });
        }
        for (let f of highlightFeatureLines) {
          IGVGraphics.strokeLine(context, f[0], f[1], f[2], f[3], { strokeStyle: f[4], lineWidth: 2 });
        }
      }
    }
    drawGuideLines(options2);
  }
  doAutoscale(features) {
    let min, max;
    if (features.length > 0) {
      min = Number.MAX_VALUE;
      max = -Number.MAX_VALUE;
      features.forEach(function(feature2) {
        min = Math.min(min, ...feature2.values);
        max = Math.max(max, ...feature2.values);
      });
      min -= 0.01;
      max += 0.01;
    } else {
      min = 0;
      max = 100;
    }
    return { min, max };
  }
  clickedFeatures(clickState) {
    const BOUNDING_BOX_PADDING = 10;
    const MIN_DISTANCE_TO_SEGMENT = 5;
    const clickX = clickState.canvasX;
    const clickY = clickState.canvasY;
    let key = null;
    for (key of Object.keys(this.clickDetectorCache)) {
      key = parseInt(key);
      if (key >= clickX) {
        break;
      }
    }
    if (key) {
      let closestDistanceSoFar = Number.MAX_VALUE;
      let closestResult = [];
      const segments = this.clickDetectorCache[key];
      for (let segment of segments) {
        const x1 = segment[0];
        const x2 = segment[2];
        if (clickX < x1 || clickX > x2) return [];
        const y1 = segment[1];
        const y2 = segment[3];
        if (clickY < Math.min(y1, y2) - BOUNDING_BOX_PADDING || clickY > Math.max(y1, y2) + BOUNDING_BOX_PADDING) continue;
        const distance = distanceToLine(clickX, clickY, x1, y1, x2, y2);
        if (distance < closestDistanceSoFar) {
          closestResult = [{ "name": segment[4], "color": segment[5] }];
          closestDistanceSoFar = distance;
        }
      }
      if (closestDistanceSoFar < MIN_DISTANCE_TO_SEGMENT) {
        if (this.config.clickToHighlight) {
          if (closestResult[0]["name"] in this.config.samplesClickedToHighlight) {
            delete this.config.samplesClickedToHighlight[closestResult[0]["name"]];
          } else if (this.config.clickToHighlight === "any") {
            var colourList = [
              "red",
              "darkblue",
              "green",
              "teal",
              "olivedrab",
              "orange",
              "maroon",
              "purple",
              "blue",
              "gold"
            ];
            var colour = colourList[Math.floor(Math.random() * (colourList.length + 1))];
            this.config.samplesClickedToHighlight[closestResult[0]["name"]] = colour;
          } else {
            this.config.samplesClickedToHighlight[closestResult[0]["name"]] = this.config.clickToHighlight;
          }
          this.trackView.repaintViews();
        }
        return closestResult;
      }
    }
    return [];
  }
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    const items = [];
    features.forEach(function(f) {
      for (let property of Object.keys(f)) {
        if (isSimpleType(f[property])) {
          items.push({ name: property, value: f[property] });
        }
      }
    });
    return items;
  }
  get supportsWholeGenome() {
    return false;
  }
}
function distanceToLine(x, y, ax, ay, bx, by) {
  const bx_minus_ax = bx - ax;
  const by_minus_ay = by - ay;
  const v = Math.abs(bx_minus_ax * (ay - y) - (ax - x) * by_minus_ay);
  const r = Math.sqrt(bx_minus_ax * bx_minus_ax + by_minus_ay * by_minus_ay);
  const distance = r > 0 ? v / r : 0;
  return distance;
}
class RnaStructTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
    if (!config.height) {
      this.height = 300;
    }
    this.arcOrientation = false;
    this.theta = Math.PI / 2;
    if ("bp" === config.format) {
      this.featureSource = new RNAFeatureSource(config, browser.genome);
    } else {
      this.featureSource = new TextFeatureSource(config, browser.genome);
    }
  }
  async getFeatures(chr, start, end) {
    const visibilityWindow = this.visibilityWindow;
    return this.featureSource.getFeatures({ chr, start, end, visibilityWindow });
  }
  draw(options2) {
    const ctx2 = options2.context;
    const theta = Math.PI / 2;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    options2.viewportWidth;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const xScale = bpPerPixel;
    const orienation = this.arcOrientation;
    IGVGraphics.fillRect(ctx2, 0, options2.pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    const featureList = options2.features;
    if (featureList) {
      sortByScore(featureList, 1);
      for (let feature2 of featureList) {
        if (feature2.startLeft) {
          let sl = Math.round((feature2.startLeft - bpStart) / xScale);
          let sr = Math.round((feature2.startRight - bpStart) / xScale);
          let el = Math.round((feature2.endLeft - bpStart) / xScale);
          let er = Math.round((feature2.endRight - bpStart) / xScale);
          ctx2.fillStyle = feature2.color;
          ctx2.strokeStyle = feature2.color;
          ctx2.beginPath();
          let x1 = (sl + er) / 2;
          let r1 = (er - sl) / 2;
          let y1 = this.height;
          let sa = Math.PI + (Math.PI / 2 - theta);
          let ea = 2 * Math.PI - (Math.PI / 2 - theta);
          if (orienation) {
            y1 = 0;
            ctx2.arc(x1, y1, r1, ea, sa);
            ctx2.lineTo(er, y1);
          } else {
            ctx2.arc(x1, y1, r1, sa, ea);
            ctx2.lineTo(el, y1);
          }
          const x2 = (sr + el) / 2;
          const r2 = (el - sr) / 2;
          const y2 = y1;
          if (orienation) {
            ctx2.arc(x2, y2, r2, sa, ea, true);
            ctx2.lineTo(el, y2);
          } else {
            ctx2.arc(x2, y2, r2, ea, sa, true);
            ctx2.lineTo(sl, y2);
          }
          ctx2.stroke();
          ctx2.fill();
          feature2.drawState = { x1, y1, r1, x2, y2, r2, sa, ea };
        } else {
          let s = Math.round((feature2.start - bpStart) / xScale);
          let e = Math.round((feature2.end - bpStart) / xScale);
          ctx2.strokeStyle = feature2.color;
          ctx2.beginPath();
          let x = (s + e) / 2;
          let r = (e - s) / 2;
          let y = this.height;
          let sa = Math.PI + (Math.PI / 2 - theta);
          let ea = 2 * Math.PI - (Math.PI / 2 - theta);
          if (orienation) {
            y = 0;
            ctx2.arc(x, y, r, ea, sa);
          } else {
            ctx2.arc(x, y, r, sa, ea);
          }
          ctx2.stroke();
          feature2.drawState = { x1: x, y1: y, r1: r, sa, ea };
        }
      }
    }
  }
  clickedFeatures(clickState) {
    const features = super.clickedFeatures(clickState);
    const clicked = [];
    sortByScore(features, -1);
    for (let f of features) {
      const ds = f.drawState;
      const dx1 = clickState.canvasX - ds.x1;
      const dy1 = clickState.canvasY - ds.y1;
      const d1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
      const outerLim = ds.r1 + 3;
      let d2;
      let innerLim;
      if (ds.x2 === void 0) {
        d2 = d1;
        innerLim = ds.r1 - 3;
      } else {
        const dx2 = clickState.canvasX - ds.x2;
        const dy2 = clickState.canvasY - ds.y2;
        d2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
        innerLim = ds.r2 - 3;
      }
      if (d1 < outerLim && d2 > innerLim) {
        clicked.push(f);
        break;
      }
    }
    return clicked;
  }
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    if (features && features.length > 0) {
      return this.extractPopupData(features[0], this.getGenomeId());
    }
  }
  menuItemList() {
    var self2 = this;
    return [
      {
        name: "Toggle arc direction",
        click: function() {
          self2.arcOrientation = !self2.arcOrientation;
          self2.trackView.repaintViews();
        }
      }
    ];
  }
}
function sortByScore(featureList, direction) {
  featureList.sort(function(a, b) {
    const s1 = a.score === void 0 ? -Number.MAX_VALUE : a.score;
    const s2 = b.score === void 0 ? -Number.MAX_VALUE : b.score;
    const d = direction === void 0 ? 1 : direction;
    return d * (s1 - s2);
  });
}
class RNAFeatureSource {
  constructor(config, genome) {
    this.config = config;
    this.genome = genome;
  }
  async getFeatures({ chr, start, end, bpPerPixel, visibilityWindow }) {
    const genome = this.genome;
    if (!this.featureCache) {
      const options2 = buildOptions$1(this.config);
      const data = await igvxhr.loadString(this.config.url, options2);
      this.featureCache = new FeatureCache$1(parseBP(data), genome);
      return this.featureCache.queryFeatures(chr, start, end);
    } else {
      return this.featureCache.queryFeatures(chr, start, end);
    }
    function parseBP(data) {
      if (!data) return null;
      const dataWrapper = getDataWrapper(data);
      let header = true;
      let line;
      const colors = [];
      const descriptors = [];
      const features = [];
      while ((line = dataWrapper.nextLine()) !== void 0) {
        const tokens = line.split("	");
        if (header && line.startsWith("color:")) {
          const color = "rgb(" + tokens[1] + "," + tokens[2] + "," + tokens[3] + ")";
          colors.push(color);
          if (tokens.length > 4) {
            descriptors.push(tokens[4]);
          }
        } else {
          header = false;
          const chr2 = tokens[0];
          const startLeftNuc = Number.parseInt(tokens[1]) - 1;
          const startRightNuc = Number.parseInt(tokens[2]) - 1;
          const endLeftNuc = Number.parseInt(tokens[3]);
          const endRightNuc = Number.parseInt(tokens[4]);
          var colorIdx = Number.parseInt(tokens[5]);
          const color = colors[colorIdx];
          let feature2;
          if (startLeftNuc <= endRightNuc) {
            feature2 = {
              chr: chr2,
              startLeft: Math.min(startLeftNuc, startRightNuc),
              startRight: Math.max(startLeftNuc, startRightNuc),
              endLeft: Math.min(endLeftNuc, endRightNuc),
              endRight: Math.max(endLeftNuc, endRightNuc),
              color,
              score: colorIdx
            };
          } else {
            feature2 = {
              chr: chr2,
              startLeft: Math.min(endLeftNuc, endRightNuc),
              startRight: Math.max(endLeftNuc, endRightNuc),
              endLeft: Math.min(startLeftNuc, startRightNuc),
              endRight: Math.max(startLeftNuc, startRightNuc),
              color,
              score: colorIdx
            };
          }
          feature2.start = feature2.startLeft;
          feature2.end = feature2.endRight;
          if (descriptors.length > colorIdx) {
            feature2.description = descriptors[colorIdx];
          }
          features.push(feature2);
        }
      }
      return features;
    }
  }
}
class IdeogramTrack {
  constructor(browser) {
    this.browser = browser;
    this.type = "ideogram";
    this.height = 16;
    this.order = Number.MIN_SAFE_INTEGER;
    this.disableButtons = true;
    this.ignoreTrackMenu = true;
  }
  async getFeatures(chr, start, end) {
    return [];
  }
  computePixelHeight(ignore) {
    return this.height;
  }
  draw({ context, referenceFrame, pixelWidth, pixelHeight }) {
    const chr = referenceFrame.chr;
    const chromosome = referenceFrame.genome.getChromosome(chr);
    if (void 0 === chromosome || pixelWidth <= 0 || pixelHeight <= 0 || "all" === chr.toLowerCase()) {
      return;
    }
    const stainColors = [];
    drawIdeogram({
      ctx: context,
      chr,
      referenceFrame,
      genome: referenceFrame.genome,
      width: pixelWidth,
      height: pixelHeight,
      stainColors
    });
    const widthBP = Math.round(referenceFrame.bpPerPixel * pixelWidth);
    const xBP = referenceFrame.start;
    let chrLength = chromosome.bpLength;
    const cytobands = referenceFrame.genome.getCytobands(chr);
    if (cytobands && cytobands.length > 0 && cytobands[cytobands.length - 1].end) {
      chrLength = Math.max(chrLength, cytobands[cytobands.length - 1].end);
      chromosome.bpLength = chrLength;
    }
    if (widthBP < chrLength) {
      const percentWidth = widthBP / chrLength;
      const percentX = xBP / chrLength;
      let x = Math.floor(percentX * pixelWidth);
      let ww = Math.floor(percentWidth * pixelWidth);
      x = Math.max(0, x);
      x = Math.min(pixelWidth - ww, x);
      context.save();
      context.strokeStyle = "red";
      context.lineWidth = ww < 2 ? 1 : 2;
      const xx = x + context.lineWidth / 2;
      ww = ww < 2 ? 1 : ww - context.lineWidth;
      const yy = context.lineWidth / 2;
      const hh = pixelHeight - context.lineWidth;
      context.strokeRect(xx, yy, ww, hh);
      context.restore();
    }
  }
  dispose() {
    this.trackView = void 0;
  }
}
function drawIdeogram({ ctx: ctx2, chr, referenceFrame, genome, width, height, stainColors }) {
  const shim = 1;
  const shim2 = 0.5 * shim;
  const ideogramTop = 0;
  if (void 0 === genome) {
    return;
  }
  IGVGraphics.fillRect(ctx2, 0, 0, width, height, { fillStyle: IGVColor.greyScale(255) });
  const cytobands = genome.getCytobands(chr);
  if (cytobands) {
    const center = ideogramTop + height / 2;
    const xC = [];
    const yC = [];
    if (0 === cytobands.length) {
      return;
    }
    const chrLength = cytobands[cytobands.length - 1].end;
    const scale = width / chrLength;
    ctx2.beginPath();
    IGVGraphics.roundRect(ctx2, shim2, shim2 + ideogramTop, width - 2 * shim2, height - 2 * shim2, (height - 2 * shim2) / 2, 0, 1);
    ctx2.clip();
    for (let i = 0; i < cytobands.length; i++) {
      const cytoband = cytobands[i];
      const start = scale * cytoband.start;
      const end = scale * cytoband.end;
      if (cytoband.type === "c") {
        if (cytoband.name.charAt(0) === "p") {
          xC[0] = start;
          yC[0] = height + ideogramTop;
          xC[1] = start;
          yC[1] = ideogramTop;
          xC[2] = end;
          yC[2] = center;
        } else {
          xC[0] = end;
          yC[0] = height + ideogramTop;
          xC[1] = end;
          yC[1] = ideogramTop;
          xC[2] = start;
          yC[2] = center;
        }
        ctx2.fillStyle = "rgb(150, 0, 0)";
        ctx2.strokeStyle = "rgb(150, 0, 0)";
        IGVGraphics.polygon(ctx2, xC, yC, 1, 0);
      } else {
        ctx2.fillStyle = getCytobandColor(stainColors, cytoband);
        IGVGraphics.fillRect(ctx2, start, shim + ideogramTop, end - start, height - 2 * shim);
      }
    }
  }
  ctx2.strokeStyle = IGVColor.greyScale(41);
  IGVGraphics.roundRect(ctx2, shim2, shim2 + ideogramTop, width - 2 * shim2, height - 2 * shim2, (height - 2 * shim2) / 2, 0, 1);
}
function getCytobandColor(colors, data) {
  if (data.type === "c") {
    return "rgb(150, 10, 10)";
  } else {
    var stain = data.stain;
    var shade = 230;
    if (data.type === "p") {
      shade = Math.floor(230 - stain / 100 * 230);
    }
    var c = colors[shade];
    if (!c) {
      c = "rgb(" + shade + "," + shade + "," + shade + ")";
      colors[shade] = c;
    }
    return c;
  }
}
let JUNCTION_MOTIF_PALETTE = new PaletteColorTable("Dark2");
const someMotifValues = ["GT/AG", "CT/AC", "GC/AG", "CT/GC", "AT/AC", "GT/AT", "non-canonical"];
someMotifValues.forEach((motif) => {
  JUNCTION_MOTIF_PALETTE.getColor(motif);
});
const junctionRenderingContext = {};
class SpliceJunctionTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
  }
  init(config) {
    super.init(config);
    this.type = config.type || "junctions";
    if (config._featureSource) {
      this.featureSource = config._featureSource;
      delete config._featureSource;
    } else {
      this.featureSource = config.featureSource ? config.featureSource : FeatureSource(config, this.browser.genome);
    }
    this.margin = config.margin === void 0 ? 10 : config.margin;
    if (!this.height) {
      this.height = 100;
    }
    if (config.colorByNumReadsThreshold === void 0) {
      config.colorByNumReadsThreshold = 5;
    }
  }
  async postInit() {
    if (typeof this.featureSource.getHeader === "function") {
      this.header = await this.featureSource.getHeader();
      if (this.disposed) return;
    }
    if (this.header) {
      this.setTrackProperties(this.header);
    }
    if (this.visibilityWindow === void 0 && typeof this.featureSource.defaultVisibilityWindow === "function") {
      this.visibilityWindow = await this.featureSource.defaultVisibilityWindow();
    }
    return this;
  }
  get supportsWholeGenome() {
    return false;
  }
  async getFeatures(chr, start, end, bpPerPixel) {
    const visibilityWindow = this.visibilityWindow;
    return this.featureSource.getFeatures({ chr, start, end, bpPerPixel, visibilityWindow });
  }
  /**
   * The required height in pixels required for the track content.   This is not the visible track height, which
   * can be smaller (with a scrollbar) or larger.
   *
   * @param features
   * @returns {*}
   */
  computePixelHeight(features) {
    return this.height;
  }
  draw(options2) {
    const featureList = options2.features;
    const ctx2 = options2.context;
    const bpPerPixel = options2.bpPerPixel;
    const bpStart = options2.bpStart;
    const pixelWidth = options2.pixelWidth;
    const pixelHeight = options2.pixelHeight;
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    if (!this.config.isMergedTrack) {
      IGVGraphics.fillRect(ctx2, 0, options2.pixelTop, pixelWidth, pixelHeight, { "fillStyle": "rgb(255, 255, 255)" });
    }
    if (featureList) {
      junctionRenderingContext.referenceFrame = options2.viewport.referenceFrame;
      junctionRenderingContext.referenceFrameStart = junctionRenderingContext.referenceFrame.start;
      junctionRenderingContext.referenceFrameEnd = junctionRenderingContext.referenceFrameStart + junctionRenderingContext.referenceFrame.toBP(options2.viewport.getWidth());
      junctionRenderingContext.featureZoomOutTracker = {};
      for (let feature2 of featureList) {
        if (feature2.end < bpStart) continue;
        if (feature2.start > bpEnd) break;
        this.renderJunction(feature2, bpStart, bpPerPixel, pixelHeight, ctx2);
      }
    } else {
      console.log("No feature list");
    }
  }
  /**
   *
   * @param feature
   * @param bpStart  genomic location of the left edge of the current canvas
   * @param xScale  scale in base-pairs per pixel
   * @param pixelHeight  pixel height of the current canvas
   * @param ctx  the canvas 2d context
   */
  renderJunction(feature2, bpStart, xScale, pixelHeight, ctx2) {
    feature2.isVisible = false;
    const junctionLeftPx = Math.round((feature2.start - bpStart) / xScale);
    const junctionRightPx = Math.round((feature2.end - bpStart) / xScale);
    const junctionMiddlePx = (junctionLeftPx + junctionRightPx) / 2;
    if (junctionRightPx - junctionLeftPx <= 3) {
      if (junctionMiddlePx in junctionRenderingContext.featureZoomOutTracker) {
        return;
      }
      junctionRenderingContext.featureZoomOutTracker[junctionMiddlePx] = true;
    }
    if (this.config.hideAnnotatedJunctions && feature2.attributes.annotated_junction === "true") {
      return;
    }
    if (this.config.hideUnannotatedJunctions && feature2.attributes.annotated_junction === "false") {
      return;
    }
    if (this.config.hideMotifs && this.config.hideMotifs.includes(feature2.attributes.motif)) {
      return;
    }
    if (this.config.hideStrand === feature2.strand) {
      return;
    }
    if (this.config.minJunctionEndsVisible) {
      let numJunctionEndsVisible = 0;
      if (feature2.start >= junctionRenderingContext.referenceFrameStart && feature2.start <= junctionRenderingContext.referenceFrameEnd) {
        numJunctionEndsVisible += 1;
      }
      if (feature2.end >= junctionRenderingContext.referenceFrameStart && feature2.end <= junctionRenderingContext.referenceFrameEnd) {
        numJunctionEndsVisible += 1;
      }
      if (numJunctionEndsVisible < this.config.minJunctionEndsVisible) {
        return;
      }
    }
    let uniquelyMappedReadCount;
    let multiMappedReadCount;
    let totalReadCount;
    if (feature2.attributes.uniquely_mapped) {
      uniquelyMappedReadCount = parseInt(feature2.attributes.uniquely_mapped);
      if (uniquelyMappedReadCount < this.config.minUniquelyMappedReads) {
        return;
      }
      multiMappedReadCount = parseInt(feature2.attributes.multi_mapped);
      totalReadCount = uniquelyMappedReadCount + multiMappedReadCount;
      if (totalReadCount < this.config.minTotalReads) {
        return;
      }
      if (totalReadCount > 0 && multiMappedReadCount / totalReadCount > this.config.maxFractionMultiMappedReads) {
        return;
      }
      if (feature2.attributes.maximum_spliced_alignment_overhang && parseInt(feature2.attributes.maximum_spliced_alignment_overhang) < this.config.minSplicedAlignmentOverhang) {
        return;
      }
    }
    let numSamplesWithThisJunction;
    if (feature2.attributes.num_samples_with_this_junction) {
      numSamplesWithThisJunction = parseInt(feature2.attributes.num_samples_with_this_junction);
      if (this.config.minSamplesWithThisJunction && numSamplesWithThisJunction < this.config.minSamplesWithThisJunction) {
        return;
      }
      if (this.config.maxSamplesWithThisJunction && numSamplesWithThisJunction > this.config.maxSamplesWithThisJunction) {
        return;
      }
      if (feature2.attributes.num_samples_total) {
        feature2.attributes.percent_samples_with_this_junction = 100 * numSamplesWithThisJunction / Number(feature2.attributes.num_samples_total);
        if (this.config.minPercentSamplesWithThisJunction) {
          if (feature2.attributes.percent_samples_with_this_junction < this.config.minPercentSamplesWithThisJunction || feature2.attributes.percent_samples_with_this_junction > this.config.maxPercentSamplesWithThisJunction) {
            return;
          }
        }
      }
    }
    const py = this.margin;
    const rowHeight = this.height;
    const cy = py + 0.5 * rowHeight;
    let topY = py;
    const bottomY = py + rowHeight;
    const bezierBottomY = bottomY - 10;
    const bezierControlLeftPx = (junctionLeftPx + junctionMiddlePx) / 2;
    const bezierControlRightPx = (junctionMiddlePx + junctionRightPx) / 2;
    let lineWidth = 1;
    if (feature2.attributes.line_width) {
      lineWidth = Number(feature2.attributes.line_width);
    } else {
      if (this.config.thicknessBasedOn === void 0 || this.config.thicknessBasedOn === "numUniqueReads") {
        lineWidth = uniquelyMappedReadCount;
      } else if (this.config.thicknessBasedOn === "numReads") {
        lineWidth = totalReadCount;
      } else if (this.config.thicknessBasedOn === "numSamplesWithThisJunction") {
        if (numSamplesWithThisJunction !== void 0) {
          lineWidth = numSamplesWithThisJunction;
        }
      }
      lineWidth = 1 + Math.log(lineWidth + 1) / Math.log(12);
    }
    let bounceHeight;
    if (this.config.bounceHeightBasedOn === void 0 || this.config.bounceHeightBasedOn === "random") {
      bounceHeight = (feature2.start + feature2.end) % 7;
    } else if (this.config.bounceHeightBasedOn === "distance") {
      bounceHeight = 6 * (feature2.end - feature2.start) / (junctionRenderingContext.referenceFrameEnd - junctionRenderingContext.referenceFrameStart);
    } else if (this.config.bounceHeightBasedOn === "thickness") {
      bounceHeight = 2 * lineWidth;
    }
    topY += rowHeight * Math.max(7 - bounceHeight, 0) / 10;
    let color;
    if (feature2.attributes.color) {
      color = feature2.attributes.color;
    } else if (this.config.colorBy === void 0 || this.config.colorBy === "numUniqueReads") {
      color = uniquelyMappedReadCount > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA";
    } else if (this.config.colorBy === "numReads") {
      color = totalReadCount > this.config.colorByNumReadsThreshold ? "blue" : "#AAAAAA";
    } else if (this.config.colorBy === "isAnnotatedJunction") {
      color = feature2.attributes.annotated_junction === "true" ? "#b0b0ec" : "orange";
    } else if (this.config.colorBy === "strand") {
      color = feature2.strand === "+" ? "#b0b0ec" : "#ecb0b0";
    } else if (this.config.colorBy === "motif") {
      color = JUNCTION_MOTIF_PALETTE.getColor(feature2.attributes.motif);
    } else {
      color = "#AAAAAA";
    }
    let label = "";
    if (feature2.attributes.label) {
      label = feature2.attributes.label.replace(/_/g, " ");
    } else if (this.config.labelWith === void 0 || this.config.labelWith === "uniqueReadCount") {
      label = uniquelyMappedReadCount;
    } else if (this.config.labelWith === "totalReadCount") {
      label = totalReadCount;
    } else if (this.config.labelWith === "numSamplesWithThisJunction") {
      if (numSamplesWithThisJunction !== void 0) {
        label = numSamplesWithThisJunction;
      }
    } else if (this.config.labelWith === "percentSamplesWithThisJunction") {
      if (feature2.attributes.percent_samples_with_this_junction !== void 0) {
        label = feature2.attributes.percent_samples_with_this_junction.toFixed(0) + "%";
      }
    } else if (this.config.labelWith === "motif") {
      if (feature2.attributes.motif !== void 0) {
        label += feature2.attributes.motif;
      }
    }
    if (this.config.labelWithInParen === "uniqueReadCount") {
      label += " (" + uniquelyMappedReadCount + ")";
    } else if (this.config.labelWithInParen === "totalReadCount") {
      label += " (" + totalReadCount + ")";
    } else if (this.config.labelWithInParen === "multiMappedReadCount") {
      if (multiMappedReadCount > 0) {
        label += " (+" + multiMappedReadCount + ")";
      }
    } else if (this.config.labelWithInParen === "numSamplesWithThisJunction") {
      if (numSamplesWithThisJunction !== void 0) {
        label += " (" + numSamplesWithThisJunction + ")";
      }
    } else if (this.config.labelWithInParen === "percentSamplesWithThisJunction") {
      if (feature2.attributes.percent_samples_with_this_junction !== void 0) {
        label += " (" + feature2.attributes.percent_samples_with_this_junction.toFixed(0) + "%)";
      }
    } else if (this.config.labelWithInParen === "motif") {
      if (feature2.attributes.motif !== void 0) {
        label += ` ${feature2.attributes.motif}`;
      }
    }
    feature2.isVisible = true;
    ctx2.beginPath();
    ctx2.moveTo(junctionLeftPx, bezierBottomY);
    ctx2.bezierCurveTo(bezierControlLeftPx, topY, bezierControlRightPx, topY, junctionRightPx, bezierBottomY);
    ctx2.lineWidth = lineWidth;
    ctx2.strokeStyle = color;
    ctx2.stroke();
    const drawArrowhead = (ctx3, x, y, size) => {
      ctx3.beginPath();
      ctx3.moveTo(x, y);
      ctx3.lineTo(x - size / 2, y - size);
      ctx3.lineTo(x + size / 2, y - size);
      ctx3.lineTo(x, y);
      ctx3.closePath();
      ctx3.fill();
    };
    if (feature2.attributes.left_shape || feature2.attributes.right_shape) {
      ctx2.fillStyle = color;
      const arrowSize = ctx2.lineWidth > 2 ? 10 : 7;
      if (feature2.attributes.left_shape) {
        drawArrowhead(ctx2, junctionLeftPx, bezierBottomY, arrowSize);
      }
      if (feature2.attributes.right_shape) {
        drawArrowhead(ctx2, junctionRightPx, bezierBottomY, arrowSize);
      }
    }
    ctx2.fillText(label, junctionMiddlePx - ctx2.measureText(label).width / 2, (7 * topY + cy) / 8);
  }
  clickedFeatures(clickState) {
    const allFeatures = super.clickedFeatures(clickState);
    return allFeatures.filter(function(feature2) {
      return feature2.isVisible && feature2.attributes;
    });
  }
  /**
   * Return "popup data" for feature @ genomic location.  Data is an array of key-value pairs
   */
  popupData(clickState, features) {
    if (features === void 0) features = this.clickedFeatures(clickState);
    const genomicLocation = clickState.genomicLocation;
    const data = [];
    for (let feature2 of features) {
      const featureData = typeof feature2.popupData === "function" ? feature2.popupData(genomicLocation) : this.extractPopupData(feature2._f || feature2, this.getGenomeId());
      if (featureData) {
        if (data.length > 0) {
          data.push("<hr/><hr/>");
        }
        Array.prototype.push.apply(data, featureData);
      }
    }
    return data;
  }
  /**
   * Called when the track is removed.  Do any needed cleanup here
   */
  dispose() {
    this.trackView = void 0;
  }
}
let RemoteFile$1 = class RemoteFile {
  constructor(args) {
    this.config = args;
    this.url = mapUrl$2(args.path || args.url);
  }
  async read(position, length) {
    const headers = this.config.headers || {};
    if (position !== void 0 && length) {
      const rangeString = "bytes=" + position + "-" + (position + length - 1);
      headers["Range"] = rangeString;
    }
    let url = this.url.slice();
    if (this.config.oauthToken) {
      const token = resolveToken(this.config.oauthToken);
      headers["Authorization"] = `Bearer ${token}`;
    }
    if (this.config.apiKey) {
      url = addParameter$1(url, "key", this.config.apiKey);
    }
    const response = await fetch(url, {
      method: "GET",
      headers,
      redirect: "follow",
      mode: "cors"
    });
    const status = response.status;
    if (status >= 400) {
      const err2 = Error(response.statusText);
      err2.code = status;
      throw err2;
    } else {
      return response.arrayBuffer();
    }
    async function resolveToken(token) {
      if (typeof token === "function") {
        return await Promise.resolve(token());
      } else {
        return token;
      }
    }
  }
};
function mapUrl$2(url) {
  if (url.includes("//www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov")) {
    return url.replace("ftp://", "https://");
  } else {
    return url;
  }
}
function addParameter$1(url, name2, value) {
  const paramSeparator = url.includes("?") ? "&" : "?";
  return url + paramSeparator + name2 + "=" + value;
}
let BufferedFile$1 = class BufferedFile {
  constructor(args) {
    this.file = args.file;
    this.fetchSize = args.fetchSize || 16e3;
    this.maxSize = args.maxSize || 1e6;
    this.buffers = [];
  }
  async read(position, length) {
    let overlappingBuffers = this.buffers.filter((b) => b.overlaps(position, position + length));
    for (let buffer of overlappingBuffers) {
      if (buffer.contains(position, position + length)) {
        return buffer.slice(position, position + length);
      }
    }
    if (overlappingBuffers.length === 0) {
      let size = Math.max(length, this.fetchSize);
      this.buffers.sort((a, b) => a.start - b.start);
      const idx = binarySearch(this.buffers, (b) => b.start > position, 0);
      if (idx < this.buffers.length) {
        size = Math.min(size, this.buffers[idx].start - position);
      }
      const bufferStart = position;
      const bufferData = await this.file.read(bufferStart, size);
      const buffer = new Buffer$1(bufferStart, bufferData);
      this.addBuffer(buffer);
      return buffer.slice(position, position + length);
    } else {
      overlappingBuffers.sort((a, b) => a.start - b.start);
      const allBuffers = [];
      let currentEnd = position;
      for (let ob of overlappingBuffers) {
        if (currentEnd < ob.start) {
          const bufferStart = currentEnd;
          const bufferSize = ob.start - currentEnd;
          const bufferData = await this.file.read(bufferStart, bufferSize);
          const buffer = new Buffer$1(bufferStart, bufferData);
          allBuffers.push(buffer);
        }
        allBuffers.push(ob);
        currentEnd = ob.end;
      }
      const requestedEnd = position + length;
      if (requestedEnd > currentEnd) {
        const bufferStart = currentEnd;
        const bufferSize = requestedEnd - bufferStart;
        const bufferData = await this.file.read(bufferStart, bufferSize);
        const buffer = new Buffer$1(bufferStart, bufferData);
        allBuffers.push(buffer);
      }
      const newStart = allBuffers[0].start;
      const newArrayBuffer = concatArrayBuffers(allBuffers.map((b) => b.buffer));
      const newBuffer = new Buffer$1(newStart, newArrayBuffer);
      const tmp = new Set(overlappingBuffers);
      this.buffers = this.buffers.filter((b) => !tmp.has(b));
      this.addBuffer(newBuffer);
      return newBuffer.slice(position, position + length);
    }
  }
  addBuffer(buffer) {
    const size = this.buffers.reduce((a, b) => a + b.size, 0) + buffer.size;
    if (size > this.maxSize) {
      const overage = size - this.maxSize;
      this.buffers.sort((a, b) => a.creationTime - b.creationTime);
      let sum = 0;
      let i;
      for (i = 0; i < this.buffers.length; i++) {
        sum += this.buffers[i].size;
        if (sum > overage) {
          break;
        }
      }
      this.buffers = i < this.buffers.length - 1 ? this.buffers.slice(i) : [];
    }
    if (buffer.size <= this.maxSize) {
      this.buffers.push(buffer);
    }
  }
};
class Buffer$1 {
  constructor(bufferStart, buffer) {
    this.creationTime = Date.now();
    this.start = bufferStart;
    this.buffer = buffer;
  }
  slice(start, end) {
    if (start < this.start || end - start > this.buffer.byteLength) {
      throw Error("buffer bounds error");
    }
    return this.buffer.slice(start - this.start, end - this.start);
  }
  get end() {
    return this.start + this.buffer.byteLength;
  }
  get size() {
    return this.buffer.byteLength;
  }
  contains(start, end) {
    return start >= this.start && end <= this.end;
  }
  overlaps(start, end) {
    return start > this.start && start < this.end || end > this.start && end < this.end;
  }
  toString() {
    return `Buffer ${this.creationTime}   ${this.start} - ${this.end}`;
  }
}
function concatArrayBuffers(buffers) {
  const size = buffers.reduce((a, b) => a + b.byteLength, 0);
  const tmp = new Uint8Array(size);
  let offset2 = 0;
  for (let b of buffers) {
    tmp.set(new Uint8Array(b), offset2);
    offset2 += b.byteLength;
  }
  return tmp.buffer;
}
function binarySearch(array, pred, min) {
  let lo = min - 1, hi = array.length;
  while (1 + lo < hi) {
    const mi = lo + (hi - lo >> 1);
    if (pred(array[mi])) {
      hi = mi;
    } else {
      lo = mi;
    }
  }
  return hi;
}
class BlobFile {
  constructor(blob) {
    this.file = blob;
  }
  async read(position, length) {
    if (length === 0) {
      return new ArrayBuffer();
    }
    const blob = position != void 0 && length ? this.file.slice(position, position + length) : this.file;
    return blob.arrayBuffer();
  }
}
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
async function _unpack_struct_from_async(structure, async_buf, offset2 = 0) {
  var output = /* @__PURE__ */ new Map();
  for (let [key, fmt] of structure.entries()) {
    let value = await struct.unpack_from_async("<" + fmt, async_buf, offset2);
    offset2 += struct.calcsize(fmt);
    if (value.length == 1) {
      value = value[0];
    }
    output.set(key, value);
  }
  return output;
}
function _unpack_struct_from(structure, buf, offset2 = 0) {
  var output = /* @__PURE__ */ new Map();
  for (let [key, fmt] of structure.entries()) {
    let value = struct.unpack_from("<" + fmt, buf, offset2);
    offset2 += struct.calcsize(fmt);
    if (value.length == 1) {
      value = value[0];
    }
    output.set(key, value);
  }
  return output;
}
function assert(thing) {
  if (!thing) {
    thing();
  }
}
function _structure_size(structure) {
  var fmt = "<" + Array.from(structure.values()).join("");
  return struct.calcsize(fmt);
}
function _padded_size(size, padding_multiple = 8) {
  return Math.ceil(size / padding_multiple) * padding_multiple;
}
var dtype_to_format = {
  "u": "Uint",
  "i": "Int",
  "f": "Float"
};
function dtype_getter(dtype_str) {
  var big_endian = struct._is_big_endian(dtype_str);
  var getter, nbytes;
  if (/S/.test(dtype_str)) {
    getter = "getString";
    nbytes = ((dtype_str.match(/S(\d*)/) || [])[1] || 1) | 0;
  } else {
    let [_, fstr, bytestr] = dtype_str.match(/[<>=!@]?(i|u|f)(\d*)/);
    nbytes = parseInt(bytestr || 4, 10);
    let nbits = nbytes * 8;
    getter = "get" + dtype_to_format[fstr] + nbits.toFixed();
  }
  return [getter, big_endian, nbytes];
}
var Struct = class {
  constructor() {
    this.big_endian = isBigEndian();
    this.getters = {
      "s": "getUint8",
      "b": "getInt8",
      "B": "getUint8",
      "h": "getInt16",
      "H": "getUint16",
      "i": "getInt32",
      "I": "getUint32",
      "l": "getInt32",
      "L": "getUint32",
      "q": "getInt64",
      "Q": "getUint64",
      "f": "getFloat32",
      "d": "getFloat64"
    };
    this.byte_lengths = {
      "s": 1,
      "b": 1,
      "B": 1,
      "h": 2,
      "H": 2,
      "i": 4,
      "I": 4,
      "l": 4,
      "L": 4,
      "q": 8,
      "Q": 8,
      "f": 4,
      "d": 8
    };
    let all_formats = Object.keys(this.byte_lengths).join("");
    this.fmt_size_regex = "(\\d*)([" + all_formats + "])";
  }
  calcsize(fmt) {
    var size = 0;
    var match;
    var regex = new RegExp(this.fmt_size_regex, "g");
    while ((match = regex.exec(fmt)) !== null) {
      let n = parseInt(match[1] || 1, 10);
      let f = match[2];
      let subsize = this.byte_lengths[f];
      size += n * subsize;
    }
    return size;
  }
  _is_big_endian(fmt) {
    var big_endian;
    if (/^</.test(fmt)) {
      big_endian = false;
    } else if (/^(!|>)/.test(fmt)) {
      big_endian = true;
    } else {
      big_endian = this.big_endian;
    }
    return big_endian;
  }
  async unpack_from_async(fmt, async_buf, offset2) {
    offset2 = Number.parseInt(offset2 || 0);
    const total_size = this.calcsize(fmt);
    const local_buffer = await async_buf.slice(offset2, offset2 + total_size);
    let local_offset = 0;
    var view = new DataView64(local_buffer);
    var output = [];
    var big_endian = this._is_big_endian(fmt);
    var match;
    var regex = new RegExp(this.fmt_size_regex, "g");
    while ((match = regex.exec(fmt)) !== null) {
      let n = parseInt(match[1] || 1, 10);
      let f = match[2];
      let getter = this.getters[f];
      let size = this.byte_lengths[f];
      if (f == "s") {
        output.push(new TextDecoder().decode(local_buffer.slice(local_offset, local_offset + n)));
        local_offset += n;
      } else {
        for (var i = 0; i < n; i++) {
          output.push(view[getter](local_offset, !big_endian));
          local_offset += size;
        }
      }
    }
    return output;
  }
  unpack_from(fmt, buffer, offset2) {
    offset2 = Number.parseInt(offset2 || 0);
    const total_size = this.calcsize(fmt);
    const local_buffer = buffer.slice(offset2, offset2 + total_size);
    let local_offset = 0;
    var view = new DataView64(local_buffer);
    var output = [];
    var big_endian = this._is_big_endian(fmt);
    var match;
    var regex = new RegExp(this.fmt_size_regex, "g");
    while ((match = regex.exec(fmt)) !== null) {
      let n = parseInt(match[1] || 1, 10);
      let f = match[2];
      let getter = this.getters[f];
      let size = this.byte_lengths[f];
      if (f == "s") {
        output.push(new TextDecoder().decode(local_buffer.slice(local_offset, local_offset + n)));
        local_offset += n;
      } else {
        for (var i = 0; i < n; i++) {
          output.push(view[getter](local_offset, !big_endian));
          local_offset += size;
        }
      }
    }
    return output;
  }
};
var struct = new Struct();
function isBigEndian() {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  return !((view[0] = 1) & array[0]);
}
var DataView64 = class extends DataView {
  getUint64(byteOffset, littleEndian) {
    const left = BigInt(this.getUint32(byteOffset, littleEndian));
    const right = BigInt(this.getUint32(byteOffset + 4, littleEndian));
    let combined = littleEndian ? left + (right << 32n) : (left << 32n) + right;
    return Number.parseInt(combined);
  }
  getInt64(byteOffset, littleEndian) {
    var low, high;
    if (littleEndian) {
      low = this.getUint32(byteOffset, true);
      high = this.getInt32(byteOffset + 4, true);
    } else {
      high = this.getInt32(byteOffset, false);
      low = this.getUint32(byteOffset + 4, false);
    }
    let combined = BigInt(low) + (BigInt(high) << 32n);
    return Number.parseInt(combined);
  }
  getString(byteOffset, littleEndian, length) {
    const str_buffer = this.buffer.slice(byteOffset, byteOffset + length);
    const decoder = new TextDecoder();
    return decoder.decode(str_buffer);
  }
  getVLENStruct(byteOffset, littleEndian, length) {
    let item_size = this.getUint32(byteOffset, littleEndian);
    let collection_address = this.getUint64(byteOffset + 4, littleEndian);
    let object_index = this.getUint32(byteOffset + 12, littleEndian);
    return [item_size, collection_address, object_index];
  }
};
function bitSize(integer) {
  return integer.toString(2).length;
}
function _unpack_integer(nbytes, buf, offset2 = 0, littleEndian = true) {
  const local_buffer = buf.slice(offset2, offset2 + nbytes);
  let bytes = new Uint8Array(local_buffer);
  if (!littleEndian) {
    bytes.reverse();
  }
  let integer = bytes.reduce((accumulator, currentValue, index2) => accumulator + (currentValue << index2 * 8), 0);
  return integer;
}
var DatatypeMessage = class {
  constructor(buf, offset2) {
    this.buf = buf;
    this.offset = offset2;
    this.dtype = this.determine_dtype();
  }
  async determine_dtype() {
    let datatype_msg = await _unpack_struct_from_async(DATATYPE_MSG, this.buf, this.offset);
    this.offset += DATATYPE_MSG_SIZE;
    let datatype_class = datatype_msg.get("class_and_version") & 15;
    if (datatype_class == DATATYPE_FIXED_POINT) {
      return this._determine_dtype_fixed_point(datatype_msg);
    } else if (datatype_class == DATATYPE_FLOATING_POINT) {
      return this._determine_dtype_floating_point(datatype_msg);
    } else if (datatype_class == DATATYPE_TIME) {
      throw "Time datatype class not supported.";
    } else if (datatype_class == DATATYPE_STRING) {
      return this._determine_dtype_string(datatype_msg);
    } else if (datatype_class == DATATYPE_BITFIELD) {
      throw "Bitfield datatype class not supported.";
    } else if (datatype_class == DATATYPE_OPAQUE) {
      return {
        datatype_class: DATATYPE_OPAQUE,
        size: datatype_msg.get("size")
      };
    } else if (datatype_class == DATATYPE_COMPOUND) {
      return this._determine_dtype_compound(datatype_msg);
    } else if (datatype_class == DATATYPE_REFERENCE) {
      return ["REFERENCE", datatype_msg.get("size")];
    } else if (datatype_class == DATATYPE_ENUMERATED) {
      return this.determine_dtype();
    } else if (datatype_class == DATATYPE_ARRAY) {
      throw "Array datatype class not supported.";
    } else if (datatype_class == DATATYPE_VARIABLE_LENGTH) {
      let vlen_type = this._determine_dtype_vlen(datatype_msg);
      if (vlen_type[0] == "VLEN_SEQUENCE") {
        let base_type = this.determine_dtype();
        vlen_type = ["VLEN_SEQUENCE", base_type];
      }
      return vlen_type;
    } else {
      throw "Invalid datatype class " + datatype_class;
    }
  }
  _determine_dtype_fixed_point(datatype_msg) {
    let length_in_bytes = datatype_msg.get("size");
    if (![1, 2, 4, 8].includes(length_in_bytes)) {
      throw "Unsupported datatype size";
    }
    let signed = datatype_msg.get("class_bit_field_0") & 8;
    var dtype_char;
    if (signed > 0) {
      dtype_char = "i";
    } else {
      dtype_char = "u";
    }
    let byte_order = datatype_msg.get("class_bit_field_0") & 1;
    var byte_order_char;
    if (byte_order == 0) {
      byte_order_char = "<";
    } else {
      byte_order_char = ">";
    }
    this.offset += 4;
    return byte_order_char + dtype_char + length_in_bytes.toFixed();
  }
  _determine_dtype_floating_point(datatype_msg) {
    let length_in_bytes = datatype_msg.get("size");
    if (![1, 2, 4, 8].includes(length_in_bytes)) {
      throw "Unsupported datatype size";
    }
    let dtype_char = "f";
    let byte_order = datatype_msg.get("class_bit_field_0") & 1;
    var byte_order_char;
    if (byte_order == 0) {
      byte_order_char = "<";
    } else {
      byte_order_char = ">";
    }
    this.offset += 12;
    return byte_order_char + dtype_char + length_in_bytes.toFixed();
  }
  _determine_dtype_string(datatype_msg) {
    return "S" + datatype_msg.get("size").toFixed();
  }
  _determine_dtype_vlen(datatype_msg) {
    let vlen_type = datatype_msg.get("class_bit_field_0") & 1;
    if (vlen_type != 1) {
      return ["VLEN_SEQUENCE", 0, 0];
    }
    let padding_type = datatype_msg.get("class_bit_field_0") >> 4;
    let character_set = datatype_msg.get("class_bit_field_1") & 1;
    return ["VLEN_STRING", padding_type, character_set];
  }
  _determine_dtype_compound(datatype_msg) {
    throw "Compound type not yet implemented!";
  }
};
var DATATYPE_MSG = /* @__PURE__ */ new Map([
  ["class_and_version", "B"],
  ["class_bit_field_0", "B"],
  ["class_bit_field_1", "B"],
  ["class_bit_field_2", "B"],
  ["size", "I"]
]);
var DATATYPE_MSG_SIZE = _structure_size(DATATYPE_MSG);
var COMPOUND_PROP_DESC_V1 = /* @__PURE__ */ new Map([
  ["offset", "I"],
  ["dimensionality", "B"],
  ["reserved_0", "B"],
  ["reserved_1", "B"],
  ["reserved_2", "B"],
  ["permutation", "I"],
  ["reserved_3", "I"],
  ["dim_size_1", "I"],
  ["dim_size_2", "I"],
  ["dim_size_3", "I"],
  ["dim_size_4", "I"]
]);
_structure_size(COMPOUND_PROP_DESC_V1);
var DATATYPE_FIXED_POINT = 0;
var DATATYPE_FLOATING_POINT = 1;
var DATATYPE_TIME = 2;
var DATATYPE_STRING = 3;
var DATATYPE_BITFIELD = 4;
var DATATYPE_OPAQUE = 5;
var DATATYPE_COMPOUND = 6;
var DATATYPE_REFERENCE = 7;
var DATATYPE_ENUMERATED = 8;
var DATATYPE_VARIABLE_LENGTH = 9;
var DATATYPE_ARRAY = 10;
function zero$1(buf) {
  let len2 = buf.length;
  while (--len2 >= 0) {
    buf[len2] = 0;
  }
}
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
var adler32 = (adler, buf, len2, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len2 !== 0) {
    n = len2 > 2e3 ? 2e3 : len2;
    len2 -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len2, pos) => {
  const t = crcTable;
  const end = pos + len2;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  1: "stream end",
  0: "",
  "-1": "file error",
  "-2": "stream error",
  "-3": "data error",
  "-4": "insufficient memory",
  "-5": "buffer error",
  "-6": "incompatible version"
};
var constants$2 = {
  Z_NO_FLUSH: 0,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFLATED: 8
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len2 = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len2 += chunks[i].length;
  }
  const result = new Uint8Array(len2);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len2) => {
  if (len2 < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len2 ? buf : buf.subarray(0, len2));
    }
  }
  let result = "";
  for (let i = 0; i < len2; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len2 = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len2 * 2);
  for (out = 0, i = 0; i < len2; ) {
    let c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    let c_len = _utf8len[c];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len2) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var BAD$1 = 30;
var TYPE$1 = 12;
var inffast = function inflate_fast3(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len2;
  let dist;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len2 = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len2 += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len2) {
                          op = wnext;
                          len2 -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len2) {
                        len2 -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len2 > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len2 -= 3;
                    }
                    if (len2) {
                      output[_out++] = from_source[from++];
                      if (len2 > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len2 -= 3;
                    } while (len2 > 2);
                    if (len2) {
                      output[_out++] = output[from++];
                      if (len2 > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len2 = bits >> 3;
  _in -= len2;
  bits -= len2 << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len2 = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let base_index = 0;
  let end;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len2 = 0; len2 <= MAXBITS; len2++) {
    count[len2] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len2 = 1; len2 <= MAXBITS; len2++) {
    left <<= 1;
    left -= count[len2];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len2 = 1; len2 < MAXBITS; len2++) {
    offs[len2 + 1] = offs[len2] + count[len2];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES$1) {
    base = extra = work;
    end = 19;
  } else if (type === LENS$1) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len2 = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len2 - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len2 - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len2 - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len2] === 0) {
      if (len2 === max) {
        break;
      }
      len2 = lens[lens_index + work[sym]];
    }
    if (len2 > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len2 - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len2 - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
    copy -= dist;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len2;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n;
  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len2 = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len2;
          } else if (len2 > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len2 = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(input.subarray(next, next + copy), len2);
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.name += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len2 = input[next + copy++];
              if (state.head && len2 && state.length < 65536) {
                state.head.comment += String.fromCharCode(len2);
              }
            } while (len2 && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len2) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len2 = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len2 = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len2;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended)
    return false;
  if (flush_mode === ~~flush_mode)
    _flush_mode = flush_mode;
  else
    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail)
            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0)
      continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0)
      break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err)
    throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
var inflate_2 = inflate$1;
var ungzip$1 = inflate$1;
var inflate_1$1 = {
  inflate: inflate_2,
  ungzip: ungzip$1
};
var { inflate, ungzip } = inflate_1$1;
var inflate_1 = inflate;
var ungzip_1 = ungzip;
var zlib_decompress = function(buf, itemsize) {
  let input_array = new Uint8Array(buf);
  return inflate_1(input_array).buffer;
};
var unshuffle = function(buf, itemsize) {
  let buffer_size = buf.byteLength;
  let unshuffled_view = new Uint8Array(buffer_size);
  let step = Math.floor(buffer_size / itemsize);
  let shuffled_view = new DataView(buf);
  for (var j = 0; j < itemsize; j++) {
    for (var i = 0; i < step; i++) {
      unshuffled_view[j + i * itemsize] = shuffled_view.getUint8(j * step + i);
    }
  }
  return unshuffled_view.buffer;
};
var fletch32 = function(buf, itemsize) {
  _verify_fletcher32(buf);
  return buf.slice(0, -4);
};
function _verify_fletcher32(chunk_buffer) {
  var odd_chunk_buffer = chunk_buffer.byteLength % 2 != 0;
  var data_length = chunk_buffer.byteLength - 4;
  var view = new DataView(chunk_buffer);
  var sum1 = 0;
  var sum2 = 0;
  for (var offset2 = 0; offset2 < data_length - 1; offset2 += 2) {
    let datum = view.getUint16(offset2, true);
    sum1 = (sum1 + datum) % 65535;
    sum2 = (sum2 + sum1) % 65535;
  }
  if (odd_chunk_buffer) {
    let datum = view.getUint8(data_length - 1);
    sum1 = (sum1 + datum) % 65535;
    sum2 = (sum2 + sum1) % 65535;
  }
  var [ref_sum1, ref_sum2] = struct.unpack_from(">HH", chunk_buffer, data_length);
  ref_sum1 = ref_sum1 % 65535;
  ref_sum2 = ref_sum2 % 65535;
  if (sum1 != ref_sum1 || sum2 != ref_sum2) {
    throw 'ValueError("fletcher32 checksum invalid")';
  }
  return true;
}
var GZIP_DEFLATE_FILTER = 1;
var SHUFFLE_FILTER = 2;
var FLETCH32_FILTER = 3;
var Filters = /* @__PURE__ */ new Map([
  [GZIP_DEFLATE_FILTER, zlib_decompress],
  [SHUFFLE_FILTER, unshuffle],
  [FLETCH32_FILTER, fletch32]
]);
var AbstractBTree = class {
  constructor(fh, offset2) {
    this.fh = fh;
    this.offset = offset2;
    this.depth = null;
  }
  async init() {
    this.all_nodes = /* @__PURE__ */ new Map();
    await this._read_root_node();
    await this._read_children();
  }
  async _read_children() {
    let node_level = this.depth;
    while (node_level > 0) {
      for (var parent_node of this.all_nodes.get(node_level)) {
        for (var child_addr of parent_node.get("addresses")) {
          this._add_node(await this._read_node(child_addr, node_level - 1));
        }
      }
      node_level--;
    }
  }
  async _read_root_node() {
    let root_node = await this._read_node(this.offset, null);
    this._add_node(root_node);
    this.depth = root_node.get("node_level");
  }
  _add_node(node) {
    let node_level = node.get("node_level");
    if (this.all_nodes.has(node_level)) {
      this.all_nodes.get(node_level).push(node);
    } else {
      this.all_nodes.set(node_level, [node]);
    }
  }
  async _read_node(offset2, node_level) {
    let node = await this._read_node_header(offset2, node_level);
    node.set("keys", []);
    node.set("addresses", []);
    return node;
  }
  async _read_node_header(offset2) {
    throw "NotImplementedError: must define _read_node_header in implementation class";
  }
};
var BTreeV1 = class extends AbstractBTree {
  constructor() {
    super(...arguments);
    __publicField(this, "B_LINK_NODE", /* @__PURE__ */ new Map([
      ["signature", "4s"],
      ["node_type", "B"],
      ["node_level", "B"],
      ["entries_used", "H"],
      ["left_sibling", "Q"],
      ["right_sibling", "Q"]
    ]));
  }
  async _read_node_header(offset2, node_level) {
    let node = await _unpack_struct_from_async(this.B_LINK_NODE, this.fh, offset2);
    if (node_level != null) {
      if (node.get("node_level") != node_level) {
        throw "node level does not match";
      }
    }
    return node;
  }
};
var BTreeV1Groups = class extends BTreeV1 {
  constructor(fh, offset2) {
    super(fh, offset2);
    __publicField(this, "NODE_TYPE", 0);
    this.ready = this.init();
  }
  async _read_node(offset2, node_level) {
    let node = await this._read_node_header(offset2, node_level);
    offset2 += _structure_size(this.B_LINK_NODE);
    let keys = [];
    let addresses = [];
    let entries_used = node.get("entries_used");
    for (var i = 0; i < entries_used; i++) {
      let key = (await struct.unpack_from_async("<Q", this.fh, offset2))[0];
      offset2 += 8;
      let address = (await struct.unpack_from_async("<Q", this.fh, offset2))[0];
      offset2 += 8;
      keys.push(key);
      addresses.push(address);
    }
    keys.push((await struct.unpack_from_async("<Q", this.fh, offset2))[0]);
    node.set("keys", keys);
    node.set("addresses", addresses);
    return node;
  }
  symbol_table_addresses() {
    var all_address = [];
    var root_nodes = this.all_nodes.get(0);
    for (var node of root_nodes) {
      all_address = all_address.concat(node.get("addresses"));
    }
    return all_address;
  }
};
var BTreeV1RawDataChunks = class extends BTreeV1 {
  constructor(fh, offset2, dims) {
    super(fh, offset2);
    __publicField(this, "NODE_TYPE", 1);
    this.dims = dims;
    this.ready = this.init();
  }
  async _read_node(offset2, node_level) {
    let node = await this._read_node_header(offset2, node_level);
    offset2 += _structure_size(this.B_LINK_NODE);
    var keys = [];
    var addresses = [];
    let entries_used = node.get("entries_used");
    for (var i = 0; i < entries_used; i++) {
      let [chunk_size, filter_mask] = await struct.unpack_from_async("<II", this.fh, offset2);
      offset2 += 8;
      let fmt = "<" + this.dims.toFixed() + "Q";
      let fmt_size = struct.calcsize(fmt);
      let chunk_offset = await struct.unpack_from_async(fmt, this.fh, offset2);
      offset2 += fmt_size;
      let chunk_address = (await struct.unpack_from_async("<Q", this.fh, offset2))[0];
      offset2 += 8;
      keys.push(/* @__PURE__ */ new Map([
        ["chunk_size", chunk_size],
        ["filter_mask", filter_mask],
        ["chunk_offset", chunk_offset]
      ]));
      addresses.push(chunk_address);
    }
    node.set("keys", keys);
    node.set("addresses", addresses);
    return node;
  }
  async construct_data_from_chunks(chunk_shape, data_shape, dtype, filter_pipeline) {
    var item_getter, item_big_endian, item_size;
    if (dtype instanceof Array) {
      let dtype_class = dtype[0];
      if (dtype_class == "REFERENCE") {
        let size = dtype[1];
        if (size != 8) {
          throw "NotImplementedError('Unsupported Reference type')";
        }
        dtype = "<u8";
        item_getter = "getUint64";
        item_big_endian = false;
        item_size = 8;
      } else if (dtype_class == "VLEN_STRING" || dtype_class == "VLEN_SEQUENCE") {
        item_getter = "getVLENStruct";
        item_big_endian = false;
        item_size = 16;
      } else {
        throw "NotImplementedError('datatype not implemented')";
      }
    } else {
      [item_getter, item_big_endian, item_size] = dtype_getter(dtype);
    }
    var data_size = data_shape.reduce(function(a, b) {
      return a * b;
    }, 1);
    var chunk_size = chunk_shape.reduce(function(a, b) {
      return a * b;
    }, 1);
    let dims = data_shape.length;
    var current_stride = 1;
    chunk_shape.slice().map(function(d2) {
      let s = current_stride;
      current_stride *= d2;
      return s;
    });
    var current_stride = 1;
    var data_strides = data_shape.slice().reverse().map(function(d2) {
      let s = current_stride;
      current_stride *= d2;
      return s;
    }).reverse();
    var data = new Array(data_size);
    let chunk_buffer_size = chunk_size * item_size;
    for (var node of this.all_nodes.get(0)) {
      let node_keys = node.get("keys");
      let node_addresses = node.get("addresses");
      let nkeys = node_keys.length;
      for (var ik = 0; ik < nkeys; ik++) {
        let node_key = node_keys[ik];
        let addr = node_addresses[ik];
        var chunk_buffer;
        if (filter_pipeline == null) {
          chunk_buffer = await this.fh.slice(addr, addr + chunk_buffer_size);
        } else {
          chunk_buffer = await this.fh.slice(addr, addr + node_key.get("chunk_size"));
          let filter_mask = node_key.get("filter_mask");
          chunk_buffer = this._filter_chunk(chunk_buffer, filter_mask, filter_pipeline, item_size);
        }
        var chunk_offset = node_key.get("chunk_offset").slice();
        var apos = chunk_offset.slice();
        var cpos = apos.map(function() {
          return 0;
        });
        var cview = new DataView64(chunk_buffer);
        for (var ci = 0; ci < chunk_size; ci++) {
          for (var d = dims - 1; d >= 0; d--) {
            if (cpos[d] >= chunk_shape[d]) {
              cpos[d] = 0;
              apos[d] = chunk_offset[d];
              if (d > 0) {
                cpos[d - 1] += 1;
                apos[d - 1] += 1;
              }
            } else {
              break;
            }
          }
          let inbounds = apos.slice(0, -1).every(function(p, d2) {
            return p < data_shape[d2];
          });
          if (inbounds) {
            let cb_offset = ci * item_size;
            let datum = cview[item_getter](cb_offset, !item_big_endian, item_size);
            let ai = apos.slice(0, -1).reduce(function(prev, curr, index2) {
              return curr * data_strides[index2] + prev;
            }, 0);
            data[ai] = datum;
          }
          cpos[dims - 1] += 1;
          apos[dims - 1] += 1;
        }
      }
    }
    return data;
  }
  _filter_chunk(chunk_buffer, filter_mask, filter_pipeline, itemsize) {
    let num_filters = filter_pipeline.length;
    let buf = chunk_buffer.slice();
    for (var filter_index = num_filters - 1; filter_index >= 0; filter_index--) {
      if (filter_mask & 1 << filter_index) {
        continue;
      }
      let pipeline_entry = filter_pipeline[filter_index];
      let filter_id = pipeline_entry.get("filter_id");
      let client_data = pipeline_entry.get("client_data");
      if (Filters.has(filter_id)) {
        buf = Filters.get(filter_id)(buf, itemsize, client_data);
      } else {
        throw 'NotImplementedError("Filter with id:' + filter_id.toFixed() + ' not supported")';
      }
    }
    return buf;
  }
};
var BTreeV2 = class extends AbstractBTree {
  constructor(fh, offset2) {
    super(fh, offset2);
    __publicField(this, "B_TREE_HEADER", /* @__PURE__ */ new Map([
      ["signature", "4s"],
      ["version", "B"],
      ["node_type", "B"],
      ["node_size", "I"],
      ["record_size", "H"],
      ["depth", "H"],
      ["split_percent", "B"],
      ["merge_percent", "B"],
      ["root_address", "Q"],
      ["root_nrecords", "H"],
      ["total_nrecords", "Q"]
    ]));
    __publicField(this, "B_LINK_NODE", /* @__PURE__ */ new Map([
      ["signature", "4s"],
      ["version", "B"],
      ["node_type", "B"]
    ]));
    this.ready = this.init();
  }
  async _read_root_node() {
    let h = await this._read_tree_header(this.offset);
    this.address_formats = this._calculate_address_formats(h);
    this.header = h;
    this.depth = h.get("depth");
    let address = [h.get("root_address"), h.get("root_nrecords"), h.get("total_nrecords")];
    let root_node = await this._read_node(address, this.depth);
    this._add_node(root_node);
  }
  async _read_tree_header(offset2) {
    let header = await _unpack_struct_from_async(this.B_TREE_HEADER, this.fh, this.offset);
    return header;
  }
  _calculate_address_formats(header) {
    let node_size = header.get("node_size");
    let record_size = header.get("record_size");
    let nrecords_max = 0;
    let ntotalrecords_max = 0;
    let address_formats = /* @__PURE__ */ new Map();
    let max_depth = header.get("depth");
    for (var node_level = 0; node_level <= max_depth; node_level++) {
      let offset_fmt = "";
      let num1_fmt = "";
      let num2_fmt = "";
      let offset_size, num1_size, num2_size;
      if (node_level == 0) {
        offset_size = 0;
        num1_size = 0;
        num2_size = 0;
      } else if (node_level == 1) {
        offset_size = 8;
        offset_fmt = "<Q";
        num1_size = this._required_bytes(nrecords_max);
        num1_fmt = this._int_format(num1_size);
        num2_size = 0;
      } else {
        offset_size = 8;
        offset_fmt = "<Q";
        num1_size = this._required_bytes(nrecords_max);
        num1_fmt = this._int_format(num1_size);
        num2_size = this._required_bytes(ntotalrecords_max);
        num2_fmt = this._int_format(num2_size);
      }
      address_formats.set(node_level, [
        offset_size,
        num1_size,
        num2_size,
        offset_fmt,
        num1_fmt,
        num2_fmt
      ]);
      if (node_level < max_depth) {
        let addr_size = offset_size + num1_size + num2_size;
        nrecords_max = this._nrecords_max(node_size, record_size, addr_size);
        if (ntotalrecords_max > 0) {
          ntotalrecords_max *= nrecords_max;
        } else {
          ntotalrecords_max = nrecords_max;
        }
      }
    }
    return address_formats;
  }
  _nrecords_max(node_size, record_size, addr_size) {
    return Math.floor((node_size - 10 - addr_size) / (record_size + addr_size));
  }
  _required_bytes(integer) {
    return Math.ceil(bitSize(integer) / 8);
  }
  _int_format(bytelength) {
    return ["<B", "<H", "<I", "<Q"][bytelength - 1];
  }
  async _read_node(address, node_level) {
    let [offset2, nrecords, ntotalrecords] = address;
    let node = this._read_node_header(offset2, node_level);
    offset2 += _structure_size(this.B_LINK_NODE);
    let record_size = this.header.get("record_size");
    let keys = [];
    for (let i = 0; i < nrecords; i++) {
      let record = await this._parse_record(this.fh, offset2, record_size);
      offset2 += record_size;
      keys.push(record);
    }
    let addresses = [];
    let fmts = this.address_formats.get(node_level);
    if (node_level != 0) {
      let [offset_size, num1_size, num2_size, offset_fmt, num1_fmt, num2_fmt] = fmts;
      for (let j = 0; j <= nrecords; j++) {
        let address_offset = (await struct.unpack_from_async(offset_fmt, this.fh, offset2))[0];
        offset2 += offset_size;
        let num1 = (await struct.unpack_from_async(num1_fmt, this.fh, offset2))[0];
        offset2 += num1_size;
        let num2 = num1;
        if (num2_size > 0) {
          num2 = (await struct.unpack_from_async(num2_fmt, this.fh, offset2))[0];
          offset2 += num2_size;
        }
        addresses.push([address_offset, num1, num2]);
      }
    }
    node.set("keys", keys);
    node.set("addresses", addresses);
    return node;
  }
  async _read_node_header(offset2, node_level) {
    let node = await _unpack_struct_from_async(this.B_LINK_NODE, this.fh, offset2);
    node.set("node_level", node_level);
    return node;
  }
  *iter_records() {
    for (let nodelist of this.all_nodes.values()) {
      for (let node of nodelist) {
        for (let key of node.get("keys")) {
          yield key;
        }
      }
    }
  }
  _parse_record(record) {
    throw "NotImplementedError";
  }
};
var BTreeV2GroupNames = class extends BTreeV2 {
  constructor() {
    super(...arguments);
    __publicField(this, "NODE_TYPE", 5);
  }
  async _parse_record(buf, offset2, size) {
    let namehash = (await struct.unpack_from_async("<I", buf, offset2))[0];
    offset2 += 4;
    const heapid = await buf.slice(offset2, offset2 + 7);
    return /* @__PURE__ */ new Map([["namehash", namehash], ["heapid", heapid]]);
  }
};
var BTreeV2GroupOrders = class extends BTreeV2 {
  constructor() {
    super(...arguments);
    __publicField(this, "NODE_TYPE", 6);
  }
  async _parse_record(buf, offset2, size) {
    let creationorder = (await struct.unpack_from_async("<Q", buf, offset2))[0];
    offset2 += 8;
    const heapid = await buf.slice(offset2, offset2 + 7);
    return /* @__PURE__ */ new Map([["creationorder", creationorder], ["heapid", heapid]]);
  }
};
var SuperBlock = class {
  constructor(fh, offset2) {
    this.ready = this.init(fh, offset2);
  }
  async init(fh, offset2) {
    let version_hint = await struct.unpack_from_async("<B", fh, offset2 + 8);
    var contents;
    if (version_hint == 0) {
      contents = await _unpack_struct_from_async(SUPERBLOCK_V0, fh, offset2);
      this._end_of_sblock = offset2 + SUPERBLOCK_V0_SIZE;
    } else if (version_hint == 2 || version_hint == 3) {
      contents = await _unpack_struct_from_async(SUPERBLOCK_V2_V3, fh, offset2);
      this._end_of_sblock = offset2 + SUPERBLOCK_V2_V3_SIZE;
    } else {
      throw "unsupported superblock version: " + version_hint.toFixed();
    }
    if (contents.get("format_signature") != FORMAT_SIGNATURE) {
      throw "Incorrect file signature: " + contents.get("format_signature");
    }
    if (contents.get("offset_size") != 8 || contents.get("length_size") != 8) {
      throw "File uses non-64-bit addressing";
    }
    this.version = contents.get("superblock_version");
    this._contents = contents;
    this._root_symbol_table = null;
    this._fh = fh;
  }
  async get_offset_to_dataobjects() {
    if (this.version == 0) {
      var sym_table = new SymbolTable(this._fh, this._end_of_sblock, true);
      await sym_table.ready;
      this._root_symbol_table = sym_table;
      return sym_table.group_offset;
    } else if (this.version == 2 || this.version == 3) {
      return this._contents.get("root_group_address");
    } else {
      throw "Not implemented version = " + this.version.toFixed();
    }
  }
};
var Heap = class {
  constructor(fh, offset2) {
    this.ready = this.init(fh, offset2);
  }
  async init(fh, offset2) {
    let local_heap = await _unpack_struct_from_async(LOCAL_HEAP, fh, offset2);
    assert(local_heap.get("signature") == "HEAP");
    assert(local_heap.get("version") == 0);
    let data_offset = local_heap.get("address_of_data_segment");
    let heap_data = await fh.slice(data_offset, data_offset + local_heap.get("data_segment_size"));
    local_heap.set("heap_data", heap_data);
    this._contents = local_heap;
    this.data = heap_data;
  }
  get_object_name(offset2) {
    let end = new Uint8Array(this.data).indexOf(0, offset2);
    let name_size = end - offset2;
    let name2 = struct.unpack_from("<" + name_size.toFixed() + "s", this.data, offset2)[0];
    return name2;
  }
};
var SymbolTable = class {
  constructor(fh, offset2, root = false) {
    this.ready = this.init(fh, offset2, root);
  }
  async init(fh, offset2, root) {
    var node;
    if (root) {
      node = /* @__PURE__ */ new Map([["symbols", 1]]);
    } else {
      node = await _unpack_struct_from_async(SYMBOL_TABLE_NODE, fh, offset2);
      if (node.get("signature") != "SNOD") {
        throw "incorrect node type";
      }
      offset2 += SYMBOL_TABLE_NODE_SIZE;
    }
    var entries2 = [];
    var n_symbols = node.get("symbols");
    for (var i = 0; i < n_symbols; i++) {
      entries2.push(await _unpack_struct_from_async(SYMBOL_TABLE_ENTRY, fh, offset2));
      offset2 += SYMBOL_TABLE_ENTRY_SIZE;
    }
    if (root) {
      this.group_offset = entries2[0].get("object_header_address");
    }
    this.entries = entries2;
    this._contents = node;
    return this;
  }
  assign_name(heap) {
    this.entries.forEach(function(entry) {
      let offset2 = entry.get("link_name_offset");
      let link_name = heap.get_object_name(offset2);
      entry.set("link_name", link_name);
    });
  }
  get_links(heap) {
    var links = {};
    this.entries.forEach(function(e) {
      let cache_type = e.get("cache_type");
      let link_name = e.get("link_name");
      if (cache_type == 0 || cache_type == 1) {
        links[link_name] = e.get("object_header_address");
      } else if (cache_type == 2) {
        let scratch = e.get("scratch");
        let buf = new ArrayBuffer(4);
        let bufView = new Uint8Array(buf);
        for (var i = 0; i < 4; i++) {
          bufView[i] = scratch.charCodeAt(i);
        }
        let offset2 = struct.unpack_from("<I", buf, 0)[0];
        links[link_name] = heap.get_object_name(offset2);
      }
    });
    return links;
  }
};
var GlobalHeap = class {
  constructor(fh, offset2) {
    this.ready = this.init(fh, offset2);
  }
  async init(fh, offset2) {
    let header = await _unpack_struct_from_async(GLOBAL_HEAP_HEADER, fh, offset2);
    offset2 += GLOBAL_HEAP_HEADER_SIZE;
    let heap_data_size = header.get("collection_size") - GLOBAL_HEAP_HEADER_SIZE;
    let heap_data = await fh.slice(offset2, offset2 + heap_data_size);
    this.heap_data = heap_data;
    this._header = header;
    this._objects = null;
  }
  get objects() {
    if (this._objects == null) {
      this._objects = /* @__PURE__ */ new Map();
      var offset2 = 0;
      while (offset2 <= this.heap_data.byteLength - GLOBAL_HEAP_OBJECT_SIZE) {
        let info = _unpack_struct_from(GLOBAL_HEAP_OBJECT, this.heap_data, offset2);
        if (info.get("object_index") == 0) {
          break;
        }
        offset2 += GLOBAL_HEAP_OBJECT_SIZE;
        let obj_data = this.heap_data.slice(offset2, offset2 + info.get("object_size"));
        this._objects.set(info.get("object_index"), obj_data);
        offset2 += _padded_size(info.get("object_size"));
      }
    }
    return this._objects;
  }
};
var FractalHeap = class {
  constructor(fh, offset2) {
    this.fh = fh;
    this.ready = this.init(offset2);
  }
  async init(offset2) {
    let header = await _unpack_struct_from_async(FRACTAL_HEAP_HEADER, this.fh, offset2);
    offset2 += _structure_size(FRACTAL_HEAP_HEADER);
    assert(header.get("signature") == "FRHP");
    assert(header.get("version") == 0);
    if (header.get("filter_info_size") > 0) {
      throw "Filter info size not supported on FractalHeap";
    }
    if (header.get("btree_address_huge_objects") == UNDEFINED_ADDRESS) {
      header.set("btree_address_huge_objects", null);
    } else {
      throw "Huge objects not implemented in FractalHeap";
    }
    if (header.get("root_block_address") == UNDEFINED_ADDRESS) {
      header.set("root_block_address", null);
    }
    let nbits = header.get("log2_maximum_heap_size");
    let block_offset_size = this._min_size_nbits(nbits);
    let h = /* @__PURE__ */ new Map([
      ["signature", "4s"],
      ["version", "B"],
      ["heap_header_adddress", "Q"],
      ["block_offset", `${block_offset_size}B`]
    ]);
    this.indirect_block_header = new Map(h);
    this.indirect_block_header_size = _structure_size(h);
    if ((header.get("flags") & 2) == 2) {
      h.set("checksum", "I");
    }
    this.direct_block_header = h;
    this.direct_block_header_size = _structure_size(h);
    let maximum_dblock_size = header.get("maximum_direct_block_size");
    this._managed_object_offset_size = this._min_size_nbits(nbits);
    let value = Math.min(maximum_dblock_size, header.get("max_managed_object_size"));
    this._managed_object_length_size = this._min_size_integer(value);
    let start_block_size = header.get("starting_block_size");
    let table_width = header.get("table_width");
    if (!(start_block_size > 0)) {
      throw "Starting block size == 0 not implemented";
    }
    let log2_maximum_dblock_size = Number(Math.floor(Math.log2(maximum_dblock_size)));
    assert(1n << BigInt(log2_maximum_dblock_size) == maximum_dblock_size);
    let log2_start_block_size = Number(Math.floor(Math.log2(start_block_size)));
    assert(1n << BigInt(log2_start_block_size) == start_block_size);
    this._max_direct_nrows = log2_maximum_dblock_size - log2_start_block_size + 2;
    let log2_table_width = Math.floor(Math.log2(table_width));
    assert(1 << log2_table_width == table_width);
    this._indirect_nrows_sub = log2_table_width + log2_start_block_size - 1;
    this.header = header;
    this.nobjects = header.get("managed_object_count") + header.get("huge_object_count") + header.get("tiny_object_count");
    let managed = [];
    let root_address = header.get("root_block_address");
    let nrows = 0;
    if (root_address != null) {
      nrows = header.get("indirect_current_rows_count");
    }
    if (nrows > 0) {
      for await (let data of this._iter_indirect_block(this.fh, root_address, nrows)) {
        managed.push(data);
      }
    } else {
      let data = await this._read_direct_block(this.fh, root_address, start_block_size);
      managed.push(data);
    }
    let data_size = managed.reduce((p, c) => p + c.byteLength, 0);
    let combined = new Uint8Array(data_size);
    let moffset = 0;
    managed.forEach((m) => {
      combined.set(new Uint8Array(m), moffset);
      moffset += m.byteLength;
    });
    this.managed = combined.buffer;
  }
  async _read_direct_block(fh, offset2, block_size) {
    let data = await fh.slice(offset2, offset2 + block_size);
    let header = _unpack_struct_from(this.direct_block_header, data);
    assert(header.get("signature") == "FHDB");
    return data;
  }
  get_data(heapid) {
    let firstbyte = struct.unpack_from("<B", heapid, 0)[0];
    let idtype = firstbyte >> 4 & 3;
    let version2 = firstbyte >> 6;
    let data_offset = 1;
    if (idtype == 0) {
      assert(version2 == 0);
      let nbytes = this._managed_object_offset_size;
      let offset2 = _unpack_integer(nbytes, heapid, data_offset);
      data_offset += nbytes;
      nbytes = this._managed_object_length_size;
      let size = _unpack_integer(nbytes, heapid, data_offset);
      return this.managed.slice(offset2, offset2 + size);
    } else if (idtype == 1) {
      throw "tiny objectID not supported in FractalHeap";
    } else if (idtype == 2) {
      throw "huge objectID not supported in FractalHeap";
    } else {
      throw "unknown objectID type in FractalHeap";
    }
  }
  _min_size_integer(integer) {
    return this._min_size_nbits(bitSize(integer));
  }
  _min_size_nbits(nbits) {
    return Math.ceil(nbits / 8);
  }
  async *_iter_indirect_block(fh, offset2, nrows) {
    let header = await _unpack_struct_from_async(this.indirect_block_header, fh, offset2);
    offset2 += this.indirect_block_header_size;
    assert(header.get("signature") == "FHIB");
    let block_offset_bytes = header.get("block_offset");
    let block_offset = block_offset_bytes.reduce((p, c, i) => p + (c << i * 8), 0);
    header.set("block_offset", block_offset);
    let [ndirect, nindirect] = this._indirect_info(nrows);
    let direct_blocks = [];
    for (let i = 0; i < ndirect; i++) {
      let address = (await struct.unpack_from_async("<Q", fh, offset2))[0];
      offset2 += 8;
      if (address == UNDEFINED_ADDRESS) {
        break;
      }
      let block_size = this._calc_block_size(i);
      direct_blocks.push([address, block_size]);
    }
    let indirect_blocks = [];
    for (let i = ndirect; i < ndirect + nindirect; i++) {
      let address = (await struct.unpack_from_async("<Q", fh, offset2))[0];
      offset2 += 8;
      if (address == UNDEFINED_ADDRESS) {
        break;
      }
      let block_size = this._calc_block_size(i);
      let nrows2 = this._iblock_nrows_from_block_size(block_size);
      indirect_blocks.push([address, nrows2]);
    }
    for (let [address, block_size] of direct_blocks) {
      let obj = await this._read_direct_block(fh, address, block_size);
      yield obj;
    }
    for (let [address, nrows2] of indirect_blocks) {
      for await (let obj of this._iter_indirect_block(fh, address, nrows2)) {
        yield obj;
      }
    }
  }
  _calc_block_size(iblock) {
    let row = Math.floor(iblock / this.header.get("table_width"));
    return 2 ** Math.max(row - 1, 0) * this.header.get("starting_block_size");
  }
  _iblock_nrows_from_block_size(block_size) {
    let log2_block_size = Math.floor(Math.log2(block_size));
    assert(2 ** log2_block_size == block_size);
    return log2_block_size - this._indirect_nrows_sub;
  }
  _indirect_info(nrows) {
    let table_width = this.header.get("table_width");
    let nobjects = nrows * table_width;
    let ndirect_max = this._max_direct_nrows * table_width;
    let ndirect, nindirect;
    if (nrows <= ndirect_max) {
      ndirect = nobjects;
      nindirect = 0;
    } else {
      ndirect = ndirect_max;
      nindirect = nobjects - ndirect_max;
    }
    return [ndirect, nindirect];
  }
  _int_format(bytelength) {
    return ["B", "H", "I", "Q"][bytelength - 1];
  }
};
var FORMAT_SIGNATURE = struct.unpack_from("8s", new Uint8Array([137, 72, 68, 70, 13, 10, 26, 10]).buffer)[0];
var UNDEFINED_ADDRESS = struct.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer)[0];
var SUPERBLOCK_V0 = /* @__PURE__ */ new Map([
  ["format_signature", "8s"],
  ["superblock_version", "B"],
  ["free_storage_version", "B"],
  ["root_group_version", "B"],
  ["reserved_0", "B"],
  ["shared_header_version", "B"],
  ["offset_size", "B"],
  ["length_size", "B"],
  ["reserved_1", "B"],
  ["group_leaf_node_k", "H"],
  ["group_internal_node_k", "H"],
  ["file_consistency_flags", "L"],
  ["base_address_lower", "Q"],
  ["free_space_address", "Q"],
  ["end_of_file_address", "Q"],
  ["driver_information_address", "Q"]
]);
var SUPERBLOCK_V0_SIZE = _structure_size(SUPERBLOCK_V0);
var SUPERBLOCK_V2_V3 = /* @__PURE__ */ new Map([
  ["format_signature", "8s"],
  ["superblock_version", "B"],
  ["offset_size", "B"],
  ["length_size", "B"],
  ["file_consistency_flags", "B"],
  ["base_address", "Q"],
  ["superblock_extension_address", "Q"],
  ["end_of_file_address", "Q"],
  ["root_group_address", "Q"],
  ["superblock_checksum", "I"]
]);
var SUPERBLOCK_V2_V3_SIZE = _structure_size(SUPERBLOCK_V2_V3);
var SYMBOL_TABLE_ENTRY = /* @__PURE__ */ new Map([
  ["link_name_offset", "Q"],
  ["object_header_address", "Q"],
  ["cache_type", "I"],
  ["reserved", "I"],
  ["scratch", "16s"]
]);
var SYMBOL_TABLE_ENTRY_SIZE = _structure_size(SYMBOL_TABLE_ENTRY);
var SYMBOL_TABLE_NODE = /* @__PURE__ */ new Map([
  ["signature", "4s"],
  ["version", "B"],
  ["reserved_0", "B"],
  ["symbols", "H"]
]);
var SYMBOL_TABLE_NODE_SIZE = _structure_size(SYMBOL_TABLE_NODE);
var LOCAL_HEAP = /* @__PURE__ */ new Map([
  ["signature", "4s"],
  ["version", "B"],
  ["reserved", "3s"],
  ["data_segment_size", "Q"],
  ["offset_to_free_list", "Q"],
  ["address_of_data_segment", "Q"]
]);
var GLOBAL_HEAP_HEADER = /* @__PURE__ */ new Map([
  ["signature", "4s"],
  ["version", "B"],
  ["reserved", "3s"],
  ["collection_size", "Q"]
]);
var GLOBAL_HEAP_HEADER_SIZE = _structure_size(GLOBAL_HEAP_HEADER);
var GLOBAL_HEAP_OBJECT = /* @__PURE__ */ new Map([
  ["object_index", "H"],
  ["reference_count", "H"],
  ["reserved", "I"],
  ["object_size", "Q"]
]);
var GLOBAL_HEAP_OBJECT_SIZE = _structure_size(GLOBAL_HEAP_OBJECT);
var FRACTAL_HEAP_HEADER = /* @__PURE__ */ new Map([
  ["signature", "4s"],
  ["version", "B"],
  ["object_index_size", "H"],
  ["filter_info_size", "H"],
  ["flags", "B"],
  ["max_managed_object_size", "I"],
  ["next_huge_object_index", "Q"],
  ["btree_address_huge_objects", "Q"],
  ["managed_freespace_size", "Q"],
  ["freespace_manager_address", "Q"],
  ["managed_space_size", "Q"],
  ["managed_alloc_size", "Q"],
  ["next_directblock_iterator_address", "Q"],
  ["managed_object_count", "Q"],
  ["huge_objects_total_size", "Q"],
  ["huge_object_count", "Q"],
  ["tiny_objects_total_size", "Q"],
  ["tiny_object_count", "Q"],
  ["table_width", "H"],
  ["starting_block_size", "Q"],
  ["maximum_direct_block_size", "Q"],
  ["log2_maximum_heap_size", "H"],
  ["indirect_starting_rows_count", "H"],
  ["root_block_address", "Q"],
  ["indirect_current_rows_count", "H"]
]);
var DataObjects = class {
  constructor(fh, offset2) {
    this.ready = this.init(fh, offset2);
  }
  async init(fh, offset2) {
    let version_hint = (await struct.unpack_from_async("<B", fh, offset2))[0];
    if (version_hint == 1) {
      var [msgs, msg_data, header] = await this._parse_v1_objects(fh, offset2);
    } else if (version_hint == "O".charCodeAt(0)) {
      var [msgs, msg_data, header] = await this._parse_v2_objects(fh, offset2);
    } else {
      throw "InvalidHDF5File('unknown Data Object Header')";
    }
    this.fh = fh;
    this.msgs = msgs;
    this.msg_data = msg_data;
    this.offset = offset2;
    this._global_heaps = {};
    this._header = header;
    this._filter_pipeline = null;
    this._chunk_params_set = false;
    this._chunks = null;
    this._chunk_dims = null;
    this._chunk_address = null;
  }
  get dtype() {
    let msg = this.find_msg_type(DATATYPE_MSG_TYPE)[0];
    let msg_offset = msg.get("offset_to_message");
    return new DatatypeMessage(this.fh, msg_offset).dtype;
  }
  get chunks() {
    return this._get_chunk_params().then(() => {
      return this._chunks;
    });
  }
  get shape() {
    let msg = this.find_msg_type(DATASPACE_MSG_TYPE)[0];
    let msg_offset = msg.get("offset_to_message");
    return determine_data_shape(this.fh, msg_offset);
  }
  async get_filter_pipeline() {
    if (this._filter_pipeline != null) {
      return this._filter_pipeline;
    }
    let filter_msgs = this.find_msg_type(DATA_STORAGE_FILTER_PIPELINE_MSG_TYPE);
    if (!filter_msgs.length) {
      this._filter_pipeline = null;
      return this._filter_pipeline;
    }
    var offset2 = filter_msgs[0].get("offset_to_message");
    let [version2, nfilters] = await struct.unpack_from_async("<BB", this.fh, offset2);
    offset2 += struct.calcsize("<BB");
    var filters = [];
    if (version2 == 1) {
      await struct.unpack_from_async("<HI", this.fh, offset2);
      offset2 += struct.calcsize("<HI");
      for (var _ = 0; _ < nfilters; _++) {
        let filter_info = await _unpack_struct_from_async(FILTER_PIPELINE_DESCR_V1, this.fh, offset2);
        offset2 += FILTER_PIPELINE_DESCR_V1_SIZE;
        let padded_name_length = _padded_size(filter_info.get("name_length"), 8);
        let fmt = "<" + padded_name_length.toFixed() + "s";
        let filter_name = (await struct.unpack_from_async(fmt, this.fh, offset2))[0];
        filter_info.set("filter_name", filter_name);
        offset2 += padded_name_length;
        fmt = "<" + filter_info.get("client_data_values").toFixed() + "I";
        let client_data = await struct.unpack_from_async(fmt, this.fh, offset2);
        filter_info.set("client_data", client_data);
        offset2 += 4 * filter_info.get("client_data_values");
        if (filter_info.get("client_data_values") % 2) {
          offset2 += 4;
        }
        filters.push(filter_info);
      }
    } else if (version2 == 2) {
      for (let nf = 0; nf < nfilters; nf++) {
        let filter_info = /* @__PURE__ */ new Map();
        let buf = this.fh;
        let filter_id = (await struct.unpack_from_async("<H", buf, offset2))[0];
        offset2 += 2;
        filter_info.set("filter_id", filter_id);
        let name_length = 0;
        if (filter_id > 255) {
          name_length = (await struct.unpack_from_async("<H", buf, offset2))[0];
          offset2 += 2;
        }
        let flags = (await struct.unpack_from_async("<H", buf, offset2))[0];
        offset2 += 2;
        let optional = (flags & 1) > 0;
        filter_info.set("optional", optional);
        let num_client_values = (await struct.unpack_from_async("<H", buf, offset2))[0];
        offset2 += 2;
        let name2;
        if (name_length > 0) {
          name2 = (await struct.unpack_from_async(`${name_length}s`, buf, offset2))[0];
          offset2 += name_length;
        }
        filter_info.set("name", name2);
        let client_values = await struct.unpack_from_async(`<${num_client_values}i`, buf, offset2);
        offset2 += 4 * num_client_values;
        filter_info.set("client_data_values", client_values);
        filters.push(filter_info);
      }
    } else {
      throw `version ${version2} is not supported`;
    }
    this._filter_pipeline = filters;
    return this._filter_pipeline;
  }
  find_msg_type(msg_type) {
    return this.msgs.filter(function(m) {
      return m.get("type") == msg_type;
    });
  }
  async get_attributes() {
    let attrs = {};
    let attr_msgs = this.find_msg_type(ATTRIBUTE_MSG_TYPE);
    for (let msg of attr_msgs) {
      let offset2 = msg.get("offset_to_message");
      let [name2, value] = await this.unpack_attribute(offset2);
      attrs[name2] = value;
    }
    return attrs;
  }
  async get_fillvalue() {
    let msg = this.find_msg_type(FILLVALUE_MSG_TYPE)[0];
    var offset2 = msg.get("offset_to_message");
    var is_defined;
    let version2 = (await struct.unpack_from_async("<B", this.fh, offset2))[0];
    var info, size, fillvalue;
    if (version2 == 1 || version2 == 2) {
      info = await _unpack_struct_from_async(FILLVAL_MSG_V1V2, this.fh, offset2);
      offset2 += FILLVAL_MSG_V1V2_SIZE;
      is_defined = info.get("fillvalue_defined");
    } else if (version2 == 3) {
      info = await _unpack_struct_from_async(FILLVAL_MSG_V3, this.fh, offset2);
      offset2 += FILLVAL_MSG_V3_SIZE;
      is_defined = info.get("flags") & 32;
    } else {
      throw 'InvalidHDF5File("Unknown fillvalue msg version: "' + String(version2);
    }
    if (is_defined) {
      size = (await struct.unpack_from_async("<I", this.fh, offset2))[0];
      offset2 += 4;
    } else {
      size = 0;
    }
    if (size) {
      let [getter, big_endian, size2] = dtype_getter(await this.dtype);
      let payload_view = new DataView64(await this.fh.slice(offset2, offset2 + size2));
      fillvalue = payload_view[getter](offset2, !big_endian, size2);
    } else {
      fillvalue = 0;
    }
    return fillvalue;
  }
  async unpack_attribute(offset2) {
    let version2 = (await struct.unpack_from_async("<B", this.fh, offset2))[0];
    var attr_map, padding_multiple;
    if (version2 == 1) {
      attr_map = await _unpack_struct_from_async(ATTR_MSG_HEADER_V1, this.fh, offset2);
      assert(attr_map.get("version") == 1);
      offset2 += ATTR_MSG_HEADER_V1_SIZE;
      padding_multiple = 8;
    } else if (version2 == 3) {
      attr_map = await _unpack_struct_from_async(ATTR_MSG_HEADER_V3, this.fh, offset2);
      assert(attr_map.get("version") == 3);
      offset2 += ATTR_MSG_HEADER_V3_SIZE;
      padding_multiple = 1;
    } else {
      throw "unsupported attribute message version: " + version2;
    }
    let name_size = attr_map.get("name_size");
    let name2 = (await struct.unpack_from_async("<" + name_size.toFixed() + "s", this.fh, offset2))[0];
    name2 = name2.replace(/\x00$/, "");
    offset2 += _padded_size(name_size, padding_multiple);
    var dtype;
    try {
      dtype = await new DatatypeMessage(this.fh, offset2).dtype;
    } catch (e) {
      console.warn("Attribute " + name2 + " type not implemented, set to null.");
      return [name2, null];
    }
    offset2 += _padded_size(attr_map.get("datatype_size"), padding_multiple);
    let shape = await this.determine_data_shape(this.fh, offset2);
    let items = shape.reduce(function(a, b) {
      return a * b;
    }, 1);
    offset2 += _padded_size(attr_map.get("dataspace_size"), padding_multiple);
    if (dtype.datatype_class === 5) {
      value = await this.fh.slice(offset2, offset2 + dtype.size);
    } else {
      var value = await this._attr_value(dtype, this.fh, items, offset2);
      if (shape.length == 0) {
        value = value[0];
      }
    }
    return [name2, value];
  }
  async determine_data_shape(buf, offset2) {
    let version2 = (await struct.unpack_from_async("<B", buf, offset2))[0];
    var header;
    if (version2 == 1) {
      header = await _unpack_struct_from_async(DATASPACE_MSG_HEADER_V1, buf, offset2);
      assert(header.get("version") == 1);
      offset2 += DATASPACE_MSG_HEADER_V1_SIZE;
    } else if (version2 == 2) {
      header = await _unpack_struct_from_async(DATASPACE_MSG_HEADER_V2, buf, offset2);
      assert(header.get("version") == 2);
      offset2 += DATASPACE_MSG_HEADER_V2_SIZE;
    } else {
      throw "unknown dataspace message version";
    }
    let ndims = header.get("dimensionality");
    let dim_sizes = await struct.unpack_from_async("<" + ndims.toFixed() + "Q", buf, offset2);
    return dim_sizes;
  }
  async _attr_value(dtype, buf, count, offset2) {
    var value = new Array(count);
    if (dtype instanceof Array) {
      let dtype_class = dtype[0];
      for (var i = 0; i < count; i++) {
        if (dtype_class == "VLEN_STRING") {
          let character_set = dtype[2];
          var [vlen, vlen_data] = await this._vlen_size_and_data(buf, offset2);
          const encoding = character_set == 0 ? "ascii" : "utf-8";
          const decoder = new TextDecoder(encoding);
          value[i] = decoder.decode(vlen_data);
          offset2 += 16;
        } else if (dtype_class == "REFERENCE") {
          var address = await struct.unpack_from_async("<Q", buf, offset2);
          value[i] = address;
          offset2 += 8;
        } else if (dtype_class == "VLEN_SEQUENCE") {
          let base_dtype = dtype[1];
          var [vlen, vlen_data] = this._vlen_size_and_data(buf, offset2);
          value[i] = this._attr_value(base_dtype, vlen_data, vlen, 0);
          offset2 += 16;
        } else {
          throw "NotImplementedError";
        }
      }
    } else {
      let [getter, big_endian, size] = dtype_getter(dtype);
      const arrayBuffer = await buf.slice(offset2, offset2 + count * size);
      let view = new DataView64(arrayBuffer, 0);
      let bufferOffset = 0;
      for (var i = 0; i < count; i++) {
        value[i] = view[getter](bufferOffset, !big_endian, size);
        bufferOffset += size;
      }
    }
    return value;
  }
  async _vlen_size_and_data(buf, offset2) {
    let vlen_size = (await struct.unpack_from_async("<I", buf, offset2))[0];
    let gheap_id = await _unpack_struct_from_async(GLOBAL_HEAP_ID, buf, offset2 + 4);
    let gheap_address = gheap_id.get("collection_address");
    assert(gheap_id.get("collection_address") < Number.MAX_SAFE_INTEGER);
    var gheap;
    if (!(gheap_address in this._global_heaps)) {
      gheap = new GlobalHeap(this.fh, gheap_address);
      await gheap.ready;
      this._global_heaps[gheap_address] = gheap;
    }
    gheap = this._global_heaps[gheap_address];
    let vlen_data = gheap.objects.get(gheap_id.get("object_index"));
    return [vlen_size, vlen_data];
  }
  async _parse_v1_objects(fh, offset2) {
    let header = await _unpack_struct_from_async(OBJECT_HEADER_V1, fh, offset2);
    assert(header.get("version") == 1);
    let total_header_messages = header.get("total_header_messages");
    var block_size = header.get("object_header_size");
    var block_offset = offset2 + _structure_size(OBJECT_HEADER_V1);
    var msg_data = await fh.slice(block_offset, block_offset + block_size);
    var object_header_blocks = [[block_offset, block_size]];
    var current_block = 0;
    var local_offset = 0;
    var msgs = new Array(total_header_messages);
    for (var i = 0; i < total_header_messages; i++) {
      if (local_offset >= block_size) {
        [block_offset, block_size] = object_header_blocks[++current_block];
        local_offset = 0;
      }
      let msg = await _unpack_struct_from_async(HEADER_MSG_INFO_V1, fh, block_offset + local_offset);
      let offset_to_message = block_offset + local_offset + HEADER_MSG_INFO_V1_SIZE;
      msg.set("offset_to_message", offset_to_message);
      if (msg.get("type") == OBJECT_CONTINUATION_MSG_TYPE) {
        var [fh_off, size] = await struct.unpack_from_async("<QQ", fh, offset_to_message);
        object_header_blocks.push([fh_off, size]);
      }
      local_offset += HEADER_MSG_INFO_V1_SIZE + msg.get("size");
      msgs[i] = msg;
    }
    return [msgs, msg_data, header];
  }
  async _parse_v2_objects(buf, offset2) {
    var [header, creation_order_size, block_offset] = await this._parse_v2_header(buf, offset2);
    offset2 = block_offset;
    var msgs = [];
    var block_size = header.get("size_of_chunk_0");
    var msg_data = buf.slice(offset2, offset2 += block_size);
    var object_header_blocks = [[block_offset, block_size]];
    var current_block = 0;
    var local_offset = 0;
    while (true) {
      if (local_offset >= block_size - HEADER_MSG_INFO_V2_SIZE) {
        let next_block = object_header_blocks[++current_block];
        if (next_block == null) {
          break;
        }
        [block_offset, block_size] = next_block;
        local_offset = 0;
      }
      let msg = await _unpack_struct_from_async(HEADER_MSG_INFO_V2, buf, block_offset + local_offset);
      let offset_to_message = block_offset + local_offset + HEADER_MSG_INFO_V2_SIZE + creation_order_size;
      msg.set("offset_to_message", offset_to_message);
      if (msg.get("type") == OBJECT_CONTINUATION_MSG_TYPE) {
        var [fh_off, size] = await struct.unpack_from_async("<QQ", buf, offset_to_message);
        object_header_blocks.push([fh_off + 4, size - 4]);
      }
      local_offset += HEADER_MSG_INFO_V2_SIZE + msg.get("size") + creation_order_size;
      msgs.push(msg);
    }
    return [msgs, msg_data, header];
  }
  async _parse_v2_header(buf, offset2) {
    let header = await _unpack_struct_from_async(OBJECT_HEADER_V2, buf, offset2);
    var creation_order_size;
    offset2 += _structure_size(OBJECT_HEADER_V2);
    assert(header.get("version") == 2);
    if (header.get("flags") & 4) {
      creation_order_size = 2;
    } else {
      creation_order_size = 0;
    }
    assert((header.get("flags") & 16) == 0);
    if (header.get("flags") & 32) {
      let times = await struct.unpack_from_async("<4I", buf, offset2);
      offset2 += 16;
      header.set("access_time", times[0]);
      header.set("modification_time", times[1]);
      header.set("change_time", times[2]);
      header.set("birth_time", times[3]);
    }
    let chunk_fmt = ["<B", "<H", "<I", "<Q"][header.get("flags") & 3];
    header.set("size_of_chunk_0", (await struct.unpack_from_async(chunk_fmt, buf, offset2))[0]);
    offset2 += struct.calcsize(chunk_fmt);
    return [header, creation_order_size, offset2];
  }
  async find_link(name2) {
    if (this._links) {
      for (link of this._links) {
        if (name2 === link[0]) {
          return link;
        }
      }
    } else {
      const links = [];
      for await (const link2 of this.iter_links()) {
        if (name2 === link2[0]) {
          return link2;
        }
        links.push(link2);
      }
      this._links = links;
    }
    return void 0;
  }
  async get_links() {
    const links = [];
    for await (const link2 of this.iter_links()) {
      links.push(link2);
    }
    return Object.fromEntries(links);
  }
  async *iter_links() {
    for (let msg of this.msgs) {
      if (msg.get("type") == SYMBOL_TABLE_MSG_TYPE) {
        yield* this._iter_links_from_symbol_tables(msg);
      } else if (msg.get("type") == LINK_MSG_TYPE) {
        yield this._get_link_from_link_msg(msg);
      } else if (msg.get("type") == LINK_INFO_MSG_TYPE) {
        yield* this._iter_link_from_link_info_msg(msg);
      }
    }
  }
  async *_iter_links_from_symbol_tables(sym_tbl_msg) {
    assert(sym_tbl_msg.get("size") == 16);
    let data = await _unpack_struct_from_async(SYMBOL_TABLE_MSG, this.fh, sym_tbl_msg.get("offset_to_message"));
    yield* this._iter_links_btree_v1(data.get("btree_address"), data.get("heap_address"));
  }
  async *_iter_links_btree_v1(btree_address, heap_address) {
    let btree = new BTreeV1Groups(this.fh, btree_address);
    await btree.ready;
    let heap = new Heap(this.fh, heap_address);
    await heap.ready;
    for (let symbol_table_address of btree.symbol_table_addresses()) {
      let table = new SymbolTable(this.fh, symbol_table_address);
      await table.ready;
      table.assign_name(heap);
      yield* Object.entries(table.get_links(heap));
    }
  }
  async _get_link_from_link_msg(link_msg) {
    let offset2 = link_msg.get("offset_to_message");
    return await this._decode_link_msg(this.fh, offset2)[1];
  }
  async _decode_link_msg(data, offset2) {
    let [version2, flags] = await struct.unpack_from_async("<BB", data, offset2);
    offset2 += 2;
    assert(version2 == 1);
    let size_of_length_of_link_name = 2 ** (flags & 3);
    let link_type_field_present = (flags & 2 ** 3) > 0;
    let link_name_character_set_field_present = (flags & 2 ** 4) > 0;
    let ordered = (flags & 2 ** 2) > 0;
    let link_type;
    if (link_type_field_present) {
      link_type = (await struct.unpack_from_async("<B", data, offset2))[0];
      offset2 += 1;
    } else {
      link_type = 0;
    }
    assert([0, 1].includes(link_type));
    let creationorder;
    if (ordered) {
      creationorder = (await struct.unpack_from_async("<Q", data, offset2))[0];
      offset2 += 8;
    }
    let link_name_character_set = 0;
    if (link_name_character_set_field_present) {
      link_name_character_set = (await struct.unpack_from_async("<B", data, offset2))[0];
      offset2 += 1;
    }
    let encoding = link_name_character_set == 0 ? "ascii" : "utf-8";
    let name_size_fmt = ["<B", "<H", "<I", "<Q"][flags & 3];
    let name_size = (await struct.unpack_from_async(name_size_fmt, data, offset2))[0];
    offset2 += size_of_length_of_link_name;
    let name2 = new TextDecoder(encoding).decode(await data.slice(offset2, offset2 + name_size));
    offset2 += name_size;
    let address;
    if (link_type == 0) {
      address = (await struct.unpack_from_async("<Q", data, offset2))[0];
    } else if (link_type == 1) {
      let length_of_soft_link_value = (await struct.unpack_from_async("<H", data, offset2))[0];
      offset2 += 2;
      address = new TextDecoder(encoding).decode(await data.slice(offset2, offset2 + length_of_soft_link_value));
    }
    return [creationorder, [name2, address]];
  }
  async *_iter_link_from_link_info_msg(info_msg) {
    let offset2 = info_msg.get("offset_to_message");
    let data = await this._decode_link_info_msg(this.fh, offset2);
    let heap_address = data.get("heap_address");
    let name_btree_address = data.get("name_btree_address");
    let order_btree_address = data.get("order_btree_address");
    if (name_btree_address != null) {
      yield* this._iter_links_btree_v2(name_btree_address, order_btree_address, heap_address);
    }
  }
  async *_iter_links_btree_v2(name_btree_address, order_btree_address, heap_address) {
    let heap = new FractalHeap(this.fh, heap_address);
    await heap.ready;
    let btree;
    const ordered = order_btree_address != null;
    if (ordered) {
      btree = new BTreeV2GroupOrders(this.fh, order_btree_address);
      await btree.ready;
    } else {
      btree = new BTreeV2GroupNames(this.fh, name_btree_address);
      await btree.ready;
    }
    let items = /* @__PURE__ */ new Map();
    for (let record of btree.iter_records()) {
      let data = heap.get_data(record.get("heapid"));
      let [creationorder, item] = await this._decode_link_msg(data, 0);
      const key = ordered ? creationorder : item[0];
      items.set(key, item);
    }
    let sorted_keys = Array.from(items.keys()).sort();
    for (let key of sorted_keys) {
      yield items.get(key);
    }
  }
  async _decode_link_info_msg(data, offset2) {
    let [version2, flags] = await struct.unpack_from_async("<BB", data, offset2);
    assert(version2 == 0);
    offset2 += 2;
    if ((flags & 1) > 0) {
      offset2 += 8;
    }
    let fmt = (flags & 2) > 0 ? LINK_INFO_MSG2 : LINK_INFO_MSG1;
    let link_info = await _unpack_struct_from_async(fmt, data, offset2);
    let output = /* @__PURE__ */ new Map();
    for (let [k, v] of link_info.entries()) {
      output.set(k, v == UNDEFINED_ADDRESS2 ? null : v);
    }
    return output;
  }
  get is_dataset() {
    return this.find_msg_type(DATASPACE_MSG_TYPE).length > 0;
  }
  async get_data() {
    let msg = this.find_msg_type(DATA_STORAGE_MSG_TYPE)[0];
    let msg_offset = msg.get("offset_to_message");
    var [version2, dims, layout_class, property_offset] = await this._get_data_message_properties(msg_offset);
    if (layout_class == 0) {
      throw "Compact storage of DataObject not implemented";
    } else if (layout_class == 1) {
      return this._get_contiguous_data(property_offset);
    } else if (layout_class == 2) {
      return this._get_chunked_data(msg_offset);
    }
  }
  async _get_data_message_properties(msg_offset) {
    let dims, layout_class, property_offset;
    let [version2, arg1, arg2] = await struct.unpack_from_async("<BBB", this.fh, msg_offset);
    if (version2 == 1 || version2 == 2) {
      dims = arg1;
      layout_class = arg2;
      property_offset = msg_offset;
      property_offset += struct.calcsize("<BBB");
      property_offset += struct.calcsize("<BI");
      assert(layout_class == 1 || layout_class == 2);
    } else if (version2 == 3 || version2 == 4) {
      layout_class = arg1;
      property_offset = msg_offset;
      property_offset += struct.calcsize("<BB");
    }
    assert(version2 >= 1 && version2 <= 4);
    return [version2, dims, layout_class, property_offset];
  }
  async _get_contiguous_data(property_offset) {
    let [data_offset] = await struct.unpack_from_async("<Q", this.fh, property_offset);
    const shape = await this.shape;
    const dtype = await this.dtype;
    if (data_offset == UNDEFINED_ADDRESS2) {
      let size = shape.reduce(function(a, b) {
        return a * b;
      }, 1);
      return new Array(size);
    }
    var fullsize = shape.reduce(function(a, b) {
      return a * b;
    }, 1);
    if (!(dtype instanceof Array)) {
      if (/[<>=!@\|]?(i|u|f|S)(\d*)/.test(dtype)) {
        let [item_getter, item_is_big_endian, item_size] = dtype_getter(dtype);
        let output = new Array(fullsize);
        const local_buffer = await this.fh.slice(data_offset, data_offset + item_size * fullsize);
        let view = new DataView64(local_buffer);
        for (var i = 0; i < fullsize; i++) {
          output[i] = view[item_getter](i * item_size, !item_is_big_endian, item_size);
        }
        return output;
      } else if (dtype.datatype_class === 5) {
        return this.fh.slice(data_offset, data_offset + dtype.size);
      } else {
        throw "not Implemented - no proper dtype defined";
      }
    } else {
      let dtype_class = dtype[0];
      if (dtype_class == "REFERENCE") {
        let size = dtype[1];
        if (size != 8) {
          throw "NotImplementedError('Unsupported Reference type')";
        }
        let ref_addresses = await this.fh.slice(data_offset, data_offset + fullsize);
        return ref_addresses;
      } else if (dtype_class == "VLEN_STRING") {
        let character_set = dtype[2];
        const encoding = character_set == 0 ? "ascii" : "utf-8";
        const decoder = new TextDecoder(encoding);
        var value = [];
        for (var i = 0; i < fullsize; i++) {
          const [vlen, vlen_data] = await this._vlen_size_and_data(this.fh, data_offset);
          value[i] = decoder.decode(vlen_data);
          data_offset += 16;
        }
        return value;
      } else {
        throw "NotImplementedError('datatype not implemented')";
      }
    }
  }
  async _get_chunked_data(offset2) {
    await this._get_chunk_params();
    if (this._chunk_address == UNDEFINED_ADDRESS2) {
      return [];
    }
    var chunk_btree = new BTreeV1RawDataChunks(this.fh, this._chunk_address, this._chunk_dims);
    await chunk_btree.ready;
    const dtype = await this.dtype;
    const shape = await this.shape;
    const chunks = await this.chunks;
    const filter_pipeline = await this.get_filter_pipeline();
    let data = await chunk_btree.construct_data_from_chunks(chunks, shape, dtype, filter_pipeline);
    if (dtype instanceof Array && /^VLEN/.test(dtype[0])) {
      let dtype_class = dtype[0];
      for (var i = 0; i < data.length; i++) {
        let [item_size, gheap_address, object_index] = data[i];
        var gheap;
        if (!(gheap_address in this._global_heaps)) {
          gheap = new GlobalHeap(this.fh, gheap_address);
          await gheap.ready;
          this._global_heaps[gheap_address] = gheap;
        } else {
          gheap = this._global_heaps[gheap_address];
        }
        let vlen_data = gheap.objects.get(object_index);
        if (dtype_class == "VLEN_STRING") {
          let character_set = dtype[2];
          const encoding = character_set == 0 ? "ascii" : "utf-8";
          const decoder = new TextDecoder(encoding);
          data[i] = decoder.decode(vlen_data);
        }
      }
    }
    return data;
  }
  async _get_chunk_params() {
    if (this._chunk_params_set) {
      return;
    }
    this._chunk_params_set = true;
    var msg = this.find_msg_type(DATA_STORAGE_MSG_TYPE)[0];
    var offset2 = msg.get("offset_to_message");
    var [version2, dims, layout_class, property_offset] = await this._get_data_message_properties(offset2);
    if (layout_class != 2) {
      return;
    }
    var data_offset;
    if (version2 == 1 || version2 == 2) {
      var address = (await struct.unpack_from_async("<Q", this.fh, property_offset))[0];
      data_offset = property_offset + struct.calcsize("<Q");
    } else if (version2 == 3) {
      var [dims, address] = await struct.unpack_from_async("<BQ", this.fh, property_offset);
      data_offset = property_offset + struct.calcsize("<BQ");
    }
    assert(version2 >= 1 && version2 <= 3);
    var fmt = "<" + (dims - 1).toFixed() + "I";
    var chunk_shape = await struct.unpack_from_async(fmt, this.fh, data_offset);
    this._chunks = chunk_shape;
    this._chunk_dims = dims;
    this._chunk_address = address;
    return;
  }
};
async function determine_data_shape(buf, offset2) {
  let version2 = (await struct.unpack_from_async("<B", buf, offset2))[0];
  var header;
  if (version2 == 1) {
    header = await _unpack_struct_from_async(DATASPACE_MSG_HEADER_V1, buf, offset2);
    assert(header.get("version") == 1);
    offset2 += DATASPACE_MSG_HEADER_V1_SIZE;
  } else if (version2 == 2) {
    header = await _unpack_struct_from_async(DATASPACE_MSG_HEADER_V2, buf, offset2);
    assert(header.get("version") == 2);
    offset2 += DATASPACE_MSG_HEADER_V2_SIZE;
  } else {
    throw "InvalidHDF5File('unknown dataspace message version')";
  }
  let ndims = header.get("dimensionality");
  let dim_sizes = await struct.unpack_from_async("<" + (ndims * 2).toFixed() + "I", buf, offset2);
  return dim_sizes.filter(function(s, i) {
    return i % 2 == 0;
  });
}
var UNDEFINED_ADDRESS2 = struct.unpack_from("<Q", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer);
var GLOBAL_HEAP_ID = /* @__PURE__ */ new Map([
  ["collection_address", "Q"],
  ["object_index", "I"]
]);
_structure_size(GLOBAL_HEAP_ID);
var ATTR_MSG_HEADER_V1 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["reserved", "B"],
  ["name_size", "H"],
  ["datatype_size", "H"],
  ["dataspace_size", "H"]
]);
var ATTR_MSG_HEADER_V1_SIZE = _structure_size(ATTR_MSG_HEADER_V1);
var ATTR_MSG_HEADER_V3 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["flags", "B"],
  ["name_size", "H"],
  ["datatype_size", "H"],
  ["dataspace_size", "H"],
  ["character_set_encoding", "B"]
]);
var ATTR_MSG_HEADER_V3_SIZE = _structure_size(ATTR_MSG_HEADER_V3);
var OBJECT_HEADER_V1 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["reserved", "B"],
  ["total_header_messages", "H"],
  ["object_reference_count", "I"],
  ["object_header_size", "I"],
  ["padding", "I"]
]);
var OBJECT_HEADER_V2 = /* @__PURE__ */ new Map([
  ["signature", "4s"],
  ["version", "B"],
  ["flags", "B"]
]);
var DATASPACE_MSG_HEADER_V1 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["dimensionality", "B"],
  ["flags", "B"],
  ["reserved_0", "B"],
  ["reserved_1", "I"]
]);
var DATASPACE_MSG_HEADER_V1_SIZE = _structure_size(DATASPACE_MSG_HEADER_V1);
var DATASPACE_MSG_HEADER_V2 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["dimensionality", "B"],
  ["flags", "B"],
  ["type", "B"]
]);
var DATASPACE_MSG_HEADER_V2_SIZE = _structure_size(DATASPACE_MSG_HEADER_V2);
var HEADER_MSG_INFO_V1 = /* @__PURE__ */ new Map([
  ["type", "H"],
  ["size", "H"],
  ["flags", "B"],
  ["reserved", "3s"]
]);
var HEADER_MSG_INFO_V1_SIZE = _structure_size(HEADER_MSG_INFO_V1);
var HEADER_MSG_INFO_V2 = /* @__PURE__ */ new Map([
  ["type", "B"],
  ["size", "H"],
  ["flags", "B"]
]);
var HEADER_MSG_INFO_V2_SIZE = _structure_size(HEADER_MSG_INFO_V2);
var SYMBOL_TABLE_MSG = /* @__PURE__ */ new Map([
  ["btree_address", "Q"],
  ["heap_address", "Q"]
]);
var LINK_INFO_MSG1 = /* @__PURE__ */ new Map([
  ["heap_address", "Q"],
  ["name_btree_address", "Q"]
]);
var LINK_INFO_MSG2 = /* @__PURE__ */ new Map([
  ["heap_address", "Q"],
  ["name_btree_address", "Q"],
  ["order_btree_address", "Q"]
]);
var FILLVAL_MSG_V1V2 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["space_allocation_time", "B"],
  ["fillvalue_write_time", "B"],
  ["fillvalue_defined", "B"]
]);
var FILLVAL_MSG_V1V2_SIZE = _structure_size(FILLVAL_MSG_V1V2);
var FILLVAL_MSG_V3 = /* @__PURE__ */ new Map([
  ["version", "B"],
  ["flags", "B"]
]);
var FILLVAL_MSG_V3_SIZE = _structure_size(FILLVAL_MSG_V3);
var FILTER_PIPELINE_DESCR_V1 = /* @__PURE__ */ new Map([
  ["filter_id", "H"],
  ["name_length", "H"],
  ["flags", "H"],
  ["client_data_values", "H"]
]);
var FILTER_PIPELINE_DESCR_V1_SIZE = _structure_size(FILTER_PIPELINE_DESCR_V1);
var DATASPACE_MSG_TYPE = 1;
var LINK_INFO_MSG_TYPE = 2;
var DATATYPE_MSG_TYPE = 3;
var FILLVALUE_MSG_TYPE = 5;
var LINK_MSG_TYPE = 6;
var DATA_STORAGE_MSG_TYPE = 8;
var DATA_STORAGE_FILTER_PIPELINE_MSG_TYPE = 11;
var ATTRIBUTE_MSG_TYPE = 12;
var OBJECT_CONTINUATION_MSG_TYPE = 16;
var SYMBOL_TABLE_MSG_TYPE = 17;
var Group = class {
  constructor(name2, parent) {
    if (parent == null) {
      this.parent = this;
      this.file = this;
    } else {
      this.parent = parent;
      this.file = parent.file;
    }
    this.name = name2;
  }
  async init(dataobjects) {
    const index2 = this.file.index;
    if (index2 && this.name in index2) {
      this._links = index2[this.name];
    } else {
      this._links = await dataobjects.get_links();
    }
    this._dataobjects = dataobjects;
    this._attrs = null;
    this._keys = null;
  }
  get keys() {
    if (this._keys == null) {
      this._keys = Object.keys(this._links);
    }
    return this._keys.slice();
  }
  get values() {
    return this.keys.map((k) => this.get(k));
  }
  length() {
    return this.keys.length;
  }
  _dereference(ref) {
    if (!ref) {
      throw "cannot deference null reference";
    }
    let obj = this.file._get_object_by_address(ref);
    if (obj == null) {
      throw "reference not found in file";
    }
    return obj;
  }
  async get(y) {
    if (typeof y == "number") {
      return this._dereference(y);
    }
    var path = normpath(y);
    if (path == "/") {
      return this.file;
    }
    if (path == ".") {
      return this;
    }
    if (/^\//.test(path)) {
      return this.file.get(path.slice(1));
    }
    if (posix_dirname(path) != "") {
      var [next_obj, additional_obj] = path.split(/\/(.*)/);
    } else {
      var next_obj = path;
      var additional_obj = ".";
    }
    if (!(next_obj in this._links)) {
      throw next_obj + " not found in group";
    }
    var obj_name = normpath(this.name + "/" + next_obj);
    let link_target = this._links[next_obj];
    if (typeof link_target == "string") {
      try {
        return this.get(link_target);
      } catch (error) {
        return null;
      }
    }
    var dataobjs = new DataObjects(this.file._fh, link_target);
    await dataobjs.ready;
    if (dataobjs.is_dataset) {
      if (additional_obj != ".") {
        throw obj_name + " is a dataset, not a group";
      }
      return new Dataset$1(obj_name, dataobjs, this);
    } else {
      var new_group = new Group(obj_name, this);
      await new_group.init(dataobjs);
      return new_group.get(additional_obj);
    }
  }
  visit(func) {
    return this.visititems((name2, obj) => func(name2));
  }
  visititems(func) {
    var root_name_length = this.name.length;
    if (!/\/$/.test(this.name)) {
      root_name_length += 1;
    }
    var queue = this.values.slice();
    while (queue) {
      let obj = queue.shift();
      if (queue.length == 1)
        console.log(obj);
      let name2 = obj.name.slice(root_name_length);
      let ret = func(name2, obj);
      if (ret != null) {
        return ret;
      }
      if (obj instanceof Group) {
        queue = queue.concat(obj.values);
      }
    }
    return null;
  }
  get attrs() {
    if (this._attrs == null) {
      this._attrs = this._dataobjects.get_attributes();
    }
    return this._attrs;
  }
};
var File$1 = class extends Group {
  constructor(fh, filename, options2) {
    super("/", null);
    this.ready = this.init(fh, filename, options2);
  }
  async init(fh, filename, options2) {
    var superblock = new SuperBlock(fh, 0);
    await superblock.ready;
    var offset2 = await superblock.get_offset_to_dataobjects();
    var dataobjects = new DataObjects(fh, offset2);
    await dataobjects.ready;
    this.parent = this;
    this.file = this;
    this.name = "/";
    this._dataobjects = dataobjects;
    this._attrs = null;
    this._keys = null;
    this._fh = fh;
    this.filename = filename || "";
    this.mode = "r";
    this.userblock_size = 0;
    if (options2 && options2.index) {
      this.index = options2.index;
    } else {
      let index_offset;
      if (options2 && options2.indexOffset) {
        index_offset = options2.indexOffset;
      } else {
        const attrs = await this.attrs;
        if (attrs.hasOwnProperty("_index_offset")) {
          index_offset = attrs["_index_offset"];
        } else {
          const indexName = this.indexName || "_index";
          const index_link = await dataobjects.find_link(indexName);
          if (index_link) {
            index_offset = index_link[1];
          }
        }
      }
      if (index_offset) {
        try {
          const dataobject = new DataObjects(fh, index_offset);
          await dataobject.ready;
          const comp_index_data = await dataobject.get_data();
          const inflated = ungzip_1(comp_index_data);
          const json = new TextDecoder().decode(inflated);
          this.index = JSON.parse(json);
        } catch (e) {
          console.error(`Error loading index by offset ${e}`);
        }
      }
    }
    if (this.index && this.name in this.index) {
      this._links = this.index[this.name];
    } else {
      this._links = await dataobjects.get_links();
    }
  }
  _get_object_by_address(obj_addr) {
    if (this._dataobjects.offset == obj_addr) {
      return this;
    }
    return this.visititems((y) => {
      y._dataobjects.offset == obj_addr ? y : null;
    });
  }
};
var Dataset$1 = class Dataset extends Array {
  constructor(name2, dataobjects, parent) {
    super();
    this.parent = parent;
    this.file = parent.file;
    this.name = name2;
    this._dataobjects = dataobjects;
    this._attrs = null;
    this._astype = null;
  }
  get value() {
    var data = this._dataobjects.get_data();
    if (this._astype == null) {
      return this.getValue(data);
    }
    return data.astype(this._astype);
  }
  get shape() {
    return this._dataobjects.shape;
  }
  get attrs() {
    return this._dataobjects.get_attributes();
  }
  get dtype() {
    return this._dataobjects.dtype;
  }
  get fillvalue() {
    return this._dataobjects.get_fillvalue();
  }
  async to_array() {
    const value = await this.value;
    const shape = await this.shape;
    return create_nested_array(value, shape);
  }
  async getValue(data) {
    const dtype = await this.dtype;
    if ((typeof dtype === "string" || dtype instanceof String) && dtype.startsWith("S")) {
      return (await data).map((s) => {
        let idx = s.indexOf("\0");
        return idx >= 0 ? s.substring(0, idx) : s;
      });
    } else {
      return data;
    }
  }
};
function posix_dirname(p) {
  let sep = "/";
  let i = p.lastIndexOf(sep) + 1;
  let head = p.slice(0, i);
  let all_sep = new RegExp("^" + sep + "+$");
  let end_sep = new RegExp(sep + "$");
  if (head && !all_sep.test(head)) {
    head = head.replace(end_sep, "");
  }
  return head;
}
function normpath(path) {
  return path.replace(/\/(\/)+/g, "/");
}
function create_nested_array(value, shape) {
  const total_length = value.length;
  const dims_product = shape.reduce((previous, current) => previous * current, 1);
  if (total_length !== dims_product) {
    console.warn(`shape product: ${dims_product} does not match length of flattened array: ${total_length}`);
  }
  let output = value;
  const subdims = shape.slice(1).reverse();
  for (let dim of subdims) {
    const new_output = [];
    const { length } = output;
    let cursor = 0;
    while (cursor < length) {
      new_output.push(output.slice(cursor, cursor += dim));
    }
    output = new_output;
  }
  return output;
}
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
async function openH5File(options2) {
  if (options2.url && isBlobLike(options2.url)) {
    options2.file = options2.url;
    options2.url = void 0;
  }
  const isRemote = options2.url !== void 0;
  let fileReader = options2.reader ? options2.reader : getReaderFor(options2);
  const fetchSize = options2.fetchSize || 2e3;
  const maxSize = options2.maxSize || 2e5;
  if (isRemote) {
    fileReader = new BufferedFile$1({ file: fileReader, fetchSize, maxSize });
  }
  const asyncBuffer = new AsyncBuffer(fileReader);
  const index2 = await readExternalIndex(options2);
  const indexOffset = options2.indexOffset;
  const filename = getFilenameFor(options2);
  const hdfFile = new File$1(asyncBuffer, filename, { index: index2, indexOffset });
  await hdfFile.ready;
  return hdfFile;
}
async function readExternalIndex(options2) {
  let indexReader;
  if (options2.indexReader) {
    indexReader = options2.indexReader;
  } else if (options2.index) {
    return options2.index;
  } else if (options2.indexURL) {
    indexReader = new RemoteFile$1({ url: options2.indexURL });
  } else if (options2.indexPath) {
    indexReader = new NodeLocalFile({ path: options2.indexPath });
  } else if (options2.indexFile) {
    indexReader = new BlobFile({ file: options2.indexFile });
  }
  if (indexReader) {
    const indexFileContents = await indexReader.read();
    const indexFileJson = new TextDecoder().decode(indexFileContents);
    return JSON.parse(indexFileJson);
  } else {
    return void 0;
  }
}
function getReaderFor(options2) {
  if (options2.url) {
    return new RemoteFile$1(options2);
  } else if (options2.path) {
    return new NodeLocalFile(options2);
  } else if (options2.file) {
    return new BlobFile(options2.file);
  } else {
    throw Error("One of 'url', 'path (node only)', or 'file (browser only)' must be specified");
  }
}
function getFilenameFor(options2) {
  if (options2.url) {
    return getFilename(options2.url);
  } else if (options2.path) {
    return getFilename(options2.path);
  } else if (options2.file) {
    return options2.file.name;
  }
}
class AsyncBuffer {
  constructor(fileReader) {
    this.fileReader = fileReader;
  }
  async slice(start, end) {
    return this.fileReader.read(start, end - start);
  }
}
function getFilename(pathOrURL) {
  const idx = pathOrURL.lastIndexOf("/");
  return idx > 0 ? pathOrURL.substring(idx + 1) : pathOrURL;
}
function isBlobLike(obj) {
  return typeof obj.slice === "function" && typeof obj.arrayBuffer === "function";
}
class HDF5Reader {
  constructor(h5_file, bin_size2 = 1e5) {
    this.h5_file = h5_file;
    this.bin_size = bin_size2;
    this.h5_obj = void 0;
  }
  async fetch() {
    if (!this.h5_obj) {
      this.h5_obj = await openH5File({
        url: this.h5_file,
        fetchSize: 1e6,
        maxSize: 2e8
      });
    }
    return this.h5_obj;
  }
  async get_keys() {
    let h5_obj = await this.fetch();
    return h5_obj.keys;
  }
  async get_rd_signal(bin_size2 = this.bin_size) {
    let h5_obj = await this.fetch();
    let h5_obj_keys = h5_obj.keys;
    let signal_bin = new ParseSignals(h5_obj_keys);
    let rd_bins = signal_bin.get_rd_bins();
    let snp_bins = signal_bin.get_snp_bins();
    this.available_bins = [...new Set(rd_bins, snp_bins)];
    if (!this.available_bins.includes(bin_size2)) {
      bin_size2 = this.available_bins.at(-1);
    }
    const chr_ds = await h5_obj.get("rd_chromosomes");
    await chr_ds.dtype;
    let rd_chromosomes = await chr_ds.value;
    let rd_flag = "";
    let rd_stat = await this.rd_stat(h5_obj, h5_obj_keys, bin_size2);
    var wigFeatures = [];
    var wigFeatures_gc = [];
    var wigFeatures_rd_call_meanshift = [];
    var wigFeatures_rd_call_combined = [];
    var wigFeatures_baf1 = [];
    var wigFeatures_baf2 = [];
    for (let chrom of rd_chromosomes) {
      var signal_rd = `his_rd_p_${chrom}_${bin_size2}${rd_flag}`;
      let chr_wig = await this.get_chr_signal(h5_obj, h5_obj_keys, chrom, bin_size2, signal_rd, rd_stat);
      wigFeatures = wigFeatures.concat(chr_wig);
      var signal_rd_gc = `his_rd_p_${chrom}_${bin_size2}_GC`;
      let chr_wig_gc = await this.get_chr_signal(h5_obj, h5_obj_keys, chrom, bin_size2, signal_rd_gc, rd_stat);
      wigFeatures_gc = wigFeatures_gc.concat(chr_wig_gc);
      let signal_rd_call = `his_rd_p_${chrom}_${bin_size2}_partition_GC_merge`;
      let chr_wig_rd_call_meanshift = await this.get_chr_signal(h5_obj, h5_obj_keys, chrom, bin_size2, signal_rd_call, rd_stat);
      wigFeatures_rd_call_meanshift = wigFeatures_rd_call_meanshift.concat(chr_wig_rd_call_meanshift);
      let chr_wig_rd_call = await this.rd_call_combined(h5_obj, h5_obj_keys, chrom, bin_size2, rd_stat);
      wigFeatures_rd_call_combined = wigFeatures_rd_call_combined.concat(chr_wig_rd_call);
      let signal_baf_1 = `snp_likelihood_${chrom}_${bin_size2}_mask`;
      let chr_wig_bafs = await this.get_baf_signals(h5_obj, h5_obj_keys, chrom, bin_size2, signal_baf_1);
      wigFeatures_baf1 = wigFeatures_baf1.concat(chr_wig_bafs[0]);
      wigFeatures_baf2 = wigFeatures_baf2.concat(chr_wig_bafs[1]);
    }
    this.callers = [];
    if (wigFeatures_rd_call_combined.length != 0) {
      this.callers.push("ReadDepth");
    }
    if (wigFeatures_rd_call_combined.length != 0) {
      this.callers.push("2D");
    }
    var obj = {};
    var signal_obj = {
      "RD_Raw": wigFeatures,
      "RD_Raw_gc_coor": wigFeatures_gc,
      "ReadDepth": wigFeatures_rd_call_meanshift,
      "2D": wigFeatures_rd_call_combined,
      "BAF1": wigFeatures_baf1,
      "BAF2": wigFeatures_baf2
    };
    obj[bin_size2] = signal_obj;
    return obj;
  }
  decode_segments(segments_arr) {
    let max = 2 ** 32 - 1;
    let segments = [];
    let l = [];
    for (let x of segments_arr) {
      if (x == max) {
        segments.push(l);
        l = [];
      } else {
        l.push(x);
      }
    }
    return segments;
  }
  async rd_call_combined(h5_obj, h5_obj_keys, chrom, bin_size2, rd_stat) {
    let chr_wig = [];
    let segments;
    let mosaic_call_segments = `his_rd_p_${chrom}_${bin_size2}_partition_GC_mosaic_segments_2d`;
    if (h5_obj_keys.includes(mosaic_call_segments)) {
      const chrom_dataset = await h5_obj.get(mosaic_call_segments);
      let chrom_data = await chrom_dataset.value;
      segments = this.decode_segments(chrom_data);
    }
    let mosaic_calls = `his_rd_p_${chrom}_${bin_size2}_partition_GC_mosaic_call_2d`;
    if (h5_obj_keys.includes(mosaic_calls)) {
      const segments_call_dataset = await h5_obj.get(mosaic_calls);
      let segments_call = await segments_call_dataset.to_array();
      segments.forEach((ind_segment, segment_idx) => {
        ind_segment.forEach((bin_value, bin_idx) => {
          chr_wig.push({ chr: chrom, start: bin_value * bin_size2, end: (bin_value + 1) * bin_size2, value: segments_call[0][segment_idx] / rd_stat[4] * 2 });
        });
      });
    }
    return chr_wig;
  }
  async rd_stat(h5_obj, h5_obj_keys, bin_size2) {
    let rd_stat_signal = `rd_stat_${bin_size2}_auto`;
    let rd_stat;
    if (h5_obj_keys.includes(rd_stat_signal)) {
      const rd_stat_dataset = await h5_obj.get(rd_stat_signal);
      rd_stat = await rd_stat_dataset.value;
    }
    return rd_stat;
  }
  async get_chr_signal(h5_obj, h5_obj_keys, chrom, bin_size2, signal_name, rd_stat) {
    let chr_wig = [];
    if (h5_obj_keys.includes(signal_name)) {
      const chrom_dataset = await h5_obj.get(signal_name);
      let chrom_data = await chrom_dataset.value;
      chrom_data.forEach((bin_value, bin_idx) => {
        chr_wig.push({ chr: chrom, start: bin_idx * bin_size2, end: (bin_idx + 1) * bin_size2, value: bin_value / rd_stat[4] * 2 });
      });
    }
    return chr_wig;
  }
  async get_baf_signals(h5_obj, h5_obj_keys, chrom, bin_size2, signal_name) {
    let chr_wig_1 = [];
    let chr_wig_2 = [];
    if (h5_obj_keys.includes(signal_name)) {
      let chrom_dataset = await h5_obj.get(signal_name);
      let chrom_data = await chrom_dataset.to_array();
      chrom_data.forEach((bin_value, bin_idx) => {
        let max_value = Math.max(...bin_value);
        const res = bin_value.indexOf(max_value);
        let lh = Math.max(res / 200, 1 - res / 200);
        chr_wig_1.push({ chr: chrom, start: bin_idx * bin_size2, end: (bin_idx + 1) * bin_size2, value: -2 * lh });
        if (lh != 0.5) {
          chr_wig_2.push({ chr: chrom, start: bin_idx * bin_size2, end: (bin_idx + 1) * bin_size2, value: -2 * (1 - lh) });
        }
      });
    }
    return [chr_wig_1, chr_wig_2];
  }
  async get_baf_signals_v2(h5_obj, h5_obj_keys, chrom, bin_size2, signal_name) {
    let chr_wig_1 = [];
    let chr_wig_2 = [];
    if (h5_obj_keys.includes(signal_name)) {
      let chrom_dataset = await h5_obj.get(signal_name);
      let chrom_data = await chrom_dataset.to_array();
      chrom_data.forEach((lh, bin_idx) => {
        if (!isNaN(lh)) {
          chr_wig_1.push({ chr: chrom, start: bin_idx * bin_size2, end: (bin_idx + 1) * bin_size2, value: -2 * (0.5 - lh) });
          if (lh != 0.5) {
            chr_wig_2.push({ chr: chrom, start: bin_idx * bin_size2, end: (bin_idx + 1) * bin_size2, value: -2 * (0.5 + lh) });
          }
        }
      });
    }
    console.log(chrom, chr_wig_1, chr_wig_2);
    return [chr_wig_1, chr_wig_2];
  }
}
class ParseSignals {
  constructor(signals) {
    this.signals = signals;
  }
  get_rd_bins() {
    let rd_keys = [];
    this.signals.forEach((val) => {
      let match = val.match(/^his_rd_p_(.*)_(\d+)$/);
      if (match) {
        rd_keys.push({ chr: match[1], bin_size: match[2] });
      }
    });
    const rd_bins = [...new Set(rd_keys.map((item) => Number(item.bin_size)))];
    return rd_bins;
  }
  get_snp_bins() {
    let slected_signals = [];
    this.signals.forEach((val) => {
      let match = val.match(/^snp_likelihood_(.*)_(\d+)_mask$/);
      if (match) {
        slected_signals.push({ chr: match[1], bin_size: match[2] });
      }
    });
    const bins = [...new Set(slected_signals.map((item) => Number(item.bin_size)))];
    return bins;
  }
}
class GetFit {
  constructor(allBins) {
    this.allBins = allBins;
  }
  getValues() {
    const bins = Object.values(this.allBins).reduce(
      (binResult, bin) => {
        return binResult.concat(bin.filter((a) => a.binScore > 0).map((a) => a.binScore));
      },
      []
    );
    return bins;
  }
  getMean(data) {
    return data.reduce(function(a, b) {
      return a + b;
    }) / data.length;
  }
  fit_data() {
    let rd_list = this.getValues();
    let distParmas = getDistParams(rd_list);
    return distParmas;
  }
  histogram(data, bins) {
    const step = bins[1] - bins[0];
    const hist_bins = [];
    data.forEach((value, index2) => {
      bins.forEach((bin_value, bin_index) => {
        if (!hist_bins[bin_value]) {
          hist_bins[bin_value] = { count: 0 };
        }
        if (bin_value <= value && value < bin_value + step) {
          hist_bins[bin_value].count++;
          return false;
        }
      });
    });
    const dist_p = [];
    hist_bins.forEach((bin, index2) => {
      dist_p.push(bin.count);
    });
    return dist_p;
  }
}
function range_function(start, stop, step) {
  const data_array = Array(Math.ceil((stop - start) / step)).fill(start).map((x, y) => x + y * step);
  return data_array;
}
function filterOutliers(someArray) {
  if (someArray.length < 4)
    return someArray;
  let values, q1, q3, iqr, maxValue, minValue;
  values = someArray.slice().sort((a, b) => a - b);
  if (values.length / 4 % 1 === 0) {
    q1 = 1 / 2 * (values[values.length / 4] + values[values.length / 4 + 1]);
    q3 = 1 / 2 * (values[values.length * (3 / 4)] + values[values.length * (3 / 4) + 1]);
  } else {
    q1 = values[Math.floor(values.length / 4 + 1)];
    q3 = values[Math.ceil(values.length * (3 / 4) + 1)];
  }
  iqr = q3 - q1;
  maxValue = q3 + iqr * 1.5;
  minValue = q1 - iqr * 1.5;
  return values.filter((x) => x >= minValue && x <= maxValue);
}
function getDistParams(bins) {
  let filteredBins = filterOutliers(bins);
  const n = filteredBins.length;
  const mean = filteredBins.reduce((a, b) => a + b) / n;
  const std = Math.sqrt(filteredBins.map((x) => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);
  return [mean, std];
}
function linspace(a, b, n) {
  if (typeof n === "undefined") n = Math.max(Math.round(b - a) + 1, 1);
  if (n < 2) {
    return n === 1 ? [a] : [];
  }
  var ret = Array(n);
  n--;
  for (let i = n; i >= 0; i--) {
    ret[i] = (i * b + (n - i) * a) / n;
  }
  return ret;
}
var g_utils = { range_function, getDistParams, linspace, GetFit };
function TdistributionCDF(t, v) {
  if (isNaN(t) || isNaN(v) || v <= 0) {
    return NaN;
  }
  if (t === 0) {
    return 0.5;
  }
  return 1 / 2 + 1 / 2 * (incompbeta(1 / 2 * v, 1 / 2, 1) - incompbeta(1 / 2 * v, 1 / 2, v / (v + t * t))) * Math.sign(t);
}
function incompbeta(a, b, x) {
  if (x == 0) {
    return 0;
  } else if (x == 1) {
    return 1;
  } else {
    let lbeta = lgamma(a + b) - lgamma(a) - lgamma(b) + a * Math.log(x) + b * Math.log(1 - x);
    if (x < (a + 1) / (a + b + 2)) {
      return Math.exp(lbeta) * contfractbeta(a, b, x) / a;
    } else {
      return 1 - Math.exp(lbeta) * contfractbeta(b, a, 1 - x) / b;
    }
  }
}
function contfractbeta(a, b, x, ITMAX = 1e3) {
  let EPS = 3e-7;
  let az = 1;
  let am = 1;
  let bm = 1;
  let qab = a + b;
  let qap = a + 1;
  let qam = a - 1;
  let bz = 1 - qab * x / qap;
  for (let i = 0; i <= ITMAX; i++) {
    let em = parseFloat(i + 1);
    let tem = em + em;
    let d = em * (b - em) * x / ((qam + tem) * (a + tem));
    let ap = az + d * am;
    let bp = bz + d * bm;
    d = -(a + em) * (qab + em) * x / ((qap + tem) * (a + tem));
    let app = ap + d * az;
    let bpp = bp + d * bz;
    let aold = az;
    am = ap / bpp;
    bm = bp / bpp;
    az = app / bpp;
    bz = 1;
    if (Math.abs(az - aold) < EPS * Math.abs(az)) {
      return az;
    }
  }
}
function factorial(xf) {
  if (xf == 0 || xf == 1) return 1;
  else {
    let result = xf * factorial(xf - 1);
    return result;
  }
}
function gamma(a) {
  let gamma2;
  var qc = [75122.633153, 80916.6278952, 36308.2951477, 8687.24529705, 1168.92649479, 83.8676043424, 2.50662827511];
  var sum1 = 0;
  var prod1 = 1;
  if (a == 0) {
    gamma2 = 1e99;
  } else {
    if (a % 1 == 0) {
      gamma2 = factorial(a - 1);
    } else {
      for (let j = 0; j < qc.length; j++) {
        sum1 = sum1 + qc[j] * Math.pow(a, j);
        prod1 = prod1 * (a + j);
      }
      gamma2 = sum1 * Math.pow(a + 5.5, a + 0.5) * Math.exp(-(a + 5.5)) / prod1;
    }
  }
  return gamma2;
}
function lgamma(xg) {
  return Math.log(gamma(xg));
}
function t_test_1_sample$1(mean, m, s, n) {
  if (s == 0) s = 1;
  var t = (mean - m) / s * Math.sqrt(n);
  var p = 1 - TdistributionCDF(Math.abs(t), n - 1);
  return p;
}
function t_test_2_samples$1(m1, s1, n1, m2, s2, n2) {
  if (s1 == 0) s1 = 1;
  if (s2 == 0) s2 = 1;
  var t = (m1 - m2) / Math.sqrt(s1 ** 2 / n1 + s2 ** 2 / n2);
  var df = (s1 ** 2 / n1 + s2 ** 2 / n2) ** 2 * (n1 - 1) * (n2 - 1) / (s1 ** 4 * (n2 - 1) / n1 ** 2 + s2 ** 4 * (n1 - 1) / n2 ** 2);
  var p = 1 - TdistributionCDF(Math.abs(t), parseInt(df + 0.5));
  return p;
}
var t_dist = { TdistributionCDF, gamma, t_test_1_sample: t_test_1_sample$1, t_test_2_samples: t_test_2_samples$1 };
class CombinedCaller {
  constructor(wigFeatures, binSize) {
    this.wigFeatures = wigFeatures;
    this.binSize = binSize;
  }
  get_fit() {
    var fit_info = new g_utils.GetFit(this.wigFeatures);
    var [globalMean, globalStd] = fit_info.fit_data();
    return { globalMean, globalStd };
  }
  async call_2d(omin = null, mcount = null, event_type = "both", max_distance = 0.1, baf_threshold = 0, max_copy_number = 10, min_cell_fraction = 0) {
    let fit_obj = this.get_fit();
    this.globalMean = fit_obj.globalMean;
    this.globalStd = fit_obj.globalStd;
    let overlap_min = omin == null ? 0.05 * this.binSize / 3e9 : omin;
    let min_count = mcount == null ? parseInt(this.binSize / 1e4) : mcount;
    let gstat_rd0 = [];
    let gstat_rd_all = [];
    let gstat_rd = [];
    let gstat_error = [];
    let gstat_lh = [];
    let gstat_n = [];
    for (const [chr, wig] of Object.entries(this.wigFeatures)) {
      let segments = [];
      let levels = [];
      let likelihoods = [];
      wig.forEach((bin, bin_idx) => {
        if (bin.hets_count > 4) {
          if (bin.dp_count > min_count) {
            segments.push([bin_idx]);
            levels.push(bin.binScore);
            likelihoods.push(bin.likelihood_score);
            delete bin.likelihood_score;
          }
        }
      });
      let diff_level = [];
      for (let i = 1; i < levels.length; i++) {
        diff_level.push(Math.abs(levels[i] - levels[i - 1]));
      }
      let min_flank = [0];
      for (let i = 1; i < diff_level.length; i++) {
        min_flank.push(Math.min(diff_level[i - 1], diff_level[i]));
      }
      min_flank.push(0);
      let error = levels.map((x2, x_idx) => {
        return Math.sqrt(Math.sqrt(x2) ** 2 + this.globalStd ** 2 + Math.pow(min_flank[x_idx] / 2, 2));
      });
      let overlaps2 = [];
      for (let i = 0; i < segments.length - 1; i++) {
        let lh_overlap = 0;
        try {
          lh_overlap = likelihood_overlap(likelihoods[i], likelihoods[i + 1]);
        } catch {
          console.log("Overlap failed: ", i, likelihoods[i], segments[i + 1], likelihoods[i + 1]);
        }
        let rd_overlap = normal_overlap_approx(levels[i], error[i], levels[i + 1], error[i + 1]);
        overlaps2.push(rd_overlap * lh_overlap);
      }
      while (overlaps2.length > 0) {
        overlaps2 = overlaps2.filter((num) => typeof num === "number");
        let max_overlap = arrayMax(overlaps2);
        if (isNaN(max_overlap)) {
          console.log("NaN value", overlaps2);
        }
        if (max_overlap < overlap_min) {
          break;
        }
        let i = overlaps2.indexOf(max_overlap);
        let merge_level = normal_merge(levels[i], error[i], levels[i + 1], error[i + 1]);
        let nlh;
        let nlh_sum;
        try {
          nlh = likelihoods[i].map((l_value, l_idx) => {
            return l_value * likelihoods[i + 1][l_idx];
          });
          nlh_sum = nlh.reduce((a, c_value) => {
            return a + c_value;
          });
        } catch {
          console.log(likelihoods);
          console.log("max_overlap:", max_overlap, i, overlaps2.length);
          console.log("likelihood: ", i, likelihoods[i], likelihoods[i + 1]);
          console.log("nlh: ", nlh_sum);
        }
        levels[i] = merge_level.nl;
        error[i] = merge_level.ne;
        likelihoods[i] = nlh.map(function(item) {
          return item / nlh_sum;
        });
        segments[i].push(...segments[i + 1]);
        levels.splice(i + 1, 1);
        error.splice(i + 1, 1);
        segments.splice(i + 1, 1);
        likelihoods.splice(i + 1, 1);
        overlaps2.splice(i, 1);
        if (i < overlaps2.length) {
          let rd_overlap = normal_overlap_approx(levels[i], error[i], levels[i + 1], error[i + 1]);
          let new_overlap = rd_overlap * likelihood_overlap(likelihoods[i], likelihoods[i + 1]);
          overlaps2[i] = new_overlap;
        }
        if (i > 0) {
          let new_overlap = normal_overlap_approx(levels[i - 1], error[i - 1], levels[i], error[i]) * likelihood_overlap(likelihoods[i - 1], likelihoods[i]);
          overlaps2[i - 1] = new_overlap;
        }
      }
      let ons = -1;
      while (true) {
        overlaps2 = [];
        for (let i2 = 0; i2 < levels.length; i2++) {
          for (let j2 = i2; j2 < levels.length; j2++) {
            if (segments[j2][0] - segments[i2].at(-1) < max_distance * (segments[i2].length + segments[j2].length)) {
              overlaps2.push(normal_overlap_approx(levels[i2], error[i2], levels[j2], error[j2]) * likelihood_overlap(likelihoods[i2], likelihoods[j2]));
            }
          }
        }
        if (overlaps2.length == 0) {
          break;
        }
        let max_overlap = arrayMax(overlaps2);
        if (max_overlap < overlap_min) {
          break;
        }
        let i = 0;
        let j = 1;
        while (i < segments.length - 1) {
          let overlap_value = normal_overlap_approx(levels[i], error[i], levels[j], error[j]) * likelihood_overlap(likelihoods[i], likelihoods[j]);
          if (segments[j][0] - segments[i].at(-1) < max_distance * (segments[i].length + segments[j].length) && overlap_value == max_overlap) {
            let merge_level = normal_merge(levels[i], error[i], levels[i + 1], error[i + 1]);
            levels[i] = merge_level.nl;
            error[i] = merge_level.ne;
            let nlh = likelihoods[i].map((l_value, l_idx) => {
              return l_value * likelihoods[i + 1][l_idx];
            });
            let nlh_sum = nlh.reduce((a, c_value) => {
              return a + c_value;
            });
            likelihoods[i] = nlh.map(function(item) {
              return item / nlh_sum;
            });
            segments[i].push(...segments[i + 1]);
            segments[i] = segments[i].sort((a, b) => a - b);
            levels.splice(j, 1);
            error.splice(j, 1);
            segments.splice(j, 1);
            likelihoods.splice(j, 1);
            if (j >= segments.length) {
              i += 1;
              j = i + 1;
            }
          } else {
            j += 1;
            if (j >= segments.length) {
              i += 1;
              j = i + 1;
            }
          }
        }
        if (ons == segments.length) {
          break;
        }
        ons = segments.length;
      }
      segments.forEach((seg_value, seg_idx) => {
        let baf_info = likelihood_baf_pval(likelihoods[seg_idx]);
        if (seg_value.length > 1) {
          seg_value.forEach((bin, bin_idx) => {
            gstat_rd_all.push(wig[bin]);
            if (baf_info.mean <= baf_threshold) {
              gstat_rd0.push(wig[bin]);
            }
            wig[bin].segment_score = levels[seg_idx];
          });
          gstat_rd.push(levels[seg_idx]);
          gstat_error.push(error[seg_idx]);
          gstat_lh.push(likelihoods[seg_idx]);
        }
      });
      continue;
    }
    let points = parseInt(1e3 * (1 - min_cell_fraction));
    if (points == 0) {
      points = 1;
    }
    let x = g_utils.linspace(min_cell_fraction, 1, points);
    let master_lh = {};
    let germline_lh = {};
    for (let cn = 10; cn > -1; cn--) {
      for (let h1 = 0; h1 < cn / 2 + 1; h1++) {
        let h2 = cn - h1;
        let mrd = x.map((v, idx) => {
          return 1 - v + v * cn / 2;
        });
        let g_mrd = cn / 2;
        let g_mbaf;
        let mbaf;
        if (cn > 0) {
          g_mbaf = 0.5 - h1 / (h1 + h2);
          mbaf = x.map((v, idx) => {
            return 0.5 - (1 - v + v * h1) / (2 - 2 * v + (h1 + h2) * v);
          });
        } else {
          g_mbaf = 0;
          mbaf = x.map((v, idx) => {
            return 0 * v;
          });
        }
        for (let ei = 0; ei < gstat_rd.length; ei++) {
          let g_lh = normal(g_mrd * this.globalMean, 1, gstat_rd[ei], gstat_error[ei]) * likelihood_of_baf(gstat_lh[ei], 0.5 + g_mbaf);
          if (ei in germline_lh) {
            germline_lh[ei].push([cn, h1, h2, g_lh, 1]);
          } else {
            germline_lh[ei] = [cn, h1, h2, g_lh, 1];
          }
          let slh = 0;
          let max_lh = 0;
          let max_x = 0;
          mrd.forEach((mi, idx) => {
            if (!isNaN(mbaf[idx])) {
              let tmpl = normal(mi * this.globalMean, 1, gstat_rd[ei], gstat_error[ei]) * likelihood_of_baf(gstat_lh[ei], 0.5 + mbaf[idx]);
              slh += tmpl;
              if (tmpl > max_lh) {
                max_lh = tmpl;
                max_x = x[idx];
              }
            }
          });
          if (ei in master_lh) {
            master_lh[ei].push([cn, h1, h2, slh / x.length, max_x]);
          } else {
            master_lh[ei] = [cn, h1, h2, slh / x.length, max_x];
          }
        }
        for (let ei = 0; ei < gstat_rd.length; ei++) {
          if (event_type == "germline") {
            master_lh[ei].sort((a, b) => a[3] - b[3]);
          } else {
            master_lh[ei].sort((a, b) => a[3] - b[3]);
            if (event_type == "both") {
              germline_lh[ei].sort((a, b) => a[3] - b[3]);
              if (germline_lh[ei][0][3] > master_lh[ei][0][3]) {
                let tmp_list = master_lh[ei].filter((x2) => x2[0] != germline_lh[ei][0][0] && x2[1] <= germline_lh[ei][0][1]);
                master_lh[ei] = [germline_lh[ei][0]].push(...tmp_list);
              }
            }
          }
        }
        for (let ei = 0; ei < gstat_rd.length; ei++) {
          if (master_lh[ei][0][0] > 2) ;
          if (master_lh[ei][0][0] < 2) ;
          gstat_rd[ei] / this.globalMean;
          t_dist.t_test_1_sample(this.globalMean, gstat_rd[ei], gstat_error[ei], gstat_n[ei]);
        }
      }
    }
    var rawbinScore = this.formatDataStructure(this.wigFeatures, "binScore", this.globalMean);
    var callScore = this.formatDataStructure(this.wigFeatures, "segment_score", this.globalMean);
    return { binScore: rawbinScore, segment_score: callScore };
  }
  formatDataStructure(wigFeatures, feature_column, scaling_factor = 1) {
    const results = [];
    for (const [chr, wig] of Object.entries(wigFeatures)) {
      wig.forEach((sample) => {
        var new_sample = { ...sample };
        if (scaling_factor != 1) {
          new_sample.value = sample[feature_column] / scaling_factor * 2;
        }
        results.push(new_sample);
      });
    }
    return results;
  }
  formatDataStructure_BAF(feature_column, scaling_factor = 2) {
    const baf1 = [];
    const baf2 = [];
    for (const [chr, wig] of Object.entries(this.wigFeatures)) {
      wig.forEach((sample) => {
        var baf1_value = { ...sample };
        var baf2_value = { ...sample };
        let value = sample[feature_column];
        if (value != 0.5) {
          baf2_value.value = -2 * (1 - value);
          baf2.push(baf2_value);
        }
        baf1_value.value = -2 * value;
        baf1.push(baf1_value);
      });
    }
    return [baf1, baf2];
  }
}
function arrayMax(arr2) {
  return arr2.reduce(function(p, v) {
    return p > v ? p : v;
  });
}
function normal(x, a, x0, sigma) {
  return a * Math.exp(-1 * (x - x0) ** 2 / (2 * sigma ** 2)) / Math.sqrt(2 * Math.PI) / sigma;
}
function normal_overlap_approx(m1, s1, m2, s2) {
  return Math.exp(-1 * (m1 - m2) ** 2 / (s1 ** 2 + s2 ** 2));
}
function likelihood_overlap(likelihood_1, likelihood_2) {
  let sum;
  try {
    sum = likelihood_1.reduce((accumulator, currentValue, currentIndex) => {
      return accumulator + Math.min(currentValue, likelihood_2[currentIndex]);
    });
  } catch {
    console.log("Failed to find likelihood overlap: ", likelihood_1, likelihood_2);
    return 0;
  }
  return sum;
}
function normal_merge(m1, s1, m2, s2) {
  if (s1 == 0 && s2 == 0) {
    return { nl: 0.5 * (m1 + m2), ne: 0 };
  } else {
    return { nl: (m1 * s2 * s2 + m2 * s1 * s1) / (s1 * s1 + s2 * s2), ne: Math.sqrt(s1 * s1 * s2 * s2 / (s1 * s1 + s2 * s2)) };
  }
}
function likelihood_of_baf(likelihood, baf) {
  let bin = parseInt(baf * (likelihood.length - 1));
  let fr = baf * (likelihood.length - 1) - bin;
  if (bin < likelihood.length - 1) {
    return likelihood[bin] * (1 - fr) + likelihood[bin + 1] * fr;
  } else {
    return likelihood[bin];
  }
}
function likelihood_baf_pval(likelihood) {
  const res = likelihood.length;
  const max_lh = Math.max(...likelihood);
  let ix = likelihood.indexOf(max_lh);
  if (ix > Math.floor(res / 2)) {
    ix = res - 1 - ix;
  }
  const b = (res / 2 - ix) / (res + 1);
  const ix1 = Math.floor((res / 2 + ix) / 2);
  const ix2 = res - 1 - ix1;
  let p = likelihood.slice(ix1, ix2 + 1).reduce((acc, val) => acc + val, 0) / likelihood.reduce((acc, val) => acc + val, 0);
  if (ix === Math.floor(res / 2)) {
    p = 1;
  }
  return { mean: b, p };
}
var combined_caller = { CombinedCaller };
function erf(x) {
  var m = 1, s = 1, sum = x * 1;
  for (var i = 1; i < 50; i++) {
    m *= i;
    s *= -1;
    sum += s * Math.pow(x, 2 * i + 1) / (m * (2 * i + 1));
  }
  return 2 * sum / Math.sqrt(3.14159265358979);
}
function getEValue(mean, sigma, rd, start, end) {
  var arr2 = new DataStat(rd.slice(start, end));
  if (arr2.std == 0) {
    if (sigma > 0) {
      arr2.std = sigma * arr2.mean / mean;
    } else {
      arr2.std = 1;
    }
  }
  var p_val = t_test_1_sample(mean, arr2.mean, arr2.std, end - start) / (end - start);
  return p_val;
}
function gaussianEValue(mean, sigma, rd, start, end) {
  var arr2 = new DataStat(rd.slice(start, end));
  if (arr2.mean < mean) {
    var x = (arr2.max - arr2.mean) / (sigma * Math.sqrt(2));
    return Math.pow(0.5 * (1 + erf(x)), end - start);
  }
  var x = (arr2.min - arr2.mean) / (sigma * Math.sqrt(2));
  return Math.pow(0.5 * (1 - erf(x)), end - start);
}
function adjustToEvalue(mean, sigma, rd, start, end, pval, max_steps = 1e3) {
  var val = getEValue(mean, sigma, rd, start, end);
  var step = 0, done = false;
  while (val > pval & !done & step < max_steps) {
    done = true;
    step += 1;
    var [v1, v2, v3, v4] = [1e10, 1e10, 1e10, 1e10];
    if (start > 0) v1 = getEValue(mean, sigma, rd, start - 1, end);
    if (end - start > 2) {
      var v2 = getEValue(mean, sigma, rd, start + 1, end);
      var v3 = getEValue(mean, sigma, rd, start, end - 1);
    }
    if (end < rd.length) {
      var v4 = getEValue(mean, sigma, rd, start, end + 1);
    }
    if (Math.min[v4] < val) {
      done = false;
      if (v1 == Math.min[v4]) {
        start -= 1;
        val = v1;
      }
      elif(v2 == Math.min[v4]);
      {
        start += 1;
        val = v2;
      }
      elif(v3 == Math.min[v4]);
      {
        end -= 1;
        val = v3;
      }
      elif(v4 == Math.min[v4]);
      {
        end += 1;
        val = v4;
      }
    }
  }
  if (val <= pval) {
    return end;
  }
  return 0;
}
class DataStat {
  constructor(data_array) {
    this.data = data_array;
    this.mean = data_array.reduce((acc, n) => acc + n) / data_array.length;
    this.std = Math.sqrt(data_array.reduce((acc, n) => (n - this.mean) ** 2) / data_array.length);
  }
}
function t_test_1_sample(mean, m, s, n) {
  if (s == 0) s = 1;
  var t = (mean - m) / s * Math.sqrt(n);
  var p = 1 - t_dist.TdistributionCDF(Math.abs(t), n - 1);
  return p;
}
function t_test_2_samples(m1, s1, n1, m2, s2, n2) {
  if (s1 == 0) s1 = 1;
  if (s2 == 0) s2 = 1;
  var t = (m1 - m2) / Math.sqrt(s1 ** 2 / n1 + s2 ** 2 / n2);
  var df = (s1 ** 2 / n1 + s2 ** 2 / n2) ** 2 * (n1 - 1) * (n2 - 1) / (s1 ** 4 * (n2 - 1) / n1 ** 2 + s2 ** 4 * (n1 - 1) / n2 ** 2);
  var p = 1 - t_dist.TdistributionCDF(Math.abs(t), parseInt(df + 0.5));
  return p;
}
class Partition {
  constructor(rd, mean, std) {
    this.rd = rd;
    this.mean = mean;
    this.std = std;
    this.bin_bands = [2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128];
  }
  get_rd_signal_bandwidth(data_array) {
    var new_array = [];
    data_array.forEach((value, index2) => {
      var tmp_value = 0;
      if (value > this.mean / 4) {
        tmp_value = this.mean / (this.std ** 2 * value);
      } else {
        tmp_value = 4 / this.std ** 2;
      }
      new_array.push(tmp_value);
    });
    return new_array;
  }
  meanShiftCaller(repeats = 3) {
    var ChrLevels = {};
    Object.entries(this.rd).forEach(([chr, chr_rd]) => {
      var masked = new Array(chr_rd.length).fill(false);
      var levels = new Array(chr_rd.length);
      for (let b = 0; b < chr_rd.length; b++) {
        if (!masked[b]) {
          levels[b] = chr_rd[b];
        }
      }
      this.bin_bands.forEach((bin_band, bin_band_index) => {
        var not_masked = masked.map((value, index2) => {
          return !value;
        });
        var nm_levels = [];
        Object.entries(chr_rd).forEach(([k, v]) => {
          nm_levels.push(v.binScore);
        });
        var mask_borders = [0];
        var count = 0;
        for (let i2 = 0; i2 < masked.length; i2++) {
          if (masked[i2]) {
            if (count > 0) {
              mask_borders.push(mask_borders[mask_borders.length - 1] + count - 1);
              count = 0;
            }
          } else {
            count += 1;
          }
        }
        mask_borders.shift();
        for (let step = 0; step < repeats; step++) {
          var isig = this.get_rd_signal_bandwidth(nm_levels);
          var grad = new Array(nm_levels.length).fill(0);
          for (let i2 = 0; i2 < nm_levels.length; i2++) {
            for (let j2 = i2 - 3 * bin_band; j2 <= i2 + 3 * bin_band + 1; j2++) {
              if (j2 < 0 || j2 >= nm_levels.length) continue;
              if (Math.abs(i2 - j2) >= nm_levels.length) continue;
              var g_value = (j2 - i2) * Math.exp(-0.5 * (j2 - i2) ** 2 / bin_band ** 2) * Math.exp(-0.5 * (nm_levels[i2] - nm_levels[j2]) ** 2 * isig[i2]);
              grad[i2] += g_value;
            }
          }
          var border = new Array();
          for (var i = 0; i < grad.length - 1; i++) {
            if (grad[i] < 0 & grad[i + 1] >= 0) border.push(i);
          }
          border.push(grad.length - 1);
          border = border.concat(mask_borders).sort((a, b) => a - b);
          border = Array.from(new Set(border));
          var pb = 0;
          for (var i = 0; i < border.length; i++) {
            var range_array = nm_levels.slice(pb, border[i] + 1);
            var range_mean = range_array.reduce((acc, n2) => acc + n2) / range_array.length;
            nm_levels.fill(range_mean, pb, border[i] + 1);
            pb = border[i] + 1;
          }
        }
        for (var i = 0, j = 0; i < levels.length; i++) {
          if (not_masked[i]) {
            levels[i] = nm_levels[j];
            j++;
          }
        }
        var border = new Array();
        for (var i = 0; i < levels.length - 1; i++) {
          var diff = Math.abs(levels[i + 1] - levels[i]);
          if (diff > 0.01) border.push(i + 1);
        }
        border.unshift(0);
        border.push(levels.length);
        masked = new Array(this.rd.length).fill(false);
        for (var i = 1; i < border.length; i++) {
          var seg = [border[i - 1], border[i]];
          var seg_left = [border[i - 1], border[i - 1]];
          if (i > 1) {
            seg_left[0] = border[i - 2];
          } else continue;
          var seg_right = [border[i], border[i]];
          if (i < border.length - 1) {
            seg_right[1] = border[i + 1];
          } else continue;
          var n = seg[1] - seg[0];
          var n_left = seg_left[1] - seg_left[0];
          var n_right = seg_right[1] - seg_right[0];
          if (n <= 1) continue;
          var seg_array = new DataStat(levels.slice(seg[0], seg[1]));
          if (n_right <= 15 || n_left <= 15 || n <= 15) {
            var ns = 1.8 * Math.sqrt(levels[seg_left[0]] / this.mean) * this.std;
            if (Math.abs(levels[seg_left[0]] - levels[seg[0]]) < ns) {
              continue;
            }
            ns = 1.8 * Math.sqrt(levels[seg_right[0]] / this.mean) * this.std;
            if (Math.abs(levels[seg_right[0]] - levels[seg[0]]) < ns) {
              continue;
            }
          } else {
            var seg_left_array = levels.slice(seg_left[0], seg_left[1]);
            var seg_left_1 = new DataStat(seg_left_array);
            var seg_right_array = levels.slice(seg_right[0], seg_right[1]);
            var seg_right_1 = new DataStat(seg_right_array);
            var ttest_2sample_1 = t_test_2_samples(
              seg_array.mean,
              seg_array.std,
              seg_array.data.length,
              seg_left_1.mean,
              seg_left_1.std,
              seg_left_1.data.length
            );
            if (ttest_2sample_1 > 0.01 / genome_size * bin_size * (n + n_left)) {
              continue;
            }
            var ttest_2sample_2 = t_test_2_samples(
              seg_array.mean,
              seg_array.std,
              seg_array.data.length,
              seg_right_1.mean,
              seg_right_1.std,
              seg_right_1.data.length
            );
            if (ttest_2sample_2 > 0.01 / genome_size * bin_size * (n + n_right)) {
              continue;
            }
          }
          var ttest_1sample_1 = t_test_1_sample(this.mean, seg_array.mean, seg_array.std, seg_array.data.length);
          if (ttest_1sample_1 > 0.05) {
            continue;
          }
          let segments_rd = nm_levels.slice(seg[0], seg[1]);
          var raw_seg_data = new DataStat(segments_rd);
          masked.fill(true, seg[0], seg[1]);
          levels.fill(raw_seg_data.mean, seg[0], seg[1]);
        }
      });
      ChrLevels[chr] = levels;
    });
    return ChrLevels;
  }
  call_mean_shift(repeats = 3) {
    const bin_size2 = 1e3;
    const genome_size2 = 2871e6;
    var masked = new Array(this.rd.length).fill(false);
    var levels = new Array(this.rd.length);
    for (var b = 0; b < this.rd.length; b++) {
      if (!masked[b]) {
        levels[b] = this.rd[b];
      }
    }
    this.bin_bands.forEach((bin_band, bin_band_index) => {
      var not_masked = masked.map((value, index2) => {
        return !value;
      });
      var nm_levels = [];
      not_masked.forEach((value, index2) => {
        if (value) nm_levels.push(this.rd[index2]);
      });
      var mask_borders = [0];
      var count = 0;
      for (var i = 0; i < masked.length; i++) {
        if (masked[i]) {
          if (count > 0) {
            mask_borders.push(
              mask_borders[mask_borders.length - 1] + count - 1
            );
            count = 0;
          }
        } else {
          count += 1;
        }
      }
      mask_borders.shift();
      for (var step = 0; step < repeats; step++) {
        var isig = this.get_rd_signal_bandwidth(nm_levels);
        var grad = new Array(nm_levels.length).fill(0);
        for (var i = 0; i < nm_levels.length; i++) {
          for (var j = i - 3 * bin_band; j <= i + 3 * bin_band + 1; j++) {
            if (j < 0 || j >= nm_levels.length) continue;
            if (Math.abs(i - j) >= nm_levels.length) continue;
            var g_value = (j - i) * Math.exp(-0.5 * (j - i) ** 2 / bin_band ** 2) * Math.exp(-0.5 * (nm_levels[i] - nm_levels[j]) ** 2 * isig[i]);
            grad[i] += g_value;
          }
        }
        var border = new Array();
        for (var i = 0; i < grad.length - 1; i++) {
          if (grad[i] < 0 & grad[i + 1] >= 0) border.push(i);
        }
        border.push(grad.length - 1);
        border = border.concat(mask_borders).sort((a, b2) => a - b2);
        border = Array.from(new Set(border));
        var pb = 0;
        for (var i = 0; i < border.length; i++) {
          var range_array = nm_levels.slice(pb, border[i] + 1);
          var range_mean = range_array.reduce((acc, n2) => acc + n2) / range_array.length;
          nm_levels.fill(range_mean, pb, border[i] + 1);
          pb = border[i] + 1;
        }
      }
      for (var i = 0, j = 0; i < levels.length; i++) {
        if (not_masked[i]) {
          levels[i] = nm_levels[j];
          j++;
        }
      }
      var border = new Array();
      for (var i = 0; i < levels.length - 1; i++) {
        var diff = Math.abs(levels[i + 1] - levels[i]);
        if (diff > 0.01) border.push(i + 1);
      }
      border.unshift(0);
      border.push(levels.length);
      masked = new Array(this.rd.length).fill(false);
      for (var i = 1; i < border.length; i++) {
        var seg = [border[i - 1], border[i]];
        var seg_left = [border[i - 1], border[i - 1]];
        if (i > 1) {
          seg_left[0] = border[i - 2];
        } else continue;
        var seg_right = [border[i], border[i]];
        if (i < border.length - 1) {
          seg_right[1] = border[i + 1];
        } else continue;
        var n = seg[1] - seg[0];
        var n_left = seg_left[1] - seg_left[0];
        var n_right = seg_right[1] - seg_right[0];
        if (n <= 1) continue;
        var seg_array = new DataStat(levels.slice(seg[0], seg[1]));
        if (n_right <= 15 || n_left <= 15 || n <= 15) {
          var ns = 1.8 * Math.sqrt(levels[seg_left[0]] / this.mean) * this.std;
          if (Math.abs(levels[seg_left[0]] - levels[seg[0]]) < ns) {
            continue;
          }
          ns = 1.8 * Math.sqrt(levels[seg_right[0]] / this.mean) * this.std;
          if (Math.abs(levels[seg_right[0]] - levels[seg[0]]) < ns) {
            continue;
          }
        } else {
          var seg_left_array = levels.slice(seg_left[0], seg_left[1]);
          var seg_left_1 = new DataStat(seg_left_array);
          var seg_right_array = levels.slice(seg_right[0], seg_right[1]);
          var seg_right_1 = new DataStat(seg_right_array);
          var ttest_2sample_1 = t_test_2_samples(
            seg_array.mean,
            seg_array.std,
            seg_array.data.length,
            seg_left_1.mean,
            seg_left_1.std,
            seg_left_1.data.length
          );
          if (ttest_2sample_1 > 0.01 / genome_size2 * bin_size2 * (n + n_left)) {
            continue;
          }
          var ttest_2sample_2 = t_test_2_samples(
            seg_array.mean,
            seg_array.std,
            seg_array.data.length,
            seg_right_1.mean,
            seg_right_1.std,
            seg_right_1.data.length
          );
          if (ttest_2sample_2 > 0.01 / genome_size2 * bin_size2 * (n + n_right)) {
            continue;
          }
        }
        var ttest_1sample_1 = t_test_1_sample(
          this.mean,
          seg_array.mean,
          seg_array.std,
          seg_array.data.length
        );
        if (ttest_1sample_1 > 0.05) {
          continue;
        }
        var raw_seg_data = new DataStat(this.rd.slice(seg[0], seg[1]));
        masked.fill(true, seg[0], seg[1]);
        levels.fill(raw_seg_data.mean, seg[0], seg[1]);
      }
    });
    return levels;
  }
  cnv_calling(bin_size2 = 1e5) {
    var delta = 0.25;
    var delta = delta * this.mean;
    var min = this.mean - delta, max = this.mean + delta;
    var normal_genome_size = 2971e6;
    var levels = this.meanShiftCaller();
    var merged_level = {};
    var cnv_levels = [];
    Object.entries(levels).forEach(([chr, chr_levels]) => {
      var done = false;
      while (!done) {
        done = true;
        var borders = new Array(1).fill(0);
        for (let i = 0; i < chr_levels.length - 1; i++) {
          var diff = Math.abs(chr_levels[i + 1] - chr_levels[i]);
          if (diff > 0.01) borders.push(i + 1);
        }
        borders.push(chr_levels.length);
        for (let ix = 0; ix < borders.length - 2; ix++) {
          var v1 = Math.abs(chr_levels[borders[ix]] - chr_levels[borders[ix + 1]]);
          if (v1 < delta) {
            var v2 = v1 + 1, v3 = v1 + 1;
            if (ix > 0) {
              v2 = Math.abs(chr_levels[borders[ix]] - chr_levels[borders[ix - 1]]);
            }
            if (ix < borders.length - 3) {
              v3 = Math.abs(levels[borders[ix + 1]] - chr_levels[borders[ix + 2]]);
            }
            if (v1 < v2 && v1 < v3) {
              done = false;
              var tmp_array = new DataStat(chr_levels.slice(borders[ix], borders[ix + 2]));
              chr_levels.fill(tmp_array.mean, borders[ix], borders[ix + 2]);
              borders.splice(ix + 1, ix + 1);
            }
          }
        }
      }
      var chr_rd = [];
      Object.entries(this.rd[chr]).forEach(([bin, binDict]) => {
        chr_rd.push(binDict.binScore);
      });
      var flags = new Array(chr_levels.length).fill("");
      var b = 0;
      var pval = 0.05 * bin_size2 / normal_genome_size;
      while (b < chr_levels.length) {
        var b0 = b, border_start = b;
        while (b < chr_levels.length & chr_levels[b] < min) {
          b += 1;
        }
        var border_end = b;
        if (border_end > border_start + 1) {
          var adj = adjustToEvalue(this.mean, this.std, chr_rd, border_start, border_end, pval);
          if (adj) {
            var border_start, border_end = adj;
            flags.fill("D", border_start, border_end);
          }
        }
        border_start = b;
        while (b < chr_levels.length & chr_levels[b] > max) {
          b += 1;
        }
        border_end = b;
        if (border_end > border_start + 1) {
          adj = adjustToEvalue(this.mean, this.std, chr_rd, border_start, border_end, pval);
          if (adj) {
            border_end = adj;
            flags.fill("A", border_start, border_end);
          }
        }
        if (b == b0) b += 1;
      }
      b = 0;
      while (b < chr_levels.length) {
        while (b < chr_levels.length & flags[b] != "") b += 1;
        border_start = b;
        while (b < chr_levels.length & chr_levels[b] < min) b += 1;
        border_end = b;
        if (border_end > border_start + 1) {
          if (gaussianEValue(this.mean, this.std, chr_rd, border_start, border_end) < 0.05 / normal_genome_size) {
            flags.fill(["d"] * (border_end - border_start), border_start, border_end);
          }
          b -= 1;
        }
        b += 1;
      }
      b = 0;
      var cf;
      if (b < chr_levels.length) cf = flags[b];
      border_start = 0;
      var merge = [...chr_rd];
      while (b < chr_levels.length) {
        while (flags[b] == cf) {
          b += 1;
          if (b >= flags.length) break;
        }
        if (b > border_start) {
          var merge_arr = new DataStat(merge.slice(border_start, b));
          merge.fill(merge_arr.mean, border_start, b);
        }
        if (b < chr_levels.length) cf = flags[b];
        border_start = b;
      }
      merged_level[chr] = merge;
      b = 0;
      while (b < chr_levels.length) {
        cf = flags[b];
        if (cf == "") {
          b += 1;
          continue;
        }
        border_start = b;
        while (b < chr_levels.length & cf == flags[b]) {
          b += 1;
        }
        var border_arr = new DataStat(merge.slice(border_start, b));
        let cnv = border_arr.mean / this.mean;
        let event_type;
        if (cf == "D") {
          event_type = "deletion";
        } else {
          event_type = "duplication";
        }
        let cnv_dict = {
          chr,
          start: bin_size2 * border_start + 1,
          end: bin_size2 * b,
          size: bin_size2 * (b - border_start + 1),
          value: cnv * 2,
          event_type
        };
        cnv_levels.push(cnv_dict);
      }
    });
    return [merged_level, cnv_levels];
  }
}
var read_depth_caller = { Partition };
class CNVpytorVCF {
  constructor(allVariants, binSize) {
    this.allVariants = allVariants;
    this.rowBinSize = 1e4;
    this.binSize = binSize;
    this.binFactor = binSize / this.rowBinSize;
  }
  async computeDepthFeatures() {
    const chromosomes = Object.keys(this.allVariants);
    const wigFeatures = [];
    for (let chr of chromosomes) {
      const variants = this.allVariants[chr];
      if (variants.length === 0) continue;
      const firstSnp = variants[0];
      let sum = 0;
      let count = 0;
      let binStart = firstSnp.start = firstSnp.start % this.binSize;
      let binEnd = binStart + this.binSize;
      let featureBin = 0;
      for (let snp of variants) {
        const position = snp.start + 1;
        featureBin = Math.max(Math.floor((snp.start - 1) / this.binSize), 0);
        if (position > binEnd) {
          if (count > 0) {
            wigFeatures.push({ chr, start: binStart, end: binEnd, value: sum, bin: featureBin, count });
          }
          sum = 0;
          binStart = snp.start - snp.start % this.binSize;
          binEnd = binStart + this.binSize;
        }
        const dpValue = snp.calls[9].info["DP"];
        if (dpValue) {
          sum += Number.parseInt(dpValue);
          count++;
        }
      }
      if (count > 0) {
        wigFeatures.push({ chr, start: binStart, end: binEnd, value: sum, bin: featureBin, count });
      }
    }
    return wigFeatures;
  }
  // for for read depth calculation
  async computeReadDepth() {
    const chromosomes = Object.keys(this.allVariants);
    var wigFeatures = {};
    for (let chr of chromosomes) {
      const variants = this.allVariants[chr];
      var featureBin;
      if (variants.length === 0) continue;
      for (let snp of variants) {
        featureBin = Math.max(Math.floor(snp.start / this.rowBinSize), 0);
        if (!wigFeatures[chr]) {
          wigFeatures[chr] = [];
        }
        if (!wigFeatures[chr][featureBin]) {
          wigFeatures[chr][featureBin] = {
            chr,
            start: featureBin * this.rowBinSize,
            end: (featureBin + 1) * this.rowBinSize,
            value: 0,
            sum_score: 0,
            count: 0
          };
        }
        const dpValue = snp.calls[9].info["DP"];
        if (dpValue) {
          wigFeatures[chr][featureBin].sum_score += Number.parseInt(dpValue);
          wigFeatures[chr][featureBin].count++;
        }
      }
    }
    var avgbin = {};
    for (let chr of chromosomes) {
      if (!avgbin[chr]) {
        avgbin[chr] = [];
      }
      for (let k = 0; k < wigFeatures[chr].length / this.binFactor; k++) {
        const featureBin2 = k;
        if (!avgbin[chr][k]) {
          avgbin[chr][k] = {
            chr,
            binScore: 0,
            start: featureBin2 * this.binSize,
            end: (featureBin2 + 1) * this.binSize
          };
        }
        for (var j = k * 10; j < 10 * k + 10; j++) {
          if (wigFeatures[chr][j]) {
            var tmp_score = parseInt(wigFeatures[chr][j].sum_score / wigFeatures[chr][j].count) * 100;
            avgbin[chr][k].binScore += tmp_score;
          }
        }
      }
    }
    var finalFeatureSet = this.readDepthMeanshift(avgbin);
    return finalFeatureSet;
  }
  readDepthMeanshift(wigFeatures) {
    var fit_info = new g_utils.GetFit(wigFeatures);
    var [globamMean, globalStd] = fit_info.fit_data();
    var partition = new read_depth_caller.Partition(wigFeatures, globamMean, globalStd);
    var partition_array = partition.meanShiftCaller();
    var caller_array = partition.cnv_calling();
    Object.entries(wigFeatures).forEach(([chr, chr_rd]) => {
      chr_rd.forEach((bin, index2) => {
        bin.partition_level = parseInt(partition_array[chr][index2]);
        bin.partition_call = parseInt(caller_array[0][chr][index2]);
      });
    });
    var rawbinScore = this.formatDataStructure(wigFeatures, "binScore", globamMean);
    var partition_levels = this.formatDataStructure(wigFeatures, "partition_level", globamMean);
    var partition_call = this.formatDataStructure(wigFeatures, "partition_call", globamMean);
    return [rawbinScore, partition_levels, partition_call, caller_array[1]];
  }
  formatDataStructure(wigFeatures, feature_column, scaling_factor = 1) {
    const results = [];
    for (const [chr, wig] of Object.entries(wigFeatures)) {
      wig.forEach((sample) => {
        var new_sample = { ...sample };
        if (scaling_factor != 1) {
          new_sample.value = sample[feature_column] / scaling_factor * 2;
        }
        results.push(new_sample);
      });
    }
    return results;
  }
  async computeBAF_v2() {
    const chromosomes = Object.keys(this.allVariants);
    const wigFeatures = {};
    const baf1 = [], baf2 = [];
    for (let chr of chromosomes) {
      const variants = this.allVariants[chr];
      if (variants.length === 0) continue;
      var featureBin;
      for (let snp of variants) {
        featureBin = Math.max(Math.floor(snp.start / this.binSize), 0);
        if (!wigFeatures[chr]) {
          wigFeatures[chr] = [];
        }
        if (!wigFeatures[chr][featureBin]) {
          if (featureBin > 0) {
            let previous_featureBin = featureBin - 1;
            if (wigFeatures[chr][previous_featureBin]) {
              const updated_bin2 = this.get_max_min_score(wigFeatures[chr][previous_featureBin]);
              if (updated_bin2.value != 0.5) {
                let baf_wig = Object.assign({}, updated_bin2);
                baf_wig.value = -2 * (1 - updated_bin2.value);
                baf2.push(baf_wig);
              }
              updated_bin2.value = -2 * updated_bin2.value;
              wigFeatures[chr][previous_featureBin] = updated_bin2;
              baf1.push(wigFeatures[chr][previous_featureBin]);
            }
          }
          wigFeatures[chr][featureBin] = {
            chr,
            start: featureBin * this.binSize,
            end: (featureBin + 1) * this.binSize,
            value: 0,
            count: 0,
            likelihood_score: [],
            min_score: 0
          };
        }
        const calls = snp.calls[9];
        let genotype = calls.genotype;
        let ad_score = calls.info["AD"].split(",");
        let ad_a = ad_score[0], ad_b = ad_score[1];
        if (genotype[0] == 0 && genotype[1] == 1 || genotype[0] == 1 && genotype[1] == 0) {
          if (wigFeatures[chr][featureBin].likelihood_score.length == 0) {
            wigFeatures[chr][featureBin].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
              return beta(ad_a, ad_b, value);
            });
          } else {
            var sum = 0;
            wigFeatures[chr][featureBin].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
              var likelihood_value = wigFeatures[chr][featureBin].likelihood_score[index2] * beta(ad_a, ad_b, value);
              sum = sum + likelihood_value;
              return likelihood_value;
            });
            wigFeatures[chr][featureBin].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
              return wigFeatures[chr][featureBin].likelihood_score[index2] / sum;
            });
          }
          wigFeatures[chr][featureBin].count++;
        }
      }
      const updated_bin = this.get_max_min_score(wigFeatures[chr][featureBin]);
      if (updated_bin.value != 0.5) {
        let baf_wig = Object.assign({}, updated_bin);
        baf_wig.value = -2 * (1 - updated_bin.value);
        baf2.push(baf_wig);
      }
      updated_bin.value = -2 * updated_bin.value;
      wigFeatures[chr][featureBin] = updated_bin;
      baf1.push(wigFeatures[chr][featureBin]);
    }
    return [baf1, baf2];
  }
  format_BAF_likelihood(wigFeatures) {
    const results = [];
    for (const [chr, wig] of Object.entries(wigFeatures)) {
      wig.forEach((sample) => {
        var new_sample = { ...sample };
        if (sample.value != 0.5) {
          new_sample.value = 1 - sample.value;
          results.push(new_sample);
        }
      });
    }
    return results;
  }
  get_max_min_score(sample) {
    if (sample.likelihood_score.length > 0) {
      const max = Math.max(...sample.likelihood_score);
      const res = sample.likelihood_score.indexOf(max);
      sample.value = Math.max(res / 100, 1 - res / 100);
      sample.min_score = Math.min(res / 100, 1 - res / 100);
    } else {
      sample.score = 0;
    }
    return sample;
  }
  async getAllbins() {
    const bins = await this.computeDepthFeatures();
    const fitter = new g_utils.GetFit(bins);
    fitter.fit_data();
    return bins;
  }
  async read_rd_baf(caller = "ReadDepth") {
    const chromosomes = Object.keys(this.allVariants);
    var wigFeatures = {};
    for (let chr of chromosomes) {
      const variants = this.allVariants[chr];
      var featureBin;
      if (variants.length === 0) continue;
      for (let snp of variants) {
        featureBin = Math.max(Math.floor(snp.start / this.rowBinSize), 0);
        if (!wigFeatures[chr]) {
          wigFeatures[chr] = [];
        }
        if (!wigFeatures[chr][featureBin]) {
          wigFeatures[chr][featureBin] = {
            chr,
            start: featureBin * this.rowBinSize,
            end: (featureBin + 1) * this.rowBinSize,
            // value: 0,
            dp_sum_score: 0,
            dp_count: 0,
            hets_count: 0,
            hets: []
            //likelihood_score: [],
          };
        }
        const calls = snp.calls[9];
        const dpValue = calls.info["DP"];
        if (dpValue) {
          wigFeatures[chr][featureBin].dp_sum_score += Number.parseInt(dpValue);
          wigFeatures[chr][featureBin].dp_count++;
        }
        let ad_score = calls.info["AD"].split(",");
        let genotype = calls.genotype;
        if (genotype[0] == 0 && genotype[1] == 1 || genotype[0] == 1 && genotype[1] == 0) {
          wigFeatures[chr][featureBin].hets_count++;
          let ad_a = parseInt(ad_score[0]), ad_b = parseInt(ad_score[1]);
          wigFeatures[chr][featureBin].hets.push({ ref: ad_a, alt: ad_b });
        }
      }
    }
    var avgbin = this.adjust_bin_size(wigFeatures);
    var finalFeatureSet;
    if (caller == "ReadDepth") {
      finalFeatureSet = this.readDepthMeanshift(avgbin);
      var baf = this.formatDataStructure_BAF(avgbin, "max_likelihood");
    } else if (caller == "2D") {
      let caller_obj = new combined_caller.CombinedCaller(avgbin, this.binSize);
      let processed_bins = await caller_obj.call_2d();
      finalFeatureSet = [processed_bins.binScore, [], processed_bins.segment_score];
      var baf = caller_obj.formatDataStructure_BAF("max_likelihood");
    }
    return [finalFeatureSet, baf];
  }
  formatDataStructure_BAF(wigFeatures, feature_column, scaling_factor = 2) {
    const baf1 = [];
    const baf2 = [];
    for (const [chr, wig] of Object.entries(wigFeatures)) {
      wig.forEach((sample) => {
        delete sample.likelihood_score;
        var baf1_value = { ...sample };
        var baf2_value = { ...sample };
        let value = sample[feature_column];
        if (value != 0.5) {
          baf2_value.value = -2 * (1 - value);
          baf2.push(baf2_value);
        }
        baf1_value.value = -2 * value;
        baf1.push(baf1_value);
      });
    }
    return [baf1, baf2];
  }
  adjust_bin_size(wigFeatures) {
    const chromosomes = Object.keys(this.allVariants);
    var avgbin = {};
    for (let chr of chromosomes) {
      if (!avgbin[chr]) {
        avgbin[chr] = [];
      }
      for (let k = 0; k < wigFeatures[chr].length / this.binFactor; k++) {
        const featureBin = k;
        if (!avgbin[chr][k]) {
          avgbin[chr][k] = {
            chr,
            start: featureBin * this.binSize,
            end: (featureBin + 1) * this.binSize,
            dp_count: 0,
            hets_count: 0,
            binScore: 0,
            likelihood_score: []
          };
        }
        for (var j = k * 10; j < 10 * k + 10; j++) {
          if (wigFeatures[chr][j]) {
            var tmp_score = parseInt(wigFeatures[chr][j].dp_sum_score / wigFeatures[chr][j].dp_count) * 100;
            avgbin[chr][k].binScore += tmp_score;
            avgbin[chr][k].dp_count += wigFeatures[chr][j].dp_count;
            avgbin[chr][k].hets_count += wigFeatures[chr][j].hets_count;
            if (wigFeatures[chr][j].hets.length != 0) {
              wigFeatures[chr][j].hets.forEach((hets, hets_idx) => {
                if (avgbin[chr][k].likelihood_score.length == 0) {
                  avgbin[chr][k].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
                    return beta(hets.ref, hets.alt, value);
                  });
                } else {
                  var likelihood_sum = 0;
                  avgbin[chr][k].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
                    var likelihood_value = avgbin[chr][k].likelihood_score[index2] * beta(hets.ref, hets.alt, value);
                    likelihood_sum += likelihood_value;
                    return likelihood_value;
                  });
                  avgbin[chr][k].likelihood_score = g_utils.linspace(0, 1, 100).map((value, index2) => {
                    return avgbin[chr][k].likelihood_score[index2] / likelihood_sum;
                  });
                }
              });
            }
          }
        }
        const updated_bin = this.get_max_min_score(avgbin[chr][k]);
        avgbin[chr][k].max_likelihood = updated_bin.value;
      }
    }
    return avgbin;
  }
}
function beta(a, b, p, phased = true) {
  return p ** a * (1 - p) ** b + p ** b * (1 - p) ** a;
}
const DEFAULT_TRACK_HEIGHT = 250;
class CNVPytorTrack extends TrackBase {
  constructor(config, browser) {
    super(config, browser);
    this.featureType = "numeric";
    this.paintAxis = paintAxis;
    if (!config.max) {
      this.defaultScale = true;
      this.autoscale = false;
    }
    this.height = config.height !== void 0 ? config.height : DEFAULT_TRACK_HEIGHT;
  }
  async init(config) {
    this.type = "cnvpytor";
    this.graphType = config.graphType || "points";
    this.bin_size = config.bin_size || 1e5;
    this.signal_name = config.signal_name || "rd_snp";
    this.cnv_caller = config.cnv_caller || "2D";
    this.colors = config.colors || ["gray", "black", "green", "blue"];
    super.init(config);
  }
  get supportsWholeGenome() {
    return true;
  }
  get_signals() {
    let signals = [];
    if (this.signal_name == "rd_snp") {
      signals = ["RD_Raw", "RD_Raw_gc_coor", this.cnv_caller, "BAF1", "BAF2"];
    } else if (this.signal_name == "rd") {
      signals = ["RD_Raw", "RD_Raw_gc_coor", this.cnv_caller];
    } else if (this.signal_name == "snp") {
      signals = ["BAF1", "BAF2"];
    } else if (this.signal_name == "cnh") {
      signals = [this.cnv_caller];
    }
    return signals;
  }
  get_signal_colors() {
    let signal_colors = [
      { singal_name: "RD_Raw", color: this.colors[0] },
      { singal_name: "RD_Raw_gc_coor", color: this.colors[1] },
      { singal_name: "ReadDepth", color: this.colors[2] },
      { singal_name: "2D", color: this.colors[2] },
      { singal_name: "BAF1", color: this.colors[3] },
      { singal_name: "BAF2", color: this.colors[3] }
    ];
    return signal_colors;
  }
  async postInit() {
    if (this.config.format == "vcf") {
      this.featureSource = FeatureSource(this.config, this.browser.genome);
      this.header = await this.getHeader();
      var allVariants = this.featureSource.reader.features.reduce(function(r, a) {
        r[a.chr] = r[a.chr] || [];
        r[a.chr].push(a);
        return r;
      }, /* @__PURE__ */ Object.create(null));
      const cnvpytor_obj = new CNVpytorVCF(allVariants, this.bin_size);
      let wigFeatures;
      let bafFeatures;
      this.wigFeatures_obj = {};
      this.wigFeatures_obj[this.bin_size] = {};
      let dataWigs;
      if (this.config.cnv_caller == "2D") {
        dataWigs = await cnvpytor_obj.read_rd_baf("2D");
        wigFeatures = dataWigs[0];
        bafFeatures = dataWigs[1];
        this.wigFeatures_obj[this.bin_size]["2D"] = wigFeatures[2];
        this.available_callers = ["2D"];
      } else {
        dataWigs = await cnvpytor_obj.read_rd_baf();
        wigFeatures = dataWigs[0];
        bafFeatures = dataWigs[1];
        this.wigFeatures_obj[this.bin_size]["ReadDepth"] = wigFeatures[2];
        this.available_callers = ["ReadDepth"];
      }
      this.wigFeatures_obj[this.bin_size]["RD_Raw"] = wigFeatures[0];
      this.wigFeatures_obj[this.bin_size]["RD_Raw_gc_coor"] = wigFeatures[1];
      this.wigFeatures_obj[this.bin_size]["BAF1"] = bafFeatures[0];
      this.wigFeatures_obj[this.bin_size]["BAF2"] = bafFeatures[1];
      this.available_bins = [this.bin_size];
      this.set_available_callers();
    } else {
      this.cnvpytor_obj = new HDF5Reader(this.config.url, this.bin_size);
      this.wigFeatures_obj = await this.cnvpytor_obj.get_rd_signal(this.bin_size);
      this.available_bins = this.cnvpytor_obj.available_bins;
      this.available_callers = this.cnvpytor_obj.callers;
      this.set_available_callers();
    }
    this.tracks = [];
    const p = [];
    this.signals = this.get_signals();
    this.signal_colors = this.get_signal_colors();
    for (let bin_size2 in this.wigFeatures_obj) {
      for (const [signal_name, wig] of Object.entries(this.wigFeatures_obj[bin_size2])) {
        if (this.signals.includes(signal_name)) {
          let tconf = {};
          tconf.type = "wig";
          tconf.isMergedTrack = true;
          tconf.features = wig;
          tconf.name = signal_name;
          tconf.color = this.signal_colors.filter((x) => x.singal_name === signal_name).map((x) => x.color);
          const t = await this.browser.createTrack(tconf);
          if (t) {
            t.autoscale = false;
            this.tracks.push(t);
          } else {
            console.warn("Could not create track " + tconf);
          }
          if (typeof t.postInit === "function") {
            p.push(t.postInit());
          }
        }
      }
    }
    this.flipAxis = this.config.flipAxis ? this.config.flipAxis : false;
    this.logScale = this.config.logScale ? this.config.logScale : false;
    this.autoscale = this.config.autoscale;
    if (!this.autoscale) {
      this.dataRange = {
        min: this.config.min || 0,
        max: this.config.max
      };
    }
    for (let t of this.tracks) {
      t.autoscale = false;
      t.dataRange = this.dataRange;
    }
    return Promise.all(p);
  }
  set_available_callers() {
    if (!this.available_callers.includes(this.cnv_caller)) {
      if (this.available_callers.length > 0) {
        this.cnv_caller = this.available_callers[0];
      } else {
        this.cnv_caller = null;
      }
    }
  }
  async getHeader() {
    if (!this.header) {
      if (typeof this.featureSource.getHeader === "function") {
        const header = await this.featureSource.getHeader();
        if (header) {
          this.callSets = header.callSets || [];
        }
        this.header = header;
      }
      this.sampleNames = this.callSets ? this.callSets.map((cs) => cs.name) : [];
    }
    return this.header;
  }
  get height() {
    return this._height;
  }
  set height(h) {
    this._height = h;
    if (this.tracks) {
      for (let t of this.tracks) {
        t.height = h;
        t.config.height = h;
      }
    }
  }
  menuItemList() {
    let items = [];
    if (this.flipAxis !== void 0) {
      items.push({
        label: "Flip y-axis",
        click: () => {
          this.flipAxis = !this.flipAxis;
          this.trackView.repaintViews();
        }
      });
    }
    items = items.concat(MenuUtils$1.numericDataMenuItems(this.trackView));
    items.push("<hr/>");
    items.push("Bin Sizes");
    for (let rd_bin of this.available_bins) {
      const checkBox = createCheckbox$2(rd_bin, rd_bin === this.bin_size);
      items.push({
        object: $$1(checkBox),
        click: async () => {
          this.bin_size = rd_bin;
          await this.recreate_tracks(rd_bin);
          this.clearCachedFeatures();
          this.trackView.updateViews();
          this.trackView.repaintViews();
        }
      });
    }
    items.push("<hr/>");
    items.push("Signal Type");
    let signal_dct = { "rd_snp": "RD and BAF Likelihood", "rd": "RD Signal", "snp": "BAF Likelihood" };
    for (let signal_name in signal_dct) {
      const checkBox = createCheckbox$2(signal_dct[signal_name], signal_name === this.signal_name);
      items.push({
        object: $$1(checkBox),
        click: async () => {
          this.signal_name = signal_name;
          await this.recreate_tracks(this.bin_size);
          this.clearCachedFeatures();
          this.trackView.updateViews();
          this.trackView.repaintViews();
        }
      });
    }
    items.push("<hr/>");
    items.push("CNV caller");
    for (let cnv_caller of this.available_callers) {
      const checkBox = createCheckbox$2(cnv_caller, cnv_caller === this.cnv_caller);
      items.push({
        object: $$1(checkBox),
        click: async () => {
          this.cnv_caller = cnv_caller;
          await this.recreate_tracks(this.bin_size);
          this.clearCachedFeatures();
          this.trackView.updateViews();
          this.trackView.repaintViews();
        }
      });
    }
    return items;
  }
  async recreate_tracks(bin_size2) {
    this.tracks = [];
    const p = [];
    if (!(bin_size2 in this.wigFeatures_obj)) {
      this.wigFeatures_obj = { ...this.wigFeatures_obj, ...await this.cnvpytor_obj.get_rd_signal(bin_size2) };
    }
    this.signals = this.get_signals();
    this.signal_colors = this.get_signal_colors();
    for (const [signal_name, wig] of Object.entries(this.wigFeatures_obj[bin_size2])) {
      if (this.signals.includes(signal_name)) {
        let tconf = {};
        tconf.type = "wig";
        tconf.isMergedTrack = true;
        tconf.features = wig;
        tconf.name = signal_name;
        tconf.color = this.signal_colors.filter((x) => x.singal_name === signal_name).map((x) => x.color);
        const t = await this.browser.createTrack(tconf);
        if (t) {
          t.autoscale = false;
          this.tracks.push(t);
        } else {
          console.warn("Could not create track " + tconf);
        }
        if (typeof t.postInit === "function") {
          p.push(t.postInit());
        }
      }
    }
    this.flipAxis = this.config.flipAxis ? this.config.flipAxis : false;
    this.logScale = this.config.logScale ? this.config.logScale : false;
    this.autoscale = this.config.autoscale;
    if (!this.autoscale) {
      this.dataRange = {
        min: this.config.min || 0,
        max: this.config.max
      };
    }
    for (let t of this.tracks) {
      t.autoscale = false;
      t.dataRange = this.dataRange;
    }
    return Promise.all(p);
  }
  async getFeatures(chr, bpStart, bpEnd, bpPerPixel) {
    if (this.tracks) {
      const promises = this.tracks.map((t) => t.getFeatures(chr, bpStart, bpEnd, bpPerPixel));
      return Promise.all(promises);
    } else {
      return void 0;
    }
  }
  // TODO: refactor to igvUtils.js
  getScaleFactor(min, max, height, logScale) {
    const scale = logScale ? height / (Math.log10(max + 1) - (min <= 0 ? 0 : Math.log10(min + 1))) : height / (max - min);
    return scale;
  }
  computeYPixelValue(yValue, yScaleFactor) {
    return (this.flipAxis ? yValue - this.dataRange.min : this.dataRange.max - yValue) * yScaleFactor;
  }
  computeYPixelValueInLogScale(yValue, yScaleFactor) {
    let maxValue = this.dataRange.max;
    let minValue = this.dataRange.min;
    if (maxValue <= 0) return 0;
    if (minValue <= -1) minValue = 0;
    minValue = minValue <= 0 ? 0 : Math.log10(minValue + 1);
    maxValue = Math.log10(maxValue + 1);
    yValue = Math.log10(yValue + 1);
    return (this.flipAxis ? yValue - minValue : maxValue - yValue) * yScaleFactor;
  }
  draw(options2) {
    const mergedFeatures = options2.features;
    if (!mergedFeatures) return;
    if (this.defaultScale) {
      if (this.signal_name == "rd_snp") {
        this.dataRange = {
          min: this.config.min || this.dataRange.min || -2,
          max: this.config.max || this.dataRange.max || 6
        };
      } else if (this.signal_name == "rd") {
        this.dataRange = {
          min: this.config.min || this.dataRange.min || 0,
          max: this.config.max || this.dataRange.max || 6
        };
      } else if (this.signal_name == "snp") {
        this.dataRange = {
          min: this.config.min || this.dataRange.min || -2,
          max: this.config.max || this.dataRange.max || 0
        };
      }
    }
    if (this.autoscale) {
      this.dataRange = autoscale(options2.referenceFrame.chr, mergedFeatures);
    }
    if (this.tracks) {
      for (let i = 0, len2 = this.tracks.length; i < len2; i++) {
        const trackOptions = Object.assign({}, options2);
        trackOptions.features = mergedFeatures[i];
        this.tracks[i].dataRange = this.dataRange;
        this.tracks[i].flipAxis = this.flipAxis;
        this.tracks[i].logScale = this.logScale;
        if (this.graphType) {
          this.tracks[i].graphType = this.graphType;
        }
        this.tracks[i].draw(trackOptions);
      }
    }
    const scaleFactor = this.getScaleFactor(this.dataRange.min, this.dataRange.max, options2.pixelHeight, this.logScale);
    const yScale = (yValue) => this.logScale ? this.computeYPixelValueInLogScale(yValue, scaleFactor) : this.computeYPixelValue(yValue, scaleFactor);
    if (this.config.hasOwnProperty("guideLines")) {
      for (let line of this.config.guideLines) {
        if (line.hasOwnProperty("color") && line.hasOwnProperty("y") && line.hasOwnProperty("dotted")) {
          let y = yScale(line.y);
          let props = {
            "strokeStyle": line["color"],
            "strokeWidth": 1
          };
          if (line["dotted"]) IGVGraphics.dashedLine(options2.context, 0, y, options2.pixelWidth, y, 5, props);
          else IGVGraphics.strokeLine(options2.context, 0, y, options2.pixelWidth, y, props);
        }
      }
    }
  }
  popupData(clickState, features) {
    const featuresArray = features || clickState.viewport.cachedFeatures;
    if (featuresArray && featuresArray.length === this.tracks.length) {
      const popupData = [];
      for (let i = 0; i < this.tracks.length; i++) {
        if (i > 0) popupData.push("<hr/>");
        popupData.push(`<div style=background-color:rgb(245,245,245);border-bottom-style:dashed;border-bottom-width:1px;padding-bottom:5px;padding-top:10px;font-weight:bold;font-size:larger >${this.tracks[i].name}</div>`);
        const trackPopupData = this.tracks[i].popupData(clickState, featuresArray[i]);
        popupData.push(...trackPopupData);
      }
      return popupData;
    }
  }
}
function autoscale(chr, featureArrays) {
  let min = 0;
  let max = -Number.MAX_VALUE;
  for (let features of featureArrays) {
    for (let f of features) {
      if (typeof f.value !== "undefined" && !Number.isNaN(f.value)) {
        min = Math.min(min, f.value);
        max = Math.max(max, f.value);
      }
    }
  }
  return { min, max };
}
const trackFunctions = /* @__PURE__ */ new Map([
  ["ideogram", (config, browser) => new IdeogramTrack(config, browser)],
  ["sequence", (config, browser) => new SequenceTrack(config, browser)],
  ["feature", (config, browser) => new FeatureTrack(config, browser)],
  ["seg", (config, browser) => new SegTrack(config, browser)],
  ["mut", (config, browser) => new SegTrack(config, browser)],
  ["maf", (config, browser) => new SegTrack(config, browser)],
  ["wig", (config, browser) => new WigTrack(config, browser)],
  ["merged", (config, browser) => new MergedTrack(config, browser)],
  ["alignment", (config, browser) => new BAMTrack(config, browser)],
  ["interaction", (config, browser) => new InteractionTrack(config, browser)],
  ["interact", (config, browser) => new InteractionTrack(config, browser)],
  ["variant", (config, browser) => new VariantTrack(config, browser)],
  ["eqtl", (config, browser) => new EqtlTrack(config, browser)],
  ["gwas", (config, browser) => new GWASTrack(config, browser)],
  ["arc", (config, browser) => new RnaStructTrack(config, browser)],
  ["gcnv", (config, browser) => new GCNVTrack(config, browser)],
  ["junction", (config, browser) => new SpliceJunctionTrack(config, browser)],
  ["blat", (config, browser) => new BlatTrack(config, browser)],
  ["cnvpytor", (config, browser) => new CNVPytorTrack(config, browser)]
]);
const addTrackCreatorFunction = function(type, track) {
  trackFunctions.set(type, track);
};
const getTrack = function(type, config, browser) {
  let trackKey;
  switch (type) {
    case "annotation":
    case "genes":
    case "fusionjuncspan":
    case "snp":
      trackKey = "feature";
      break;
    case "seg":
    case "maf":
    case "mut":
      trackKey = "seg";
      break;
    case "junctions":
    case "splicejunctions":
      trackKey = "junction";
      break;
    default:
      trackKey = type;
  }
  return trackFunctions.has(trackKey) ? trackFunctions.get(trackKey)(config, browser) : void 0;
};
var TrackFactory = {
  tracks: trackFunctions,
  addTrack: addTrackCreatorFunction,
  trackFunctions,
  addTrackCreatorFunction,
  getTrack
};
class XMLSession {
  constructor(xmlString, knownGenomes2) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlString, "text/xml");
    this.processRootNode(xmlDoc, knownGenomes2);
    const resourceElements = xmlDoc.getElementsByTagName("Resource");
    const trackElements = xmlDoc.getElementsByTagName("Track");
    const hasTrackElements = trackElements && trackElements.length > 0;
    const tracks = [];
    this.tracks = tracks;
    const resourceMap = /* @__PURE__ */ new Map();
    Array.from(resourceElements).forEach(function(r, idx) {
      var config = {
        url: r.getAttribute("path"),
        indexURL: r.getAttribute("index"),
        order: idx
      };
      resourceMap.set(config.url, config);
      if (!hasTrackElements) {
        tracks.push(config);
      }
    });
    if (hasTrackElements) {
      Array.from(trackElements).forEach(function(track) {
        const subtracks = track.getElementsByTagName("Track");
        if (subtracks && subtracks.length > 0) {
          const mergedTrack = {
            type: "merged",
            tracks: []
          };
          extractTrackAttributes(track, mergedTrack);
          tracks.push(mergedTrack);
          Array.from(subtracks).forEach(function(t) {
            t.processed = true;
            const id = t.getAttribute("id");
            const config = resourceMap.get(id);
            if (config) {
              mergedTrack.tracks.push(config);
              extractTrackAttributes(t, config);
              config.autoscale = false;
              mergedTrack.height = config.height;
            }
          });
        } else if (!track.processed) {
          const id = track.getAttribute("id");
          const res = resourceMap.get(id);
          if (res) {
            tracks.push(res);
            extractTrackAttributes(track, res);
          }
        }
      });
    }
  }
  processRootNode(xmlDoc, knownGenomes2) {
    const elements = xmlDoc.getElementsByTagName("Session");
    if (!elements || elements.length === 0) ;
    const session = elements.item(0);
    const genome = session.getAttribute("genome");
    const locus = session.getAttribute("locus");
    const ucscID = session.getAttribute("ucscID");
    if (knownGenomes2 && knownGenomes2.hasOwnProperty(genome)) {
      this.genome = genome;
    } else {
      this.reference = {
        fastaURL: genome
      };
      if (ucscID) {
        this.reference.id = ucscID;
      }
    }
    if (locus) {
      this.locus = locus;
    }
  }
}
function extractTrackAttributes(track, config) {
  config.name = track.getAttribute("name");
  const color = track.getAttribute("color");
  if (color) {
    config.color = "rgb(" + color + ")";
  }
  const altColor = track.getAttribute("altColor");
  if (color) {
    config.altColor = "rgb(" + altColor + ")";
  }
  const height = track.getAttribute("height");
  if (height) {
    config.height = parseInt(height);
  }
  const autoScale = track.getAttribute("autoScale");
  if (autoScale) {
    config.autoscale = autoScale === "true";
  }
  const autoscaleGroup = track.getAttribute("autoscaleGroup");
  if (autoscaleGroup) {
    config.autoscaleGroup = autoscaleGroup;
  }
  const windowFunction = track.getAttribute("windowFunction");
  if (windowFunction) {
    config.windowFunction = windowFunction;
  }
  const visWindow = track.getAttribute("visibilityWindow") || track.getAttribute("featureVisibilityWindow");
  if (visWindow) {
    config.visibilityWindow = visWindow;
  }
  const indexed = track.getAttribute("indexed");
  if (indexed) {
    config.indexed = indexed === "true";
  }
  const normalize2 = track.getAttribute("normalize");
  if (normalize2) {
    config.normalize = normalize2 === "true";
  }
  const dataRangeCltn = track.getElementsByTagName("DataRange");
  if (dataRangeCltn.length > 0) {
    const dataRange = dataRangeCltn.item(0);
    config.min = Number(dataRange.getAttribute("minimum"));
    config.max = Number(dataRange.getAttribute("maximum"));
    config.logScale = dataRange.getAttribute("type") === "LOG";
  }
}
const splitLines = splitLines$5;
class SampleInformation {
  constructor() {
    this.attributes = {};
    this.plinkLoaded = false;
  }
  async loadPlinkFile(url, config) {
    if (!config) config = {};
    var options2 = buildOptions$1(config);
    const data = await igvxhr.loadString(url, options2);
    var lines = splitLines(data);
    for (let line of lines) {
      var line_arr = line.split(" ");
      this.attributes[line_arr[1]] = {
        familyId: line_arr[0],
        fatherId: line_arr[2],
        motherId: line_arr[3],
        sex: line_arr[4],
        phenotype: line_arr[5]
      };
    }
    this.plinkLoaded = true;
    return this;
  }
  /**
   * Return the attributes for the given sample as a map-like object (key-value pairs)
   * @param sample
   */
  getAttributes(sample) {
    return this.attributes[sample];
  }
  getAttributeNames() {
    if (this.hasAttributes()) {
      return Object.keys(this.attributes[Object.keys(this.attributes)[0]]);
    } else return [];
  }
  hasAttributes() {
    return Object.keys(this.attributes).length > 0;
  }
}
function loadPlinkFile(url, config) {
  const si = new SampleInformation();
  return si.loadPlinkFile(url, config);
}
class GtexSelection {
  constructor(gene, snp) {
    this.geneColors = {};
    this.gene = null;
    this.snp = null;
    this.genesCount = 0;
    if (gene) {
      this.gene = gene.toUpperCase();
      this.geneColors[this.gene] = brewer[this.genesCount++];
    }
    if (snp) {
      this.snp = snp.toUpperCase();
    }
  }
  addGene(geneName) {
    if (!this.geneColors[geneName.toUpperCase()]) {
      this.geneColors[geneName.toUpperCase()] = brewer[this.genesCount++];
    }
  }
  colorForGene(geneName) {
    return this.geneColors[geneName.toUpperCase()];
  }
}
var brewer = [];
brewer.push("rgb(228,26,28)");
brewer.push("rgb(55,126,184)");
brewer.push("rgb(77,175,74)");
brewer.push("rgb(166,86,40)");
brewer.push("rgb(152,78,163)");
brewer.push("rgb(255,127,0)");
brewer.push("rgb(247,129,191)");
brewer.push("rgb(153,153,153)");
brewer.push("rgb(255,255,51)");
brewer.push("rgb(102, 194, 165");
brewer.push("rgb(252, 141, 98");
brewer.push("rgb(141, 160, 203");
brewer.push("rgb(231, 138, 195");
brewer.push("rgb(166, 216, 84");
brewer.push("rgb(255, 217, 47");
brewer.push("rgb(229, 196, 148");
brewer.push("rgb(179, 179, 179");
brewer.push("rgb( 141, 211, 199");
brewer.push("rgb(255, 255, 179");
brewer.push("rgb(190, 186, 218");
brewer.push("rgb(251, 128, 114");
brewer.push("rgb(128, 177, 211");
brewer.push("rgb(253, 180, 98");
brewer.push("rgb(179, 222, 105");
brewer.push("rgb(252, 205, 229");
brewer.push("rgb(217, 217, 217");
brewer.push("rgb(188, 128, 189");
brewer.push("rgb(204, 235, 197");
brewer.push("rgb(255, 237, 111");
class ReferenceFrame {
  constructor(genome, chr, start, end, bpPerPixel) {
    this.genome = genome;
    this.chr = chr;
    this.start = start;
    this.end = end;
    this.bpPerPixel = bpPerPixel;
    this.id = domUtils$1.guid();
  }
  /**
   * Extend this frame to accomodate the given locus.  Used th CircularView methods to merge 2 frames.
   * @param locus
   */
  extend(locus) {
    const newStart = Math.min(locus.start, this.start);
    const newEnd = Math.max(locus.end, this.end);
    const ratio = (newEnd - newStart) / (this.end - this.start);
    this.start = newStart;
    this.end = newEnd;
    this.bpPerPixel *= ratio;
  }
  calculateEnd(pixels) {
    return this.start + this.bpPerPixel * pixels;
  }
  calculateBPP(end, pixels) {
    return (end - this.start) / pixels;
  }
  set(json) {
    this.chr = json.chr;
    this.start = json.start;
    this.bpPerPixel = json.bpPerPixel;
  }
  toPixels(bp) {
    return bp / this.bpPerPixel;
  }
  toBP(pixels) {
    return this.bpPerPixel * pixels;
  }
  /**
   * Shift frame by stated pixels.  Return true if view changed, false if not.
   *
   * @param pixels
   * @param clamp -- if true "clamp" shift to prevent panning off edge of chromosome.  This is disabled if "show soft clipping" is on
   * @param viewportWidth
   */
  shiftPixels(pixels, viewportWidth, clamp) {
    const currentStart = this.start;
    const deltaBP = pixels * this.bpPerPixel;
    this.start += deltaBP;
    if (clamp) {
      this.clampStart(viewportWidth);
    }
    this.end = this.start + viewportWidth * this.bpPerPixel;
    return currentStart !== this.start;
  }
  clampStart(viewportWidth) {
    const min = this.genome.getChromosome(this.chr).bpStart || 0;
    this.start = Math.max(min, this.start);
    if (viewportWidth) {
      const { bpLength } = this.genome.getChromosome(this.chr);
      const maxStart = bpLength - viewportWidth * this.bpPerPixel;
      if (this.start > maxStart) {
        this.start = maxStart;
      }
    }
  }
  async zoomWithScaleFactor(browser, scaleFactor, viewportWidth, centerBPOrUndefined) {
    const centerBP = void 0 === centerBPOrUndefined ? this.start + this.toBP(viewportWidth / 2) : centerBPOrUndefined;
    const { start, bpPerPixel } = this.start;
    const { bpLength } = this.getChromosome();
    const bppThreshold = scaleFactor < 1 ? browser.minimumBases() / viewportWidth : bpLength / viewportWidth;
    if (scaleFactor < 1) {
      this.bpPerPixel = Math.max(this.bpPerPixel * scaleFactor, bppThreshold);
    } else {
      this.bpPerPixel = Math.min(this.bpPerPixel * scaleFactor, bppThreshold);
    }
    const widthBP = this.bpPerPixel * viewportWidth;
    this.start = centerBP - 0.5 * widthBP;
    this.clampStart(viewportWidth);
    this.end = this.start + widthBP;
    const viewChanged = start !== this.start || bpPerPixel !== this.bpPerPixel;
    if (viewChanged) {
      await browser.updateViews(true);
    }
  }
  getChromosome() {
    return this.genome.getChromosome(this.chr);
  }
  getMultiLocusLabelBPLengthOnly(pixels) {
    const margin = "&nbsp";
    const ss = Math.floor(this.start) + 1;
    const ee = Math.round(this.start + this.bpPerPixel * pixels);
    return `${margin}${this.chr}${margin}${prettyBasePairNumber(ee - ss)}${margin}`;
  }
  getMultiLocusLabelLocusOnly(pixels) {
    const margin = "&nbsp";
    const { chr, start, end } = this.getPresentationLocusComponents(pixels);
    return `${margin}${chr}:${start}-${end}${margin}`;
  }
  getMultiLocusLabel(pixels) {
    const margin = "&nbsp";
    const { chr, start, end } = this.getPresentationLocusComponents(pixels);
    const ss = Math.floor(this.start) + 1;
    const ee = Math.round(this.start + this.bpPerPixel * pixels);
    return `${margin}${chr}:${start}-${end}${margin}${margin}(${prettyBasePairNumber(ee - ss)})${margin}`;
  }
  getPresentationLocusComponents(pixels) {
    if ("all" === this.chr) {
      return { chr: this.chr };
    } else {
      const ss = numberFormatter$1(Math.floor(this.start) + 1);
      const ee = numberFormatter$1(Math.round(this.start + this.bpPerPixel * pixels));
      return { chr: this.chr, start: ss, end: ee };
    }
  }
  getLocusString() {
    if ("all" === this.chr) {
      return "all";
    } else {
      const ss = numberFormatter$1(Math.floor(this.start) + 1);
      const ee = numberFormatter$1(Math.round(this.end));
      return `${this.chr}:${ss}-${ee}`;
    }
  }
  description(blurb) {
    console.log(` ${blurb || ""} referenceFrame - ${this.chr} bpp ${this.bpPerPixel.toFixed(3)} start ${numberFormatter$1(Math.round(this.start))} end ${numberFormatter$1(Math.round(this.end))} `);
  }
}
function createReferenceFrameList(loci, genome, browserFlanking, minimumBases, viewportWidth, isSoftclipped) {
  return loci.map((locus) => {
    if (browserFlanking && locus.gene) {
      locus.start = Math.max(0, locus.start - browserFlanking);
      locus.end += browserFlanking;
    }
    if (!isSoftclipped) {
      const chromosome = genome.getChromosome(locus.chr);
      validateGenomicExtent(chromosome.bpLength, locus, minimumBases);
    }
    const referenceFrame = new ReferenceFrame(
      genome,
      locus.chr,
      locus.start,
      locus.end,
      (locus.end - locus.start) / viewportWidth
    );
    referenceFrame.locusSearchString = locus.locusSearchString;
    if (locus.gene || locus.snp) {
      referenceFrame.selection = new GtexSelection(locus.gene, locus.snp);
    }
    return referenceFrame;
  });
}
const DEFAULT_SEARCH_CONFIG = {
  timeout: 5e3,
  type: "plain",
  // Legacy plain text support -- deprecated
  url: "https://igv.org/genomes/locus.php?genome=$GENOME$&name=$FEATURE$",
  coords: 0,
  chromosomeField: "chromosome",
  startField: "start",
  endField: "end",
  geneField: "gene",
  snpField: "snp"
};
async function search(browser, string) {
  if (void 0 === string || "" === string.trim()) {
    return;
  }
  if (string && string.trim().toLowerCase() === "all" || string === "*") {
    string = "all";
  }
  const loci = string.split(" ");
  let searchConfig = browser.searchConfig || DEFAULT_SEARCH_CONFIG;
  let list = [];
  const searchLocus = async (locus) => {
    let locusObject = parseLocusString(browser, locus);
    if (!locusObject) {
      const feature2 = browser.genome.featureDB.get(locus.toUpperCase());
      if (feature2) {
        locusObject = {
          chr: feature2.chr,
          start: feature2.start,
          end: feature2.end,
          gene: feature2.name,
          locusSearchString: string
        };
      }
    }
    if (!locusObject && (browser.config && false !== browser.config.search)) {
      try {
        locusObject = await searchWebService(browser, locus, searchConfig);
      } catch (error) {
        console.error(error);
        throw Error("Search service currently unavailable.");
      }
    }
    return locusObject;
  };
  for (let locus of loci) {
    const locusObject = await searchLocus(locus);
    if (locusObject) {
      locusObject.locusSearchString = locus;
      list.push(locusObject);
    }
  }
  if (list.length === 0) {
    const locusObject = await searchLocus(string);
    if (locusObject) {
      locusObject.locusSearchString = string;
      list.push(locusObject);
    }
  }
  return 0 === list.length ? void 0 : list;
}
function parseLocusString(browser, locus) {
  const tabTokens = locus.split("	");
  if (tabTokens.length >= 3) {
    try {
      const chr2 = browser.genome.getChromosomeName(tabTokens[0]);
      const start = parseInt(tabTokens[1].replace(/,/g, ""), 10) - 1;
      const end = parseInt(tabTokens[2].replace(/,/g, ""), 10);
      if (!isNaN(start) && !isNaN(end)) {
        return { chr: chr2, start, end };
      }
    } catch (e) {
    }
  }
  const a = locus.split(":");
  const chr = a[0];
  if ("all" === chr && browser.genome.getChromosome(chr)) {
    return { chr, start: 0, end: browser.genome.getChromosome(chr).bpLength };
  } else if (void 0 === browser.genome.getChromosome(chr)) {
    return void 0;
  } else {
    const queryChr = browser.genome.getChromosomeName(chr);
    const extent = {
      chr: queryChr,
      start: 0,
      end: browser.genome.getChromosome(chr).bpLength
    };
    if (a.length > 1) {
      let b = a[1].split("-");
      if (b.length > 2) {
        if (a[1].startsWith("-")) {
          const i = a[1].indexOf("-", 1);
          if (i > 0) {
            const t12 = a[1].substring(0, i);
            const t22 = a[1].substring(i + 1);
            b = [t12, t22];
          }
        } else {
          return void 0;
        }
      }
      let numeric;
      numeric = b[0].replace(/,/g, "");
      if (isNaN(numeric)) {
        return void 0;
      }
      extent.start = parseInt(numeric, 10) - 1;
      extent.end = extent.start + 1;
      if (1 === b.length) {
        extent.start -= 20;
        extent.end += 20;
      }
      if (2 === b.length) {
        numeric = b[1].replace(/,/g, "");
        if (isNaN(numeric)) {
          return void 0;
        } else {
          extent.end = parseInt(numeric, 10);
        }
        if (extent.start < 0 && !browser.isSoftclipped()) {
          const delta = -extent.start;
          extent.start += delta;
          extent.end += delta;
        }
      }
    }
    return extent;
  }
}
async function searchWebService(browser, locus, searchConfig) {
  let path = searchConfig.url.replace("$FEATURE$", locus.toUpperCase());
  if (path.indexOf("$GENOME$") > -1) {
    path = path.replace("$GENOME$", browser.genome.id ? browser.genome.id : "hg19");
  }
  const options2 = searchConfig.timeout ? { timeout: searchConfig.timeout } : void 0;
  const result = await igvxhr.loadString(path, options2);
  const locusObject = processSearchResult(browser, result, searchConfig);
  if (locusObject) {
    locusObject.locusSearchString = locus;
  }
  return locusObject;
}
function processSearchResult(browser, result, searchConfig) {
  let results;
  if ("plain" === searchConfig.type) {
    results = parseSearchResults$1(browser, result);
  } else {
    results = JSON.parse(result);
  }
  if (searchConfig.resultsField) {
    results = results[searchConfig.resultsField];
  }
  if (!results || 0 === results.length) {
    return void 0;
  } else {
    const chromosomeField = searchConfig.chromosomeField || "chromosome";
    const startField = searchConfig.startField || "start";
    const endField = searchConfig.endField || "end";
    const coords = searchConfig.coords || 1;
    let result2;
    if (Array.isArray(results)) {
      result2 = results[0];
    } else {
      result2 = results;
    }
    if (!(result2.hasOwnProperty(chromosomeField) && result2.hasOwnProperty(startField))) {
      console.error("Search service results must include chromosome and start fields: " + result2);
    }
    const chrResult = result2[chromosomeField];
    const chromosome = browser.genome.getChromosome(chrResult);
    if (!chromosome) {
      return void 0;
    }
    const chr = chromosome.name;
    let start = result2[startField] - coords;
    let end = result2[endField];
    if (void 0 === end) {
      end = start + 1;
    }
    const locusObject = { chr, start, end };
    const type = result2.type ? result2.type : "gene";
    if (searchConfig.geneField && type === "gene") {
      locusObject.gene = result2[searchConfig.geneField];
    }
    if (searchConfig.snpField && type === "snp") {
      locusObject.snp = result2[searchConfig.snpField];
    }
    return locusObject;
  }
}
function parseSearchResults$1(browser, data) {
  const linesTrimmed = [];
  const results = [];
  const lines = splitLines$5(data);
  lines.forEach(function(item) {
    if ("" === item) ;
    else {
      linesTrimmed.push(item);
    }
  });
  linesTrimmed.forEach(function(line) {
    var tokens = line.split("	"), source, locusTokens, rangeTokens, obj;
    if (tokens.length >= 3) {
      locusTokens = tokens[1].split(":");
      rangeTokens = locusTokens[1].split("-");
      source = tokens[2].trim();
      obj = {
        gene: tokens[0],
        chromosome: browser.genome.getChromosomeName(locusTokens[0].trim()),
        start: parseInt(rangeTokens[0].replace(/,/g, "")),
        end: parseInt(rangeTokens[1].replace(/,/g, "")),
        type: "gtex" === source ? "snp" : "gene"
      };
      results.push(obj);
    }
  });
  return results;
}
class NavbarManager {
  constructor(browser) {
    this.browser = browser;
  }
  navbarDidResize(width) {
    this.updateNavbar(this.createResponsiveClassSchedule(width));
  }
  updateNavbar(responsiveClassSchedule) {
    this.browser.$toggle_button_container.removeClass();
    this.browser.$toggle_button_container.addClass(responsiveClassSchedule.$toggle_button_container);
    $$1(this.browser.zoomWidget.zoomContainer).removeClass();
    $$1(this.browser.zoomWidget.zoomContainer).addClass(responsiveClassSchedule.zoomContainer);
  }
  createResponsiveClassSchedule(navbarWidth) {
    let candidates = {};
    const isWGV = this.browser.isMultiLocusWholeGenomeView() || this.browser.referenceFrameList && GenomeUtils.isWholeGenomeView(this.browser.referenceFrameList[0].chr);
    if (isWGV) {
      this.browser.windowSizePanel.hide();
    } else {
      this.browser.windowSizePanel.show();
    }
    if (navbarWidth > 990) {
      candidates.$toggle_button_container = "igv-navbar-toggle-button-container";
      candidates.zoomContainer = "igv-zoom-widget";
    } else if (navbarWidth > 860) {
      candidates.$toggle_button_container = "igv-navbar-toggle-button-container";
      candidates.zoomContainer = "igv-zoom-widget-900";
    } else if (navbarWidth > 540) {
      candidates.$toggle_button_container = "igv-navbar-toggle-button-container-750";
      candidates.zoomContainer = "igv-zoom-widget-900";
    } else {
      candidates.$toggle_button_container = "igv-navbar-toggle-button-container-750";
      candidates.zoomContainer = "igv-zoom-widget-900";
      this.browser.windowSizePanel.hide();
    }
    if (isWGV) {
      candidates["zoomContainer"] = "igv-zoom-widget-hidden";
    }
    return candidates;
  }
}
const ChromosomeSelectWidget = function(browser, parent) {
  this.container = domUtils$1.div({ class: "igv-chromosome-select-widget-container" });
  parent.appendChild(this.container);
  this.select = document.createElement("select");
  this.select.setAttribute("name", "chromosome-select-widget");
  this.container.appendChild(this.select);
  this.select.addEventListener("change", () => {
    this.select.blur();
    if (this.select.value !== "") {
      browser.search(this.select.value);
    }
  });
  this.showAllChromosomes = browser.config.showAllChromosomes !== false;
};
ChromosomeSelectWidget.prototype.show = function() {
  this.container.style.display = "flex";
};
ChromosomeSelectWidget.prototype.hide = function() {
  this.container.style.display = "none";
};
ChromosomeSelectWidget.prototype.update = function(genome) {
  const list = this.showAllChromosomes ? genome.chromosomeNames.slice() : genome.wgChromosomeNames.slice();
  if (genome.showWholeGenomeView()) {
    list.unshift("all");
    list.unshift("");
  }
  this.select.innerHTML = "";
  for (let name2 of list) {
    const option = document.createElement("option");
    option.setAttribute("value", name2);
    option.innerText = name2;
    this.select.appendChild(option);
  }
};
class WindowSizePanel {
  constructor(parent, browser) {
    this.container = domUtils$1.div({ class: "igv-windowsize-panel-container" });
    parent.appendChild(this.container);
    browser.on("locuschange", (referenceFrameList) => {
      this.updatePanel(referenceFrameList);
    });
    this.browser = browser;
  }
  show() {
    this.container.style.display = "block";
  }
  hide() {
    this.container.style.display = "none";
  }
  updatePanel(referenceFrameList) {
    const width = this.browser.calculateViewportWidth(this.browser.referenceFrameList.length);
    this.container.innerText = 1 === referenceFrameList.length ? prettyBasePairNumber(Math.round(width * referenceFrameList[0].bpPerPixel)) : "";
  }
}
class CursorGuide {
  constructor(columnContainer, browser) {
    this.browser = browser;
    this.columnContainer = columnContainer;
    this.horizontalGuide = domUtils$1.div({ class: "igv-cursor-guide-horizontal" });
    columnContainer.appendChild(this.horizontalGuide);
    this.verticalGuide = domUtils$1.div({ class: "igv-cursor-guide-vertical" });
    columnContainer.appendChild(this.verticalGuide);
    this.addMouseHandler(browser);
    this.setVisibility(browser.config.showCursorGuide);
  }
  addMouseHandler(browser) {
    this.boundMouseMoveHandler = mouseMoveHandler.bind(this);
    this.columnContainer.addEventListener("mousemove", this.boundMouseMoveHandler);
    function mouseMoveHandler(event) {
      const { x, y } = domUtils$1.translateMouseCoordinates(event, this.columnContainer);
      this.horizontalGuide.style.top = `${y}px`;
      const target = document.elementFromPoint(event.clientX, event.clientY);
      const viewport = findAncestorOfClass(target, "igv-viewport");
      if (viewport && browser.getRulerTrackView()) {
        this.verticalGuide.style.left = `${x}px`;
        const columns = browser.root.querySelectorAll(".igv-column");
        let index2 = void 0;
        const viewportParent = viewport.parentElement;
        for (let i = 0; i < columns.length; i++) {
          if (void 0 === index2 && viewportParent === columns[i]) {
            index2 = i;
          }
        }
        const rulerViewport = browser.getRulerTrackView().viewports[index2];
        const result = rulerViewport.mouseMove(event);
        if (result) {
          const { start, bp, end } = result;
          const interpolant = (bp - start) / (end - start);
          if (this.customMouseHandler) {
            this.customMouseHandler({ start, bp, end, interpolant });
          }
        }
      }
    }
  }
  removeMouseHandler() {
    this.columnContainer.removeEventListener("mousemove", this.boundMouseMoveHandler);
  }
  setVisibility(showCursorGuide) {
    if (true === showCursorGuide) {
      this.show();
    } else {
      this.hide();
    }
  }
  show() {
    this.verticalGuide.style.display = "block";
    this.horizontalGuide.style.display = "block";
  }
  hide() {
    this.verticalGuide.style.display = "none";
    this.horizontalGuide.style.display = "none";
    if (this.browser.getRulerTrackView()) {
      for (let viewport of this.browser.getRulerTrackView().viewports) {
        viewport.$tooltip.hide();
      }
    }
  }
}
function findAncestorOfClass(target, classname) {
  while (target.parentElement) {
    if (target.parentElement.classList.contains(classname)) {
      return target.parentElement;
    } else {
      target = target.parentElement;
    }
  }
  return void 0;
}
class CursorGuideButton {
  constructor(browser, parent) {
    this.browser = browser;
    this.button = domUtils$1.div({ class: "igv-navbar-button" });
    parent.appendChild(this.button);
    this.button.textContent = "cursor guide";
    this.button.addEventListener("click", () => {
      browser.cursorGuideVisible = !browser.cursorGuideVisible;
      browser.setCursorGuideVisibility(browser.cursorGuideVisible);
      this.setButtonState(browser.cursorGuideVisible);
    });
    this.setButtonState(browser.cursorGuideVisible);
    if (browser.config.showCursorTrackingGuideButton) {
      this.show();
    } else {
      this.hide();
    }
  }
  setButtonState(cursorGuideVisible) {
    if (true === cursorGuideVisible) {
      this.button.classList.add("igv-navbar-button-clicked");
    } else {
      this.button.classList.remove("igv-navbar-button-clicked");
    }
  }
  show() {
    this.button.style.display = "block";
    this.setButtonState(this.browser.cursorGuideVisible);
  }
  hide() {
    this.button.style.display = "none";
  }
}
class CenterLineButton {
  constructor(browser, parent) {
    this.browser = browser;
    this.button = domUtils$1.div({ class: "igv-navbar-button" });
    parent.appendChild(this.button);
    this.button.textContent = "center line";
    this.button.addEventListener("click", () => {
      browser.isCenterLineVisible = !browser.isCenterLineVisible;
      browser.setCenterLineVisibility(browser.isCenterLineVisible);
      this.setButtonState(browser.isCenterLineVisible);
    });
    this.setButtonState(browser.isCenterLineVisible);
    if (browser.config.showCenterGuideButton) {
      this.show();
    } else {
      this.hide();
    }
  }
  setButtonState(isCenterLineVisible) {
    if (true === isCenterLineVisible) {
      this.button.classList.add("igv-navbar-button-clicked");
    } else {
      this.button.classList.remove("igv-navbar-button-clicked");
    }
  }
  show() {
    this.isVisible = true;
    this.button.style.display = "block";
    this.setButtonState(this.browser.isCenterLineVisible);
  }
  hide() {
    this.isVisible = false;
    this.button.style.display = "none";
  }
}
class TrackLabelControl {
  constructor(parent, browser) {
    this.button = domUtils$1.div({ class: "igv-navbar-button" });
    parent.appendChild(this.button);
    this.button.textContent = "track labels";
    this.button.addEventListener("click", () => {
      browser.trackLabelsVisible = !browser.trackLabelsVisible;
      this.setState(browser.trackLabelsVisible);
      browser.setTrackLabelVisibility(browser.trackLabelsVisible);
    });
    this.browser = browser;
    this.setVisibility(browser.config.showTrackLabelButton);
    this.setState(browser.trackLabelsVisible);
  }
  setVisibility(showTrackLabelButton) {
    if (true === showTrackLabelButton) {
      this.show();
    } else {
      this.hide();
    }
  }
  setState(trackLabelsVisible) {
    if (true === trackLabelsVisible) {
      this.button.classList.add("igv-navbar-button-clicked");
    } else {
      this.button.classList.remove("igv-navbar-button-clicked");
    }
  }
  show() {
    this.button.style.display = "block";
    this.setState(this.browser.trackLabelsVisible);
  }
  hide() {
    this.button.style.display = "none";
  }
}
class SampleNameControl {
  constructor(parent, browser) {
    this.button = domUtils$1.div({ class: "igv-navbar-button" });
    parent.appendChild(this.button);
    this.button.innerText = "Sample Names";
    this.setState(browser.showSampleNames);
    this.setVisibility(browser.showSampleNameButton);
    this.button.addEventListener("click", () => {
      browser.showSampleNames = !browser.showSampleNames;
      this.setState(browser.showSampleNames);
      for (let { sampleNameViewport } of browser.trackViews) {
        if (false === browser.showSampleNames) {
          sampleNameViewport.hide();
        } else {
          sampleNameViewport.show();
        }
      }
      browser.layoutChange();
    });
  }
  setVisibility(showSampleNameButton) {
    if (true === showSampleNameButton) {
      this.show();
    } else {
      this.hide();
    }
  }
  setState(showSampleNames) {
    if (true === showSampleNames) {
      this.button.classList.add("igv-navbar-button-clicked");
    } else {
      this.button.classList.remove("igv-navbar-button-clicked");
    }
  }
  hide() {
    this.button.style.display = "none";
  }
  show() {
    this.button.style.display = "block";
  }
}
const sliderMin = 0;
let sliderMax = 23;
let sliderValueRaw = 0;
const ZoomWidget = function(browser, parent) {
  this.browser = browser;
  this.zoomContainer = domUtils$1.div({ class: "igv-zoom-widget" });
  parent.appendChild(this.zoomContainer);
  this.zoomOutButton = domUtils$1.div();
  this.zoomContainer.appendChild(this.zoomOutButton);
  this.zoomOutButton.appendChild(icons$1$1.createIcon("minus-circle"));
  this.zoomOutButton.addEventListener("click", () => {
    browser.zoomOut();
  });
  const el = domUtils$1.div();
  this.zoomContainer.appendChild(el);
  this.slider = document.createElement("input");
  this.slider.type = "range";
  this.slider.min = `${sliderMin}`;
  this.slider.max = `${sliderMax}`;
  el.appendChild(this.slider);
  this.slider.addEventListener("change", (e) => {
    e.preventDefault();
    e.stopPropagation();
    const referenceFrame = browser.referenceFrameList[0];
    const { bpLength } = referenceFrame.genome.getChromosome(referenceFrame.chr);
    const { end, start } = referenceFrame;
    const extent = end - start;
    const scaleFactor = Math.pow(2, e.target.valueAsNumber);
    const zoomedExtent = bpLength / scaleFactor;
    browser.zoomWithScaleFactor(zoomedExtent / extent);
  });
  this.zoomInButton = domUtils$1.div();
  this.zoomContainer.appendChild(this.zoomInButton);
  this.zoomInButton.appendChild(icons$1$1.createIcon("plus-circle"));
  this.zoomInButton.addEventListener("click", () => {
    browser.zoomIn();
  });
  browser.on("locuschange", (referenceFrameList) => {
    if (this.browser.isMultiLocusMode()) {
      this.disable();
    } else {
      this.enable();
      this.update(referenceFrameList);
    }
  });
};
ZoomWidget.prototype.update = function(referenceFrameList) {
  const referenceFrame = referenceFrameList[0];
  const { bpLength } = referenceFrame.genome.getChromosome(referenceFrame.chr);
  const { start, end } = referenceFrame;
  sliderMax = Math.ceil(Math.log2(bpLength / this.browser.minimumBases()));
  this.slider.max = `${sliderMax}`;
  const scaleFactor = bpLength / (end - start);
  sliderValueRaw = Math.log2(scaleFactor);
  this.slider.value = `${Math.round(sliderValueRaw)}`;
};
ZoomWidget.prototype.enable = function() {
  this.slider.disabled = false;
};
ZoomWidget.prototype.disable = function() {
  this.slider.disabled = true;
};
ZoomWidget.prototype.hide = function() {
  this.zoomContainer.style.display = "none";
};
ZoomWidget.prototype.show = function() {
  this.zoomContainer.style.display = "block";
};
ZoomWidget.prototype.hideSlider = function() {
  this.slider.style.display = "none";
};
ZoomWidget.prototype.showSlider = function() {
  this.slider.style.display = "block";
};
const SVGSaveControl = function(parent, browser) {
  const button = domUtils$1.div({ class: "igv-navbar-button" });
  parent.append(button);
  button.textContent = "Save SVG";
  button.addEventListener("click", () => browser.saveSVGtoFile({}));
};
const viewportColumnManager = {
  createColumns: (columnContainer, count) => {
    for (let i = 0; i < count; i++) {
      if (0 === i) {
        createColumn(columnContainer, "igv-column");
      } else {
        columnContainer.appendChild(domUtils$1.div({ class: "igv-column-shim" }));
        createColumn(columnContainer, "igv-column");
      }
    }
  },
  removeColumnAtIndex: (i, column) => {
    const shim = 0 === i ? column.nextElementSibling : column.previousElementSibling;
    column.remove();
    shim.remove();
  },
  insertAfter: (referenceElement) => {
    const shim = domUtils$1.div({ class: "igv-column-shim" });
    insertElementAfter(shim, referenceElement);
    const column = domUtils$1.div({ class: "igv-column" });
    insertElementAfter(column, shim);
    return column;
  },
  insertBefore: (referenceElement, count) => {
    for (let i = 0; i < count; i++) {
      const column = domUtils$1.div({ class: "igv-column" });
      insertElementBefore(column, referenceElement);
      if (count > 1 && i > 0) {
        const columnShim = domUtils$1.div({ class: "igv-column-shim" });
        insertElementBefore(columnShim, column);
      }
    }
  },
  indexOfColumn: (columnContainer, column) => {
    const allColumns = columnContainer.querySelectorAll(".igv-column");
    for (let i = 0; i < allColumns.length; i++) {
      const c = allColumns[i];
      if (c === column) {
        return i;
      }
    }
    return void 0;
  }
};
class ViewportCenterLine {
  constructor(browser, referenceFrame, column) {
    this.browser = browser;
    this.referenceFrame = referenceFrame;
    this.column = column;
    this.container = domUtils$1.div({ class: "igv-center-line" });
    column.appendChild(this.container);
    if (browser.isCenterLineVisible) {
      this.show();
    } else {
      this.hide();
    }
  }
  repaint() {
    if (this.referenceFrame) {
      const ppb = 1 / this.referenceFrame.bpPerPixel;
      if (ppb > 1) {
        const width = Math.floor(this.referenceFrame.toPixels(1));
        this.container.style.width = `${width}px`;
        this.container.classList.remove("igv-center-line-thin");
        this.container.classList.add("igv-center-line-wide");
      } else {
        this.container.style.width = "1px";
        this.container.classList.remove("igv-center-line-wide");
        this.container.classList.add("igv-center-line-thin");
      }
    }
  }
  show() {
    this.isVisible = true;
    this.container.style.display = "block";
    this.repaint();
  }
  hide() {
    this.isVisible = false;
    this.container.style.display = "none";
  }
  resize() {
    this.repaint();
  }
}
const numberFormatter = numberFormatter$1;
class RulerTrack {
  constructor(browser) {
    this.browser = browser;
    this.height = 40;
    this.name = "";
    this.id = "ruler";
    this.disableButtons = true;
    this.ignoreTrackMenu = true;
    this.order = Number.MIN_SAFE_INTEGER * 0.01;
    this.removable = false;
    this.type = "ruler";
  }
  async getFeatures(chr, start, end) {
    return [];
  }
  computePixelHeight(ignore) {
    return this.height;
  }
  draw({ context, referenceFrame, pixelWidth, pixelHeight, bpPerPixel, bpStart }) {
    if (GenomeUtils.isWholeGenomeView(referenceFrame.chr)) {
      this.drawWholeGenome({ context, pixelWidth, pixelHeight, bpPerPixel });
    } else {
      this.doDraw({ context, referenceFrame, pixelWidth, pixelHeight, bpStart });
    }
  }
  drawWholeGenome({ context, pixelWidth, pixelHeight, bpPerPixel }) {
    context.save();
    IGVGraphics.fillRect(context, 0, 0, pixelWidth, pixelHeight, { "fillStyle": "white" });
    for (let name2 of this.browser.genome.wgChromosomeNames) {
      let xBP = this.browser.genome.getCumulativeOffset(name2);
      let wBP = this.browser.genome.getChromosome(name2).bpLength;
      let x = Math.round(xBP / bpPerPixel);
      let w = Math.round(wBP / bpPerPixel);
      this.renderChromosomeRect(context, x, 0, w, pixelHeight, name2);
    }
    context.restore();
  }
  doDraw({ context, referenceFrame, pixelWidth, pixelHeight, bpStart }) {
    context.clearRect(0, 0, pixelWidth, pixelHeight);
    const tickHeight = 6;
    const shim = 2;
    const bpLength = Math.floor(referenceFrame.toBP(pixelWidth));
    const tick = findSpacing$1(bpLength, context.isSVG);
    let nTick = Math.floor(bpStart / tick.majorTick) - 1;
    const { tickDelta, labelLength } = calculateDeltas(context, referenceFrame, bpStart, nTick, tick);
    this.browser.referenceFrameList.indexOf(referenceFrame);
    let xTick;
    let bp;
    let accumulatedTickDelta = tickDelta;
    const labelLengthShim = 0.25 * labelLength;
    do {
      bp = Math.floor(nTick * tick.majorTick);
      const rulerLabel = `${numberFormatter$1(Math.floor(bp / tick.unitMultiplier))} ${tick.majorUnit}`;
      xTick = Math.round(referenceFrame.toPixels(bp - 1 - bpStart + 0.5));
      const xLabel = Math.round(xTick - context.measureText(rulerLabel).width / 2);
      if (xLabel > 0 && labelLengthShim + labelLength <= accumulatedTickDelta) {
        IGVGraphics.fillText(context, rulerLabel, xLabel, this.height - tickHeight / 0.75);
        accumulatedTickDelta = 0;
      }
      if (xTick > 0) {
        IGVGraphics.strokeLine(context, xTick, this.height - tickHeight, xTick, this.height - shim);
      }
      bp = Math.floor((1 + nTick) * tick.majorTick);
      let pixel = Math.round(referenceFrame.toPixels(bp - 1 - bpStart + 0.5));
      let delta = (pixel - xTick) / 2;
      let xx = xTick + delta;
      if (xx > 0) {
        IGVGraphics.strokeLine(context, xx, this.height - tickHeight, xx, this.height - shim);
      }
      ++nTick;
      accumulatedTickDelta += tickDelta;
    } while (xTick < pixelWidth);
    IGVGraphics.strokeLine(context, 0, this.height - shim, pixelWidth, this.height - shim);
  }
  renderChromosomeRect(ctx2, x, y, w, h, name2) {
    ctx2.textAlign = "center";
    ctx2.textBaseline = "middle";
    ctx2.font = "12px sans-serif";
    IGVGraphics.strokeLine(ctx2, x + w, y, x + w, y + h, { strokeStyle: IGVColor.greyScale(191) });
    const shortName = name2.startsWith("chr") ? name2.substring(3) : name2;
    if (w > ctx2.measureText(shortName).width) {
      IGVGraphics.fillText(ctx2, shortName, x + w / 2, y + h / 2, { fillStyle: IGVColor.greyScale(68) });
    }
  }
  get supportsWholeGenome() {
    return true;
  }
  dispose() {
  }
}
function findSpacing$1(bpLength, isSVG) {
  if (bpLength < 10) {
    return new Tick(1, "bp", 1);
  }
  const nZeroes = Math.floor(Math.log10(bpLength));
  let majorUnit = "bp";
  let unitMultiplier = 1;
  if (nZeroes > 9) {
    majorUnit = "gb";
    unitMultiplier = 1e9;
  } else if (nZeroes > 6) {
    majorUnit = "mb";
    unitMultiplier = 1e6;
  } else if (nZeroes > 3) {
    majorUnit = "kb";
    unitMultiplier = 1e3;
  }
  const denom = Math.pow(10, nZeroes - 1);
  const nMajorTicks = bpLength / denom;
  const threshold = 3 * 25;
  const belowThresholdTick = Math.pow(10, nZeroes - 1);
  const aboveThresholdTick = Math.pow(10, nZeroes) / 2;
  const majorTick = nMajorTicks < threshold && isSVG !== true ? belowThresholdTick : aboveThresholdTick;
  return new Tick(majorTick, majorUnit, unitMultiplier);
}
function calculateDeltas(context, referenceFrame, bpStart, nTick, tick) {
  const tickDelta = getX(referenceFrame, getBP(1 + nTick, tick), bpStart) - getX(referenceFrame, getBP(nTick, tick), bpStart);
  const label = `${numberFormatter$1(Math.floor(getBP(nTick, tick) / tick.unitMultiplier))} ${tick.majorUnit}`;
  const labelLength = Math.floor(context.measureText(label).width);
  return { tickDelta, labelLength };
  function getBP(nTick2, tick2) {
    return Math.floor(nTick2 * tick2.majorTick);
  }
  function getX(referenceFrame2, bp, bpStart2) {
    return Math.round(referenceFrame2.toPixels(bp - 1 - bpStart2 + 0.5));
  }
}
class Tick {
  constructor(majorTick, majorUnit, unitMultiplier) {
    this.majorTick = majorTick;
    this.minorTick = majorTick / 10;
    this.majorUnit = majorUnit;
    this.unitMultiplier = unitMultiplier;
  }
  description(blurb) {
    console.log((blurb || "") + " tick " + numberFormatter(this.majorTick) + " label width " + numberFormatter(this.labelWidthBP) + " multiplier " + this.unitMultiplier);
  }
}
const CircularViewControl = function(parent, browser) {
  this.button = domUtils$1.div({ class: "igv-navbar-button" });
  parent.appendChild(this.button);
  this.button.textContent = "circular view";
  this.button.addEventListener("click", () => {
    browser.circularViewVisible = !browser.circularViewVisible;
  });
  this.browser = browser;
  this.setVisibility(browser.config.showCircularViewButton);
  this.setState(browser.circularViewVisible);
};
CircularViewControl.prototype.setVisibility = function(showCircularViewButton) {
  if (true === showCircularViewButton) {
    this.show();
  } else {
    this.hide();
  }
};
CircularViewControl.prototype.setState = function(circularViewVisible) {
  if (true === circularViewVisible) {
    this.button.classList.add("igv-navbar-button-clicked");
  } else {
    this.button.classList.remove("igv-navbar-button-clicked");
  }
};
CircularViewControl.prototype.show = function() {
  this.button.style.display = "block";
  this.setState(this.browser.circularViewVisible);
};
CircularViewControl.prototype.hide = function() {
  this.button.style.display = "none";
};
const CustomButton = function(parent, browser, b) {
  const button = domUtils$1.div({ class: "igv-navbar-button" });
  parent.append(button);
  button.textContent = b.label;
  button.addEventListener("click", () => b.callback(browser));
};
class ROIManager {
  constructor(browser, roiMenu, roiTable, top, roiSets) {
    this.browser = browser;
    this.roiMenu = roiMenu;
    this.roiTable = roiTable;
    this.top = top;
    this.roiSets = roiSets || [];
    this.boundLocusChangeHandler = locusChangeHandler.bind(this);
    browser.on("locuschange", this.boundLocusChangeHandler);
  }
  async initialize() {
    if (this.roiSets.length > 0) {
      this.browser.showROITableButton = true;
      this.browser.roiTableControl.setVisibility(this.browser.showROITableButton);
    }
    const promises = this.roiSets.map((roiSet) => this.renderROISet({
      browser: this.browser,
      pixelTop: this.top,
      roiSet
    }));
    if (promises.length > 0) {
      await Promise.all(promises);
    }
    const records = await this.getTableRecords();
    this.roiTable.renderTable(records);
  }
  async loadROI(config, genome) {
    const configs = Array.isArray(config) ? config : [config];
    for (let c of configs) {
      this.roiSets.push(new ROISet(c, genome));
    }
    await this.initialize();
  }
  clearROIs() {
    this.roiTable.clearTable();
    const elements = this.browser.columnContainer.querySelectorAll(".igv-roi-region");
    for (let el of elements) {
      el.remove();
    }
    for (let roiSet of this.roiSets) {
      roiSet.dispose();
    }
    this.roiSets = [];
  }
  async getTableRecords() {
    const records = [];
    for (let roiSet of this.roiSets) {
      const setName = roiSet.isUserDefined ? "" : roiSet.name || "";
      const allFeatures = await roiSet.getAllFeatures();
      for (let chr of Object.keys(allFeatures)) {
        for (let feature2 of allFeatures[chr]) {
          records.push({ setName, feature: feature2 });
        }
      }
    }
    return records;
  }
  presentTable() {
    this.roiTable.present();
  }
  async repaintTable() {
    const records = await this.getTableRecords();
    this.roiTable.renderTable(records);
  }
  dismissTable() {
    this.roiTable.dismiss();
  }
  async updateUserDefinedROISet(feature2) {
    let userDefinedROISet = await this.getUserDefinedROISet();
    if (void 0 === userDefinedROISet) {
      userDefinedROISet = this.initializeUserDefinedROISet();
    }
    userDefinedROISet.addFeature(feature2);
    if (false === this.browser.showROITableButton) {
      this.setROITableButtonVisibility(true);
    }
    await this.renderROISet({ browser: this.browser, pixelTop: this.top, roiSet: userDefinedROISet });
    const records = await this.getTableRecords();
    this.roiTable.renderTable(records);
  }
  setROITableButtonVisibility(isVisible) {
    this.browser.showROITableButton = isVisible;
    this.browser.roiTableControl.setVisibility(this.browser.showROITableButton);
  }
  async renderAllROISets() {
    for (let roiSet of this.roiSets) {
      await this.renderROISet({ browser: this.browser, pixelTop: this.top, roiSet });
    }
  }
  async renderROISet({ browser, pixelTop, roiSet }) {
    const columns = browser.columnContainer.querySelectorAll(".igv-column");
    for (let i = 0; i < columns.length; i++) {
      let { chr, start: viewStart, end: viewEnd, bpPerPixel } = browser.referenceFrameList[i];
      const elements = columns[i].querySelectorAll(".igv-roi-region");
      for (let el of elements) {
        const regionKey = el.dataset.region;
        const { chr: regionChr, start: regionStart, end: regionEnd } = parseRegionKey(regionKey);
        if (regionChr !== chr || regionEnd < viewStart || regionStart > viewEnd) {
          el.remove();
        }
      }
      const features = await roiSet.getFeatures(chr, viewStart, viewEnd);
      if (features) {
        for (let feature2 of features) {
          const regionKey = createRegionKey(chr, feature2.start, feature2.end);
          const {
            x: pixelX,
            width: pixelWidth
          } = screenCoordinates(Math.max(viewStart, feature2.start), Math.min(viewEnd, feature2.end), viewStart, bpPerPixel);
          const el = columns[i].querySelector(createSelector(regionKey));
          if (el) {
            el.style.left = `${pixelX}px`;
            el.style.width = `${pixelWidth}px`;
          } else {
            const element = this.createRegionElement(browser.columnContainer, pixelTop, pixelX, pixelWidth, roiSet, regionKey, feature2.name);
            columns[i].appendChild(element);
          }
        }
      }
    }
  }
  createRegionElement(columnContainer, pixelTop, pixelX, pixelWidth, roiSet, regionKey, name2) {
    const regionElement = domUtils$1.div({ class: "igv-roi-region" });
    regionElement.style.top = `${pixelTop}px`;
    regionElement.style.left = `${pixelX}px`;
    regionElement.style.width = `${pixelWidth}px`;
    regionElement.style.backgroundColor = roiSet.color;
    regionElement.dataset.region = regionKey;
    const header = domUtils$1.div();
    regionElement.appendChild(header);
    header.style.backgroundColor = roiSet.headerColor;
    if (true === roiSet.isUserDefined) {
      header.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        const { x, y } = domUtils$1.translateMouseCoordinates(event, columnContainer);
        this.roiMenu.present(x, y, this, columnContainer, regionElement);
      });
    } else if (name2) {
      header.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        if (this.popover) {
          this.popover.dispose();
        }
        this.popover = new Popover(columnContainer, roiSet.name);
        this.popover.presentContentWithEvent(event, name2);
      });
    } else {
      header.style.pointerEvents = "none";
    }
    return regionElement;
  }
  renderSVGContext(context, { deltaX, deltaY }) {
    for (const regionElement of document.querySelectorAll(".igv-roi-region")) {
      const { x, y, width, height } = regionElement.getBoundingClientRect();
      context.fillStyle = regionElement.style.backgroundColor;
      context.fillRect(x + deltaX, y + deltaY, width, height);
      const header = regionElement.querySelector("div");
      const { x: xx, y: yy, width: ww, height: hh } = header.getBoundingClientRect();
      context.fillStyle = header.style.backgroundColor;
      context.fillRect(xx + deltaX, yy + deltaY, ww, hh);
    }
  }
  async getUserDefinedROISet() {
    return this.roiSets.find((roiSet) => true === roiSet.isUserDefined);
  }
  initializeUserDefinedROISet() {
    const config = {
      isUserDefined: true,
      features: []
    };
    const userDefinedROISet = new ROISet(config, this.browser.genome);
    this.roiSets.push(userDefinedROISet);
    return userDefinedROISet;
  }
  async deleteUserDefinedRegionWithKey(regionKey, columnContainer) {
    columnContainer.querySelectorAll(createSelector(regionKey)).forEach((node) => node.remove());
    const feature2 = await this.findUserDefinedRegionWithKey(regionKey);
    const set = await this.getUserDefinedROISet();
    if (set) {
      set.removeFeature(feature2);
    }
    const records = await this.getTableRecords();
    if (0 === records.length) {
      this.browser.roiTableControl.buttonHandler(false);
      this.setROITableButtonVisibility(false);
    }
  }
  async findUserDefinedRegionWithKey(regionKey) {
    const { chr, start, end } = parseRegionKey(regionKey);
    const set = await this.getUserDefinedROISet();
    if (set) {
      const features = await set.getFeatures(chr, start, end);
      for (let feature2 of features) {
        if (feature2.chr === chr && feature2.start >= start && feature2.end <= end) {
          return feature2;
        }
      }
    }
    return void 0;
  }
  toJSON() {
    return this.roiSets.map((roiSet) => roiSet.toJSON());
  }
  dispose() {
    this.browser.off("locuschange", this.boundLocusChangeHandler);
    const removable = this.browser.columnContainer.querySelectorAll(".igv-roi-region");
    for (let el of removable) {
      el.remove();
    }
    if (this.roiMenu) {
      this.roiMenu.dispose();
    }
    if (this.roiTable) {
      this.roiTable.dispose();
    }
    for (let roiSet of this.roiSets) {
      roiSet.dispose();
    }
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
  }
}
function locusChangeHandler() {
  this.renderAllROISets();
}
function createRegionKey(chr, start, end) {
  return `${chr}-${start}-${end}`;
}
function createSelector(regionKey) {
  return `[data-region="${regionKey}"]`;
}
function parseRegionKey(regionKey) {
  let [chr, ss, ee] = regionKey.split("-");
  ss = parseInt(ss);
  ee = parseInt(ee);
  return { chr, start: ss, end: ee, locus: `${chr}:${ss}-${ee}`, bedRecord: `${chr}	${ss}	${ee}` };
}
class ROITable extends RegionTableBase {
  constructor(config) {
    const cooked = Object.assign({ "width": "512px" }, config);
    super(cooked);
  }
  tableRowDOM(record) {
    const dom = domUtils$1.div({ class: "igv-roi-table-row" });
    const { setName, feature: feature2 } = record;
    dom.dataset.region = createRegionKey(feature2.chr, feature2.start, feature2.end);
    let strings2 = [
      feature2.chr,
      numberFormatter$1(feature2.start),
      numberFormatter$1(feature2.end),
      feature2.name || "",
      setName
    ];
    if (4 === this.columnFormat.length) {
      strings2 = strings2.slice(0, 4);
    }
    for (let i = 0; i < strings2.length; i++) {
      const el = domUtils$1.div();
      dom.appendChild(el);
      el.style.width = this.columnFormat[i].width;
      el.innerText = strings2[i];
    }
    this.tableRowDOMHelper(dom);
    return dom;
  }
  renderTable(records) {
    Array.from(this.tableRowContainer.querySelectorAll(".igv-roi-table-row")).forEach((el) => el.remove());
    if (records.length > 0) {
      const sortedRecords = records.sort((a, b) => a.feature.chr.localeCompare(b.feature.chr) || a.feature.start - b.feature.start || a.feature.end - b.feature.end);
      for (let record of sortedRecords) {
        const row = this.tableRowDOM(record);
        this.tableRowContainer.appendChild(row);
      }
    }
  }
  dispose() {
    document.removeEventListener("click", this.boundGotoButtonHandler);
    this.browser.roiTableControl.buttonHandler(false);
    super.dispose();
  }
  static getColumnFormatConfiguration(doIncludeROISetNames) {
    if (true === doIncludeROISetNames) {
      return [
        { label: "Chr", width: "20%" },
        { label: "Start", width: "15%" },
        { label: "End", width: "15%" },
        { label: "Description", width: "30%" },
        { label: "ROI Set", width: "20%" }
      ];
    } else {
      return [
        { label: "Chr", width: "25%" },
        { label: "Start", width: "20%" },
        { label: "End", width: "20%" },
        { label: "Description", width: "35%" }
      ];
    }
  }
  static gotoButtonHandler(event) {
    event.stopPropagation();
    const selected = this.tableDOM.querySelectorAll(".igv-roi-table-row-selected");
    const loci = [];
    for (let el of selected) {
      const { locus } = parseRegionKey(el.dataset.region);
      loci.push(locus);
    }
    for (let el of this.tableDOM.querySelectorAll(".igv-roi-table-row")) {
      el.classList.remove("igv-roi-table-row-selected");
    }
    this.setTableRowSelectionState(false);
    if (loci.length > 0) {
      this.browser.search(loci.join(" "));
    }
  }
}
class ROIMenu {
  constructor(browser, parent) {
    this.browser = browser;
    this.container = domUtils$1.div({ class: "igv-roi-menu-next-gen" });
    parent.appendChild(this.container);
    const header = domUtils$1.div();
    this.container.appendChild(header);
    uiUtils$1.attachDialogCloseHandlerWithParent(header, () => this.container.style.display = "none");
    this.body = domUtils$1.div();
    this.container.appendChild(this.body);
    this.container.style.display = "none";
  }
  async present(x, y, roiManager, columnContainer, regionElement) {
    removeAllChildNodes(this.body);
    const feature2 = await this.browser.roiManager.findUserDefinedRegionWithKey(regionElement.dataset.region);
    const _description_copy_ = domUtils$1.div();
    this.body.appendChild(_description_copy_);
    const placeholder = "Description";
    const str = feature2.name || placeholder;
    _description_copy_.innerText = str;
    _description_copy_.setAttribute("title", str);
    placeholder === str ? _description_copy_.classList.add("igv-roi-placeholder") : _description_copy_.classList.remove("igv-roi-placeholder");
    const description = domUtils$1.div();
    this.body.appendChild(description);
    description.innerText = "Set Description";
    description.addEventListener("click", (event) => {
      event.stopPropagation();
      this.container.style.display = "none";
      const callback = () => {
        const value = this.browser.inputDialog.value || "";
        feature2.name = value.trim();
        this.container.style.display = "none";
        this.browser.roiManager.repaintTable();
      };
      const config = {
        label: "Description",
        value: feature2.name || "",
        callback
      };
      this.browser.inputDialog.present(config, event);
    });
    const _delete_ = domUtils$1.div();
    this.body.appendChild(_delete_);
    _delete_.innerText = "Delete Region";
    _delete_.addEventListener("click", (event) => {
      event.stopPropagation();
      this.container.style.display = "none";
      this.browser.roiManager.deleteUserDefinedRegionWithKey(regionElement.dataset.region, this.browser.columnContainer);
    });
    this.container.style.left = `${x}px`;
    this.container.style.top = `${y}px`;
    this.container.style.display = "flex";
  }
  async __present(x, y, roiManager, columnContainer, regionElement) {
    removeAllChildNodes(this.container);
    const feature2 = await this.browser.roiManager.findUserDefinedRegionWithKey(regionElement.dataset.region);
    let row;
    row = domUtils$1.div({ class: "igv-roi-menu-row-edit-description" });
    this.container.appendChild(row);
    row.addEventListener("click", (e) => {
      e.stopPropagation();
    });
    const str = "description-input";
    const label = document.createElement("label");
    row.appendChild(label);
    label.setAttribute("for", str);
    label.innerText = "Description:";
    const input = document.createElement("input");
    row.appendChild(input);
    input.setAttribute("type", "text");
    input.setAttribute("name", str);
    input.setAttribute("placeholder", "");
    input.value = feature2.name || "";
    input.addEventListener("change", async (e) => {
      e.stopPropagation();
      const feature3 = await this.browser.roiManager.findUserDefinedRegionWithKey(regionElement.dataset.region);
      feature3.name = input.value;
      input.blur();
      this.container.style.display = "none";
      await this.browser.roiManager.repaintTable();
    });
    row = domUtils$1.div({ class: "igv-roi-menu-row" });
    row.innerText = "Delete region";
    this.container.appendChild(row);
    row.addEventListener("click", (event) => {
      event.stopPropagation();
      this.container.style.display = "none";
      this.browser.roiManager.deleteUserDefinedRegionWithKey(regionElement.dataset.region, this.browser.columnContainer);
    });
    this.container.style.left = `${x}px`;
    this.container.style.top = `${y}px`;
    this.container.style.display = "flex";
    columnContainer.addEventListener("click", (event) => {
      event.stopPropagation();
      this.container.style.display = "none";
    });
  }
  dispose() {
    this.container.innerHTML = "";
  }
}
function removeAllChildNodes(parent) {
  while (parent.firstChild) {
    parent.removeChild(parent.firstChild);
  }
}
class TrackROISet {
  constructor(config, genome) {
    this.name = config.name;
    this.featureSource = config.featureSource || FeatureSource(config, genome);
    this.color = config.color || ROI_DEFAULT_COLOR;
  }
  async getFeatures(chr, start, end) {
    return this.featureSource.getFeatures({ chr, start, end });
  }
  draw(drawConfiguration) {
    const { context, bpPerPixel, bpStart, pixelTop, pixelHeight, pixelWidth, features } = drawConfiguration;
    if (!features) {
      return;
    }
    const bpEnd = bpStart + pixelWidth * bpPerPixel + 1;
    for (let { start: regionStartBP, end: regionEndBP } of features) {
      if (regionEndBP < bpStart) {
        continue;
      }
      if (regionStartBP > bpEnd) {
        break;
      }
      const { x, width } = screenCoordinates(regionStartBP, regionEndBP, bpStart, bpPerPixel);
      IGVGraphics.fillRect(context, x, pixelTop, width, pixelHeight, { fillStyle: this.color });
    }
  }
}
class ROITableControl {
  constructor(parent, browser) {
    this.browser = browser;
    this.button = domUtils$1.div({ class: "igv-navbar-button" });
    parent.appendChild(this.button);
    this.button.textContent = "ROI Table";
    this.button.addEventListener("click", () => {
      this.buttonHandler(!browser.roiTableVisible);
    });
    this.browser = browser;
    this.setVisibility(browser.showROITableButton);
    this.setState(browser.roiTableVisible);
  }
  buttonHandler(status) {
    this.browser.roiTableVisible = status;
    this.setState(this.browser.roiTableVisible);
    this.browser.setROITableVisibility(this.browser.roiTableVisible);
  }
  setVisibility(doShowROITablelButton) {
    if (true === doShowROITablelButton) {
      this.show();
    } else {
      this.hide();
    }
  }
  setState(roiTableVisible) {
    if (true === roiTableVisible) {
      this.button.classList.add("igv-navbar-button-clicked");
    } else {
      this.button.classList.remove("igv-navbar-button-clicked");
    }
  }
  show() {
    this.button.style.display = "block";
    this.setState(this.browser.roiTableVisible);
  }
  hide() {
    this.button.style.display = "none";
  }
}
const igv_scrollbar_outer_width = 14;
const igv_track_manipulation_handle_width = 12;
const igv_track_gear_menu_column_width = 28;
const column_multi_locus_shim_width = 2 + 1 + 2;
const defaultSampleNameViewportWidth = 200;
class Browser {
  constructor(config, parentDiv) {
    this.config = config;
    this.guid = domUtils$1.guid();
    this.namespace = ".browser_" + this.guid;
    this.parent = parentDiv;
    this.root = domUtils$1.div({ class: "igv-container" });
    parentDiv.appendChild(this.root);
    this.alert = new Alert$2(this.root);
    this.columnContainer = domUtils$1.div({ class: "igv-column-container" });
    this.root.appendChild(this.columnContainer);
    this.menuPopup = new MenuPopup(this.columnContainer);
    this.initialize(config);
    this.trackViews = [];
    this.constants = {
      dragThreshold: 3,
      scrollThreshold: 5,
      defaultColor: "rgb(0,0,150)",
      doubleClickDelay: config.doubleClickDelay || 500
    };
    this.eventHandlers = {};
    this.addMouseHandlers();
    this.setControls(config);
  }
  initialize(config) {
    if (config.gtex) {
      GtexUtils.gtexLoaded = true;
    }
    this.flanking = config.flanking;
    this.crossDomainProxy = config.crossDomainProxy;
    this.formats = config.formats;
    this.trackDefaults = config.trackDefaults;
    this.nucleotideColors = config.nucleotideColors || defaultNucleotideColors;
    for (let key of Object.keys(this.nucleotideColors)) {
      this.nucleotideColors[key.toLowerCase()] = this.nucleotideColors[key];
    }
    this.trackLabelsVisible = config.showTrackLabels;
    this.roiTableVisible = config.showROITable;
    this.showROITableButton = config.showROITableButton;
    this.isCenterLineVisible = config.showCenterGuide;
    this.cursorGuideVisible = config.showCursorGuide;
    this.showSampleNames = config.showSampleNames;
    this.showSampleNameButton = config.showSampleNameButton;
    this.sampleNameViewportWidth = config.sampleNameViewportWidth || defaultSampleNameViewportWidth;
    if (config.search) {
      this.searchConfig = {
        type: "json",
        url: config.search.url,
        coords: config.search.coords === void 0 ? 1 : config.search.coords,
        chromosomeField: config.search.chromosomeField || "chromosome",
        startField: config.search.startField || "start",
        endField: config.search.endField || "end",
        geneField: config.search.geneField || "gene",
        snpField: config.search.snpField || "snp",
        resultsField: config.search.resultsField
      };
    }
  }
  setControls(config) {
    const $navBar = this.createStandardControls(config);
    $navBar.insertBefore($$1(this.columnContainer));
    this.$navigation = $navBar;
    if (false === config.showControls) {
      $navBar.hide();
    }
  }
  createStandardControls(config) {
    this.navbarManager = new NavbarManager(this);
    const $navBar = $$1("<div>", { class: "igv-navbar" });
    this.$navigation = $navBar;
    const $navbarLeftContainer = $$1("<div>", { class: "igv-navbar-left-container" });
    $navBar.append($navbarLeftContainer);
    const $logo = $$1("<div>", { class: "igv-logo" });
    $navbarLeftContainer.append($logo);
    const logoSvg = logo();
    logoSvg.css("width", "34px");
    logoSvg.css("height", "32px");
    $logo.append(logoSvg);
    this.$current_genome = $$1("<div>", { class: "igv-current-genome" });
    $navbarLeftContainer.append(this.$current_genome);
    this.$current_genome.text("");
    const $genomicLocation = $$1("<div>", { class: "igv-navbar-genomic-location" });
    $navbarLeftContainer.append($genomicLocation);
    this.chromosomeSelectWidget = new ChromosomeSelectWidget(this, $genomicLocation.get(0));
    if (void 0 === config.showChromosomeWidget) {
      config.showChromosomeWidget = true;
    }
    if (true === config.showChromosomeWidget) {
      this.chromosomeSelectWidget.show();
    } else {
      this.chromosomeSelectWidget.hide();
    }
    const $locusSizeGroup = $$1("<div>", { class: "igv-locus-size-group" });
    $genomicLocation.append($locusSizeGroup);
    const $searchContainer = $$1("<div>", { class: "igv-search-container" });
    $locusSizeGroup.append($searchContainer);
    this.$searchInput = $$1("<input>", { class: "igv-search-input", type: "text", placeholder: "Locus Search" });
    $searchContainer.append(this.$searchInput);
    this.$searchInput.change(() => this.doSearch(this.$searchInput.val()));
    const searchIconContainer = domUtils$1.div({ class: "igv-search-icon-container" });
    $searchContainer.append($$1(searchIconContainer));
    searchIconContainer.appendChild(icons$1$1.createIcon("search"));
    searchIconContainer.addEventListener("click", () => this.doSearch(this.$searchInput.val()));
    this.windowSizePanel = new WindowSizePanel($locusSizeGroup.get(0), this);
    const $navbarRightContainer = $$1("<div>", { class: "igv-navbar-right-container" });
    $navBar.append($navbarRightContainer);
    const $toggle_button_container = $$1('<div class="igv-navbar-toggle-button-container">');
    $navbarRightContainer.append($toggle_button_container);
    this.$toggle_button_container = $toggle_button_container;
    this.cursorGuide = new CursorGuide(this.columnContainer, this);
    this.cursorGuideButton = new CursorGuideButton(this, $toggle_button_container.get(0));
    this.centerLineButton = new CenterLineButton(this, $toggle_button_container.get(0));
    this.setTrackLabelVisibility(config.showTrackLabels);
    this.trackLabelControl = new TrackLabelControl($toggle_button_container.get(0), this);
    this.roiTableControl = new ROITableControl($toggle_button_container.get(0), this);
    this.sampleNameControl = new SampleNameControl($toggle_button_container.get(0), this);
    if (true === config.showSVGButton) {
      this.svgSaveControl = new SVGSaveControl($toggle_button_container.get(0), this);
    }
    if (config.customButtons) {
      for (let b of config.customButtons) {
        new CustomButton($toggle_button_container.get(0), this, b);
      }
    }
    this.zoomWidget = new ZoomWidget(this, $navbarRightContainer.get(0));
    if (false === config.showNavigation) {
      this.$navigation.hide();
    }
    this.inputDialog = new InputDialog$1(this.root);
    this.inputDialog.container.id = `igv-input-dialog-${domUtils$1.guid()}`;
    this.dataRangeDialog = new DataRangeDialog$1(this, $$1(this.root));
    this.dataRangeDialog.$container.get(0).id = `igv-data-range-dialog-${domUtils$1.guid()}`;
    this.genericColorPicker = new GenericColorPicker({ parent: this.columnContainer, width: 432 });
    this.genericColorPicker.container.id = `igv-track-color-picker-${domUtils$1.guid()}`;
    return $navBar;
  }
  getSampleNameViewportWidth() {
    return false === this.showSampleNames ? 0 : this.sampleNameViewportWidth;
  }
  isMultiLocusMode() {
    return this.referenceFrameList && this.referenceFrameList.length > 1;
  }
  addTrackToFactory(name2, track) {
    TrackFactory.addTrack(name2, track);
  }
  isMultiLocusWholeGenomeView() {
    if (void 0 === this.referenceFrameList || 1 === this.referenceFrameList.length) {
      return false;
    }
    for (let referenceFrame of this.referenceFrameList) {
      if ("all" === referenceFrame.chr.toLowerCase()) {
        return true;
      }
    }
    return false;
  }
  /**
   * PUBLIC API FUNCTION
   *
   * Return the current genomic region as a locus string, or array of locus strings if in multi-locus view
   * @returns {string|*[]|*}
   */
  currentLoci() {
    const noCommaLocusString = (rf) => `${rf.chr}:${rf.start + 1}-${rf.end}`;
    if (void 0 === this.referenceFrameList || 0 === this.referenceFrameList.length) {
      return "";
    } else if (1 === this.referenceFrameList.length) {
      return noCommaLocusString(this.referenceFrameList[0]);
    } else {
      return this.referenceFrameList.map((rf) => noCommaLocusString(rf));
    }
  }
  /**
   * Render browse display as SVG
   * @returns {string}
   */
  toSVG() {
    const { y, width, height } = this.columnContainer.getBoundingClientRect();
    const h_render = 8e3;
    const config = {
      width,
      height: h_render,
      backdropColor: "white",
      multiLocusGap: 0,
      viewbox: {
        x: 0,
        y: 0,
        width,
        height: h_render
      }
    };
    const context = new ctx(config);
    const delta = { deltaX: 0, deltaY: -y };
    for (let trackView of this.trackViews) {
      trackView.renderSVGContext(context, delta);
    }
    this.roiManager.renderSVGContext(context, delta);
    context.setHeight(height);
    return context.getSerializedSvg(true);
  }
  renderSVG($container) {
    const svg2 = this.toSVG();
    $container.empty();
    $container.append(svg2);
    return svg2;
  }
  saveSVGtoFile(config) {
    let svg2 = this.toSVG();
    if (config.$container) {
      config.$container.empty();
      config.$container.append(svg2);
    }
    const path = config.filename || "igvjs.svg";
    const data = URL.createObjectURL(new Blob([svg2], { type: "application/octet-stream" }));
    download(path, data);
  }
  /**
   * Initialize a session from an object, json, or by loading from a file.
   *
   * TODO Really should be split into at least 2 functions, load from file and load from object/json
   *
   * @param options
   * @returns {*}
   */
  async loadSession(options2) {
    this.roiSets = [];
    let session;
    if (options2.url || options2.file) {
      session = await loadSessionFile(options2);
    } else {
      session = options2;
    }
    return this.loadSessionObject(session);
    async function loadSessionFile(options3) {
      const urlOrFile = options3.url || options3.file;
      if (options3.url && (options3.url.startsWith("blob:") || options3.url.startsWith("data:"))) {
        const json = Browser.uncompressSession(options3.url);
        return JSON.parse(json);
      } else {
        let filename = options3.filename;
        if (!filename) {
          filename = options3.url ? await getFilename$1(options3.url) : options3.file.name;
        }
        if (filename.endsWith(".xml")) {
          const knownGenomes2 = GenomeUtils.KNOWN_GENOMES;
          const string = await igvxhr.loadString(urlOrFile);
          return new XMLSession(string, knownGenomes2);
        } else if (filename.endsWith(".json")) {
          return igvxhr.loadJson(urlOrFile);
        } else {
          return void 0;
        }
      }
    }
  }
  /**
   * Note:  public API function
   * @param session
   * @returns {Promise<void>}
   */
  async loadSessionObject(session) {
    this.cleanHouseForSession();
    this.showSampleNames = session.showSampleNames || false;
    this.sampleNameControl.setState(this.showSampleNames === true);
    if (session.sampleNameViewportWidth) {
      this.sampleNameViewportWidth = session.sampleNameViewportWidth;
    }
    createColumn(this.columnContainer, "igv-axis-column");
    createColumn(this.columnContainer, "igv-sample-name-column");
    createColumn(this.columnContainer, "igv-scrollbar-column");
    createColumn(this.columnContainer, "igv-track-drag-column");
    createColumn(this.columnContainer, "igv-gear-menu-column");
    const genomeOrReference = session.reference || session.genome;
    if (!genomeOrReference) {
      console.warn("No genome or reference object specified");
      return;
    }
    const genomeConfig = await GenomeUtils.expandReference(this.alert, genomeOrReference);
    await this.loadReference(genomeConfig, session.locus);
    this.centerLineList = this.createCenterLineList(this.columnContainer);
    let ideogramHeight = 0;
    if (false !== session.showIdeogram) {
      const track = new IdeogramTrack(this);
      track.id = "ideogram";
      const trackView = new TrackView(this, this.columnContainer, track);
      const { $viewport } = trackView.viewports[0];
      ideogramHeight = getElementAbsoluteHeight($viewport.get(0));
      this.trackViews.push(trackView);
    }
    if (false !== session.showRuler) {
      this.trackViews.push(new TrackView(this, this.columnContainer, new RulerTrack(this)));
    }
    if (session.gtexSelections) {
      for (let referenceFrame of this.referenceFrameList) {
        for (let s of Object.keys(session.gtexSelections)) {
          const gene = session.gtexSelections[s].gene;
          const snp = session.gtexSelections[s].snp;
          referenceFrame.selection = new GtexSelection(gene, snp);
        }
      }
    }
    if (this.roiManager) {
      this.roiManager.dispose();
    }
    const roiMenu = new ROIMenu(this, this.columnContainer);
    const roiTableConfig = {
      browser: this,
      parent: this.columnContainer,
      headerTitle: "Regions of Interest",
      dismissHandler: () => this.roiTableControl.buttonHandler(false),
      gotoButtonHandler: ROITable.gotoButtonHandler
    };
    if (session.roi) {
      const roiSetList = session.roi.map((c) => new ROISet(c, this.genome));
      const named = roiSetList.filter(({ name: name2 }) => name2 !== void 0 && name2.length > 0);
      roiTableConfig.columnFormat = ROITable.getColumnFormatConfiguration(named.length > 0);
      const roiTable = new ROITable(roiTableConfig);
      this.roiManager = new ROIManager(this, roiMenu, roiTable, ideogramHeight, roiSetList);
    } else {
      roiTableConfig.columnFormat = ROITable.getColumnFormatConfiguration(false);
      const roiTable = new ROITable(roiTableConfig);
      this.roiManager = new ROIManager(this, roiMenu, roiTable, ideogramHeight, void 0);
    }
    await this.roiManager.initialize();
    const genomeTracks = genomeConfig.tracks || [];
    const trackConfigurations = session.tracks ? genomeTracks.concat(session.tracks) : genomeTracks;
    const pushSequenceTrack = trackConfigurations.filter((track) => "sequence" === track.type && !track.url && !track.fastaURL).length === 0;
    if (pushSequenceTrack) {
      trackConfigurations.push({ type: "sequence", order: defaultSequenceTrackOrder });
    }
    let trackOrder = 1;
    for (let t of trackConfigurations) {
      if (void 0 === t.order) {
        t.order = trackOrder++;
      }
    }
    await this.loadTrackList(trackConfigurations);
    for (let rtv of this.trackViews.filter((tv) => tv.track.type === "ruler" || tv.track.type === "ideogram")) {
      rtv.updateViews();
    }
    this.updateUIWithReferenceFrameList();
  }
  createCenterLineList(columnContainer) {
    const centerLines = columnContainer.querySelectorAll(".igv-center-line");
    for (let i = 0; i < centerLines.length; i++) {
      centerLines[i].remove();
    }
    const centerLineList = [];
    const viewportColumns = columnContainer.querySelectorAll(".igv-column");
    for (let i = 0; i < viewportColumns.length; i++) {
      centerLineList.push(new ViewportCenterLine(this, this.referenceFrameList[i], viewportColumns[i]));
    }
    return centerLineList;
  }
  /**
   * Load a reference genome object.  This includes the fasta, and optional cytoband, but no tracks.  This method
   * is used by loadGenome and loadSession.
   *
   * @param genomeConfig
   * @param initialLocus
   */
  async loadReference(genomeConfig, initialLocus) {
    const genome = await GenomeUtils.loadGenome(genomeConfig);
    const genomeChange = void 0 === this.genome || this.genome.id !== genome.id;
    this.genome = genome;
    this.updateNavbarDOMWithGenome(genome);
    if (genomeChange) {
      this.removeAllTracks();
    }
    let locus = getInitialLocus(initialLocus, genome);
    const locusFound = await this.search(locus, true);
    if (!locusFound) {
      console.log("Initial locus not found: " + locus);
      locus = genome.getHomeChromosomeName();
      const locusFound2 = await this.search(locus, true);
      if (!locusFound2) {
        throw new Error("Cannot set initial locus");
      }
    }
    if (genomeChange && this.circularView) {
      this.circularView.setAssembly({
        name: this.genome.id,
        id: this.genome.id,
        chromosomes: makeCircViewChromosomes(this.genome)
      });
    }
  }
  cleanHouseForSession() {
    for (let trackView of this.trackViews) {
      trackView.removeDOMFromColumnContainer();
    }
    const elements = this.columnContainer.querySelectorAll(".igv-axis-column, .igv-column-shim, .igv-column, .igv-sample-name-column, .igv-scrollbar-column, .igv-track-drag-column, .igv-gear-menu-column");
    elements.forEach((column) => column.remove());
    this.trackViews = [];
    if (this.circularView) {
      this.circularView.clearChords();
    }
  }
  updateNavbarDOMWithGenome(genome) {
    let genomeLabel = genome.id && genome.id.length < 10 ? genome.id : "";
    this.$current_genome.text(genomeLabel);
    this.$current_genome.attr("title", genome.id || "");
    this.chromosomeSelectWidget.update(genome);
  }
  /**
   * Load a genome, defined by a string ID or a json-like configuration object. This includes a fasta reference
   * as well as optional cytoband and annotation tracks.
   *
   * @param idOrConfig
   * @returns genome
   */
  async loadGenome(idOrConfig) {
    const genomeConfig = await GenomeUtils.expandReference(this.alert, idOrConfig);
    await this.loadReference(genomeConfig, void 0);
    const tracks = genomeConfig.tracks || [];
    const pushSequenceTrack = tracks.filter((track) => track.type === "sequence").length === 0;
    if (pushSequenceTrack) {
      tracks.push({ type: "sequence", order: defaultSequenceTrackOrder });
    }
    await this.loadTrackList(tracks);
    await this.updateViews();
    return this.genome;
  }
  /**
   * Called after a session load, search, pan (horizontal drag), or resize
   *
   * @param referenceFrameList
   */
  updateUIWithReferenceFrameList() {
    const referenceFrameList = this.referenceFrameList;
    this.updateLocusSearchWidget();
    const isWGV = this.isMultiLocusWholeGenomeView() || GenomeUtils.isWholeGenomeView(referenceFrameList[0].chr);
    this.navbarManager.navbarDidResize(this.$navigation.width(), isWGV);
    toggleTrackLabels(this.trackViews, this.trackLabelsVisible);
    this.setCenterLineAndCenterLineButtonVisibility(!GenomeUtils.isWholeGenomeView(referenceFrameList[0].chr));
  }
  setTrackLabelVisibility(isVisible) {
    toggleTrackLabels(this.trackViews, isVisible);
  }
  setROITableVisibility(isVisible) {
    true === isVisible ? this.roiManager.presentTable() : this.roiManager.dismissTable();
  }
  // cursor guide
  setCursorGuideVisibility(cursorGuideVisible) {
    if (cursorGuideVisible) {
      this.cursorGuide.show();
    } else {
      this.cursorGuide.hide();
    }
  }
  setCustomCursorGuideMouseHandler(mouseHandler) {
    this.cursorGuide.customMouseHandler = mouseHandler;
  }
  // center line
  setCenterLineVisibility(isCenterLineVisible) {
    for (let centerLine of this.centerLineList) {
      if (true === isCenterLineVisible) {
        centerLine.show();
        centerLine.repaint();
      } else {
        centerLine.hide();
      }
    }
  }
  setCenterLineAndCenterLineButtonVisibility(isCenterLineVisible) {
    for (let centerLine of this.centerLineList) {
      const isShown2 = isCenterLineVisible && centerLine.isVisible;
      isShown2 ? centerLine.show() : centerLine.container.style.display = "none";
    }
    const isShown = isCenterLineVisible && this.centerLineButton.isVisible;
    isShown ? this.centerLineButton.show() : this.centerLineButton.button.style.display = "none";
  }
  /**
   * Public API function. Load a list of tracks.
   *
   * @param configList  Array of track configurations
   * @returns {Promise<*>}  Promise for track objects
   */
  async loadTrackList(configList) {
    const promises = [];
    for (let config of configList) {
      promises.push(this._loadTrack(config));
    }
    const loadedTracks = await Promise.all(promises);
    const groupAutoscaleViews = this.trackViews.filter(function(trackView) {
      return trackView.track.autoscaleGroup;
    });
    if (groupAutoscaleViews.length > 0) {
      this.updateViews();
    }
    return loadedTracks;
  }
  /**
   * Public API function
   *
   * Load an individual track.  If part of an autoscale group force a general update
   *
   * @param config  A track configuration
   * @returns {Promise<*>}  Promise for track object
   */
  async loadTrack(config) {
    const newTrack = this._loadTrack(config);
    if (config.autoscaleGroup) {
      await newTrack;
      this.updateViews();
    }
    return newTrack;
  }
  /**
   * Return a promise to load a track.   Private function used by loadTrack() and loadTrackList()
   *
   * @param config
   * @returns {*}
   */
  async _loadTrack(config) {
    if (isString$2(config)) {
      config = JSON.parse(config);
    }
    try {
      const newTrack = await this.createTrack(config);
      if (void 0 === newTrack) {
        return;
      }
      if (void 0 === newTrack.order) {
        newTrack.order = this.trackViews.length;
      }
      const trackView = new TrackView(this, this.columnContainer, newTrack);
      this.trackViews.push(trackView);
      toggleTrackLabels(this.trackViews, this.trackLabelsVisible);
      this.reorderTracks();
      this.fireEvent("trackorderchanged", [this.getTrackOrder()]);
      if (typeof newTrack.postInit === "function") {
        try {
          trackView.startSpinner();
          await newTrack.postInit();
        } finally {
          trackView.stopSpinner();
        }
      }
      if (!newTrack.autoscaleGroup) {
        if (config.sync) {
          await trackView.updateViews();
        } else {
          trackView.updateViews();
        }
      }
      if (typeof newTrack.hasSamples === "function" && newTrack.hasSamples()) {
        if (this.config.showSampleNameButton !== false) {
          this.sampleNameControl.show();
        }
      }
      return newTrack;
    } catch (error) {
      const httpMessages2 = {
        "401": "Access unauthorized",
        "403": "Access forbidden",
        "404": "Not found"
      };
      console.error(error);
      let msg = error.message || error.error || error.toString();
      if (httpMessages2.hasOwnProperty(msg)) {
        msg = httpMessages2[msg];
      }
      msg += ": " + config.url;
      this.alert.present(new Error(msg), void 0);
    }
  }
  /**
   * Public API function - load a region of interest
   *
   * @param config  A "track" configuration object, or array of objects,  of type == "annotation" (bed, gff, etc)
   *
   * @returns {Promise<void>}
   */
  async loadROI(config) {
    await this.roiManager.loadROI(config, this.genome);
  }
  /**
   * Public API function - clear all regions of interest (ROI), including preloaded and user-defined ROIs
   */
  clearROIs() {
    this.roiManager.clearROIs();
  }
  /**
   * Public API function. Return a promise for the list of user-defined regions-of-interest
   */
  async getUserDefinedROIs() {
    if (this.roiManager) {
      const set = await this.roiManager.getUserDefinedROISet();
      if (void 0 === set) {
        return [];
      }
      const featureHash = await set.getAllFeatures();
      const featureList = [];
      for (let value of Object.values(featureHash)) {
        featureList.push(...value);
      }
      return featureList;
    } else {
      return [];
    }
  }
  getRulerTrackView() {
    const list = this.trackViews.filter(({ track }) => "ruler" === track.id);
    return list.length > 0 ? list[0] : void 0;
  }
  /**
   * Create a Track object.
   * @param config
   * @returns {Promise<*>}
   */
  async createTrack(config) {
    let url = await resolveURL(config.url || config.fastaURL);
    if (isString$2(url)) {
      url = url.trim();
    }
    if (url) {
      if (config.format) {
        config.format = config.format.toLowerCase();
      } else if (config.fastaURL) {
        config.format = "fasta";
      } else {
        let filename = config.filename;
        if (!filename) {
          filename = await getFilename$1(url);
        }
        const format2 = inferFileFormat(filename);
        if ("tsv" === format2) {
          config.format = await inferFileFormatFromHeader(config);
        } else if (format2) {
          config.format = format2;
        } else {
          if (config.sourceType === "htsget") {
            await HtsgetReader.inferFormat(config);
          }
        }
      }
    }
    let type = config.type ? config.type.toLowerCase() : void 0;
    if (!type) {
      type = inferTrackType(config);
      if ("bedtype" === type) {
        const featureSource = FeatureSource(config, this.genome);
        config._featureSource = featureSource;
        const trackType = await featureSource.trackType();
        if (trackType) {
          type = trackType;
        } else {
          type = "annotation";
        }
      }
      config.type = type;
    }
    if (this.trackDefaults && type) {
      const settings = this.trackDefaults[type];
      if (settings) {
        for (let property in settings) {
          if (settings.hasOwnProperty(property) && config[property] === void 0) {
            config[property] = settings[property];
          }
        }
      }
    }
    const track = TrackFactory.getTrack(type, config, this);
    if (void 0 === track) {
      this.alert.present(new Error(`Error creating track.  Could not determine track type for file: ${config.url || config}`), void 0);
    } else {
      if (config.roi && config.roi.length > 0) {
        track.roiSets = config.roi.map((r) => new TrackROISet(r, this.genome));
      }
      return track;
    }
  }
  reorderTracks() {
    this.trackViews.sort(function(a, b) {
      const firstSortOrder = (tv) => {
        return "ideogram" === tv.track.id ? 1 : "ruler" === tv.track.id ? 2 : 3;
      };
      const aOrder1 = firstSortOrder(a);
      const bOrder1 = firstSortOrder(b);
      if (aOrder1 === bOrder1) {
        const aOrder2 = a.track.order || 0;
        const bOrder2 = b.track.order || 0;
        return aOrder2 - bOrder2;
      } else {
        return aOrder1 - bOrder1;
      }
    });
    for (let { axis, viewports, sampleNameViewport, outerScroll, dragHandle, gearContainer } of this.trackViews) {
      axis.remove();
      for (let { $viewport } of viewports) {
        $viewport.detach();
      }
      sampleNameViewport.viewport.remove();
      outerScroll.remove();
      dragHandle.remove();
      gearContainer.remove();
    }
    const viewportColumns = this.columnContainer.querySelectorAll(".igv-column");
    for (let { axis, viewports, sampleNameViewport, outerScroll, dragHandle, gearContainer } of this.trackViews) {
      this.columnContainer.querySelector(".igv-axis-column").appendChild(axis);
      for (let i = 0; i < viewportColumns.length; i++) {
        const { $viewport } = viewports[i];
        viewportColumns[i].appendChild($viewport.get(0));
      }
      this.columnContainer.querySelector(".igv-sample-name-column").appendChild(sampleNameViewport.viewport);
      this.columnContainer.querySelector(".igv-scrollbar-column").appendChild(outerScroll);
      this.columnContainer.querySelector(".igv-track-drag-column").appendChild(dragHandle);
      this.columnContainer.querySelector(".igv-gear-menu-column").appendChild(gearContainer);
    }
  }
  getTrackOrder() {
    return this.trackViews.filter((tv) => tv.track && tv.track.name).map((tv) => tv.track.name);
  }
  /**
   * NOTE: Public API function
   *
   * Remove all tracks matching the given name.  Usually this will be a single track, but there is no
   * guarantee names are unique
   *
   * @param name
   */
  removeTrackByName(name2) {
    const copy = this.trackViews.slice();
    for (let trackView of copy) {
      if (name2 === trackView.track.name) {
        this.removeTrack(trackView.track);
      }
    }
  }
  /**
   * NOTE: Public API function
   *
   * Remove the given track.  If it has already been removed this is a no-op.
   *
   * @param track
   */
  removeTrack(track) {
    for (let trackView of this.trackViews) {
      if (track === trackView.track) {
        this._removeTrack(trackView.track);
        break;
      }
    }
  }
  _removeTrack(track) {
    if (track.disposed) return;
    this.trackViews.splice(this.trackViews.indexOf(track.trackView), 1);
    this.fireEvent("trackremoved", [track]);
    this.fireEvent("trackorderchanged", [this.getTrackOrder()]);
    if (track.trackView) {
      track.trackView.dispose();
    }
  }
  /**
   * API function
   */
  removeAllTracks() {
    const remainingTrackViews = [];
    for (let trackView of this.trackViews) {
      if (trackView.track.id !== "ruler" && trackView.track.id !== "ideogram") {
        this.fireEvent("trackremoved", [trackView.track]);
        trackView.dispose();
      } else {
        remainingTrackViews.push(trackView);
      }
    }
    this.trackViews = remainingTrackViews;
  }
  /**
   *
   * @param property
   * @param value
   * @returns {Array}  tracks with given property value.  e.g. findTracks("type", "annotation")
   */
  findTracks(property, value) {
    let f = typeof property === "function" ? (trackView) => property(trackView.track) : (trackView) => value === trackView.track[property];
    return this.trackViews.filter(f).map((tv) => tv.track);
  }
  /**
   * Set the track height globally for all tracks.  (Note: Its not clear why this is useful).
   * @param newHeight
   */
  setTrackHeight(newHeight) {
    this.trackHeight = newHeight;
    this.trackViews.forEach(function(trackView) {
      trackView.setTrackHeight(newHeight);
    });
  }
  /**
   * API function to signal that this browser visibility has changed, e.g. from hiding/showing in a tab interface.
   *
   * @returns {Promise<void>}
   */
  async visibilityChange() {
    this.layoutChange();
  }
  async layoutChange() {
    const status = this.referenceFrameList.find((referenceFrame) => referenceFrame.bpPerPixel < 0);
    if (status) {
      const viewportWidth = this.calculateViewportWidth(this.referenceFrameList.length);
      for (let referenceFrame of this.referenceFrameList) {
        referenceFrame.bpPerPixel = (referenceFrame.end - referenceFrame.start) / viewportWidth;
      }
    }
    if (this.referenceFrameList) {
      const isWGV = this.isMultiLocusWholeGenomeView() || GenomeUtils.isWholeGenomeView(this.referenceFrameList[0].chr);
      this.navbarManager.navbarDidResize(this.$navigation.width(), isWGV);
    }
    resize.call(this);
    await this.updateViews();
  }
  async updateViews() {
    const trackViews = this.trackViews;
    this.updateLocusSearchWidget();
    for (let centerGuide of this.centerLineList) {
      centerGuide.repaint();
    }
    if (this.dragObject) {
      for (let trackView of trackViews) {
        await trackView.updateViews();
      }
    } else {
      const groupAutoscaleTracks = {};
      const otherTracks = [];
      for (let trackView of trackViews) {
        const group = trackView.track.autoscaleGroup;
        if (group) {
          var l = groupAutoscaleTracks[group];
          if (!l) {
            l = [];
            groupAutoscaleTracks[group] = l;
          }
          l.push(trackView);
        } else {
          otherTracks.push(trackView);
        }
      }
      if (Object.entries(groupAutoscaleTracks).length > 0) {
        const keys = Object.keys(groupAutoscaleTracks);
        for (let group of keys) {
          const groupTrackViews = groupAutoscaleTracks[group];
          const promises = [];
          for (let trackView of groupTrackViews) {
            promises.push(trackView.getInViewFeatures());
          }
          const featureArray = await Promise.all(promises);
          var allFeatures = [], dataRange;
          for (let features of featureArray) {
            allFeatures = allFeatures.concat(features);
          }
          dataRange = doAutoscale$1(allFeatures);
          const p = [];
          for (let trackView of groupTrackViews) {
            trackView.track.dataRange = dataRange;
            trackView.track.autoscale = false;
            p.push(trackView.updateViews());
          }
          await Promise.all(p);
        }
      }
      await Promise.all(otherTracks.map((tv) => tv.updateViews()));
    }
  }
  repaintViews() {
    for (let trackView of this.trackViews) {
      trackView.repaintViews();
    }
  }
  updateLocusSearchWidget() {
    if (!this.referenceFrameList) return;
    const referenceFrameList = this.referenceFrameList;
    const width = this.calculateViewportWidth(this.referenceFrameList.length);
    for (let referenceFrame of referenceFrameList) {
      referenceFrame.end = referenceFrame.start + referenceFrame.bpPerPixel * width;
    }
    this.chromosomeSelectWidget.select.value = referenceFrameList.length === 1 ? this.referenceFrameList[0].chr : "";
    const loc = this.referenceFrameList.map((rf) => rf.getLocusString()).join(" ");
    this.$searchInput.val(loc);
    this.fireEvent("locuschange", [this.referenceFrameList]);
  }
  calculateViewportWidth(columnCount) {
    let { width } = this.columnContainer.getBoundingClientRect();
    const sampleNameViewportWidth = this.getSampleNameViewportWidth();
    width -= igv_axis_column_width + sampleNameViewportWidth + igv_scrollbar_outer_width + igv_track_manipulation_handle_width + igv_track_gear_menu_column_width;
    width -= column_multi_locus_shim_width * (columnCount - 1);
    return Math.floor(width / columnCount);
  }
  getCenterLineXOffset() {
    let { width: columnContainerWidth } = this.columnContainer.getBoundingClientRect();
    columnContainerWidth -= igv_axis_column_width + this.getSampleNameViewportWidth() + igv_scrollbar_outer_width + igv_track_manipulation_handle_width + igv_track_gear_menu_column_width;
    return Math.floor(columnContainerWidth / 2 + igv_axis_column_width);
  }
  minimumBases() {
    return this.config.minimumBases;
  }
  // Zoom in by a factor of 2, keeping the same center location
  zoomIn() {
    this.zoomWithScaleFactor(0.5);
  }
  // Zoom out by a factor of 2, keeping the same center location if possible
  zoomOut() {
    this.zoomWithScaleFactor(2);
  }
  async zoomWithScaleFactor(scaleFactor, centerBPOrUndefined, referenceFrameOrUndefined) {
    if (!this.referenceFrameList) return;
    const viewportWidth = this.calculateViewportWidth(this.referenceFrameList.length);
    let referenceFrames = referenceFrameOrUndefined ? [referenceFrameOrUndefined] : this.referenceFrameList;
    for (let referenceFrame of referenceFrames) {
      referenceFrame.zoomWithScaleFactor(this, scaleFactor, viewportWidth, centerBPOrUndefined);
    }
  }
  /**
   * Add a new multi-locus panel for the specified region
   * @param chr
   * @param start
   * @param end
   * @param referenceFrameLeft - optional, if supplied new panel should be placed to the immediate right
   */
  async addMultiLocusPanel(chr, start, end, referenceFrameLeft) {
    if (!this.referenceFrameList) return;
    const viewportWidth = this.calculateViewportWidth(1 + this.referenceFrameList.length);
    const scaleFactor = this.calculateViewportWidth(this.referenceFrameList.length) / this.calculateViewportWidth(1 + this.referenceFrameList.length);
    for (let refFrame of this.referenceFrameList) {
      refFrame.bpPerPixel *= scaleFactor;
    }
    const bpp = (end - start) / viewportWidth;
    const newReferenceFrame = new ReferenceFrame(this.genome, chr, start, end, bpp);
    const indexLeft = referenceFrameLeft ? this.referenceFrameList.indexOf(referenceFrameLeft) : this.referenceFrameList.length - 1;
    const indexRight = 1 + indexLeft;
    const { $viewport } = this.trackViews[0].viewports[indexLeft];
    const viewportColumn = viewportColumnManager.insertAfter($viewport.get(0).parentElement);
    if (indexRight === this.referenceFrameList.length) {
      this.referenceFrameList.push(newReferenceFrame);
      for (let trackView of this.trackViews) {
        const viewport = createViewport(trackView, viewportColumn, newReferenceFrame);
        trackView.viewports.push(viewport);
      }
    } else {
      this.referenceFrameList.splice(indexRight, 0, newReferenceFrame);
      for (let trackView of this.trackViews) {
        const viewport = createViewport(trackView, viewportColumn, newReferenceFrame);
        trackView.viewports.splice(indexRight, 0, viewport);
      }
    }
    this.centerLineList = this.createCenterLineList(this.columnContainer);
    resize.call(this);
    await this.updateViews(true);
  }
  async removeMultiLocusPanel(referenceFrame) {
    const index2 = this.referenceFrameList.indexOf(referenceFrame);
    const { $viewport } = this.trackViews[0].viewports[index2];
    viewportColumnManager.removeColumnAtIndex(index2, $viewport.parent().get(0));
    for (let { viewports } of this.trackViews) {
      viewports[index2].dispose();
      viewports.splice(index2, 1);
    }
    this.referenceFrameList.splice(index2, 1);
    if (1 === this.referenceFrameList.length && this.getRulerTrackView()) {
      for (let rulerViewport of this.getRulerTrackView().viewports) {
        rulerViewport.dismissLocusLabel();
      }
    }
    const scaleFactor = this.calculateViewportWidth(1 + this.referenceFrameList.length) / this.calculateViewportWidth(this.referenceFrameList.length);
    await this.rescaleForMultiLocus(scaleFactor);
  }
  /**
   * Goto the locus represented by the selected referenceFrame, discarding all other panels
   *
   * @param referenceFrame
   * @returns {Promise<void>}
   */
  async gotoMultilocusPanel(referenceFrame) {
    const referenceFrameIndex = this.referenceFrameList.indexOf(referenceFrame);
    this.columnContainer.querySelectorAll(".igv-column").forEach((column, c) => {
      if (c === referenceFrameIndex) ;
      else {
        column.remove();
      }
    });
    this.columnContainer.querySelectorAll(".igv-column-shim").forEach((shim) => shim.remove());
    for (let trackView of this.trackViews) {
      const retain = trackView.viewports[referenceFrameIndex];
      trackView.viewports.filter((viewport, i) => i !== referenceFrameIndex).forEach((viewport) => viewport.dispose());
      trackView.viewports = [retain];
    }
    const viewportWidth = this.calculateViewportWidth(1);
    referenceFrame.bpPerPixel = (referenceFrame.end - referenceFrame.start) / viewportWidth;
    this.referenceFrameList = [referenceFrame];
    this.trackViews.forEach(({ viewports }) => viewports.forEach((viewport) => viewport.setWidth(viewportWidth)));
    this.centerLineList = this.createCenterLineList(this.columnContainer);
    this.updateUIWithReferenceFrameList();
    await this.updateViews(true);
  }
  async rescaleForMultiLocus(scaleFactor) {
    const viewportWidth = this.calculateViewportWidth(this.referenceFrameList.length);
    for (let referenceFrame of this.referenceFrameList) {
      referenceFrame.bpPerPixel *= scaleFactor;
    }
    for (let { viewports } of this.trackViews) {
      for (let viewport of viewports) {
        viewport.setWidth(viewportWidth);
      }
    }
    this.centerLineList = this.createCenterLineList(this.columnContainer);
    this.updateUIWithReferenceFrameList();
    await this.updateViews();
  }
  /**
   * @deprecated  This is a deprecated method with no known usages.  To be removed in a future release.
   */
  async goto(chr, start, end) {
    await this.search(chr + ":" + start + "-" + end);
  }
  /**
  
       * Search for the locus string -- this function is called from various igv.js GUI elements, and is not part of the
       * API.  Wraps ```search``` and presents an error dialog if false.
       *
       * @param string
       * @param init
       * @returns {Promise<void>}
       */
  async doSearch(string, init2) {
    const success = await this.search(string, init2);
    if (!success) {
      this.alert.present(new Error(`Unrecognized locus: <b> ${string} </b>`));
    }
    return success;
  }
  /**
   * Search for the locus string
   * NOTE: This is part of the API
   * @param string
   * @param init  true if called during browser initialization
   * @returns {Promise<boolean>}  true if found, false if not
   */
  async search(string, init2) {
    const loci = await search(this, string);
    if (loci && loci.length > 0) {
      this.referenceFrameList = createReferenceFrameList(loci, this.genome, this.flanking, this.minimumBases(), this.calculateViewportWidth(loci.length), this.isSoftclipped());
      for (let trackView of this.trackViews) {
        trackView.removeDOMFromColumnContainer();
      }
      this.columnContainer.querySelectorAll(".igv-column-shim, .igv-column").forEach((el) => el.remove());
      viewportColumnManager.insertBefore(this.columnContainer.querySelector(".igv-sample-name-column"), this.referenceFrameList.length);
      this.centerLineList = this.createCenterLineList(this.columnContainer);
      for (let trackView of this.trackViews) {
        trackView.addDOMToColumnContainer(this, this.columnContainer, this.referenceFrameList);
      }
      this.updateUIWithReferenceFrameList();
      if (!init2) {
        await this.updateViews();
      }
      return true;
    } else {
      return false;
    }
  }
  async loadSampleInformation(url) {
    var name2 = url;
    if (isFile$1(url)) {
      name2 = url.name;
    }
    var ext = name2.substr(name2.lastIndexOf(".") + 1);
    if (ext === "fam") {
      this.sampleInformation = await loadPlinkFile(url);
    }
  }
  // EVENTS
  on(eventName, fn2) {
    if (!this.eventHandlers[eventName]) {
      this.eventHandlers[eventName] = [];
    }
    this.eventHandlers[eventName].push(fn2);
  }
  /**
   * @deprecated use off()
   * @param eventName
   * @param fn
   */
  un(eventName, fn2) {
    this.off(eventName, fn2);
  }
  off(eventName, fn2) {
    if (!eventName) {
      this.eventHandlers = {};
    } else if (!fn2) {
      this.eventHandlers[eventName] = [];
    } else {
      const handlers = this.eventHandlers[eventName];
      if (!handlers || handlers.length === 0) {
        console.warn("No handlers to remove for event: " + eventName);
      } else {
        const callbackIndex = handlers.indexOf(fn2);
        if (callbackIndex !== -1) {
          this.eventHandlers[eventName].splice(callbackIndex, 1);
        }
      }
    }
  }
  fireEvent(eventName, args, thisObj) {
    const handlers = this.eventHandlers[eventName];
    if (void 0 === handlers || handlers.length === 0) {
      return void 0;
    }
    const scope = thisObj || window;
    const results = handlers.map(function(event) {
      return event.apply(scope, args);
    });
    return results[0];
  }
  dispose() {
    this.removeMouseHandlers();
    for (let trackView of this.trackViews) {
      trackView.dispose();
    }
  }
  /**
   * Return a json-like object (note not a json string) representing the current state.
   *
   */
  toJSON() {
    const json = {
      "version": version$2()
    };
    if (this.showSampleNames !== void 0) {
      json["showSampleNames"] = this.showSampleNames;
    }
    if (this.sampleNameViewportWidth !== defaultSampleNameViewportWidth) {
      json["sampleNameViewportWidth"] = this.sampleNameViewportWidth;
    }
    json["reference"] = this.genome.toJSON();
    if (json.reference.fastaURL instanceof File) {
      throw new Error(`Error. Sessions cannot include local file references ${json.reference.fastaURL.name}.`);
    } else if (json.reference.indexURL instanceof File) {
      throw new Error(`Error. Sessions cannot include local file references ${json.reference.indexURL.name}.`);
    }
    const locus = [];
    const gtexSelections = {};
    let hasGtexSelections = false;
    let anyTrackView = this.trackViews[0];
    for (let { referenceFrame } of anyTrackView.viewports) {
      const locusString = referenceFrame.getLocusString();
      locus.push(locusString);
      if (referenceFrame.selection) {
        const selection = {
          gene: referenceFrame.selection.gene,
          snp: referenceFrame.selection.snp
        };
        gtexSelections[locusString] = selection;
        hasGtexSelections = true;
      }
    }
    json["locus"] = locus.length === 1 ? locus[0] : locus;
    if (hasGtexSelections) {
      json["gtexSelections"] = gtexSelections;
    }
    json["roi"] = this.roiManager.toJSON();
    const trackJson = [];
    const errors = [];
    for (let { track } of this.trackViews) {
      try {
        let config;
        if (typeof track.getState === "function") {
          config = track.getState();
        } else {
          config = track.config;
        }
        if (config) {
          if (config.browser) {
            delete config.browser;
          }
          config.order = track.order;
          trackJson.push(config);
        }
      } catch (e) {
        console.error(`Track: ${track.name}: ${e}`);
        errors.push(`Track: ${track.name}: ${e}`);
      }
    }
    if (errors.length > 0) {
      let n = 1;
      let message = "Errors encountered saving session: </br>";
      for (let e of errors) {
        message += ` (${n++}) ${e.toString()} <br/>`;
      }
      throw Error(message);
    }
    json["tracks"] = trackJson;
    return json;
  }
  compressedSession() {
    const json = JSON.stringify(this.toJSON());
    return compressString(json);
  }
  sessionURL() {
    const path = window.location.href.slice();
    const idx = path.indexOf("?");
    const surl = (idx > 0 ? path.substring(0, idx) : path) + "?sessionURL=blob:" + this.compressedSession();
    return surl;
  }
  /**
   * Record a mouse click on a specific viewport.   This might be the start of a drag operation.   Dragging
   * (panning) is handled here so that the mouse can move out of a specific viewport (e.g. stray into another
   * track) without halting the drag.
   *
   * @param e
   * @param viewport
   */
  mouseDownOnViewport(e, viewport) {
    var coords;
    coords = domUtils$1.pageCoordinates(e);
    this.vpMouseDown = {
      viewport,
      lastMouseX: coords.x,
      mouseDownX: coords.x,
      lastMouseY: coords.y,
      mouseDownY: coords.y,
      referenceFrame: viewport.referenceFrame
    };
  }
  cancelTrackPan() {
    const dragObject = this.dragObject;
    this.dragObject = void 0;
    this.isScrolling = false;
    this.vpMouseDown = void 0;
    if (dragObject && dragObject.viewport.referenceFrame.start !== dragObject.start) {
      this.updateViews();
      this.fireEvent("trackdragend");
    }
  }
  isTrackPanning() {
    return this.dragObject;
  }
  isSoftclipped() {
    const result = this.trackViews.find((tv) => tv.track.showSoftClips === true);
    return result !== void 0;
  }
  /**
   * Track drag here refers to vertical dragging to reorder tracks, not horizontal panning.
   *
   * @param trackView
   */
  startTrackDrag(trackView) {
    this.dragTrack = trackView;
  }
  /**
   * Track drag here refers to vertical dragging to reorder tracks, not horizontal panning.
   *
   * @param dragDestination
   */
  updateTrackDrag(dragDestination) {
    if (dragDestination && this.dragTrack) {
      const dragged = this.dragTrack;
      const indexDestination = this.trackViews.indexOf(dragDestination);
      const indexDragged = this.trackViews.indexOf(dragged);
      const trackViews = this.trackViews;
      trackViews[indexDestination] = dragged;
      trackViews[indexDragged] = dragDestination;
      const newOrder = this.trackViews[indexDestination].track.order;
      this.trackViews[indexDragged].track.order = newOrder;
      const nTracks = trackViews.length;
      let lastOrder = newOrder;
      if (indexDestination < indexDragged) {
        for (let i = indexDestination + 1; i < nTracks; i++) {
          const track = trackViews[i].track;
          if (track.order <= lastOrder) {
            track.order = Math.min(Number.MAX_SAFE_INTEGER, lastOrder + 1);
            lastOrder = track.order;
          } else {
            break;
          }
        }
      } else {
        for (let i = indexDestination - 1; i > 0; i--) {
          const track = trackViews[i].track;
          if (track.order >= lastOrder) {
            track.order = Math.max(-Number.MAX_SAFE_INTEGER, lastOrder - 1);
            lastOrder = track.order;
          } else {
            break;
          }
        }
      }
      this.reorderTracks();
    }
  }
  /**
   * End vertical dragging of tracks (i.e. track re-order, not horizontal panning of data)
   */
  endTrackDrag() {
    if (this.dragTrack) {
      this.dragTrack = void 0;
      this.fireEvent("trackorderchanged", [this.getTrackOrder()]);
    } else {
      this.dragTrack = void 0;
    }
  }
  /**
   * Mouse handlers to support drag (pan)
   */
  addMouseHandlers() {
    this.addWindowResizeHandler();
    this.addRootMouseUpHandler();
    this.addRootMouseLeaveHandler();
    this.addColumnContainerEventHandlers();
  }
  removeMouseHandlers() {
    this.removeWindowResizeHandler();
    this.removeRootMouseUpHandler();
    this.removeRootMouseLeaveHandler();
    this.removeColumnContainerEventHandlers();
  }
  addWindowResizeHandler() {
    this.boundWindowResizeHandler = resize.bind(this);
    window.addEventListener("resize", this.boundWindowResizeHandler);
  }
  removeWindowResizeHandler() {
    window.removeEventListener("resize", this.boundWindowResizeHandler);
  }
  addRootMouseUpHandler() {
    this.boundRootMouseUpHandler = mouseUpOrLeave.bind(this);
    this.root.addEventListener("mouseup", this.boundRootMouseUpHandler);
  }
  removeRootMouseUpHandler() {
    this.root.removeEventListener("mouseup", this.boundRootMouseUpHandler);
  }
  addRootMouseLeaveHandler() {
    this.boundRootMouseLeaveHandler = mouseUpOrLeave.bind(this);
    this.root.addEventListener("mouseleave", this.boundRootMouseLeaveHandler);
  }
  removeRootMouseLeaveHandler() {
    this.root.removeEventListener("mouseleave", this.boundRootMouseLeaveHandler);
  }
  addColumnContainerEventHandlers() {
    this.boundColumnContainerMouseMoveHandler = handleMouseMove.bind(this);
    this.boundColumnContainerTouchMoveHandler = handleMouseMove.bind(this);
    this.boundColumnContainerMouseLeaveHandler = mouseUpOrLeave.bind(this);
    this.boundColumnContainerMouseUpHandler = mouseUpOrLeave.bind(this);
    this.boundColumnContainerTouchEndHandler = mouseUpOrLeave.bind(this);
    this.columnContainer.addEventListener("mousemove", this.boundColumnContainerMouseMoveHandler);
    this.columnContainer.addEventListener("touchmove", this.boundColumnContainerTouchMoveHandler);
    this.columnContainer.addEventListener("mouseleave", this.boundColumnContainerMouseLeaveHandler);
    this.columnContainer.addEventListener("mouseup", this.boundColumnContainerMouseUpHandler);
    this.columnContainer.addEventListener("touchend", this.boundColumnContainerTouchEndHandler);
  }
  removeColumnContainerEventHandlers() {
    this.columnContainer.removeEventListener("mousemove", this.boundColumnContainerMouseMoveHandler);
    this.columnContainer.removeEventListener("touchmove", this.boundColumnContainerTouchMoveHandler);
    this.columnContainer.removeEventListener("mouseleave", this.boundColumnContainerMouseLeaveHandler);
    this.columnContainer.removeEventListener("mouseup", this.boundColumnContainerMouseUpHandler);
    this.columnContainer.removeEventListener("touchend", this.boundColumnContainerTouchEndHandler);
  }
  static uncompressSession(url) {
    let bytes;
    if (url.indexOf("/gzip;base64") > 0) {
      bytes = decodeDataURI$1(url);
      let json = "";
      for (let b of bytes) {
        json += String.fromCharCode(b);
      }
      return json;
    } else {
      let enc = url.substring(5);
      return uncompressString(enc);
    }
  }
  createCircularView(container, show2) {
    show2 = show2 === true;
    this.circularView = createCircularView(container, this);
    this.circularViewControl = new CircularViewControl(this.$toggle_button_container.get(0), this);
    this.circularView.setAssembly({
      name: this.genome.id,
      id: this.genome.id,
      chromosomes: makeCircViewChromosomes(this.genome)
    });
    this.circularViewVisible = show2;
    return this.circularView;
  }
  get circularViewVisible() {
    return this.circularView !== void 0 && this.circularView.visible;
  }
  set circularViewVisible(isVisible) {
    if (this.circularView) {
      this.circularView.visible = isVisible;
      this.circularViewControl.setState(isVisible);
    }
  }
}
async function resize() {
  if (!this.referenceFrameList) return;
  const viewportWidth = this.calculateViewportWidth(this.referenceFrameList.length);
  for (let referenceFrame of this.referenceFrameList) {
    const index2 = this.referenceFrameList.indexOf(referenceFrame);
    const { chr, genome } = referenceFrame;
    const { bpLength } = genome.getChromosome(referenceFrame.chr);
    const viewportWidthBP = referenceFrame.toBP(viewportWidth);
    if (GenomeUtils.isWholeGenomeView(chr) || viewportWidthBP > bpLength) {
      referenceFrame.bpPerPixel = bpLength / viewportWidth;
    } else {
      referenceFrame.end = referenceFrame.start + referenceFrame.toBP(viewportWidth);
    }
    for (let { viewports } of this.trackViews) {
      viewports[index2].setWidth(viewportWidth);
    }
  }
  this.updateUIWithReferenceFrameList();
  await this.updateViews(true);
}
function handleMouseMove(e) {
  e.preventDefault();
  const { x, y } = domUtils$1.pageCoordinates(e);
  if (this.vpMouseDown) {
    const { viewport, referenceFrame } = this.vpMouseDown;
    const horizontal = Math.abs(x - this.vpMouseDown.mouseDownX) > Math.abs(y - this.vpMouseDown.mouseDownY);
    if (!this.dragObject && !this.isScrolling) {
      if (horizontal) {
        if (this.vpMouseDown.mouseDownX && Math.abs(x - this.vpMouseDown.mouseDownX) > this.constants.dragThreshold) {
          this.dragObject = { viewport, start: referenceFrame.start };
        }
      } else {
        if (this.vpMouseDown.mouseDownY && Math.abs(y - this.vpMouseDown.mouseDownY) > this.constants.scrollThreshold) {
          this.isScrolling = true;
          const viewportHeight = viewport.$viewport.height();
          const contentHeight = viewport.trackView.maxViewportContentHeight();
          this.vpMouseDown.r = viewportHeight / contentHeight;
        }
      }
    }
    if (this.dragObject) {
      const clampDrag = !this.isSoftclipped();
      let deltaX = this.vpMouseDown.lastMouseX - x;
      const viewChanged = referenceFrame.shiftPixels(deltaX, viewport.$viewport.width(), clampDrag);
      if (viewChanged) {
        this.updateViews();
      }
      this.fireEvent("trackdrag");
    }
    if (this.isScrolling) {
      const delta = this.vpMouseDown.r * (this.vpMouseDown.lastMouseY - y);
      viewport.trackView.moveScroller(delta);
    }
    this.vpMouseDown.lastMouseX = x;
    this.vpMouseDown.lastMouseY = y;
  }
}
function mouseUpOrLeave(e) {
  this.cancelTrackPan();
  this.endTrackDrag();
}
function getInitialLocus(locus, genome) {
  if (locus) {
    return Array.isArray(locus) ? locus.join(" ") : locus;
  } else {
    return genome.getHomeChromosomeName();
  }
}
function logo() {
  return $$1(
    '<svg width="690px" height="324px" viewBox="0 0 690 324" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>IGV</title><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="IGV" fill="#666666"><polygon id="Path" points="379.54574 8.00169252 455.581247 8.00169252 515.564813 188.87244 532.884012 253.529506 537.108207 253.529506 554.849825 188.87244 614.833392 8.00169252 689.60164 8.00169252 582.729511 320.722144 486.840288 320.722144"></polygon><path d="M261.482414,323.793286 C207.975678,323.793286 168.339046,310.552102 142.571329,284.069337 C116.803612,257.586572 103.919946,217.158702 103.919946,162.784513 C103.919946,108.410325 117.437235,67.8415913 144.472217,41.0770945 C171.507199,14.3125977 212.903894,0.930550071 268.663545,0.930550071 C283.025879,0.930550071 298.232828,1.84616386 314.284849,3.6774189 C330.33687,5.50867394 344.839793,7.97378798 357.794056,11.072835 L357.794056,68.968378 C339.48912,65.869331 323.578145,63.5450806 310.060654,61.9955571 C296.543163,60.4460336 284.574731,59.6712835 274.154998,59.6712835 C255.850062,59.6712835 240.502308,61.4320792 228.111274,64.9537236 C215.720241,68.4753679 205.793482,74.2507779 198.330701,82.2801269 C190.867919,90.309476 185.587729,100.87425 182.48997,113.974767 C179.392212,127.075284 177.843356,143.345037 177.843356,162.784513 C177.843356,181.942258 179.251407,198.000716 182.067551,210.960367 C184.883695,223.920018 189.671068,234.41436 196.429813,242.443709 C203.188559,250.473058 212.059279,256.178037 223.042241,259.558815 C234.025202,262.939594 247.683295,264.629958 264.01693,264.629958 C268.241146,264.629958 273.098922,264.489094 278.590403,264.207362 C284.081883,263.925631 289.643684,263.50304 295.275972,262.939577 L295.275972,159.826347 L361.595831,159.826347 L361.595831,308.579859 C344.698967,313.087564 327.239137,316.750019 309.215815,319.567334 C291.192494,322.38465 275.281519,323.793286 261.482414,323.793286 L261.482414,323.793286 L261.482414,323.793286 Z" id="Path"></path>;<polygon id="Path" points="0.81355666 5.00169252 73.0472883 5.00169252 73.0472883 317.722144 0.81355666 317.722144"></polygon></g> </g> </svg>'
  );
}
function toggleTrackLabels(trackViews, isVisible) {
  for (let { viewports } of trackViews) {
    for (let viewport of viewports) {
      if (viewport.$trackLabel) {
        if (0 === viewports.indexOf(viewport) && true === isVisible) {
          viewport.$trackLabel.show();
        } else {
          viewport.$trackLabel.hide();
        }
      }
    }
  }
}
let allBrowsers$1 = [];
async function createBrowser$1(parentDiv, config) {
  if (void 0 === config) config = {};
  if (!GenomeUtils.KNOWN_GENOMES) {
    await GenomeUtils.initializeGenomes(config);
  }
  setDefaults$1(config);
  if (config.queryParametersSupported) {
    extractQuery$1(config);
  }
  if (config.apiKey) {
    igvxhr.setApiKey(config.apiKey);
  }
  if (config.oauthToken) {
    igvxhr.setOauthToken(config.oauthToken);
  }
  if (config.clientId && !isInitialized()) {
    await init$1$1({
      clientId: config.clientId,
      apiKey: config.apiKey,
      scope: "https://www.googleapis.com/auth/userinfo.profile"
    });
  }
  const browser = new Browser(config, parentDiv);
  allBrowsers$1.push(browser);
  if (config.sessionURL) {
    await browser.loadSession({
      url: config.sessionURL
    });
  } else {
    await browser.loadSessionObject(config);
  }
  browser.navbarManager.navbarDidResize(browser.$navigation.width());
  return browser;
}
function removeBrowser(browser) {
  browser.dispose();
  browser.root.remove();
  allBrowsers$1 = allBrowsers$1.filter((item) => item !== browser);
}
function removeAllBrowsers() {
  for (let browser of allBrowsers$1) {
    browser.dispose();
    browser.root.remove();
  }
  allBrowsers$1 = [];
}
async function visibilityChange() {
  for (let browser of allBrowsers$1) {
    await browser.visibilityChange();
  }
}
function setDefaults$1(config) {
  if (void 0 === config.minimumBases) {
    config.minimumBases = 40;
  }
  if (void 0 === config.showIdeogram) {
    config.showIdeogram = true;
  }
  if (void 0 === config.showCircularView) {
    config.showCircularView = false;
  }
  if (void 0 === config.showCircularViewButton) {
    config.showCircularViewButton = false;
  }
  if (void 0 === config.showTrackLabelButton) {
    config.showTrackLabelButton = true;
  }
  if (void 0 === config.showTrackLabels) {
    config.showTrackLabels = true;
  }
  if (void 0 === config.showROITableButton) {
    config.showROITableButton = false;
  }
  if (void 0 === config.showROITable) {
    config.showROITable = false;
  }
  if (void 0 === config.showCursorTrackingGuideButton) {
    config.showCursorTrackingGuideButton = true;
  }
  if (void 0 === config.showCursorGuide) {
    config.showCursorGuide = config.showCursorTrackingGuide || false;
  }
  if (void 0 === config.showCenterGuideButton) {
    config.showCenterGuideButton = true;
  }
  if (void 0 === config.showCenterGuide) {
    config.showCenterGuide = false;
  }
  if (void 0 === config.showSampleNames) {
    config.showSampleNames = false;
  }
  if (void 0 === config.showSVGButton) {
    config.showSVGButton = true;
  }
  if (config.showControls === void 0) {
    config.showControls = true;
  }
  if (config.showNavigation === void 0) {
    config.showNavigation = true;
  }
  if (config.showRuler === void 0) {
    config.showRuler = true;
  }
  if (config.flanking === void 0) {
    config.flanking = 1e3;
  }
  if (config.pairsSupported === void 0) {
    config.pairsSupported = true;
  }
  if (!config.tracks) {
    config.tracks = [];
  }
}
function extractQuery$1(config) {
  var i1, i2, i, j, s, query, tokens, uri, key, value;
  uri = window.location.href;
  query = {};
  i1 = uri.indexOf("?");
  i2 = uri.lastIndexOf("#");
  let files;
  let indexURLs;
  let names;
  if (i1 >= 0) {
    if (i2 < 0) i2 = uri.length;
    for (i = i1 + 1; i < i2; ) {
      j = uri.indexOf("&", i);
      if (j < 0) j = i2;
      s = uri.substring(i, j);
      tokens = s.split("=", 2);
      if (tokens.length === 2) {
        key = tokens[0];
        value = decodeURIComponent(tokens[1]);
        if ("file" === key) {
          files = value.split(",");
        } else if ("index" === key) {
          indexURLs = value.split(",");
        } else if ("name" === key) {
          names = value.split(",");
        } else if ("genome" === key && ((value.startsWith("https://") || value.startsWith("http://")) && !value.endsWith(".json"))) {
          config["reference"] = {
            fastaURL: value,
            indexURL: value + ".fai"
          };
        } else {
          config[key] = value;
        }
        i = j + 1;
      } else {
        i++;
      }
    }
  }
  if (files) {
    if (!config.tracks)
      config.tracks = [];
    for (let i3 = 0; i3 < files.length; i3++) {
      if (files[i3].endsWith(".xml") || files[i3].endsWith(".json")) {
        config.sessionURL = files[i3];
        break;
      }
      const trackConfig = { url: files[i3] };
      if (indexURLs && indexURLs.length > i3) {
        trackConfig.indexURL = indexURLs[i3];
      }
      if (names && names.length > i3) {
        trackConfig.name = names[i3];
      }
      config.tracks.push(trackConfig);
    }
  }
  return query;
}
async function createTrack(config, browser) {
  return await Browser.prototype.createTrack.call(browser, config);
}
function embedCSS$3() {
  var css = '.igv-navbar {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  box-sizing: border-box;\n  width: 100%;\n  color: #444;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  line-height: 32px;\n  padding-left: 8px;\n  padding-right: 8px;\n  margin-top: 2px;\n  margin-bottom: 6px;\n  height: 32px;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: #f3f3f3;\n}\n.igv-navbar .igv-navbar-left-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-left-container .igv-logo {\n  width: 34px;\n  height: 32px;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-left-container .igv-current-genome {\n  height: 32px;\n  margin-left: 4px;\n  margin-right: 4px;\n  user-select: none;\n  line-height: 32px;\n  vertical-align: middle;\n  text-align: center;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container {\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n  height: 100%;\n  width: 125px;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-chromosome-select-widget-container select {\n  display: block;\n  cursor: pointer;\n  width: 100px;\n  height: 75%;\n  outline: none;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  margin-left: 8px;\n  height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 210px;\n  height: 22px;\n  line-height: 22px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container input.igv-search-input {\n  cursor: text;\n  width: 85%;\n  height: 22px;\n  line-height: 22px;\n  font-size: 12px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  text-align: left;\n  padding-left: 8px;\n  margin-right: 8px;\n  outline: none;\n  border-style: solid;\n  border-radius: 3px;\n  border-width: thin;\n  border-color: #bfbfbf;\n  background-color: white;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-search-container .igv-search-icon-container {\n  cursor: pointer;\n  height: 16px;\n  width: 16px;\n}\n.igv-navbar .igv-navbar-left-container .igv-navbar-genomic-location .igv-locus-size-group .igv-windowsize-panel-container {\n  margin-left: 4px;\n  user-select: none;\n}\n.igv-navbar .igv-navbar-right-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 32px;\n  line-height: 32px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n  height: 100%;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div {\n  margin-left: 0;\n  margin-right: 4px;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container div:last-child {\n  margin-left: 0;\n  margin-right: 0;\n}\n.igv-navbar .igv-navbar-right-container .igv-navbar-toggle-button-container-750 {\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget div:nth-child(even) {\n  display: block;\n  height: fit-content;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget input {\n  display: block;\n  width: 125px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 {\n  color: #737373;\n  font-size: 18px;\n  height: 32px;\n  line-height: 32px;\n  margin-left: 8px;\n  user-select: none;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div {\n  cursor: pointer;\n  margin-left: unset;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:first-child {\n  height: 24px;\n  width: 24px;\n  margin-left: unset;\n  margin-right: 8px;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:last-child {\n  height: 24px;\n  width: 24px;\n  margin-left: 8px;\n  margin-right: unset;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 div:nth-child(even) {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 input {\n  width: 0;\n  height: 0;\n  display: none;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-900 svg {\n  display: block;\n}\n.igv-navbar .igv-navbar-right-container .igv-zoom-widget-hidden {\n  display: none;\n}\n\n.igv-navbar-button {\n  display: block;\n  box-sizing: unset;\n  padding-left: 6px;\n  padding-right: 6px;\n  height: 18px;\n  text-transform: capitalize;\n  user-select: none;\n  line-height: 18px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 11px;\n  font-weight: 200;\n  color: #737373;\n  background-color: #f3f3f3;\n  border-color: #737373;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 6px;\n}\n\n.igv-navbar-button-clicked {\n  color: white;\n  background-color: #737373;\n}\n\n.igv-navbar-button:hover {\n  cursor: pointer;\n}\n\n.igv-zoom-in-notice-container {\n  z-index: 1024;\n  position: absolute;\n  top: 8px;\n  left: 50%;\n  transform: translate(-50%, 0%);\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n  background-color: white;\n}\n.igv-zoom-in-notice-container > div {\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-top: 2px;\n  padding-bottom: 2px;\n  width: 100%;\n  height: 100%;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: #3f3f3f;\n}\n\n.igv-zoom-in-notice {\n  position: absolute;\n  top: 10px;\n  left: 50%;\n}\n.igv-zoom-in-notice div {\n  position: relative;\n  left: -50%;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #3f3f3f;\n  background-color: rgba(255, 255, 255, 0.51);\n  z-index: 64;\n}\n\n.igv-container-spinner {\n  position: absolute;\n  top: 90%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 1024;\n  width: 24px;\n  height: 24px;\n  pointer-events: none;\n  color: #737373;\n}\n\n.igv-multi-locus-close-button {\n  position: absolute;\n  top: 2px;\n  right: 0;\n  padding-left: 2px;\n  padding-right: 2px;\n  width: 12px;\n  height: 12px;\n  color: #666666;\n  background-color: white;\n  z-index: 1000;\n}\n.igv-multi-locus-close-button > svg {\n  vertical-align: top;\n}\n\n.igv-multi-locus-close-button:hover {\n  cursor: pointer;\n  color: #434343;\n}\n\n.igv-multi-locus-ruler-label {\n  z-index: 64;\n  position: absolute;\n  top: 2px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label > div {\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  color: rgb(16, 16, 16);\n  background-color: white;\n}\n.igv-multi-locus-ruler-label > div {\n  cursor: pointer;\n}\n\n.igv-multi-locus-ruler-label-square-dot {\n  z-index: 64;\n  position: absolute;\n  left: 50%;\n  top: 5%;\n  transform: translate(-50%, 0%);\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-multi-locus-ruler-label-square-dot > div:first-child {\n  width: 14px;\n  height: 14px;\n}\n.igv-multi-locus-ruler-label-square-dot > div:last-child {\n  margin-left: 16px;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  color: rgb(16, 16, 16);\n}\n\n.igv-ruler-sweeper {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 26px;\n  bottom: 0;\n  left: 0;\n  width: 0;\n  z-index: 99999;\n  background-color: rgba(68, 134, 247, 0.25);\n}\n\n.igv-ruler-tooltip {\n  pointer-events: none;\n  z-index: 128;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 1px;\n  height: 32px;\n  background-color: transparent;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-ruler-tooltip > div {\n  pointer-events: none;\n  width: 128px;\n  height: auto;\n  padding: 1px;\n  color: #373737;\n  font-size: 10px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  background-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-color: #373737;\n}\n\n.igv-track-label {\n  position: absolute;\n  left: 8px;\n  top: 8px;\n  width: auto;\n  height: auto;\n  max-width: 50%;\n  padding-left: 4px;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  text-align: center;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-color: #444;\n  border-radius: 2px;\n  border-style: solid;\n  border-width: thin;\n  background-color: white;\n  z-index: 128;\n  cursor: pointer;\n}\n\n.igv-track-label:hover,\n.igv-track-label:focus,\n.igv-track-label:active {\n  background-color: #e8e8e8;\n}\n\n.igv-track-label-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-top: 4px;\n}\n\n.igv-center-line {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n  z-index: 8;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  border-left-style: dashed;\n  border-left-width: thin;\n  border-right-style: dashed;\n  border-right-width: thin;\n}\n\n.igv-center-line-wide {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(127, 127, 127, 0.51);\n}\n\n.igv-center-line-thin {\n  background-color: rgba(0, 0, 0, 0);\n  border-left-color: rgba(127, 127, 127, 0.51);\n  border-right-color: rgba(0, 0, 0, 0);\n}\n\n.igv-cursor-guide-horizontal {\n  display: none;\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 50%;\n  height: 1px;\n  z-index: 1;\n  margin-left: 50px;\n  margin-right: 54px;\n  border-top-style: dotted;\n  border-top-width: thin;\n  border-top-color: rgba(127, 127, 127, 0.76);\n}\n\n.igv-cursor-guide-vertical {\n  pointer-events: none;\n  user-select: none;\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 50%;\n  width: 1px;\n  z-index: 1;\n  border-left-style: dotted;\n  border-left-width: thin;\n  border-left-color: rgba(127, 127, 127, 0.76);\n  display: none;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-generic-dialog-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 200px;\n  border-color: #7F7F7F;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  z-index: 2048;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-generic-dialog-container .igv-generic-dialog-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-generic-dialog-container .igv-generic-dialog-one-liner {\n  color: #373737;\n  width: 95%;\n  height: 24px;\n  line-height: 24px;\n  text-align: left;\n  margin-top: 8px;\n  padding-left: 8px;\n  overflow-wrap: break-word;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input {\n  margin-top: 8px;\n  width: 95%;\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  padding-left: 8px;\n  background-color: white;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input div {\n  width: 30%;\n  height: 100%;\n  font-size: 16px;\n  text-align: right;\n  padding-right: 8px;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-label-input input {\n  width: 50%;\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input {\n  margin-top: 8px;\n  width: calc(100% - 16px);\n  height: 24px;\n  color: #373737;\n  line-height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  display: block;\n  height: 100%;\n  width: 100%;\n  padding-left: 4px;\n  font-family: "Open Sans", sans-serif;\n  font-weight: 400;\n  color: #373737;\n  text-align: left;\n  outline: none;\n  border-style: solid;\n  border-width: thin;\n  border-color: #7F7F7F;\n  background-color: white;\n}\n.igv-generic-dialog-container .igv-generic-dialog-input input {\n  font-size: 16px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel {\n  width: 100%;\n  height: 28px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div {\n  margin-top: 32px;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: 14px;\n  font-weight: 400;\n  width: 75px;\n  height: 28px;\n  line-height: 28px;\n  text-align: center;\n  border-color: transparent;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 2px;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child {\n  margin-left: 32px;\n  margin-right: 0;\n  background-color: #5ea4e0;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child {\n  margin-left: 0;\n  margin-right: 32px;\n  background-color: #c4c4c4;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:first-child:hover {\n  cursor: pointer;\n  background-color: #3b5c7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok-cancel div:last-child:hover {\n  cursor: pointer;\n  background-color: #7f7f7f;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok {\n  width: 100%;\n  height: 36px;\n  margin-top: 32px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div {\n  width: 98px;\n  height: 36px;\n  line-height: 36px;\n  text-align: center;\n  color: white;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  border-color: white;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 4px;\n  background-color: #2B81AF;\n}\n.igv-generic-dialog-container .igv-generic-dialog-ok div:hover {\n  cursor: pointer;\n  background-color: #25597f;\n}\n\n.igv-generic-container {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 2048;\n  background-color: white;\n  cursor: pointer;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-generic-container div:first-child {\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n  height: 24px;\n  width: 100%;\n  background-color: #dddddd;\n}\n.igv-generic-container div:first-child i {\n  display: block;\n  color: #5f5f5f;\n  cursor: pointer;\n  width: 14px;\n  height: 14px;\n  margin-right: 8px;\n  margin-bottom: 4px;\n}\n\n.igv-menu-popup {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: max-content;\n  z-index: 4096;\n  cursor: pointer;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background: white;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-end;\n  text-align: left;\n}\n.igv-menu-popup > div:not(:first-child) {\n  width: 100%;\n}\n.igv-menu-popup > div:not(:first-child) > div {\n  background: white;\n}\n.igv-menu-popup > div:not(:first-child) > div.context-menu {\n  padding-left: 4px;\n  padding-right: 4px;\n}\n.igv-menu-popup > div:not(:first-child) > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-menu-popup > div:not(:first-child) > div:hover {\n  background: #efefef;\n}\n\n.igv-menu-popup-shim {\n  padding-left: 8px;\n  padding-right: 8px;\n  padding-bottom: 1px;\n  padding-top: 1px;\n}\n\n.igv-menu-popup-header {\n  position: relative;\n  width: 100%;\n  height: 24px;\n  cursor: move;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-menu-popup-header div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-menu-popup-header div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n.igv-menu-popup-check-container {\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  width: 100%;\n  height: 20px;\n  margin-right: 4px;\n  background-color: transparent;\n}\n.igv-menu-popup-check-container div {\n  padding-top: 2px;\n  padding-left: 8px;\n}\n.igv-menu-popup-check-container div:first-child {\n  position: relative;\n  width: 12px;\n  height: 12px;\n}\n.igv-menu-popup-check-container div:first-child svg {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n}\n\n.igv-user-feedback {\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 512px;\n  height: 360px;\n  z-index: 2048;\n  background-color: white;\n  border-color: #a2a2a2;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: medium;\n  font-weight: 400;\n  color: #444;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n}\n.igv-user-feedback div:first-child {\n  position: relative;\n  height: 24px;\n  width: 100%;\n  background-color: white;\n  border-bottom-color: #a2a2a2;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-user-feedback div:first-child div {\n  position: absolute;\n  top: 2px;\n  width: 16px;\n  height: 16px;\n  background-color: transparent;\n}\n.igv-user-feedback div:first-child div:first-child {\n  left: 8px;\n}\n.igv-user-feedback div:first-child div:last-child {\n  cursor: pointer;\n  right: 8px;\n}\n.igv-user-feedback div:last-child {\n  width: 100%;\n  height: calc(100% - 24px);\n  border-width: 0;\n}\n.igv-user-feedback div:last-child div {\n  width: auto;\n  height: auto;\n  margin: 8px;\n}\n\n.igv-loading-spinner-container {\n  z-index: 1024;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  width: 32px;\n  height: 32px;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: center;\n  align-items: center;\n}\n.igv-loading-spinner-container > div {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  border-radius: 50%;\n  border: 4px solid rgba(128, 128, 128, 0.5);\n  border-top-color: rgb(255, 255, 255);\n  animation: spin 1s ease-in-out infinite;\n  -webkit-animation: spin 1s ease-in-out infinite;\n}\n\n@keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n@-webkit-keyframes spin {\n  to {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n.igv-roi-menu-next-gen {\n  position: absolute;\n  z-index: 512;\n  font-family: "Open Sans", sans-serif;\n  font-size: small;\n  font-weight: 400;\n  color: #4b4b4b;\n  background-color: white;\n  width: 192px;\n  border-radius: 4px;\n  border-color: #7F7F7F;\n  border-style: solid;\n  border-width: thin;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu-next-gen > div:first-child {\n  height: 24px;\n  border-top-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-color: #7F7F7F;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: flex-end;\n  align-items: center;\n}\n.igv-roi-menu-next-gen > div:first-child > div {\n  margin-right: 4px;\n  height: 12px;\n  width: 12px;\n  color: #7F7F7F;\n}\n.igv-roi-menu-next-gen > div:first-child > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-menu-next-gen > div:last-child {\n  background-color: white;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  text-align: start;\n  vertical-align: middle;\n}\n.igv-roi-menu-next-gen > div:last-child > div {\n  height: 24px;\n  padding-left: 4px;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  border-bottom-color: #7f7f7f;\n}\n.igv-roi-menu-next-gen > div:last-child > div:not(:first-child):hover {\n  background-color: rgba(127, 127, 127, 0.1);\n}\n.igv-roi-menu-next-gen > div:last-child div:first-child {\n  font-style: italic;\n  text-align: center;\n  padding-right: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.igv-roi-menu-next-gen > div:last-child > div:last-child {\n  border-bottom-width: 0;\n  border-bottom-color: transparent;\n}\n\n.igv-roi-placeholder {\n  font-style: normal;\n  color: rgba(75, 75, 75, 0.6);\n}\n\n.igv-roi-table {\n  position: absolute;\n  z-index: 1024;\n  width: min-content;\n  max-width: 1600px;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  font-size: 12px;\n  font-weight: 400;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  cursor: default;\n}\n.igv-roi-table > div {\n  height: 24px;\n  font-size: 14px;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n}\n.igv-roi-table > div:first-child {\n  border-color: transparent;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-width: 0;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n  background-color: #eee;\n  cursor: move;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-between;\n  align-items: center;\n}\n.igv-roi-table > div:first-child > div:first-child {\n  text-align: center;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  margin-left: 4px;\n  margin-right: 4px;\n  width: calc(100% - 4px - 12px);\n}\n.igv-roi-table > div:first-child > div:last-child {\n  margin-right: 4px;\n  margin-bottom: 2px;\n  height: 12px;\n  width: 12px;\n  color: #7f7f7f;\n}\n.igv-roi-table > div:first-child > div:last-child > svg {\n  display: block;\n}\n.igv-roi-table > div:first-child > div:last-child:hover {\n  cursor: pointer;\n  color: #444;\n}\n.igv-roi-table > .igv-roi-table-description {\n  padding: 4px;\n  margin-left: 4px;\n  word-break: break-all;\n  overflow-y: auto;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  background-color: transparent;\n}\n.igv-roi-table > .igv-roi-table-goto-explainer {\n  margin-top: 5px;\n  margin-left: 4px;\n  color: #7F7F7F;\n  font-style: italic;\n  height: 24px;\n  border-top: solid lightgray;\n  background-color: transparent;\n}\n.igv-roi-table > .igv-roi-table-column-titles {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n  padding-right: 16px;\n  background-color: white;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: #7f7f7f;\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 4px;\n  height: 24px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: #7f7f7f;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-column-titles > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container {\n  overflow: auto;\n  resize: both;\n  max-width: 1600px;\n  height: 360px;\n  background-color: transparent;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row {\n  height: 24px;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div {\n  font-size: 14px;\n  vertical-align: middle;\n  line-height: 24px;\n  text-align: left;\n  margin-left: 4px;\n  height: 24px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  border-right-color: transparent;\n  border-right-style: solid;\n  border-right-width: thin;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row > div:last-child {\n  border-right: unset;\n}\n.igv-roi-table > .igv-roi-table-row-container > .igv-roi-table-row-hover {\n  background-color: rgba(0, 0, 0, 0.04);\n}\n.igv-roi-table > div:last-child {\n  height: 32px;\n  line-height: 32px;\n  border-top-color: #7f7f7f;\n  border-top-style: solid;\n  border-top-width: thin;\n  border-bottom-color: transparent;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-width: 0;\n  background-color: #eee;\n  display: flex;\n  flex-flow: row;\n  flex-wrap: nowrap;\n  justify-content: space-around;\n  align-items: center;\n}\n\n.igv-roi-table-row-selected {\n  background-color: rgba(0, 0, 0, 0.125);\n}\n\n.igv-roi-table-button {\n  cursor: pointer;\n  height: 20px;\n  user-select: none;\n  line-height: 20px;\n  text-align: center;\n  vertical-align: middle;\n  font-family: "Open Sans", sans-serif;\n  font-size: 13px;\n  font-weight: 400;\n  color: black;\n  padding-left: 6px;\n  padding-right: 6px;\n  background-color: rgb(239, 239, 239);\n  border-color: black;\n  border-style: solid;\n  border-width: thin;\n  border-radius: 3px;\n}\n\n.igv-roi-table-button:hover {\n  font-weight: 400;\n  background-color: rgba(0, 0, 0, 0.13);\n}\n\n.igv-roi-region {\n  z-index: 64;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  pointer-events: none;\n  overflow: visible;\n  margin-top: 44px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-region > div {\n  position: relative;\n  width: 100%;\n  height: 8px;\n  pointer-events: auto;\n}\n\n.igv-roi-menu {\n  position: absolute;\n  z-index: 1024;\n  width: 144px;\n  border-color: #7f7f7f;\n  border-radius: 4px;\n  border-style: solid;\n  border-width: thin;\n  font-family: "Open Sans", sans-serif;\n  background-color: white;\n  display: flex;\n  flex-flow: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n}\n.igv-roi-menu > div:not(:last-child) {\n  border-bottom-color: rgba(128, 128, 128, 0.5);\n  border-bottom-style: solid;\n  border-bottom-width: thin;\n}\n.igv-roi-menu > div:first-child {\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-top-color: transparent;\n  border-top-style: solid;\n  border-top-width: 0;\n}\n.igv-roi-menu > div:last-child {\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n  border-bottom-color: transparent;\n  border-bottom-style: solid;\n  border-bottom-width: 0;\n}\n\n.igv-roi-menu-row {\n  height: 24px;\n  padding-left: 8px;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  line-height: 24px;\n  background-color: white;\n}\n\n.igv-roi-menu-row-edit-description {\n  width: -webkit-fill-available;\n  font-size: small;\n  text-align: start;\n  vertical-align: middle;\n  background-color: white;\n  padding-left: 4px;\n  padding-right: 4px;\n  padding-bottom: 4px;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: stretch;\n  align-items: stretch;\n}\n.igv-roi-menu-row-edit-description > label {\n  margin-left: 2px;\n  margin-bottom: 0;\n  display: block;\n  width: -webkit-fill-available;\n}\n.igv-roi-menu-row-edit-description > input {\n  display: block;\n  margin-left: 2px;\n  margin-right: 2px;\n  margin-bottom: 1px;\n  width: -webkit-fill-available;\n}\n\n.igv-container {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  padding-top: 4px;\n  user-select: none;\n  -webkit-user-select: none;\n  -ms-user-select: none;\n}\n\n.igv-viewport {\n  position: relative;\n  margin-top: 5px;\n  line-height: 1;\n  overflow-x: hidden;\n  overflow-y: hidden;\n}\n\n.igv-viewport-content {\n  position: relative;\n  width: 100%;\n}\n.igv-viewport-content > canvas {\n  position: relative;\n  display: block;\n}\n\n.igv-column-container {\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: stretch;\n  width: 100%;\n}\n\n.igv-column-shim {\n  width: 1px;\n  margin-left: 2px;\n  margin-right: 2px;\n  background-color: #545453;\n}\n\n.igv-column {\n  position: relative;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-axis-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 50px;\n}\n.igv-axis-column > div {\n  margin-top: 5px;\n  width: 100%;\n}\n\n.igv-sample-name-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n}\n\n.igv-scrollbar-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 14px;\n}\n.igv-scrollbar-column > div {\n  position: relative;\n  margin-top: 5px;\n  width: 14px;\n}\n.igv-scrollbar-column > div > div {\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  left: 2px;\n  width: 8px;\n  border-width: 1px;\n  border-style: solid;\n  border-color: #c4c4c4;\n  border-top-left-radius: 4px;\n  border-top-right-radius: 4px;\n  border-bottom-left-radius: 4px;\n  border-bottom-right-radius: 4px;\n}\n.igv-scrollbar-column > div > div:hover {\n  background-color: #c4c4c4;\n}\n\n.igv-track-drag-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 12px;\n  background-color: white;\n}\n.igv-track-drag-column > .igv-track-drag-handle {\n  z-index: 512;\n  position: relative;\n  cursor: pointer;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n  border-top-right-radius: 6px;\n  border-bottom-right-radius: 6px;\n  background-color: #c4c4c4;\n}\n.igv-track-drag-column .igv-track-drag-handle-hover {\n  background-color: #787878;\n}\n.igv-track-drag-column > .igv-track-drag-shim {\n  position: relative;\n  margin-top: 5px;\n  width: 100%;\n  border-style: solid;\n  border-width: 0;\n}\n\n.igv-gear-menu-column {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: flex-start;\n  box-sizing: border-box;\n  height: 100%;\n  width: 28px;\n}\n.igv-gear-menu-column > div {\n  display: flex;\n  flex-direction: column;\n  flex-wrap: nowrap;\n  justify-content: flex-start;\n  align-items: center;\n  margin-top: 5px;\n  width: 100%;\n  background: white;\n}\n.igv-gear-menu-column > div > div {\n  position: relative;\n  margin-top: 4px;\n  width: 16px;\n  height: 16px;\n  color: #7F7F7F;\n}\n.igv-gear-menu-column > div > div:hover {\n  cursor: pointer;\n  color: #444;\n}\n\n/*# sourceMappingURL=dom.css.map */\n';
  var style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.innerHTML = css;
  document.head.append(style);
}
const setApiKey = igvxhr.setApiKey;
embedCSS$3();
function setGoogleOauthToken(accessToken) {
  return igvxhr.setOauthToken(accessToken);
}
function setOauthToken(accessToken, host) {
  return igvxhr.setOauthToken(accessToken, host);
}
const oauth = igvxhr.oauth;
var index$1 = {
  TrackUtils,
  IGVGraphics,
  MenuUtils: MenuUtils$1,
  DataRangeDialog: DataRangeDialog$1,
  createTrack,
  createBrowser: createBrowser$1,
  removeBrowser,
  removeAllBrowsers,
  visibilityChange,
  setGoogleOauthToken,
  setOauthToken,
  oauth,
  version: version$2,
  setApiKey,
  registerFileFormats
};
function div(options2) {
  return create("div", options2);
}
function create(tag, options2) {
  const elem = document.createElement(tag);
  if (options2) {
    if (options2.class) {
      elem.classList.add(options2.class);
    }
    if (options2.id) {
      elem.id = options2.id;
    }
    if (options2.style) {
      applyStyle(elem, options2.style);
    }
  }
  return elem;
}
function hide(elem) {
  const cssStyle = getComputedStyle(elem);
  if (cssStyle.display !== "none") {
    elem._initialDisplay = cssStyle.display;
  }
  elem.style.display = "none";
}
function show(elem) {
  const currentDisplay = getComputedStyle(elem).display;
  if (currentDisplay === "none") {
    const d = elem._initialDisplay || "block";
    elem.style.display = d;
  }
}
function hideAll(selector) {
  document.querySelectorAll(selector).forEach((elem) => {
    hide(elem);
  });
}
function empty(elem) {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
}
function offset(elem) {
  if (!elem.getClientRects().length) {
    return { top: 0, left: 0 };
  }
  const rect = elem.getBoundingClientRect();
  const win = elem.ownerDocument.defaultView;
  return {
    top: rect.top + win.pageYOffset,
    left: rect.left + win.pageXOffset
  };
}
function pageCoordinates(e) {
  if (e.type.startsWith("touch")) {
    const touch = e.touches[0];
    return { x: touch.pageX, y: touch.pageY };
  } else {
    return { x: e.pageX, y: e.pageY };
  }
}
const relativeDOMBBox = (parentElement, childElement) => {
  const { x: x_p, y: y_p, width: width_p, height: height_p } = parentElement.getBoundingClientRect();
  const { x: x_c, y: y_c, width: width_c, height: height_c } = childElement.getBoundingClientRect();
  return { x: x_c - x_p, y: y_c - y_p, width: width_c, height: height_c };
};
function applyStyle(elem, style) {
  for (let key of Object.keys(style)) {
    elem.style[key] = style[key];
  }
}
function guid() {
  return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
}
let getMouseXY = (domElement, { clientX, clientY }) => {
  const { left, top, width, height } = domElement.getBoundingClientRect();
  const x = clientX - left;
  const y = clientY - top;
  return { x, y, xNormalized: x / width, yNormalized: y / height, width, height };
};
function translateMouseCoordinates(event, domElement) {
  const { clientX, clientY } = event;
  return getMouseXY(domElement, { clientX, clientY });
}
var domUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  applyStyle,
  create,
  div,
  empty,
  guid,
  hide,
  hideAll,
  offset,
  pageCoordinates,
  relativeDOMBBox,
  show,
  translateMouseCoordinates
});
class Textbox {
  constructor({ value, label, onchange }) {
    this.elem = div({ class: "igv-ui-generic-dialog-label-input" });
    if (label) {
      const div$12 = div();
      div$12.innerHTML = label;
      this.elem.appendChild(div$12);
    }
    this.textBox = create("input");
    if (value) {
      this.textBox.value = value;
    }
    this.elem.appendChild(this.textBox);
    if (onchange) {
      this.textBox.addEventListener("change", (e) => onchange(this.textBox.value));
    }
  }
  get value() {
    return this.textBox.value;
  }
  set value(v) {
    this.textBox.value = v;
  }
}
class Panel {
  constructor() {
    this.elem = create("div", {
      class: "igv-ui-panel-column"
    });
  }
  add(component) {
    if (component instanceof Node) {
      this.elem.append(component);
    } else if (typeof component === "object") {
      this.elem.append(component.elem);
    } else {
      const wrapper = div();
      wrapper.innerHTML = component;
      this.elem.append(wrapper);
    }
  }
}
function createIcon$1(name2, color) {
  return iconMarkup$1(name2, color);
}
function iconMarkup$1(name2, color) {
  color = color || "currentColor";
  let icon = icons$1[name2];
  if (!icon) {
    console.error(`No icon named: ${name2}`);
    icon = icons$1["question"];
  }
  const svg2 = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  svg2.setAttributeNS(null, "viewBox", "0 0 " + icon[0] + " " + icon[1]);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttributeNS(null, "fill", color);
  path.setAttributeNS(null, "d", icon[4]);
  svg2.appendChild(path);
  return svg2;
}
const icons$1 = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
};
function attachDialogCloseHandlerWithParent(parent, closeHandler) {
  var container = document.createElement("div");
  parent.appendChild(container);
  container.appendChild(createIcon$1("times"));
  container.addEventListener("click", function(e) {
    e.preventDefault();
    e.stopPropagation();
    closeHandler();
  });
}
var uiUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  attachDialogCloseHandlerWithParent
});
let dragData;
function makeDraggable(target, handle, constraint) {
  handle.addEventListener("mousedown", dragStart.bind(target));
  function dragStart(event) {
    event.stopPropagation();
    event.preventDefault();
    const dragFunction = drag.bind(this);
    const dragEndFunction = dragEnd.bind(this);
    const computedStyle = getComputedStyle(this);
    dragData = {
      constraint,
      dragFunction,
      dragEndFunction,
      screenX: event.screenX,
      screenY: event.screenY,
      top: parseInt(computedStyle.top.replace("px", "")),
      left: parseInt(computedStyle.left.replace("px", ""))
    };
    document.addEventListener("mousemove", dragFunction);
    document.addEventListener("mouseup", dragEndFunction);
    document.addEventListener("mouseleave", dragEndFunction);
    document.addEventListener("mouseexit", dragEndFunction);
  }
}
function drag(event) {
  if (!dragData) {
    console.error("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dx = event.screenX - dragData.screenX;
  const dy = event.screenY - dragData.screenY;
  const left = dragData.left + dx;
  const top = dragData.constraint ? Math.max(dragData.constraint.minY, dragData.top + dy) : dragData.top + dy;
  this.style.left = `${left}px`;
  this.style.top = `${top}px`;
}
function dragEnd(event) {
  if (!dragData) {
    console.error("No drag data!");
    return;
  }
  event.stopPropagation();
  event.preventDefault();
  const dragFunction = dragData.dragFunction;
  const dragEndFunction = dragData.dragEndFunction;
  document.removeEventListener("mousemove", dragFunction);
  document.removeEventListener("mouseup", dragEndFunction);
  document.removeEventListener("mouseleave", dragEndFunction);
  document.removeEventListener("mouseexit", dragEndFunction);
  dragData = void 0;
}
class Dialog {
  constructor({ label, content, okHandler, cancelHandler }) {
    const cancel = () => {
      hide(this.elem);
      if (typeof cancelHandler === "function") {
        cancelHandler(this);
      }
    };
    this.elem = div({ class: "igv-ui-generic-dialog-container" });
    const header = div({ class: "igv-ui-generic-dialog-header" });
    this.elem.appendChild(header);
    attachDialogCloseHandlerWithParent(header, cancel);
    if (label) {
      const labelDiv = div({ class: "igv-ui-dialog-one-liner" });
      this.elem.appendChild(labelDiv);
      labelDiv.innerHTML = label;
    }
    content.elem.style.margin = "8px";
    this.elem.appendChild(content.elem);
    const buttons = div({ class: "igv-ui-generic-dialog-ok-cancel" });
    this.elem.appendChild(buttons);
    this.ok = div();
    buttons.appendChild(this.ok);
    this.ok.textContent = "OK";
    this.cancel = div();
    buttons.appendChild(this.cancel);
    this.cancel.textContent = "Cancel";
    this.ok.addEventListener("click", (e) => {
      hide(this.elem);
      if (typeof okHandler === "function") {
        okHandler(this);
      }
    });
    this.cancel.addEventListener("click", cancel);
    makeDraggable(this.elem, header);
    this.elem.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  }
  present(options2, e) {
    this.label.textContent = options2.label;
    this.input.value = options2.value;
    this.callback = options2.callback;
    const page = pageCoordinates(e);
    this.clampLocation(page.x, page.y);
    show(this.elem);
  }
  clampLocation(pageX, pageY) {
    let popoverRect = this.elem.getBoundingClientRect();
    let parentRect = this.parent.getBoundingClientRect();
    const y = Math.min(Math.max(pageY, parentRect.y), parentRect.y + parentRect.height - popoverRect.height);
    const x = Math.min(Math.max(pageX, parentRect.x), parentRect.x + parentRect.width - popoverRect.width);
    this.elem.style.left = x + "px";
    this.elem.style.top = y + "px";
  }
}
class DataRangeDialog2 {
  constructor(parent, okHandler) {
    const panel = new Panel();
    this.minbox = new Textbox({ label: "Minimum", value: "0" });
    panel.add(this.minbox);
    this.maxbox = new Textbox({ label: "Maximum", value: "0" });
    panel.add(this.maxbox);
    let callback;
    if (okHandler) {
      callback = (e) => {
        okHandler(Number.parseFloat(this.minbox.value), Number.parseFloat(this.maxbox.value));
      };
    } else {
      callback = (d) => {
        console.log(`Minimum: ${this.minbox.value}`);
        console.log(`Maximum: ${this.maxbox.value}`);
      };
    }
    this.dialog = new Dialog({
      //label: 'Multi-select',
      content: panel,
      okHandler: callback
    });
    this.dialog.elem.style.position = "absolute";
    hide(this.dialog.elem);
    parent.appendChild(this.dialog.elem);
  }
  show({ min, max }) {
    if (min !== void 0) this.minbox.value = min.toString();
    if (max !== void 0) this.maxbox.value = max.toString();
    show(this.dialog.elem);
  }
}
const httpMessages = {
  "401": "Access unauthorized",
  "403": "Access forbidden",
  "404": "Not found"
};
class AlertDialog2 {
  /**
   * Initialize a new alert dialog
   * @param parent
   * @param alertProps - Optional - properties such as scroll to error
   */
  constructor(parent, alertProps) {
    this.alertProps = Object.assign({
      /** When an alert is presented - focus occur */
      shouldFocus: true,
      /** When focus occur - scroll into that element in the view */
      preventScroll: false
    }, alertProps);
    this.container = div({ class: "igv-ui-alert-dialog-container" });
    parent.appendChild(this.container);
    this.container.setAttribute("tabIndex", "-1");
    const header = div();
    this.container.appendChild(header);
    this.errorHeadline = div();
    header.appendChild(this.errorHeadline);
    this.errorHeadline.textContent = "";
    let bodyContainer = div({ class: "igv-ui-alert-dialog-body" });
    this.container.appendChild(bodyContainer);
    this.body = div({ class: "igv-ui-alert-dialog-body-copy" });
    bodyContainer.appendChild(this.body);
    let ok_container = div();
    this.container.appendChild(ok_container);
    this.ok = div();
    ok_container.appendChild(this.ok);
    this.ok.textContent = "OK";
    const okHandler = () => {
      if (typeof this.callback === "function") {
        this.callback("OK");
        this.callback = void 0;
      }
      this.body.innerHTML = "";
      hide(this.container);
    };
    this.ok.addEventListener("click", (event) => {
      event.stopPropagation();
      okHandler();
    });
    this.container.addEventListener("keypress", (event) => {
      event.stopPropagation();
      if ("Enter" === event.key) {
        okHandler();
      }
    });
    makeDraggable(this.container, header);
    hide(this.container);
  }
  present(alert2, callback) {
    this.errorHeadline.textContent = alert2.message ? "ERROR" : "";
    let string = alert2.message || alert2;
    if (httpMessages.hasOwnProperty(string)) {
      string = httpMessages[string];
    }
    this.body.innerHTML = string;
    this.callback = callback;
    show(this.container);
    if (this.alertProps.shouldFocus) {
      this.container.focus(
        { preventScroll: this.alertProps.preventScroll }
      );
    }
  }
}
let alertDialog;
const Alert$1 = {
  init(root, config = {}) {
    alertDialog = new AlertDialog2(root, config);
  },
  presentAlert(alert2, callback) {
    if (!alertDialog) {
      this.init(document.body);
    }
    alertDialog.present(alert2, callback);
  }
};
class InputDialog2 {
  constructor(parent) {
    this.parent = parent;
    this.container = div({ class: "igv-ui-generic-dialog-container" });
    parent.appendChild(this.container);
    const header = div({ class: "igv-ui-generic-dialog-header" });
    this.container.appendChild(header);
    this.label = div({ class: "igv-ui-generic-dialog-one-liner" });
    this.container.appendChild(this.label);
    this.label.text = "Unlabeled";
    this.input_container = div({ class: "igv-ui-generic-dialog-input" });
    this.container.appendChild(this.input_container);
    this.input = document.createElement("input");
    this.input_container.appendChild(this.input);
    const buttons = div({ class: "igv-ui-generic-dialog-ok-cancel" });
    this.container.appendChild(buttons);
    this.ok = div();
    buttons.appendChild(this.ok);
    this.ok.textContent = "OK";
    this.cancel = div();
    buttons.appendChild(this.cancel);
    this.cancel.textContent = "Cancel";
    hide(this.container);
    this.input.addEventListener("keyup", (e) => {
      if (13 === e.keyCode) {
        if (typeof this.callback === "function") {
          this.callback(this.input.value);
          this.callback = void 0;
        }
        this.input.value = void 0;
        hide(this.container);
      }
    });
    this.ok.addEventListener("click", () => {
      if (typeof this.callback === "function") {
        this.callback(this.input.value);
        this.callback = void 0;
      }
      this.input.value = void 0;
      hide(this.container);
    });
    const cancel = () => {
      this.input.value = "";
      hide(this.container);
    };
    this.cancel.addEventListener("click", cancel);
    attachDialogCloseHandlerWithParent(header, cancel);
    makeDraggable(this.container, header);
  }
  present(options2, e) {
    this.label.textContent = options2.label;
    this.input.value = options2.value;
    this.callback = options2.callback || options2.click;
    show(this.container);
    this.clampLocation(e.clientX, e.clientY);
  }
  clampLocation(clientX, clientY) {
    const { width: w, height: h } = this.container.getBoundingClientRect();
    const wh = window.innerHeight;
    const ww = window.innerWidth;
    const y = Math.min(wh - h, clientY);
    const x = Math.min(ww - w, clientX);
    this.container.style.left = `${x}px`;
    this.container.style.top = `${y}px`;
  }
}
const appleCrayonPalette = {
  licorice: "#000000",
  lead: "#1e1e1e",
  tungsten: "#3a3a3a",
  iron: "#545453",
  steel: "#6e6e6e",
  tin: "#878687",
  nickel: "#888787",
  aluminum: "#a09fa0",
  magnesium: "#b8b8b8",
  silver: "#d0d0d0",
  mercury: "#e8e8e8",
  snow: "#ffffff",
  //
  cayenne: "#891100",
  mocha: "#894800",
  aspargus: "#888501",
  fern: "#458401",
  clover: "#028401",
  moss: "#018448",
  teal: "#008688",
  ocean: "#004a88",
  midnight: "#001888",
  eggplant: "#491a88",
  plum: "#891e88",
  maroon: "#891648",
  //
  maraschino: "#ff2101",
  tangerine: "#ff8802",
  lemon: "#fffa03",
  lime: "#83f902",
  spring: "#05f802",
  seam_foam: "#03f987",
  turquoise: "#00fdff",
  aqua: "#008cff",
  blueberry: "#002eff",
  grape: "#8931ff",
  magenta: "#ff39ff",
  strawberry: "#ff2987",
  //
  salmon: "#ff726e",
  cantaloupe: "#ffce6e",
  banana: "#fffb6d",
  honeydew: "#cefa6e",
  flora: "#68f96e",
  spindrift: "#68fbd0",
  ice: "#68fdff",
  sky: "#6acfff",
  orchid: "#6e76ff",
  lavender: "#d278ff",
  bubblegum: "#ff7aff",
  carnation: "#ff7fd3"
};
class GenericContainer2 {
  constructor({ parent, top, left, width, height, border, closeHandler }) {
    let container = div({ class: "igv-ui-generic-container" });
    parent.appendChild(container);
    hide(container);
    this.container = container;
    if (top !== void 0) {
      this.container.style.top = `${top}px`;
    }
    if (left !== void 0) {
      this.container.style.left = `${left}px`;
    }
    if (width !== void 0) {
      this.container.style.width = `${width}px`;
    }
    if (height !== void 0) {
      this.container.style.height = `${height}px`;
    }
    if (border) {
      this.container.style.border = border;
    }
    const header = div();
    this.container.appendChild(header);
    attachDialogCloseHandlerWithParent(header, (e) => {
      hide(this.container);
      if (typeof closeHandler === "function") {
        closeHandler(e);
      }
    });
    makeDraggable(this.container, header);
  }
  show() {
    show(this.container);
  }
  hide() {
    hide(this.container);
  }
  dispose() {
    if (this.container.parent) {
      this.container.parent.removeChild(this.container);
    }
  }
}
class ColorPicker2 extends GenericContainer2 {
  constructor({ parent, top, left, width, height, defaultColors, colorHandler }) {
    super({ parent, top, left, width, height, border: "1px solid gray" });
    createColorSwatchSelector(this.container, colorHandler, defaultColors);
  }
}
const createColorSwatchSelector = (container, colorHandler, defaultColors) => {
  const hexColorStrings = Object.values(appleCrayonPalette);
  for (let hexColorString of hexColorStrings) {
    const swatch = div({ class: "igv-ui-color-swatch" });
    container.appendChild(swatch);
    decorateSwatch(swatch, hexColorString, colorHandler);
  }
  if (defaultColors) {
    for (let hexColorString of defaultColors) {
      const swatch = div({ class: "igv-ui-color-swatch" });
      container.appendChild(swatch);
      decorateSwatch(swatch, hexColorString, colorHandler);
    }
  }
};
const decorateSwatch = (swatch, hexColorString, colorHandler) => {
  swatch.style.backgroundColor = hexColorString;
  swatch.addEventListener("mouseenter", (e) => swatch.style.borderColor = hexColorString);
  swatch.addEventListener("mouseleave", (e) => swatch.style.borderColor = "white");
  swatch.addEventListener("click", (event) => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });
  swatch.addEventListener("touchend", (event) => {
    event.stopPropagation();
    colorHandler(hexColorString);
  });
};
function embedCSS() {
  const style = document.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("title", "igv-ui.css");
  style.innerHTML = `.igv-ui-popover {
  cursor: default;
  position: absolute;
  z-index: 2048;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: 1px;
  font-family: "Open Sans", sans-serif;
  font-size: small;
  background-color: white;
}
.igv-ui-popover > div:first-child {
  display: flex;
  flex-direction: row;
  flex-wrap: nowrap;
  justify-content: space-between;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-popover > div:first-child > div:first-child {
  margin-left: 4px;
}
.igv-ui-popover > div:first-child > div:last-child {
  margin-right: 4px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-popover > div:first-child > div:last-child:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-popover > div:last-child {
  overflow-y: auto;
  overflow-x: hidden;
  max-height: 400px;
  max-width: 800px;
  background-color: white;
}
.igv-ui-popover > div:last-child > div {
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  margin-left: 4px;
  margin-right: 4px;
  min-width: 220px;
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.igv-ui-popover > div:last-child > div > span {
  font-weight: bolder;
}
.igv-ui-popover > div:last-child hr {
  width: 100%;
}

.igv-ui-alert-dialog-container {
  box-sizing: content-box;
  position: absolute;
  z-index: 2048;
  top: 50%;
  left: 50%;
  width: 400px;
  height: 200px;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  outline: none;
  font-family: "Open Sans", sans-serif;
  font-size: 15px;
  font-weight: 400;
  background-color: white;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: space-between;
  align-items: center;
}
.igv-ui-alert-dialog-container > div:first-child {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-alert-dialog-container > div:first-child div:first-child {
  padding-left: 8px;
}
.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body {
  -webkit-user-select: text;
  -moz-user-select: text;
  -ms-user-select: text;
  user-select: text;
  color: #373737;
  width: 100%;
  height: calc(100% - 24px - 64px);
  overflow-y: scroll;
}
.igv-ui-alert-dialog-container .igv-ui-alert-dialog-body .igv-ui-alert-dialog-body-copy {
  margin: 16px;
  width: auto;
  height: auto;
  overflow-wrap: break-word;
  word-break: break-word;
  background-color: white;
  border: unset;
}
.igv-ui-alert-dialog-container > div:last-child {
  width: 100%;
  margin-bottom: 10px;
  background-color: white;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: center;
  align-items: center;
}
.igv-ui-alert-dialog-container > div:last-child div {
  margin: unset;
  width: 40px;
  height: 30px;
  line-height: 30px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: small;
  font-weight: 400;
  border-color: #2B81AF;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-alert-dialog-container > div:last-child div:hover {
  cursor: pointer;
  border-color: #25597f;
  background-color: #25597f;
}

.igv-ui-color-swatch {
  position: relative;
  box-sizing: content-box;
  display: flex;
  flex-flow: row;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  width: 32px;
  height: 32px;
  border-style: solid;
  border-width: 2px;
  border-color: white;
  border-radius: 4px;
}

.igv-ui-color-swatch:hover {
  border-color: dimgray;
}

.igv-ui-colorpicker-menu-close-button {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 32px;
  margin-top: 4px;
  margin-bottom: 4px;
  padding-right: 8px;
}
.igv-ui-colorpicker-menu-close-button i.fa {
  display: block;
  margin-left: 4px;
  margin-right: 4px;
  color: #5f5f5f;
}
.igv-ui-colorpicker-menu-close-button i.fa:hover,
.igv-ui-colorpicker-menu-close-button i.fa:focus,
.igv-ui-colorpicker-menu-close-button i.fa:active {
  cursor: pointer;
  color: #0f0f0f;
}

.igv-ui-generic-dialog-container {
  box-sizing: content-box;
  position: fixed;
  top: 0;
  left: 0;
  width: 300px;
  height: 200px;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  z-index: 2048;
  background-color: white;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div {
  margin-right: 4px;
  margin-bottom: 2px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-header div:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-one-liner {
  color: #373737;
  width: 95%;
  height: 24px;
  line-height: 24px;
  text-align: left;
  margin-top: 8px;
  padding-left: 8px;
  overflow-wrap: break-word;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input {
  margin-top: 8px;
  width: 95%;
  height: 24px;
  color: #373737;
  line-height: 24px;
  padding-left: 8px;
  background-color: white;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input div {
  width: 30%;
  height: 100%;
  font-size: 16px;
  text-align: right;
  padding-right: 8px;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {
  display: block;
  height: 100%;
  width: 100%;
  padding-left: 4px;
  font-family: "Open Sans", sans-serif;
  font-weight: 400;
  color: #373737;
  text-align: left;
  outline: none;
  border-style: solid;
  border-width: thin;
  border-color: #7F7F7F;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-label-input input {
  width: 50%;
  font-size: 16px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input {
  margin-top: 8px;
  width: calc(100% - 16px);
  height: 24px;
  color: #373737;
  line-height: 24px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {
  display: block;
  height: 100%;
  width: 100%;
  padding-left: 4px;
  font-family: "Open Sans", sans-serif;
  font-weight: 400;
  color: #373737;
  text-align: left;
  outline: none;
  border-style: solid;
  border-width: thin;
  border-color: #7F7F7F;
  background-color: white;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-input input {
  font-size: 16px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel {
  width: 100%;
  height: 28px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div {
  margin-top: 32px;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: 14px;
  font-weight: 400;
  width: 75px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  border-color: transparent;
  border-style: solid;
  border-width: thin;
  border-radius: 2px;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child {
  margin-left: 32px;
  margin-right: 0;
  background-color: #5ea4e0;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child {
  margin-left: 0;
  margin-right: 32px;
  background-color: #c4c4c4;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:first-child:hover {
  cursor: pointer;
  background-color: #3b5c7f;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok-cancel div:last-child:hover {
  cursor: pointer;
  background-color: #7f7f7f;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok {
  width: 100%;
  height: 36px;
  margin-top: 32px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div {
  width: 98px;
  height: 36px;
  line-height: 36px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  border-color: white;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-generic-dialog-container .igv-ui-generic-dialog-ok div:hover {
  cursor: pointer;
  background-color: #25597f;
}

.igv-ui-generic-container {
  box-sizing: content-box;
  position: absolute;
  z-index: 2048;
  background-color: white;
  cursor: pointer;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-items: center;
}
.igv-ui-generic-container > div:first-child {
  cursor: move;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  height: 24px;
  width: 100%;
  background-color: #dddddd;
}
.igv-ui-generic-container > div:first-child > div {
  display: block;
  color: #5f5f5f;
  cursor: pointer;
  width: 14px;
  height: 14px;
  margin-right: 8px;
  margin-bottom: 4px;
}

.igv-ui-dialog {
  z-index: 2048;
  position: fixed;
  width: fit-content;
  height: fit-content;
  display: flex;
  flex-flow: column;
  flex-wrap: nowrap;
  justify-content: flex-start;
  background-color: white;
  border-color: #7F7F7F;
  border-radius: 4px;
  border-style: solid;
  border-width: thin;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
}
.igv-ui-dialog .igv-ui-dialog-header {
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: flex-end;
  align-items: center;
  width: 100%;
  height: 24px;
  cursor: move;
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
  border-bottom-color: #7F7F7F;
  border-bottom-style: solid;
  border-bottom-width: thin;
  background-color: #eee;
}
.igv-ui-dialog .igv-ui-dialog-header div {
  margin-right: 4px;
  margin-bottom: 2px;
  height: 12px;
  width: 12px;
  color: #7F7F7F;
}
.igv-ui-dialog .igv-ui-dialog-header div:hover {
  cursor: pointer;
  color: #444;
}
.igv-ui-dialog .igv-ui-dialog-one-liner {
  width: 95%;
  height: 24px;
  line-height: 24px;
  text-align: left;
  margin: 8px;
  overflow-wrap: break-word;
  background-color: white;
  font-weight: bold;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel {
  width: 100%;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div {
  margin: 16px;
  margin-top: 32px;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: 14px;
  font-weight: 400;
  width: 75px;
  height: 28px;
  line-height: 28px;
  text-align: center;
  border-color: transparent;
  border-style: solid;
  border-width: thin;
  border-radius: 2px;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child {
  background-color: #5ea4e0;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child {
  background-color: #c4c4c4;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:first-child:hover {
  cursor: pointer;
  background-color: #3b5c7f;
}
.igv-ui-dialog .igv-ui-dialog-ok-cancel div:last-child:hover {
  cursor: pointer;
  background-color: #7f7f7f;
}
.igv-ui-dialog .igv-ui-dialog-ok {
  width: 100%;
  height: 36px;
  margin-top: 32px;
  display: flex;
  flex-flow: row;
  flex-wrap: nowrap;
  justify-content: space-around;
  align-items: center;
}
.igv-ui-dialog .igv-ui-dialog-ok div {
  width: 98px;
  height: 36px;
  line-height: 36px;
  text-align: center;
  color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  border-color: white;
  border-style: solid;
  border-width: thin;
  border-radius: 4px;
  background-color: #2B81AF;
}
.igv-ui-dialog .igv-ui-dialog-ok div:hover {
  cursor: pointer;
  background-color: #25597f;
}

.igv-ui-panel, .igv-ui-panel-row, .igv-ui-panel-column {
  z-index: 2048;
  background-color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
}

.igv-ui-panel-column {
  display: flex;
  flex-direction: column;
}

.igv-ui-panel-row {
  display: flex;
  flex-direction: row;
}

.igv-ui-textbox {
  background-color: white;
  font-family: "Open Sans", sans-serif;
  font-size: medium;
  font-weight: 400;
  display: flex;
  justify-content: flex-start;
  align-items: flex-start;
}

.igv-ui-table {
  background-color: white;
}

.igv-ui-table thead {
  position: sticky;
  top: 0;
}

.igv-ui-table th {
  text-align: left;
}

.igv-ui-table td {
  padding-right: 20px;
}

.igv-ui-table tr:hover {
  background-color: lightblue;
}

/*# sourceMappingURL=igv-ui.css.map */
`;
  document.head.append(style);
}
if (typeof document !== "undefined") {
  let stylesheetExists = function(stylesheetName) {
    for (let ss of document.styleSheets) {
      ss = ss.href ? ss.href.replace(/^.*[\\\/]/, "") : "";
      if (ss === stylesheetName) {
        return true;
      }
    }
    return false;
  };
  if (!stylesheetExists("igv-ui.css")) {
    embedCSS();
  }
}
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function throttle(fn2, threshhold, scope) {
  var last, deferTimer;
  return function() {
    var context, now, args;
    context = this;
    now = +/* @__PURE__ */ new Date();
    args = arguments;
    if (last && now < last + threshhold) {
      clearTimeout(deferTimer);
      deferTimer = setTimeout(function() {
        last = now;
        fn2.apply(context, args);
      }, threshhold);
    } else {
      last = now;
      fn2.apply(context, args);
    }
  };
}
function getExtension(url) {
  if (void 0 === url) {
    return void 0;
  }
  let path = isFile$2(url) || url.google_url ? url.name : url;
  let filename = path.toLowerCase();
  let index2 = filename.indexOf("?");
  if (index2 > 0) {
    filename = filename.substr(0, index2);
  }
  if (filename.endsWith(".gz")) {
    filename = filename.substr(0, filename.length - 3);
  } else if (filename.endsWith(".txt") || filename.endsWith(".tab") || filename.endsWith(".bgz")) {
    filename = filename.substr(0, filename.length - 4);
  }
  index2 = filename.lastIndexOf(".");
  return index2 < 0 ? filename : filename.substr(1 + index2);
}
const Globals = {};
class EventBus {
  constructor() {
    this.subscribers = {};
    this.stack = [];
  }
  subscribe(eventType, object) {
    var subscriberList = this.subscribers[eventType];
    if (subscriberList == void 0) {
      subscriberList = [];
      this.subscribers[eventType] = subscriberList;
    }
    subscriberList.push(object);
  }
  post(event) {
    const eventType = event.type;
    if (this._hold) {
      this.stack.push(event);
    } else {
      const subscriberList = this.subscribers[eventType];
      if (subscriberList) {
        for (let subscriber of subscriberList) {
          if ("function" === typeof subscriber.receiveEvent) {
            subscriber.receiveEvent(event);
          } else if ("function" === typeof subscriber) {
            subscriber(event);
          }
        }
      }
    }
  }
  hold() {
    this._hold = true;
  }
  release() {
    this._hold = false;
    for (let event of this.stack) {
      this.post(event);
    }
    this.stack = [];
  }
}
EventBus.globalBus = new EventBus();
class Track2D {
  static DisplayModes = {
    lower: 1,
    upper: 2,
    both: 1 | 2
  };
  constructor(config, features) {
    this.config = config;
    this.name = config.name;
    if (config.color && validateColor(config.color)) {
      this.color = this.color = config.color;
    }
    this.displayMode = config.displayMode;
    this.isVisible = void 0 === config.isVisible ? true : config.isVisible;
    this.repColor = features.length > 0 ? features[0].color : "black";
    this.featureMap = {};
    this.featureCount = 0;
    for (let f of features) {
      this.featureCount++;
      const key = getKey(f.chr1, f.chr2);
      let list = this.featureMap[key];
      if (!list) {
        list = [];
        this.featureMap[key] = list;
      }
      list.push(f);
    }
  }
  static async loadTrack2D(config, genome) {
    const data = await igvxhr$1.loadString(config.url, buildOptions(config));
    const features = parseData(data, isBedPE(config), genome);
    return new Track2D(config, features);
  }
  getColor() {
    return this.color || this.repColor;
  }
  getFeatures(chr1, chr2) {
    const key = getKey(chr1, chr2);
    return this.featureMap[key];
  }
  toJSON() {
    const json = {
      url: this.config.url
    };
    if (this.name) {
      json.name = this.name;
    }
    if (this.color) {
      json.color = this.color;
    }
    if (this.displayMode) {
      json.displayMode = this.displayMode;
    }
    if (!this.isVisible) {
      json.isVisible = this.isVisible;
    }
    return json;
  }
}
function isBedPE(config) {
  if (typeof config.url === "string") {
    return config.url.toLowerCase().indexOf(".bedpe") > 0;
  } else if (typeof config.name === "string") {
    return config.name.toLowerCase().indexOf(".bedpe") > 0;
  } else {
    return true;
  }
}
function parseData(data, isBedPE2, genome) {
  if (!data) return null;
  const lines = splitLines$6(data);
  const allFeatures = [];
  const delimiter = "	";
  const colorColumn = isBedPE2 ? 10 : 6;
  let errorCount = 0;
  for (let line of lines) {
    line = line.trim();
    if (line.startsWith("#") || line.startsWith("track") || line.startsWith("browser") || line.length === 0) {
      continue;
    }
    const tokens = line.split(delimiter);
    if (tokens.length < 6 && errorCount <= 5) {
      if (errorCount === 5) {
        console.error("...");
      } else {
        console.error("Could not parse line: " + line);
      }
      errorCount++;
      continue;
    }
    const feature2 = {
      chr1: genome ? genome.getChromosomeName(tokens[0]) : tokens[0],
      x1: parseInt(tokens[1]),
      x2: parseInt(tokens[2]),
      chr2: genome ? genome.getChromosomeName(tokens[3]) : tokens[3],
      y1: parseInt(tokens[4]),
      y2: parseInt(tokens[5])
    };
    if (tokens.length > colorColumn) {
      feature2.color = "rgb(" + tokens[colorColumn] + ")";
    }
    if (!Number.isNaN(feature2.x1)) {
      allFeatures.push(feature2);
    }
  }
  return allFeatures;
}
function getKey(chr1, chr2) {
  return chr1 > chr2 ? chr2 + "_" + chr1 : chr1 + "_" + chr2;
}
function validateColor(str) {
  var div2 = document.createElement("div");
  div2.style.borderColor = str;
  return div2.style.borderColor !== "";
}
function buildOptions(config, options2) {
  const defaultOptions = {
    oauthToken: config.oauthToken,
    headers: config.headers,
    withCredentials: config.withCredentials,
    filename: config.filename
  };
  return Object.assign(defaultOptions, options2);
}
class Ruler {
  constructor(browser, parentElement, axis) {
    this.browser = browser;
    this.axis = axis;
    this.axisElement = parentElement.querySelector(`div[id$='-axis']`);
    this.canvasElement = parentElement.querySelector("canvas");
    this.ctx = this.canvasElement.getContext("2d");
    this.ctx.canvas.width = this.axisElement.offsetWidth;
    this.ctx.canvas.height = this.axisElement.offsetHeight;
    this.wholeGenomeContainerElement = parentElement.querySelector("div[id$='-axis-whole-genome-container']");
    this.setAxisTransform(axis);
    browser.eventBus.subscribe("MapLoad", this);
    browser.eventBus.subscribe("UpdateContactMapMousePosition", this);
  }
  wholeGenomeLayout(axisElement, wholeGenomeContainerElement, axisName, dataset) {
    const decorate = (div2) => {
      div2.addEventListener("click", () => {
        this.browser.parseGotoInput(div2.textContent);
        this.unhighlightWholeChromosome();
        this.otherRuler.unhighlightWholeChromosome();
      });
      div2.addEventListener("mouseenter", () => {
        hoverHandler.call(this, div2, true);
      });
      div2.addEventListener("mouseleave", () => {
        hoverHandler.call(this, div2, false);
      });
    };
    const hoverHandler = (element, doHover) => {
      const targetLabel = element.dataset.label;
      Array.from(this.otherRuler.wholeGenomeContainerElement.children).forEach((child) => {
        if (child.dataset.label === targetLabel) {
          if (doHover) {
            element.classList.add("hic-whole-genome-chromosome-highlight");
            child.classList.add("hic-whole-genome-chromosome-highlight");
          } else {
            element.classList.remove("hic-whole-genome-chromosome-highlight");
            child.classList.remove("hic-whole-genome-chromosome-highlight");
          }
        }
      });
    };
    let list, dimen, extent, scraps, firstDivElement;
    wholeGenomeContainerElement.innerHTML = "";
    list = dataset.chromosomes.filter((chromosome) => chromosome.name.toLowerCase() !== "all");
    extent = list.reduce((sum, chromosome) => sum + chromosome.size, 0);
    dimen = axisName === "x" ? axisElement.offsetWidth : axisElement.offsetHeight;
    scraps = 0;
    this.bboxes = [];
    firstDivElement = void 0;
    for (const chr of list) {
      const percentage = chr.bpLength / extent;
      if (percentage * dimen < 1) {
        scraps += percentage;
      } else {
        const divElement = document.createElement("div");
        divElement.className = `${this.axis}-axis-whole-genome-chromosome-container`;
        divElement.dataset.label = chr.name;
        wholeGenomeContainerElement.appendChild(divElement);
        if (!firstDivElement) {
          firstDivElement = divElement;
        }
        const size = Math.round(percentage * dimen);
        if (axisName === "x") {
          divElement.style.width = `${size}px`;
        } else {
          divElement.style.height = `${size}px`;
        }
        const borderElement = document.createElement("div");
        divElement.appendChild(borderElement);
        const labelElement = document.createElement("div");
        borderElement.appendChild(labelElement);
        labelElement.textContent = divElement.dataset.label;
        labelElement.title = divElement.dataset.label;
        decorate(divElement);
      }
    }
    scraps = Math.floor(scraps * dimen);
    if (scraps >= 1) {
      const divElement = document.createElement("div");
      wholeGenomeContainerElement.appendChild(divElement);
      divElement.className = `${this.axis}-axis-whole-genome-chromosome-container`;
      divElement.dataset.label = "-";
      divElement.style.width = `${scraps}px`;
      decorate(divElement);
    }
    for (const child of wholeGenomeContainerElement.children) {
      this.bboxes.push(bbox(axisName, child, firstDivElement));
    }
    this.hideWholeGenome();
  }
  hideWholeGenome() {
    this.wholeGenomeContainerElement.style.display = "none";
    this.canvasElement.style.display = "block";
  }
  showWholeGenome() {
    this.canvasElement.style.display = "none";
    this.wholeGenomeContainerElement.style.display = "flex";
  }
  setAxisTransform(axis) {
    this.canvasTransform = "y" === axis ? canvasTransformWithContext : identityTransformWithContext;
    this.labelTransform = "y" === axis ? labelTransformWithContext : noopTransformWithContext;
  }
  unhighlightWholeChromosome() {
    for (const child of this.wholeGenomeContainerElement.children) {
      child.classList.remove("hic-whole-genome-chromosome-highlight");
    }
  }
  receiveEvent(event) {
    let offset2, element;
    if (event.type === "MapLoad") {
      this.wholeGenomeLayout(this.axisElement, this.wholeGenomeContainerElement, this.axis, event.data);
      this.update();
    } else if (event.type === "UpdateContactMapMousePosition") {
      if (this.bboxes) {
        this.unhighlightWholeChromosome();
        offset2 = this.axis === "x" ? event.data.x : event.data.y;
        element = hitTest(this.bboxes, offset2);
        if (element) {
          element.classList.add("hic-whole-genome-chromosome-highlight");
        }
      }
    }
  }
  locusChange(event) {
    this.update();
  }
  updateWidthWithCalculation(calc) {
    this.axisElement.style.width = calc;
    const axisWidth = this.axisElement.offsetWidth;
    this.canvasElement.width = axisWidth;
    this.canvasElement.setAttribute("width", axisWidth);
    this.wholeGenomeLayout(this.axisElement, this.wholeGenomeContainerElement, this.axis, this.browser.dataset);
    this.update();
  }
  updateHeight(height) {
    this.canvasElement.height = height;
    this.canvasElement.setAttribute("height", height);
    this.wholeGenomeLayout(this.axisElement, this.wholeGenomeContainerElement, this.axis, this.browser.dataset);
    this.update();
  }
  update() {
    const browser = this.browser;
    const config = {};
    if (browser.dataset.isWholeGenome(browser.state.chr1)) {
      this.showWholeGenome();
      return;
    }
    this.hideWholeGenome();
    identityTransformWithContext(this.ctx);
    index$1.IGVGraphics.fillRect(
      this.ctx,
      0,
      0,
      this.canvasElement.width,
      this.canvasElement.height,
      { fillStyle: IGVColor$1.rgbColor(255, 255, 255) }
    );
    this.canvasTransform(this.ctx);
    const width = this.axis === "x" ? this.canvasElement.width : this.canvasElement.height;
    const height = this.axis === "x" ? this.canvasElement.height : this.canvasElement.width;
    index$1.IGVGraphics.fillRect(
      this.ctx,
      0,
      0,
      width,
      height,
      { fillStyle: IGVColor$1.rgbColor(255, 255, 255) }
    );
    config.bpPerPixel = browser.dataset.bpResolutions[browser.state.zoom] / browser.state.pixelSize;
    const bin = this.axis === "x" ? browser.state.x : browser.state.y;
    config.bpStart = bin * browser.dataset.bpResolutions[browser.state.zoom];
    config.rulerTickMarkReferencePixels = Math.max(
      this.canvasElement.width,
      this.canvasElement.height,
      this.otherRulerCanvas.width,
      this.otherRulerCanvas.height
    );
    config.rulerLengthPixels = width;
    config.rulerHeightPixels = height;
    config.height = Math.min(this.canvasElement.width, this.canvasElement.height);
    this.draw(config);
  }
  draw(options2) {
    const {
      rulerLengthPixels,
      rulerHeightPixels,
      rulerTickMarkReferencePixels,
      bpPerPixel,
      bpStart,
      chrName
    } = options2;
    const { chromosomes } = this.browser.dataset;
    const { state } = this.browser;
    const axisIsX = this.axis === "x";
    const chr = axisIsX ? chromosomes[state.chr1] : chromosomes[state.chr2];
    const { name: chrNameSelected, size: chrSize } = chr;
    if (chrName !== "all") {
      index$1.IGVGraphics.fillRect(this.ctx, 0, 0, rulerLengthPixels, rulerHeightPixels, {
        fillStyle: IGVColor$1.rgbColor(255, 255, 255)
      });
      const fontStyle = {
        textAlign: "center",
        font: "9px PT Sans",
        fillStyle: "rgba(64, 64, 64, 1)",
        strokeStyle: "rgba(64, 64, 64, 1)"
      };
      const tickSpec = findSpacing(Math.floor(rulerTickMarkReferencePixels * bpPerPixel));
      const majorTickSpacing = tickSpec.majorTick;
      let nTick = Math.floor(bpStart / majorTickSpacing) - 1;
      let pixel = 0;
      let pixelLast = 0;
      index$1.IGVGraphics.setProperties(this.ctx, fontStyle);
      this.ctx.lineWidth = 1;
      const yShim = 1;
      const tickHeight = 8;
      while (pixel < rulerLengthPixels) {
        const l = Math.floor(nTick * majorTickSpacing);
        pixel = Math.round((l - 1 - bpStart + 0.5) / bpPerPixel);
        const rulerLabel = `${formatNumber(l / tickSpec.unitMultiplier, 0)} ${tickSpec.majorUnit}`;
        const tickSpacingPixels = Math.abs(pixel - pixelLast);
        const labelWidthPixels = this.ctx.measureText(rulerLabel).width;
        const modulo = labelWidthPixels > tickSpacingPixels ? tickSpacingPixels < 32 ? 4 : 2 : 1;
        if (nTick % modulo === 0) {
          if (Math.floor(pixel * bpPerPixel + bpStart) < chrSize) {
            this.ctx.save();
            this.labelTransform(this.ctx, pixel);
            index$1.IGVGraphics.fillText(this.ctx, rulerLabel, pixel, options2.height - tickHeight / 0.75);
            this.ctx.restore();
          }
        }
        if (Math.floor(pixel * bpPerPixel + bpStart) < chrSize) {
          index$1.IGVGraphics.strokeLine(
            this.ctx,
            pixel,
            options2.height - tickHeight,
            pixel,
            options2.height - yShim
          );
        }
        pixelLast = pixel;
        nTick++;
      }
      index$1.IGVGraphics.strokeLine(this.ctx, 0, options2.height - yShim, rulerLengthPixels, options2.height - yShim);
    }
  }
}
const formatNumber = (num, decimal = 0) => {
  const precision = Math.min(Math.max(decimal, 0), 3);
  const roundedNum = Math.abs(num).toFixed(precision);
  let [integerPart, decimalPart] = roundedNum.split(".");
  integerPart = parseInt(integerPart, 10).toLocaleString();
  if (precision > 0) {
    decimalPart = decimalPart.padEnd(precision, "0");
  }
  let formattedNum = precision > 0 ? `${integerPart}.${decimalPart}` : integerPart;
  if (num < 0) {
    formattedNum = `(${formattedNum})`;
  }
  return formattedNum;
};
function bbox(axis, childElement, firstChildElement) {
  const offset2 = axis === "x" ? childElement.getBoundingClientRect().left : childElement.getBoundingClientRect().top;
  const firstOffset = axis === "x" ? firstChildElement.getBoundingClientRect().left : firstChildElement.getBoundingClientRect().top;
  const delta = offset2 - firstOffset;
  const size = axis === "x" ? childElement.offsetWidth : childElement.offsetHeight;
  return { element: childElement, a: delta, b: delta + size };
}
function hitTest(bboxes, value) {
  let hitElement = void 0;
  for (const bbox2 of bboxes) {
    if (value >= bbox2.a && value <= bbox2.b) {
      hitElement = bbox2.element;
      break;
    }
  }
  return hitElement;
}
function TickSpacing(majorTick, majorUnit, unitMultiplier) {
  this.majorTick = majorTick;
  this.majorUnit = majorUnit;
  this.unitMultiplier = unitMultiplier;
}
function findSpacing(rulerLengthBP) {
  if (rulerLengthBP < 10) {
    return new TickSpacing(1, "", 1);
  }
  var nZeroes = Math.floor(log10(rulerLengthBP));
  var majorUnit = "";
  var unitMultiplier = 1;
  if (nZeroes > 9) {
    majorUnit = "gb";
    unitMultiplier = 1e9;
  }
  if (nZeroes > 6) {
    majorUnit = "mb";
    unitMultiplier = 1e6;
  } else if (nZeroes > 3) {
    majorUnit = "kb";
    unitMultiplier = 1e3;
  }
  var nMajorTicks = rulerLengthBP / Math.pow(10, nZeroes - 1);
  if (nMajorTicks < 25) {
    return new TickSpacing(Math.pow(10, nZeroes - 1), majorUnit, unitMultiplier);
  } else {
    return new TickSpacing(Math.pow(10, nZeroes) / 2, majorUnit, unitMultiplier);
  }
  function log10(x) {
    var dn = Math.log(10);
    return Math.log(x) / dn;
  }
}
function canvasTransformWithContext(ctx2) {
  ctx2.setTransform(0, 1, 1, 0, 0, 0);
}
function labelTransformWithContext(context, exe) {
  context.translate(exe, 0);
  context.scale(-1, 1);
  context.translate(-exe, 0);
}
function identityTransformWithContext(context) {
  context.setTransform(1, 0, 0, 1, 0, 0);
}
function noopTransformWithContext(ctx2) {
}
const createCheckbox = (name2, initialState) => {
  const container = document.createElement("div");
  container.className = "jb-igv-menu-popup-check-container";
  const div2 = document.createElement("div");
  container.appendChild(div2);
  const svg2 = iconMarkup("check", initialState === true ? "#444" : "transparent");
  div2.appendChild(svg2);
  const label = document.createElement("div");
  label.textContent = name2;
  container.appendChild(label);
  return container;
};
function createIcon(name2, color) {
  return iconMarkup(name2, color);
}
const iconMarkup = (name2, color = "currentColor") => {
  const icon = icons[name2] ?? icons["question"];
  if (!icons[name2]) {
    console.error(`No icon named: ${name2}`);
  }
  const [width, height, , , pathData] = icon;
  const svgNS = "http://www.w3.org/2000/svg";
  const svg2 = document.createElementNS(svgNS, "svg");
  svg2.setAttribute("viewBox", `0 0 ${width} ${height}`);
  svg2.setAttribute("xmlns", svgNS);
  svg2.setAttribute("aria-label", `${name2} icon`);
  svg2.setAttribute("role", "img");
  const path = document.createElementNS(svgNS, "path");
  path.setAttribute("fill", color);
  path.setAttribute("d", pathData);
  svg2.appendChild(path);
  return svg2;
};
const icons = {
  "check": [512, 512, [], "f00c", "M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"],
  "cog": [512, 512, [], "f013", "M444.788 291.1l42.616 24.599c4.867 2.809 7.126 8.618 5.459 13.985-11.07 35.642-29.97 67.842-54.689 94.586a12.016 12.016 0 0 1-14.832 2.254l-42.584-24.595a191.577 191.577 0 0 1-60.759 35.13v49.182a12.01 12.01 0 0 1-9.377 11.718c-34.956 7.85-72.499 8.256-109.219.007-5.49-1.233-9.403-6.096-9.403-11.723v-49.184a191.555 191.555 0 0 1-60.759-35.13l-42.584 24.595a12.016 12.016 0 0 1-14.832-2.254c-24.718-26.744-43.619-58.944-54.689-94.586-1.667-5.366.592-11.175 5.459-13.985L67.212 291.1a193.48 193.48 0 0 1 0-70.199l-42.616-24.599c-4.867-2.809-7.126-8.618-5.459-13.985 11.07-35.642 29.97-67.842 54.689-94.586a12.016 12.016 0 0 1 14.832-2.254l42.584 24.595a191.577 191.577 0 0 1 60.759-35.13V25.759a12.01 12.01 0 0 1 9.377-11.718c34.956-7.85 72.499-8.256 109.219-.007 5.49 1.233 9.403 6.096 9.403 11.723v49.184a191.555 191.555 0 0 1 60.759 35.13l42.584-24.595a12.016 12.016 0 0 1 14.832 2.254c24.718 26.744 43.619 58.944 54.689 94.586 1.667 5.366-.592 11.175-5.459 13.985L444.788 220.9a193.485 193.485 0 0 1 0 70.2zM336 256c0-44.112-35.888-80-80-80s-80 35.888-80 80 35.888 80 80 80 80-35.888 80-80z"],
  "exclamation": [192, 512, [], "f12a", "M176 432c0 44.112-35.888 80-80 80s-80-35.888-80-80 35.888-80 80-80 80 35.888 80 80zM25.26 25.199l13.6 272C39.499 309.972 50.041 320 62.83 320h66.34c12.789 0 23.331-10.028 23.97-22.801l13.6-272C167.425 11.49 156.496 0 142.77 0H49.23C35.504 0 24.575 11.49 25.26 25.199z"],
  "exclamation-circle": [512, 512, [], "f06a", "M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "exclamation-triangle": [576, 512, [], "f071", "M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"],
  "minus": [448, 512, [], "f068", "M424 318.2c13.3 0 24-10.7 24-24v-76.4c0-13.3-10.7-24-24-24H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h400z"],
  "minus-circle": [512, 512, [], "f056", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zM124 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H124z"],
  "minus-square": [448, 512, [], "f146", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM92 296c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h264c6.6 0 12 5.4 12 12v56c0 6.6-5.4 12-12 12H92z"],
  "plus": [448, 512, [], "f067", "M448 294.2v-76.4c0-13.3-10.7-24-24-24H286.2V56c0-13.3-10.7-24-24-24h-76.4c-13.3 0-24 10.7-24 24v137.8H24c-13.3 0-24 10.7-24 24v76.4c0 13.3 10.7 24 24 24h137.8V456c0 13.3 10.7 24 24 24h76.4c13.3 0 24-10.7 24-24V318.2H424c13.3 0 24-10.7 24-24z"],
  "plus-circle": [512, 512, [], "f055", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm144 276c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92h-92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "plus-square": [448, 512, [], "f0fe", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-32 252c0 6.6-5.4 12-12 12h-92v92c0 6.6-5.4 12-12 12h-56c-6.6 0-12-5.4-12-12v-92H92c-6.6 0-12-5.4-12-12v-56c0-6.6 5.4-12 12-12h92v-92c0-6.6 5.4-12 12-12h56c6.6 0 12 5.4 12 12v92h92c6.6 0 12 5.4 12 12v56z"],
  "question": [384, 512, [], "f128", "M202.021 0C122.202 0 70.503 32.703 29.914 91.026c-7.363 10.58-5.093 25.086 5.178 32.874l43.138 32.709c10.373 7.865 25.132 6.026 33.253-4.148 25.049-31.381 43.63-49.449 82.757-49.449 30.764 0 68.816 19.799 68.816 49.631 0 22.552-18.617 34.134-48.993 51.164-35.423 19.86-82.299 44.576-82.299 106.405V320c0 13.255 10.745 24 24 24h72.471c13.255 0 24-10.745 24-24v-5.773c0-42.86 125.268-44.645 125.268-160.627C377.504 66.256 286.902 0 202.021 0zM192 373.459c-38.196 0-69.271 31.075-69.271 69.271 0 38.195 31.075 69.27 69.271 69.27s69.271-31.075 69.271-69.271-31.075-69.27-69.271-69.27z"],
  "save": [448, 512, [], "f0c7", "M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z"],
  "search": [512, 512, [], "f002", "M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"],
  "share": [512, 512, [], "f064", "M503.691 189.836L327.687 37.851C312.281 24.546 288 35.347 288 56.015v80.053C127.371 137.907 0 170.1 0 322.326c0 61.441 39.581 122.309 83.333 154.132 13.653 9.931 33.111-2.533 28.077-18.631C66.066 312.814 132.917 274.316 288 272.085V360c0 20.7 24.3 31.453 39.687 18.164l176.004-152c11.071-9.562 11.086-26.753 0-36.328z"],
  "spinner": [512, 512, [], "f110", "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z"],
  "square": [448, 512, [], "f0c8", "M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48z"],
  "square-full": [512, 512, [], "f45c", "M512 512H0V0h512v512z"],
  "times": [384, 512, [], "f00d", "M323.1 441l53.9-53.9c9.4-9.4 9.4-24.5 0-33.9L279.8 256l97.2-97.2c9.4-9.4 9.4-24.5 0-33.9L323.1 71c-9.4-9.4-24.5-9.4-33.9 0L192 168.2 94.8 71c-9.4-9.4-24.5-9.4-33.9 0L7 124.9c-9.4 9.4-9.4 24.5 0 33.9l97.2 97.2L7 353.2c-9.4 9.4-9.4 24.5 0 33.9L60.9 441c9.4 9.4 24.5 9.4 33.9 0l97.2-97.2 97.2 97.2c9.3 9.3 24.5 9.3 33.9 0z"],
  "times-circle": [512, 512, [], "f057", "M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"],
  "wrench": [512, 512, [], "f0ad", "M481.156 200c9.3 0 15.12 10.155 10.325 18.124C466.295 259.992 420.419 288 368 288c-79.222 0-143.501-63.974-143.997-143.079C223.505 65.469 288.548-.001 368.002 0c52.362.001 98.196 27.949 123.4 69.743C496.24 77.766 490.523 88 481.154 88H376l-40 56 40 56h105.156zm-171.649 93.003L109.255 493.255c-24.994 24.993-65.515 24.994-90.51 0-24.993-24.994-24.993-65.516 0-90.51L218.991 202.5c16.16 41.197 49.303 74.335 90.516 90.503zM104 432c0-13.255-10.745-24-24-24s-24 10.745-24 24 10.745 24 24 24 24-10.745 24-24z"]
};
const MenuUtils = {
  trackMenuItemList: (trackPair) => {
    const menuItems = [];
    menuItems.push(trackRenameMenuItem(trackPair));
    menuItems.push("<hr/>");
    menuItems.push(colorPickerMenuItem({ trackPair, label: "Set color", option: "color" }));
    menuItems.push(unsetColorMenuItem({ trackPair, label: "Unset color" }));
    if (trackPair.track.removable !== false) {
      menuItems.push("<hr/>");
      menuItems.push(trackRemovalMenuItem(trackPair));
    }
    return menuItems;
  },
  numericDataMenuItems: (trackPair) => {
    const menuItems = [];
    const element = document.createElement("div");
    element.textContent = "Set data range";
    const click = () => {
      const { min, max } = trackPair.track.dataRange;
      trackPair.dataRangeDialog.show({ min: min || 0, max });
    };
    menuItems.push({ element, click });
    if (trackPair.track.logScale !== void 0) {
      menuItems.push({
        element: createCheckbox("Log scale", trackPair.track.logScale),
        click: () => {
          trackPair.track.logScale = !trackPair.track.logScale;
          trackPair.repaintViews();
        }
      });
    }
    menuItems.push({
      element: createCheckbox("Autoscale", trackPair.track.autoscale),
      click: () => {
        trackPair.track.autoscale = !trackPair.track.autoscale;
        trackPair.repaintViews();
      }
    });
    return menuItems;
  },
  nucleotideColorChartMenuItems: (trackPair) => {
    const menuItems = [];
    menuItems.push(document.createElement("hr"));
    const element = document.createElement("div");
    element.className = "jb-igv-menu-popup-chart";
    element.innerHTML = `
        <div>A</div>
        <div>C</div>
        <div>T</div>
        <div>G</div>
    `;
    const click = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };
    menuItems.push({ element, click });
    return menuItems;
  }
};
function trackRemovalMenuItem(trackPair) {
  const element = document.createElement("div");
  element.textContent = "Remove track";
  const click = () => trackPair.browser.layoutController.removeTrackXYPair(trackPair);
  return { element, click };
}
function colorPickerMenuItem({ trackPair, label, option }) {
  const element = document.createElement("div");
  element.textContent = label;
  const click = () => trackPair.colorPicker.show();
  return { element, click };
}
function unsetColorMenuItem({ trackPair, label }) {
  const element = document.createElement("div");
  element.textContent = label;
  const click = () => {
    trackPair.track.color = void 0;
    trackPair.repaintViews();
  };
  return { element, click };
}
function trackRenameMenuItem(trackPair) {
  const element = document.createElement("div");
  element.textContent = "Set track name";
  const click = (e) => {
    const callback = (value2) => {
      let name2;
      if (value2 === "" || value2 === void 0) {
        name2 = "";
      } else {
        name2 = value2.trim();
      }
      trackPair.track.name = name2;
    };
    const value = trackPair.track.name || "";
    trackPair.browser.inputDialog.present({ label: "Track Name", value, callback }, e);
  };
  return { element, click };
}
class TrackGearPopup {
  constructor(parentElement) {
    this.popoverElement = document.createElement("div");
    this.popoverElement.className = "jb-igv-menu-popup";
    parentElement.appendChild(this.popoverElement);
    const popoverHeaderElement = document.createElement("div");
    popoverHeaderElement.className = "jb-igv-menu-popup-header";
    this.popoverElement.appendChild(popoverHeaderElement);
    uiUtils.attachDialogCloseHandlerWithParent(popoverHeaderElement, () => {
      this.popoverElement.style.display = "none";
    });
    this.popoverContentElement = document.createElement("div");
    this.popoverElement.appendChild(this.popoverContentElement);
    makeDraggable(this.popoverElement, popoverHeaderElement);
    popoverHeaderElement.addEventListener("click", (e) => {
      e.stopPropagation();
      e.preventDefault();
    });
  }
  presentMenuList(dx, dy, list) {
    TrackGearPopup.hideAllMenuPopups();
    if (list.length > 0) {
      this.popoverContentElement.innerHTML = "";
      const updatedList = trackMenuItemListHelper(list, this.popoverElement);
      for (const item of updatedList) {
        if (item.init) {
          item.init();
        }
        if (updatedList.indexOf(item) === 0) {
          item.element.classList.remove("igv-track-menu-border-top");
        }
        if (!item.element.classList.contains("igv-track-menu-border-top") && !item.element.classList.contains("jb-igv-menu-popup-check-container") && item.element.tagName === "DIV") {
          item.element.classList.add("jb-igv-menu-popup-shim");
        }
        this.popoverContentElement.appendChild(item.element);
      }
      this.popoverElement.style.left = `${dx}px`;
      this.popoverElement.style.top = `${dy}px`;
      this.popoverElement.style.display = "block";
    }
  }
  dispose() {
    this.popoverElement.innerHTML = "";
    this.popoverContentElement.innerHTML = "";
    for (let key of Object.keys(this)) {
      this[key] = void 0;
    }
  }
  static hideAllMenuPopups() {
    const popups = document.querySelectorAll(".jb-igv-menu-popup");
    for (let popup of popups) {
      popup.style.display = "none";
    }
  }
}
function trackMenuItemListHelper(itemList, popoverElement) {
  let results = [];
  if (itemList.length > 0) {
    results = itemList.map((item, i) => {
      let element;
      if (item.name) {
        element = document.createElement("div");
        element.textContent = item.name;
      } else if (item.element) {
        element = item.element instanceof HTMLElement ? item.element.cloneNode(true) : item.element;
      } else if (typeof item.label === "string") {
        element = document.createElement("div");
        element.innerHTML = item.label;
      } else if (typeof item === "string") {
        if (item.startsWith("<")) {
          const tempDiv = document.createElement("div");
          tempDiv.innerHTML = item;
          element = tempDiv.firstElementChild;
        } else {
          element = document.createElement("div");
          element.textContent = item;
        }
      }
      if (i === 0 && element) {
        element.classList.add("igv-track-menu-border-top");
      }
      if (item.click && element) {
        const eventHandler = (e) => {
          e.preventDefault();
          e.stopPropagation();
          item.click(e);
          popoverElement.style.display = "none";
        };
        element.addEventListener("click", eventHandler);
        element.addEventListener("touchend", eventHandler);
        element.addEventListener("mouseup", (e) => {
          e.preventDefault();
          e.stopPropagation();
        });
      }
      return { element, init: item.init || void 0 };
    });
  }
  return results;
}
class Tile {
  constructor(chr, startBP, endBP, bpp, buffer, features) {
    this.chr = chr;
    this.startBP = startBP;
    this.endBP = endBP;
    this.bpp = bpp;
    this.buffer = buffer;
    this.features = features;
  }
  containsRange(chr, startBP, endBP, bpp) {
    return chr === this.chr && this.bpp === bpp && this.startBP <= startBP && this.endBP >= endBP;
  }
}
class TrackPair {
  constructor(browser, track) {
    this.browser = browser;
    this.track = track;
    this.x = void 0;
    this.y = void 0;
  }
  init() {
    this.colorPicker = new ColorPicker2({
      parent: this.x.viewportElement,
      width: 456,
      height: void 0,
      colorHandler: (color) => this.setColor(color)
    });
    this.colorPicker.hide();
    this.dataRangeDialog = new DataRangeDialog2(this.x.viewportElement, (min, max) => this.setDataRange(min, max));
    this.appendRightHandGutter(this.x.viewportElement);
    for (const el of this.x.trackReorderHandleElement.querySelectorAll(".fa")) {
      el.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const direction = e.target.classList.contains("fa-arrow-up") ? -1 : 1;
        let order = parseInt(this.x.viewportElement.style.order);
        if (order === 0 && direction === -1) {
          return;
        } else if (this.browser.trackPairs.length - 1 === order && direction === 1) {
          return;
        }
        const newOrder = direction === -1 ? order - 1 : order + 1;
        const targetTrackPair = this.browser.trackPairs.find(
          (trackPair) => newOrder === parseInt(trackPair.x.viewportElement.style.order)
        );
        if (targetTrackPair) {
          targetTrackPair.x.viewportElement.style.order = `${order}`;
          targetTrackPair.y.viewportElement.style.order = `${order}`;
        }
        this.x.viewportElement.style.order = `${newOrder}`;
        this.y.viewportElement.style.order = `${newOrder}`;
        const a = this.browser.trackPairs;
        [a[order], a[newOrder]] = [a[newOrder], a[order]];
        setTrackReorderArrowColors(this.browser.trackPairs);
      });
    }
    this.track.trackView = this;
    this.track.trackView.trackDiv = this.x.viewportElement;
  }
  presentColorPicker() {
    const bbox2 = this.x.trackDiv.getBoundingClientRect();
    this.colorPicker.origin = { x: bbox2.x, y: 0 };
    this.colorPicker.containerElement.style.left = `${this.colorPicker.origin.x}px`;
    this.colorPicker.containerElement.style.top = `${this.colorPicker.origin.y}px`;
    this.colorPicker.containerElement.style.display = "block";
  }
  setTrackLabelName(name2) {
    this.x.labelElement.textContent = name2;
    this.x.labelElement.title = name2;
  }
  setColor(color) {
    this.y.tile = void 0;
    this.x.tile = void 0;
    this.track.color = color;
    this.repaintViews();
  }
  dataRange() {
    return this.track.dataRange ? this.track.dataRange : void 0;
  }
  setDataRange(min, max) {
    if (min !== void 0) {
      this.track.dataRange.min = min;
      this.track.config.min = min;
    }
    if (max !== void 0) {
      this.track.dataRange.max = max;
      this.track.config.max = max;
    }
    this.track.autoscale = false;
    this.track.config.autoScale = false;
    this.y.tile = void 0;
    this.x.tile = void 0;
    this.repaintViews();
  }
  appendRightHandGutter(parentElement) {
    const div2 = document.createElement("div");
    div2.className = "hic-igv-right-hand-gutter";
    parentElement.appendChild(div2);
    this.createTrackGearPopup(div2);
  }
  createTrackGearPopup(parentElement) {
    const container = document.createElement("div");
    container.className = "igv-trackgear-container";
    parentElement.appendChild(container);
    container.appendChild(createIcon("cog"));
    this.trackGearPopup = new TrackGearPopup(parentElement);
    this.trackGearPopup.popoverElement.style.display = "none";
    container.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      const { trackMenuItemList, numericDataMenuItems, nucleotideColorChartMenuItems } = MenuUtils;
      const list = [...trackMenuItemList(this)];
      if (this.track.type === "wig") {
        list.push(...numericDataMenuItems(this));
      }
      if (this.track.type === "sequence") {
        list.push(...nucleotideColorChartMenuItems(this));
      }
      const width = this.trackGearPopup.popoverElement.getBoundingClientRect().width;
      this.trackGearPopup.presentMenuList(-width, 0, list);
    });
  }
  async updateViews() {
    if (this.updating) {
      this.pending = true;
    } else {
      try {
        this.updating = true;
        const genomicStateX = this.browser.genomicState(this.x.axis);
        let imageTileX = await this.getTileX(genomicStateX);
        if (imageTileX) {
          this.x.drawTile(imageTileX, genomicStateX);
        }
        const genomicStateY = this.browser.genomicState(this.y.axis);
        let imageTileY = await this.getTileY(genomicStateY);
        if (imageTileY) {
          this.y.drawTile(imageTileY, genomicStateY);
        }
      } finally {
        this.updating = false;
        if (this.pending) {
          this.pending = false;
          this.updateViews();
        }
      }
    }
  }
  /**
   * Repaint current tiles with cached features (due to color, scale, or other visual attribute change)
   * @returns {Promise<void>}
   */
  async repaintViews() {
    const genomicStateX = this.browser.genomicState(this.x.axis);
    if (this.tileX) {
      this.tileX = await this.createImageTile({ axis: "x", ...genomicStateX }, this.tileX.features);
      this.x.drawTile(this.tileX, genomicStateX);
    }
    const genomicStateY = this.browser.genomicState(this.y.axis);
    if (this.tileY) {
      this.tileY = await this.createImageTile({ axis: "y", ...genomicStateY }, this.tileY.features);
      this.y.drawTile(this.tileY, genomicStateY);
    }
  }
  async getTileX(genomicState) {
    const { chromosome, bpp } = genomicState;
    if (!(this.tileX && this.tileX.containsRange(chromosome.name, genomicState.startBP, genomicState.endBP, bpp))) {
      this.tileX = await this.createImageTile({ axis: "x", ...genomicState });
    }
    return this.tileX;
  }
  async getTileY(genomicState) {
    const { chromosome, bpp } = genomicState;
    if (!(this.tileY && this.tileY.containsRange(chromosome.name, genomicState.startBP, genomicState.endBP, bpp))) {
      this.tileY = await this.createImageTile({ axis: "y", ...genomicState });
    }
    return this.tileY;
  }
  async createImageTile(genomicState, tileFeatures) {
    if (this.track.visibilityWindow > 0 && genomicState.bpp * Math.max(this.x.canvasElement.width, this.x.canvasElement.height) > this.track.visibilityWindow) ;
    else {
      const pixelWidth = 3 * this.x.canvasElement.width;
      const lengthBP = Math.round(genomicState.bpp * pixelWidth);
      const bpStart = Math.max(0, Math.round(genomicState.startBP - lengthBP / 3));
      const bpEnd = bpStart + lengthBP;
      const features = tileFeatures || await this.track.getFeatures(
        genomicState.chromosome.name,
        bpStart,
        bpEnd,
        genomicState.bpp
      );
      const canvas = document.createElement("canvas");
      canvas.width = pixelWidth;
      canvas.height = this.x.canvasElement.height;
      const context = canvas.getContext("2d");
      if (features) {
        const drawConfiguration = {
          axis: genomicState.axis,
          features,
          context,
          pixelWidth,
          bpStart,
          bpEnd,
          bpPerPixel: genomicState.bpp,
          genomicState,
          pixelHeight: Math.min(canvas.width, canvas.height),
          viewportContainerX: (genomicState.startBP - bpStart) / genomicState.bpp,
          viewportContainerWidth: pixelWidth,
          viewportWidth: pixelWidth,
          referenceFrame: {}
        };
        if (this.track.autoscale || !this.track.dataRange) {
          if (typeof this.track.doAutoscale === "function") {
            this.track.doAutoscale(features);
          } else {
            this.track.dataRange = doAutoscale(features);
          }
        }
        this.track.draw(drawConfiguration);
      } else {
        const wye = canvas.height - canvas.height / 4;
        index$1.IGVGraphics.fillRect(context, 0, wye, canvas.width, 2, { fillStyle: "rgba(0,0,0,0.1)" });
      }
      this.tile = new Tile(genomicState.chromosome.name, bpStart, bpEnd, genomicState.bpp, canvas, features);
      return this.tile;
    }
  }
  dispose() {
    this.x.dispose();
    this.y.dispose();
  }
}
function doAutoscale(features = []) {
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  if (features.length > 0) {
    for (const { value } of features) {
      if (!Number.isNaN(value)) {
        min = Math.min(min, value);
        max = Math.max(max, value);
      }
    }
    if (max > 0) min = Math.min(0, min);
    if (max < 0) max = 0;
  } else {
    min = 0;
    max = 100;
  }
  return { min, max };
}
function setTrackReorderArrowColors(trackPairs) {
  for (const trackPair of trackPairs) {
    const el = trackPair.x.viewportElement;
    const order = parseInt(el.style.order);
    const arrowUp = el.querySelector(".fa-arrow-up");
    const arrowDown = el.querySelector(".fa-arrow-down");
    if (order === 0) {
      arrowUp.style.color = "rgba(0, 0, 0, 0)";
      arrowDown.style.color = "#7F7F7F";
    } else if (order === trackPairs.length - 1) {
      arrowUp.style.color = "#7F7F7F";
      arrowDown.style.color = "rgba(0, 0, 0, 0)";
    } else {
      arrowUp.style.color = "#7F7F7F";
      arrowDown.style.color = "#7F7F7F";
    }
  }
}
class TrackRenderer {
  constructor(browser, track, axis) {
    this.browser = browser;
    this.track = track;
    this.axis = axis;
    this.id = `trackRender_${domUtils.guid()}`;
  }
  init(containerElement, size, order) {
    this.viewportElement = document.createElement("div");
    this.viewportElement.className = this.axis === "x" ? "x-track-canvas-container" : "y-track-canvas-container";
    containerElement.appendChild(this.viewportElement);
    if (this.axis === "x") {
      this.viewportElement.style.height = `${size}px`;
    } else {
      this.viewportElement.style.width = `${size}px`;
    }
    this.viewportElement.style.order = `${order}`;
    this.canvasElement = document.createElement("canvas");
    this.viewportElement.appendChild(this.canvasElement);
    this.ctx = this.canvasElement.getContext("2d");
    if (this.axis === "x") {
      this.trackReorderHandleElement = document.createElement("div");
      this.trackReorderHandleElement.className = "x-track-reorder-handle";
      this.viewportElement.appendChild(this.trackReorderHandleElement);
      this.trackReorderHandleElement.innerHTML = '<i class="fa fa-arrow-up"></i><i class="fa fa-arrow-down"></i>';
      this.labelElement = document.createElement("div");
      this.labelElement.className = "x-track-label";
      this.viewportElement.appendChild(this.labelElement);
      const labelText = this.track.name || "";
      this.labelElement.textContent = labelText;
      this.labelElement.title = labelText;
      this.labelElement.style.display = this.browser.showTrackLabelAndGutter ? "block" : "none";
      this.viewportElement.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.browser.toggleTrackLabelAndGutterState();
        const displayState = this.browser.showTrackLabelAndGutter ? "block" : "none";
        document.querySelectorAll(".x-track-label, .hic-igv-right-hand-gutter").forEach((el) => {
          el.style.display = displayState;
        });
      });
    }
    this.spinnerElement = document.createElement("div");
    this.spinnerElement.className = this.axis === "x" ? "x-track-spinner" : "y-track-spinner";
    this.viewportElement.appendChild(this.spinnerElement);
    this.stopSpinner();
  }
  dispose() {
    this.tile = void 0;
    this.viewportElement.remove();
  }
  syncCanvas() {
    this.canvasElement.width = this.viewportElement.offsetWidth;
    this.canvasElement.height = this.viewportElement.offsetHeight;
  }
  drawTile(tile, genomicState) {
    if (tile) {
      let w;
      let h;
      if (this.axis === "x") {
        w = this.canvasElement.width;
        h = this.canvasElement.height;
      } else {
        h = this.canvasElement.width;
        w = this.canvasElement.height;
        this.ctx.setTransform(0, 1, 1, 0, 0, 0);
      }
      this.ctx.clearRect(0, 0, w, h);
      this.offsetPixel = Math.round((tile.startBP - genomicState.startBP) / genomicState.bpp);
      this.ctx.drawImage(tile.buffer, this.offsetPixel, 0);
    }
  }
  startSpinner() {
    this.browser.startSpinner();
  }
  stopSpinner() {
    this.browser.stopSpinner();
  }
  isLoading() {
    return this.loading !== void 0;
  }
}
function HICEvent(type, data, propogate) {
  return {
    type,
    data: data || {},
    propogate: propogate !== void 0 ? propogate : true
    // Default to true
  };
}
function isFile(object) {
  if (!object) {
    return false;
  }
  return typeof object !== "function" && (object instanceof File || object.name !== void 0 && typeof object.slice === "function" && typeof object.arrayBuffer === "function");
}
function createDOMFromHTMLString(string) {
  const template = document.createElement("template");
  template.innerHTML = string.trim();
  return template.content.firstElementChild;
}
function getOffset(element) {
  const { top, left } = element.getBoundingClientRect();
  return { top: top + window.scrollY, left: left + window.scrollX };
}
function parseRgbString(rgbString) {
  const match = rgbString.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
  if (!match) {
    throw new Error("Invalid RGB string format");
  }
  return match.slice(1, 4).map(Number);
}
function prettyPrint(number) {
  if (typeof number !== "number") {
    console.error(`${number} must be a number`);
    return;
  }
  const integerPart = Math.trunc(number);
  return integerPart.toLocaleString();
}
function extractName(config) {
  if (config.name === void 0) {
    const urlOrFile = config.url;
    if (isFile(urlOrFile)) {
      return urlOrFile.name;
    } else {
      const str = urlOrFile.split("?").shift();
      const idx = urlOrFile.lastIndexOf("/");
      return idx > 0 ? str.substring(idx + 1) : str;
    }
  } else {
    return config.name;
  }
}
function presentError(prefix, error) {
  const httpMessages2 = {
    401: "Access unauthorized",
    403: "Access forbidden",
    404: "Not found"
  };
  const msg = httpMessages2[error.message] || error.message;
  Alert$1.presentAlert(`${prefix}: ${msg}`);
}
class LayoutController {
  constructor(browser, rootElement) {
    this.browser = browser;
    createNavBar(browser, rootElement);
    this.createAllContainers(browser, rootElement);
  }
  createAllContainers(browser, root) {
    const htmlXTrackContainer = createDOMFromHTMLString(`
        <div id="${browser.id}-x-track-container">
            <div id="${browser.id}-track-shim"></div>
            <div id="${browser.id}-x-tracks">
                <div id="${browser.id}-y-track-guide" style="display: none;"></div>
            </div>
        </div>`);
    root.appendChild(htmlXTrackContainer);
    this.xTrackContainer = root.querySelector(`div[id$='x-track-container']`);
    this.trackShim = this.xTrackContainer.querySelector(`div[id$='track-shim']`);
    this.xTracks = this.xTrackContainer.querySelector(`div[id$='x-tracks']`);
    this.yTrackGuideElement = this.xTrackContainer.querySelector(`div[id$='y-track-guide']`);
    this.contentContainer = createDOMFromHTMLString(`<div id="${browser.id}-content-container"></div>`);
    root.appendChild(this.contentContainer);
    const htmlXAxisContainer = createDOMFromHTMLString(`
        <div id="${browser.id}-x-axis-container">
            <div id="${browser.id}-x-axis">
                <canvas></canvas>
                <div id="${browser.id}-x-axis-whole-genome-container"></div>
            </div>
        </div>`);
    this.contentContainer.appendChild(htmlXAxisContainer);
    const xAxisContainer = this.contentContainer.querySelector(`div[id$='x-axis-container']`);
    this.xAxisRuler = new Ruler(browser, xAxisContainer, "x");
    const htmlYTracksYAxisViewportYScrollbar = createDOMFromHTMLString(`
        <div id="${browser.id}-y-tracks-y-axis-viewport-y-scrollbar">
            <div id="${browser.id}-y-tracks">
                <div id="${browser.id}-x-track-guide" style="display: none;"></div>
            </div>
            <div id="${browser.id}-y-axis">
                <canvas></canvas>
                <div id="${browser.id}-y-axis-whole-genome-container"></div>
            </div>
        </div>`);
    this.contentContainer.appendChild(htmlYTracksYAxisViewportYScrollbar);
    const yTracksYAxisViewportYScrollbar = this.contentContainer.querySelector(`div[id$='-y-tracks-y-axis-viewport-y-scrollbar']`);
    this.yTracks = yTracksYAxisViewportYScrollbar.querySelector(`div[id$='-y-tracks']`);
    this.xTrackGuideElement = this.yTracks.querySelector(`div[id$='-x-track-guide']`);
    this.yAxisRuler = new Ruler(browser, yTracksYAxisViewportYScrollbar, "y");
    this.xAxisRuler.otherRulerCanvas = this.yAxisRuler.canvasElement;
    this.xAxisRuler.otherRuler = this.yAxisRuler;
    this.yAxisRuler.otherRulerCanvas = this.xAxisRuler.canvasElement;
    this.yAxisRuler.otherRuler = this.xAxisRuler;
    const htmlViewport = createDOMFromHTMLString(`
        <div id="${browser.id}-viewport">
            <canvas></canvas>
            <i class="fa fa-spinner fa-spin" style="font-size: 48px; position: absolute; left: 40%; top: 40%; display: none;"></i>
            <div id="${browser.id}-sweep-zoom-container" style="display: none;"></div>
            <div id="${browser.id}-x-guide" style="display: none;"></div>
            <div id="${browser.id}-y-guide" style="display: none;"></div>
        </div>`);
    yTracksYAxisViewportYScrollbar.appendChild(htmlViewport);
    const htmlYAxisScrollbarContainer = createDOMFromHTMLString(`
        <div id="${browser.id}-y-axis-scrollbar-container">
            <div id="${browser.id}-y-axis-scrollbar">
                <div class="scrollbar-label-rotation-in-place"></div>
            </div>
        </div>`);
    yTracksYAxisViewportYScrollbar.appendChild(htmlYAxisScrollbarContainer);
    const htmlXAxisScrollbarContainer = createDOMFromHTMLString(`
        <div id="${browser.id}-x-scrollbar-container">
            <div id="${browser.id}-x-axis-scrollbar-container">
                <div id="${browser.id}-x-axis-scrollbar">
                    <div></div>
                </div>
            </div>
        </div>`);
    this.contentContainer.appendChild(htmlXAxisScrollbarContainer);
  }
  getContactMatrixViewport() {
    const parent = this.contentContainer.querySelector("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
    return parent ? parent.querySelector("div[id$='-viewport']") : null;
  }
  getYAxisScrollbarContainer() {
    const parent = this.contentContainer.querySelector("div[id$='-y-tracks-y-axis-viewport-y-scrollbar']");
    return parent ? parent.querySelector("div[id$='-y-axis-scrollbar-container']") : null;
  }
  getXAxisScrollbarContainer() {
    return this.contentContainer.querySelector("div[id$='-x-axis-scrollbar-container']");
  }
  updateLayoutWithTracks(tracks) {
    const { trackHeight } = getLayoutDimensions();
    this.resizeLayoutWithTrackXYPairCount(tracks.length + this.browser.trackPairs.length);
    for (const track of tracks) {
      const trackPair = new TrackPair(this.browser, track);
      this.browser.trackPairs.unshift(trackPair);
      trackPair.x = new TrackRenderer(this.browser, track, "x");
      trackPair.x.init(this.xTracks, trackHeight, this.browser.trackPairs.indexOf(trackPair));
      trackPair.y = new TrackRenderer(this.browser, track, "y");
      trackPair.y.init(this.yTracks, trackHeight, this.browser.trackPairs.indexOf(trackPair));
      trackPair.init();
      EventBus.globalBus.post(HICEvent("TrackXYPairLoad", trackPair));
    }
    for (const trackPair of this.browser.trackPairs) {
      const order = `${this.browser.trackPairs.indexOf(trackPair)}`;
      trackPair.x.viewportElement.style.order = order;
      trackPair.y.viewportElement.style.order = order;
    }
    setTrackReorderArrowColors(this.browser.trackPairs);
  }
  removeAllTrackXYPairs() {
    if (this.browser.trackPairs.length === 0) {
      return;
    }
    for (let trackPair of this.browser.trackPairs) {
      trackPair.dispose();
    }
    this.browser.trackPairs = [];
    this.browser.updateLayout();
    this.resizeLayoutWithTrackXYPairCount(0);
  }
  removeTrackXYPair(trackXYPair) {
    if (this.browser.trackPairs.length > 0) {
      trackXYPair.x.viewportElement.remove();
      trackXYPair.y.viewportElement.remove();
      const index2 = this.browser.trackPairs.indexOf(trackXYPair);
      this.browser.trackPairs.splice(index2, 1);
      this.resizeLayoutWithTrackXYPairCount(this.browser.trackPairs.length);
      this.browser.updateLayout();
      EventBus.globalBus.post(HICEvent("TrackXYPairRemoval", trackXYPair));
    }
  }
  resizeLayoutWithTrackXYPairCount(trackXYPairCount) {
    const { trackHeight, trackMargin, axisHeight, scrollbarHeight } = getLayoutDimensions();
    const trackAggregateHeight = trackXYPairCount === 0 ? 0 : trackXYPairCount * (trackHeight + trackMargin);
    let tokens = [getNavbarHeight(), trackAggregateHeight].map((number) => `${number}px`);
    const heightCalc = `calc(100% - (${tokens.join(" + ")}))`;
    tokens = [trackAggregateHeight, axisHeight, scrollbarHeight].map((number) => `${number}px`);
    const widthCalc = `calc(100% - (${tokens.join(" + ")}))`;
    this.xTrackContainer.style.height = `${trackAggregateHeight}px`;
    this.trackShim.style.width = `${trackAggregateHeight}px`;
    this.xTracks.style.width = widthCalc;
    this.contentContainer.style.height = heightCalc;
    this.xAxisRuler.updateWidthWithCalculation(widthCalc);
    this.yTracks.style.width = `${trackAggregateHeight}px`;
    this.yAxisRuler.updateHeight(this.yAxisRuler.axisElement.offsetHeight);
    this.browser.contactMatrixView.viewportElement.style.width = widthCalc;
    this.browser.contactMatrixView.scrollbarWidget.xAxisScrollbarContainerElement.style.width = widthCalc;
  }
}
function getNavbarContainer(browser) {
  return browser.rootElement.querySelector(".hic-navbar-container");
}
function getNavbarHeight() {
  const { navBarLabelHeight, navBarWidgetContainerHeight, navBarWidgetContainerMargin } = getLayoutDimensions();
  return 2 * (navBarLabelHeight + navBarWidgetContainerHeight + 2 * navBarWidgetContainerMargin);
}
function getCSSVariable(name2) {
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue(name2));
}
function setCSSVariable(name2, value) {
  document.documentElement.style.setProperty(name2, `${value}px`);
}
function getLayoutDimensions() {
  return {
    navBarLabelHeight: getCSSVariable("--nav-bar-label-height"),
    navBarWidgetContainerHeight: getCSSVariable("--nav-bar-widget-container-height"),
    navBarWidgetContainerMargin: getCSSVariable("--nav-bar-widget-container-margin"),
    scrollbarHeight: getCSSVariable("--hic-scrollbar-height"),
    axisHeight: getCSSVariable("--hic-axis-height"),
    trackMargin: getCSSVariable("--track-margin"),
    trackHeight: getCSSVariable("--track-height")
  };
}
function setViewportSize(width, height) {
  setCSSVariable("--hic-viewport-width", width);
  setCSSVariable("--hic-viewport-height", height);
}
function createNavBar(browser, root) {
  const hicNavbarContainer = document.createElement("div");
  hicNavbarContainer.className = "hic-navbar-container";
  root.appendChild(hicNavbarContainer);
  hicNavbarContainer.addEventListener("click", (e) => {
    e.stopPropagation();
    e.preventDefault();
    setCurrentBrowser(browser);
  });
  const htmlContactMapHicNavBarMapContainer = `<div id="${browser.id}-contact-map-hic-nav-bar-map-container">
            <div id="${browser.id}-contact-map-hic-nav-bar-map-label"></div>
             <div class="hic-nav-bar-button-container">
                <i class="fa fa-bars fa-lg" title="Present menu"></i>
                <i class="fa fa-minus-circle fa-lg" title="Delete browser panel" style="display: none;"></i>
             </div>
        </div>`;
  hicNavbarContainer.appendChild(createDOMFromHTMLString(htmlContactMapHicNavBarMapContainer));
  browser.contactMapLabel = hicNavbarContainer.querySelector(`div[id$='contact-map-hic-nav-bar-map-label']`);
  browser.menuPresentDismiss = hicNavbarContainer.querySelector(".fa-bars");
  browser.menuPresentDismiss.addEventListener("click", (e) => browser.toggleMenu());
  browser.browserPanelDeleteButton = hicNavbarContainer.querySelector(".fa-minus-circle");
  browser.browserPanelDeleteButton.addEventListener("click", (e) => deleteBrowser(browser));
  browser.browserPanelDeleteButton.style.display = "none";
  const htmlControlMapHicNavBarMapContainer = `<div id="${browser.id}-control-map-hic-nav-bar-map-container">
            <div id="${browser.id}-control-map-hic-nav-bar-map-label"></div>
        </div>`;
  hicNavbarContainer.appendChild(createDOMFromHTMLString(htmlControlMapHicNavBarMapContainer));
  browser.controlMapLabel = hicNavbarContainer.querySelector(`div[id$='control-map-hic-nav-bar-map-label']`);
  const htmlUpperHicNavBarWidgetContainer = `<div id="${browser.id}-upper-hic-nav-bar-widget-container"></div>`;
  hicNavbarContainer.appendChild(createDOMFromHTMLString(htmlUpperHicNavBarWidgetContainer));
  const htmlLowerHicNavBarWidgetContainer = `<div id="${browser.id}-lower-hic-nav-bar-widget-container"></div>`;
  hicNavbarContainer.appendChild(createDOMFromHTMLString(htmlLowerHicNavBarWidgetContainer));
}
var Zlib = {
  Huffman: {},
  Util: {},
  CRC32: {}
};
Zlib.CompressionMethod = {
  DEFLATE: 8,
  RESERVED: 15
};
Zlib.Zip = function(opt_params) {
  opt_params = opt_params || {};
  this.files = [];
  this.comment = opt_params["comment"];
  this.password;
};
Zlib.Zip.CompressionMethod = {
  STORE: 0,
  DEFLATE: 8
};
Zlib.Zip.OperatingSystem = {
  MSDOS: 0,
  UNIX: 3,
  MACINTOSH: 7
};
Zlib.Zip.Flags = {
  ENCRYPT: 1,
  DESCRIPTOR: 8,
  UTF8: 2048
};
Zlib.Zip.FileHeaderSignature = [80, 75, 1, 2];
Zlib.Zip.LocalFileHeaderSignature = [80, 75, 3, 4];
Zlib.Zip.CentralDirectorySignature = [80, 75, 5, 6];
Zlib.Zip.prototype.addFile = function(input, opt_params) {
  opt_params = opt_params || {};
  opt_params["filename"];
  var compressed;
  var size = input.length;
  var crc322 = 0;
  if (input instanceof Array) {
    input = new Uint8Array(input);
  }
  if (typeof opt_params["compressionMethod"] !== "number") {
    opt_params["compressionMethod"] = Zlib.Zip.CompressionMethod.DEFLATE;
  }
  if (opt_params["compress"]) {
    switch (opt_params["compressionMethod"]) {
      case Zlib.Zip.CompressionMethod.STORE:
        break;
      case Zlib.Zip.CompressionMethod.DEFLATE:
        crc322 = Zlib.CRC32.calc(input);
        input = this.deflateWithOption(input, opt_params);
        compressed = true;
        break;
      default:
        throw new Error("unknown compression method:" + opt_params["compressionMethod"]);
    }
  }
  this.files.push({
    buffer: input,
    option: opt_params,
    compressed,
    encrypted: false,
    size,
    crc32: crc322
  });
};
Zlib.Zip.prototype.setPassword = function(password) {
  this.password = password;
};
Zlib.Zip.prototype.compress = function() {
  var files = this.files;
  var file;
  var output;
  var op1;
  var op2;
  var op3;
  var localFileSize = 0;
  var centralDirectorySize = 0;
  var endOfCentralDirectorySize;
  var offset2;
  var needVersion;
  var flags;
  var compressionMethod;
  var date;
  var crc322;
  var size;
  var plainSize;
  var filenameLength;
  var extraFieldLength;
  var commentLength;
  var filename;
  var extraField;
  var comment;
  var buffer;
  var tmp;
  var key;
  var i;
  var il;
  var j;
  var jl;
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength = file.option["filename"] ? file.option["filename"].length : 0;
    extraFieldLength = file.option["extraField"] ? file.option["extraField"].length : 0;
    commentLength = file.option["comment"] ? file.option["comment"].length : 0;
    if (!file.compressed) {
      file.crc32 = Zlib.CRC32.calc(file.buffer);
      switch (file.option["compressionMethod"]) {
        case Zlib.Zip.CompressionMethod.STORE:
          break;
        case Zlib.Zip.CompressionMethod.DEFLATE:
          file.buffer = this.deflateWithOption(file.buffer, file.option);
          file.compressed = true;
          break;
        default:
          throw new Error("unknown compression method:" + file.option["compressionMethod"]);
      }
    }
    if (file.option["password"] !== void 0 || this.password !== void 0) {
      key = this.createEncryptionKey(file.option["password"] || this.password);
      buffer = file.buffer;
      {
        tmp = new Uint8Array(buffer.length + 12);
        tmp.set(buffer, 12);
        buffer = tmp;
      }
      for (j = 0; j < 12; ++j) {
        buffer[j] = this.encode(
          key,
          i === 11 ? file.crc32 & 255 : Math.random() * 256 | 0
        );
      }
      for (jl = buffer.length; j < jl; ++j) {
        buffer[j] = this.encode(key, buffer[j]);
      }
      file.buffer = buffer;
    }
    localFileSize += // local file header
    30 + filenameLength + // file data
    file.buffer.length;
    centralDirectorySize += // file header
    46 + filenameLength + commentLength;
  }
  endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);
  output = new Uint8Array(
    localFileSize + centralDirectorySize + endOfCentralDirectorySize
  );
  op1 = 0;
  op2 = localFileSize;
  op3 = op2 + centralDirectorySize;
  for (i = 0, il = files.length; i < il; ++i) {
    file = files[i];
    filenameLength = file.option["filename"] ? file.option["filename"].length : 0;
    extraFieldLength = 0;
    commentLength = file.option["comment"] ? file.option["comment"].length : 0;
    offset2 = op1;
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[0];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[1];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[2];
    output[op1++] = Zlib.Zip.LocalFileHeaderSignature[3];
    output[op2++] = Zlib.Zip.FileHeaderSignature[0];
    output[op2++] = Zlib.Zip.FileHeaderSignature[1];
    output[op2++] = Zlib.Zip.FileHeaderSignature[2];
    output[op2++] = Zlib.Zip.FileHeaderSignature[3];
    needVersion = 20;
    output[op2++] = needVersion & 255;
    output[op2++] = /** @type {Zlib.Zip.OperatingSystem} */
    file.option["os"] || Zlib.Zip.OperatingSystem.MSDOS;
    output[op1++] = output[op2++] = needVersion & 255;
    output[op1++] = output[op2++] = needVersion >> 8 & 255;
    flags = 0;
    if (file.option["password"] || this.password) {
      flags |= Zlib.Zip.Flags.ENCRYPT;
    }
    output[op1++] = output[op2++] = flags & 255;
    output[op1++] = output[op2++] = flags >> 8 & 255;
    compressionMethod = /** @type {Zlib.Zip.CompressionMethod} */
    file.option["compressionMethod"];
    output[op1++] = output[op2++] = compressionMethod & 255;
    output[op1++] = output[op2++] = compressionMethod >> 8 & 255;
    date = /** @type {(Date|undefined)} */
    file.option["date"] || /* @__PURE__ */ new Date();
    output[op1++] = output[op2++] = (date.getMinutes() & 7) << 5 | (date.getSeconds() / 2 | 0);
    output[op1++] = output[op2++] = date.getHours() << 3 | date.getMinutes() >> 3;
    output[op1++] = output[op2++] = (date.getMonth() + 1 & 7) << 5 | date.getDate();
    output[op1++] = output[op2++] = (date.getFullYear() - 1980 & 127) << 1 | date.getMonth() + 1 >> 3;
    crc322 = file.crc32;
    output[op1++] = output[op2++] = crc322 & 255;
    output[op1++] = output[op2++] = crc322 >> 8 & 255;
    output[op1++] = output[op2++] = crc322 >> 16 & 255;
    output[op1++] = output[op2++] = crc322 >> 24 & 255;
    size = file.buffer.length;
    output[op1++] = output[op2++] = size & 255;
    output[op1++] = output[op2++] = size >> 8 & 255;
    output[op1++] = output[op2++] = size >> 16 & 255;
    output[op1++] = output[op2++] = size >> 24 & 255;
    plainSize = file.size;
    output[op1++] = output[op2++] = plainSize & 255;
    output[op1++] = output[op2++] = plainSize >> 8 & 255;
    output[op1++] = output[op2++] = plainSize >> 16 & 255;
    output[op1++] = output[op2++] = plainSize >> 24 & 255;
    output[op1++] = output[op2++] = filenameLength & 255;
    output[op1++] = output[op2++] = filenameLength >> 8 & 255;
    output[op1++] = output[op2++] = extraFieldLength & 255;
    output[op1++] = output[op2++] = extraFieldLength >> 8 & 255;
    output[op2++] = commentLength & 255;
    output[op2++] = commentLength >> 8 & 255;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = 0;
    output[op2++] = offset2 & 255;
    output[op2++] = offset2 >> 8 & 255;
    output[op2++] = offset2 >> 16 & 255;
    output[op2++] = offset2 >> 24 & 255;
    filename = file.option["filename"];
    if (filename) {
      {
        output.set(filename, op1);
        output.set(filename, op2);
        op1 += filenameLength;
        op2 += filenameLength;
      }
    }
    extraField = file.option["extraField"];
    if (extraField) {
      {
        output.set(extraField, op1);
        output.set(extraField, op2);
        op1 += extraFieldLength;
        op2 += extraFieldLength;
      }
    }
    comment = file.option["comment"];
    if (comment) {
      {
        output.set(comment, op2);
        op2 += commentLength;
      }
    }
    {
      output.set(file.buffer, op1);
      op1 += file.buffer.length;
    }
  }
  output[op3++] = Zlib.Zip.CentralDirectorySignature[0];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[1];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[2];
  output[op3++] = Zlib.Zip.CentralDirectorySignature[3];
  output[op3++] = 0;
  output[op3++] = 0;
  output[op3++] = 0;
  output[op3++] = 0;
  output[op3++] = il & 255;
  output[op3++] = il >> 8 & 255;
  output[op3++] = il & 255;
  output[op3++] = il >> 8 & 255;
  output[op3++] = centralDirectorySize & 255;
  output[op3++] = centralDirectorySize >> 8 & 255;
  output[op3++] = centralDirectorySize >> 16 & 255;
  output[op3++] = centralDirectorySize >> 24 & 255;
  output[op3++] = localFileSize & 255;
  output[op3++] = localFileSize >> 8 & 255;
  output[op3++] = localFileSize >> 16 & 255;
  output[op3++] = localFileSize >> 24 & 255;
  commentLength = this.comment ? this.comment.length : 0;
  output[op3++] = commentLength & 255;
  output[op3++] = commentLength >> 8 & 255;
  if (this.comment) {
    {
      output.set(this.comment, op3);
      op3 += commentLength;
    }
  }
  return output;
};
Zlib.Zip.prototype.deflateWithOption = function(input, opt_params) {
  var deflator = new Zlib.RawDeflate(input, opt_params["deflateOption"]);
  return deflator.compress();
};
Zlib.Zip.prototype.getByte = function(key) {
  var tmp = key[2] & 65535 | 2;
  return tmp * (tmp ^ 1) >> 8 & 255;
};
Zlib.Zip.prototype.encode = function(key, n) {
  var tmp = this.getByte(
    /** @type {(Array.<number>|Uint32Array)} */
    key
  );
  this.updateKeys(
    /** @type {(Array.<number>|Uint32Array)} */
    key,
    n
  );
  return tmp ^ n;
};
Zlib.Zip.prototype.updateKeys = function(key, n) {
  key[0] = Zlib.CRC32.single(key[0], n);
  key[1] = (((key[1] + (key[0] & 255)) * 20173 >>> 0) * 6681 >>> 0) + 1 >>> 0;
  key[2] = Zlib.CRC32.single(key[2], key[1] >>> 24);
};
Zlib.Zip.prototype.createEncryptionKey = function(password) {
  var key = [305419896, 591751049, 878082192];
  var i;
  var il;
  {
    key = new Uint32Array(key);
  }
  for (i = 0, il = password.length; i < il; ++i) {
    this.updateKeys(key, password[i] & 255);
  }
  return key;
};
Zlib.Huffman.buildHuffmanTable = function(lengths) {
  var listSize = lengths.length;
  var maxCodeLength = 0;
  var minCodeLength = Number.POSITIVE_INFINITY;
  var size;
  var table;
  var bitLength;
  var code;
  var skip;
  var reversed;
  var rtemp;
  var i;
  var il;
  var j;
  var value;
  for (i = 0, il = listSize; i < il; ++i) {
    if (lengths[i] > maxCodeLength) {
      maxCodeLength = lengths[i];
    }
    if (lengths[i] < minCodeLength) {
      minCodeLength = lengths[i];
    }
  }
  size = 1 << maxCodeLength;
  table = new Uint32Array(size);
  for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength; ) {
    for (i = 0; i < listSize; ++i) {
      if (lengths[i] === bitLength) {
        for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {
          reversed = reversed << 1 | rtemp & 1;
          rtemp >>= 1;
        }
        value = bitLength << 16 | i;
        for (j = reversed; j < size; j += skip) {
          table[j] = value;
        }
        ++code;
      }
    }
    ++bitLength;
    code <<= 1;
    skip <<= 1;
  }
  return [table, maxCodeLength, minCodeLength];
};
var ZLIB_RAW_INFLATE_BUFFER_SIZE = 32768;
var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;
Zlib.RawInflate = function(input, opt_params) {
  this.buffer;
  this.blocks = [];
  this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;
  this.totalpos = 0;
  this.ip = 0;
  this.bitsbuf = 0;
  this.bitsbuflen = 0;
  this.input = new Uint8Array(input);
  this.output;
  this.op;
  this.bfinal = false;
  this.bufferType = Zlib.RawInflate.BufferType.ADAPTIVE;
  this.resize = false;
  if (opt_params || !(opt_params = {})) {
    if (opt_params["index"]) {
      this.ip = opt_params["index"];
    }
    if (opt_params["bufferSize"]) {
      this.bufferSize = opt_params["bufferSize"];
    }
    if (opt_params["bufferType"]) {
      this.bufferType = opt_params["bufferType"];
    }
    if (opt_params["resize"]) {
      this.resize = opt_params["resize"];
    }
  }
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      this.op = Zlib.RawInflate.MaxBackwardLength;
      this.output = new Uint8Array(
        Zlib.RawInflate.MaxBackwardLength + this.bufferSize + Zlib.RawInflate.MaxCopyLength
      );
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.op = 0;
      this.output = new Uint8Array(this.bufferSize);
      break;
    default:
      throw new Error("invalid inflate mode");
  }
};
Zlib.RawInflate.BufferType = {
  BLOCK: 0,
  ADAPTIVE: 1
};
Zlib.RawInflate.prototype.decompress = function() {
  while (!this.bfinal) {
    this.parseBlock();
  }
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      return this.concatBufferBlock();
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      return this.concatBufferDynamic();
    default:
      throw new Error("invalid inflate mode");
  }
};
Zlib.RawInflate.MaxBackwardLength = 32768;
Zlib.RawInflate.MaxCopyLength = 258;
Zlib.RawInflate.Order = (function(table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
Zlib.RawInflate.LengthCodeTable = (function(table) {
  return new Uint16Array(table);
})([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  258,
  258
]);
Zlib.RawInflate.LengthExtraTable = (function(table) {
  return new Uint8Array(table);
})([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  0,
  0
]);
Zlib.RawInflate.DistCodeTable = (function(table) {
  return new Uint16Array(table);
})([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
]);
Zlib.RawInflate.DistExtraTable = (function(table) {
  return new Uint8Array(table);
})([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
]);
Zlib.RawInflate.FixedLiteralLengthTable = /* @__PURE__ */ (function(table) {
  return table;
})((function() {
  var lengths = new Uint8Array(288);
  var i, il;
  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
  }
  return buildHuffmanTable(lengths);
})());
Zlib.RawInflate.FixedDistanceTable = /* @__PURE__ */ (function(table) {
  return table;
})((function() {
  var lengths = new Uint8Array(30);
  var i, il;
  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }
  return buildHuffmanTable(lengths);
})());
Zlib.RawInflate.prototype.parseBlock = function() {
  var hdr = this.readBits(3);
  if (hdr & 1) {
    this.bfinal = true;
  }
  hdr >>>= 1;
  switch (hdr) {
    // uncompressed
    case 0:
      this.parseUncompressedBlock();
      break;
    // fixed huffman
    case 1:
      this.parseFixedHuffmanBlock();
      break;
    // dynamic huffman
    case 2:
      this.parseDynamicHuffmanBlock();
      break;
    // reserved or other
    default:
      throw new Error("unknown BTYPE: " + hdr);
  }
};
Zlib.RawInflate.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;
  var inputLength = input.length;
  var octet;
  if (ip + (length - bitsbuflen + 7 >> 3) >= inputLength) {
    throw new Error("input buffer is broken");
  }
  while (bitsbuflen < length) {
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }
  octet = bitsbuf & /* MASK */
  (1 << length) - 1;
  bitsbuf >>>= length;
  bitsbuflen -= length;
  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;
  return octet;
};
Zlib.RawInflate.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;
  var inputLength = input.length;
  var codeTable = table[0];
  var maxCodeLength = table[1];
  var codeWithLength;
  var codeLength;
  while (bitsbuflen < maxCodeLength) {
    if (ip >= inputLength) {
      break;
    }
    bitsbuf |= input[ip++] << bitsbuflen;
    bitsbuflen += 8;
  }
  codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
  codeLength = codeWithLength >>> 16;
  if (codeLength > bitsbuflen) {
    throw new Error("invalid code length: " + codeLength);
  }
  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;
  return codeWithLength & 65535;
};
Zlib.RawInflate.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var inputLength = input.length;
  var len2;
  var nlen;
  var olength = output.length;
  var preCopy;
  this.bitsbuf = 0;
  this.bitsbuflen = 0;
  if (ip + 1 >= inputLength) {
    throw new Error("invalid uncompressed block header: LEN");
  }
  len2 = input[ip++] | input[ip++] << 8;
  if (ip + 1 >= inputLength) {
    throw new Error("invalid uncompressed block header: NLEN");
  }
  nlen = input[ip++] | input[ip++] << 8;
  if (len2 === ~nlen) {
    throw new Error("invalid uncompressed block header: length verify");
  }
  if (ip + len2 > input.length) {
    throw new Error("input buffer is broken");
  }
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.BLOCK:
      while (op + len2 > output.length) {
        preCopy = olength - op;
        len2 -= preCopy;
        {
          output.set(input.subarray(ip, ip + preCopy), op);
          op += preCopy;
          ip += preCopy;
        }
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      break;
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      while (op + len2 > output.length) {
        output = this.expandBufferAdaptive({ fixRatio: 2 });
      }
      break;
    default:
      throw new Error("invalid inflate mode");
  }
  {
    output.set(input.subarray(ip, ip + len2), op);
    op += len2;
    ip += len2;
  }
  this.ip = ip;
  this.op = op;
  this.output = output;
};
Zlib.RawInflate.prototype.parseFixedHuffmanBlock = function() {
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(
        Zlib.RawInflate.FixedLiteralLengthTable,
        Zlib.RawInflate.FixedDistanceTable
      );
      break;
    case Zlib.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(
        Zlib.RawInflate.FixedLiteralLengthTable,
        Zlib.RawInflate.FixedDistanceTable
      );
      break;
    default:
      throw new Error("invalid inflate mode");
  }
};
Zlib.RawInflate.prototype.parseDynamicHuffmanBlock = function() {
  var hlit = this.readBits(5) + 257;
  var hdist = this.readBits(5) + 1;
  var hclen = this.readBits(4) + 4;
  var codeLengths = new Uint8Array(Zlib.RawInflate.Order.length);
  var codeLengthsTable;
  var litlenTable;
  var distTable;
  var lengthTable;
  var code;
  var prev;
  var repeat;
  var i;
  var il;
  for (i = 0; i < hclen; ++i) {
    codeLengths[Zlib.RawInflate.Order[i]] = this.readBits(3);
  }
  codeLengthsTable = buildHuffmanTable(codeLengths);
  lengthTable = new Uint8Array(hlit + hdist);
  for (i = 0, il = hlit + hdist; i < il; ) {
    code = this.readCodeByTable(codeLengthsTable);
    switch (code) {
      case 16:
        repeat = 3 + this.readBits(2);
        while (repeat--) {
          lengthTable[i++] = prev;
        }
        break;
      case 17:
        repeat = 3 + this.readBits(3);
        while (repeat--) {
          lengthTable[i++] = 0;
        }
        prev = 0;
        break;
      case 18:
        repeat = 11 + this.readBits(7);
        while (repeat--) {
          lengthTable[i++] = 0;
        }
        prev = 0;
        break;
      default:
        lengthTable[i++] = code;
        prev = code;
        break;
    }
  }
  litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit));
  distTable = buildHuffmanTable(lengthTable.subarray(hlit));
  switch (this.bufferType) {
    case Zlib.RawInflate.BufferType.ADAPTIVE:
      this.decodeHuffmanAdaptive(litlenTable, distTable);
      break;
    case Zlib.RawInflate.BufferType.BLOCK:
      this.decodeHuffmanBlock(litlenTable, distTable);
      break;
    default:
      throw new Error("invalid inflate mode");
  }
};
Zlib.RawInflate.prototype.decodeHuffmanBlock = function(litlen, dist) {
  var output = this.output;
  var op = this.op;
  this.currentLitlenTable = litlen;
  var olength = output.length - Zlib.RawInflate.MaxCopyLength;
  var code;
  var ti;
  var codeDist;
  var codeLength;
  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib.RawInflate.DistCodeTable;
  var distExtraTable = Zlib.RawInflate.DistExtraTable;
  while ((code = this.readCodeByTable(litlen)) !== 256) {
    if (code < 256) {
      if (op >= olength) {
        this.op = op;
        output = this.expandBufferBlock();
        op = this.op;
      }
      output[op++] = code;
      continue;
    }
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }
    if (op >= olength) {
      this.op = op;
      output = this.expandBufferBlock();
      op = this.op;
    }
    while (codeLength--) {
      output[op] = output[op++ - codeDist];
    }
  }
  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};
Zlib.RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {
  var output = this.output;
  var op = this.op;
  this.currentLitlenTable = litlen;
  var olength = output.length;
  var code;
  var ti;
  var codeDist;
  var codeLength;
  var lengthCodeTable = Zlib.RawInflate.LengthCodeTable;
  var lengthExtraTable = Zlib.RawInflate.LengthExtraTable;
  var distCodeTable = Zlib.RawInflate.DistCodeTable;
  var distExtraTable = Zlib.RawInflate.DistExtraTable;
  while ((code = this.readCodeByTable(litlen)) !== 256) {
    if (code < 256) {
      if (op >= olength) {
        output = this.expandBufferAdaptive();
        olength = output.length;
      }
      output[op++] = code;
      continue;
    }
    ti = code - 257;
    codeLength = lengthCodeTable[ti];
    if (lengthExtraTable[ti] > 0) {
      codeLength += this.readBits(lengthExtraTable[ti]);
    }
    code = this.readCodeByTable(dist);
    codeDist = distCodeTable[code];
    if (distExtraTable[code] > 0) {
      codeDist += this.readBits(distExtraTable[code]);
    }
    if (op + codeLength > olength) {
      output = this.expandBufferAdaptive();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[op++ - codeDist];
    }
  }
  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
};
Zlib.RawInflate.prototype.expandBufferBlock = function(opt_param) {
  var buffer = new Uint8Array(
    this.op - Zlib.RawInflate.MaxBackwardLength
  );
  var backward = this.op - Zlib.RawInflate.MaxBackwardLength;
  var output = this.output;
  {
    buffer.set(output.subarray(Zlib.RawInflate.MaxBackwardLength, buffer.length));
  }
  this.blocks.push(buffer);
  this.totalpos += buffer.length;
  {
    output.set(
      output.subarray(backward, backward + Zlib.RawInflate.MaxBackwardLength)
    );
  }
  this.op = Zlib.RawInflate.MaxBackwardLength;
  return output;
};
Zlib.RawInflate.prototype.expandBufferAdaptive = function(opt_param) {
  var buffer;
  var ratio = this.input.length / this.ip + 1 | 0;
  var maxHuffCode;
  var newSize;
  var maxInflateSize;
  var input = this.input;
  var output = this.output;
  if (opt_param) {
    if (typeof opt_param.fixRatio === "number") {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === "number") {
      ratio += opt_param.addRatio;
    }
  }
  if (ratio < 2) {
    maxHuffCode = (input.length - this.ip) / this.currentLitlenTable[2];
    maxInflateSize = maxHuffCode / 2 * 258 | 0;
    newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
  } else {
    newSize = output.length * ratio;
  }
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }
  this.output = buffer;
  return this.output;
};
Zlib.RawInflate.prototype.concatBufferBlock = function() {
  var pos = 0;
  var limit = this.totalpos + (this.op - Zlib.RawInflate.MaxBackwardLength);
  var output = this.output;
  var blocks = this.blocks;
  var block;
  var buffer = new Uint8Array(limit);
  var i;
  var il;
  var j;
  var jl;
  if (blocks.length === 0) {
    return this.output.subarray(Zlib.RawInflate.MaxBackwardLength, this.op);
  }
  for (i = 0, il = blocks.length; i < il; ++i) {
    block = blocks[i];
    for (j = 0, jl = block.length; j < jl; ++j) {
      buffer[pos++] = block[j];
    }
  }
  for (i = Zlib.RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {
    buffer[pos++] = output[i];
  }
  this.blocks = [];
  this.buffer = buffer;
  return this.buffer;
};
Zlib.RawInflate.prototype.concatBufferDynamic = function() {
  var buffer;
  var op = this.op;
  {
    if (this.resize) {
      buffer = new Uint8Array(op);
      buffer.set(this.output.subarray(0, op));
    } else {
      buffer = this.output.subarray(0, op);
    }
  }
  this.buffer = buffer;
  return this.buffer;
};
var buildHuffmanTable = Zlib.Huffman.buildHuffmanTable;
Zlib.RawInflateStream = function(input, ip, opt_buffersize) {
  this.blocks = [];
  this.bufferSize = opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;
  this.totalpos = 0;
  this.ip = ip === void 0 ? 0 : ip;
  this.bitsbuf = 0;
  this.bitsbuflen = 0;
  this.input = new Uint8Array(input);
  this.output = new Uint8Array(this.bufferSize);
  this.op = 0;
  this.bfinal = false;
  this.blockLength;
  this.resize = false;
  this.litlenTable;
  this.distTable;
  this.sp = 0;
  this.status = Zlib.RawInflateStream.Status.INITIALIZED;
  this.ip_;
  this.bitsbuflen_;
  this.bitsbuf_;
};
Zlib.RawInflateStream.BlockType = {
  UNCOMPRESSED: 0,
  FIXED: 1,
  DYNAMIC: 2
};
Zlib.RawInflateStream.Status = {
  INITIALIZED: 0,
  BLOCK_HEADER_START: 1,
  BLOCK_HEADER_END: 2,
  BLOCK_BODY_START: 3,
  BLOCK_BODY_END: 4,
  DECODE_BLOCK_START: 5,
  DECODE_BLOCK_END: 6
};
Zlib.RawInflateStream.prototype.decompress = function(newInput, ip) {
  var stop = false;
  if (newInput !== void 0) {
    this.input = newInput;
  }
  if (ip !== void 0) {
    this.ip = ip;
  }
  while (!stop) {
    switch (this.status) {
      // block header
      case Zlib.RawInflateStream.Status.INITIALIZED:
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_START:
        if (this.readBlockHeader() < 0) {
          stop = true;
        }
        break;
      // block body
      case Zlib.RawInflateStream.Status.BLOCK_HEADER_END:
      /* FALLTHROUGH */
      case Zlib.RawInflateStream.Status.BLOCK_BODY_START:
        switch (this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.readUncompressedBlockHeader() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED:
            if (this.parseFixedHuffmanBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.parseDynamicHuffmanBlock() < 0) {
              stop = true;
            }
            break;
        }
        break;
      // decode data
      case Zlib.RawInflateStream.Status.BLOCK_BODY_END:
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_START:
        switch (this.currentBlockType) {
          case Zlib.RawInflateStream.BlockType.UNCOMPRESSED:
            if (this.parseUncompressedBlock() < 0) {
              stop = true;
            }
            break;
          case Zlib.RawInflateStream.BlockType.FIXED:
          /* FALLTHROUGH */
          case Zlib.RawInflateStream.BlockType.DYNAMIC:
            if (this.decodeHuffman() < 0) {
              stop = true;
            }
            break;
        }
        break;
      case Zlib.RawInflateStream.Status.DECODE_BLOCK_END:
        if (this.bfinal) {
          stop = true;
        } else {
          this.status = Zlib.RawInflateStream.Status.INITIALIZED;
        }
        break;
    }
  }
  return this.concatBuffer();
};
Zlib.RawInflateStream.MaxBackwardLength = 32768;
Zlib.RawInflateStream.MaxCopyLength = 258;
Zlib.RawInflateStream.Order = (function(table) {
  return new Uint16Array(table);
})([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
Zlib.RawInflateStream.LengthCodeTable = (function(table) {
  return new Uint16Array(table);
})([
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  258,
  258
]);
Zlib.RawInflateStream.LengthExtraTable = (function(table) {
  return new Uint8Array(table);
})([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  0,
  0
]);
Zlib.RawInflateStream.DistCodeTable = (function(table) {
  return new Uint16Array(table);
})([
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
]);
Zlib.RawInflateStream.DistExtraTable = (function(table) {
  return new Uint8Array(table);
})([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
]);
Zlib.RawInflateStream.FixedLiteralLengthTable = /* @__PURE__ */ (function(table) {
  return table;
})((function() {
  var lengths = new Uint8Array(288);
  var i, il;
  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = i <= 143 ? 8 : i <= 255 ? 9 : i <= 279 ? 7 : 8;
  }
  return buildHuffmanTable(lengths);
})());
Zlib.RawInflateStream.FixedDistanceTable = /* @__PURE__ */ (function(table) {
  return table;
})((function() {
  var lengths = new Uint8Array(30);
  var i, il;
  for (i = 0, il = lengths.length; i < il; ++i) {
    lengths[i] = 5;
  }
  return buildHuffmanTable(lengths);
})());
Zlib.RawInflateStream.prototype.readBlockHeader = function() {
  var hdr;
  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_START;
  this.save_();
  if ((hdr = this.readBits(3)) < 0) {
    this.restore_();
    return -1;
  }
  if (hdr & 1) {
    this.bfinal = true;
  }
  hdr >>>= 1;
  switch (hdr) {
    case 0:
      this.currentBlockType = Zlib.RawInflateStream.BlockType.UNCOMPRESSED;
      break;
    case 1:
      this.currentBlockType = Zlib.RawInflateStream.BlockType.FIXED;
      break;
    case 2:
      this.currentBlockType = Zlib.RawInflateStream.BlockType.DYNAMIC;
      break;
    default:
      throw new Error("unknown BTYPE: " + hdr);
  }
  this.status = Zlib.RawInflateStream.Status.BLOCK_HEADER_END;
};
Zlib.RawInflateStream.prototype.readBits = function(length) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;
  var octet;
  while (bitsbuflen < length) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }
  octet = bitsbuf & /* MASK */
  (1 << length) - 1;
  bitsbuf >>>= length;
  bitsbuflen -= length;
  this.bitsbuf = bitsbuf;
  this.bitsbuflen = bitsbuflen;
  this.ip = ip;
  return octet;
};
Zlib.RawInflateStream.prototype.readCodeByTable = function(table) {
  var bitsbuf = this.bitsbuf;
  var bitsbuflen = this.bitsbuflen;
  var input = this.input;
  var ip = this.ip;
  var codeTable = table[0];
  var maxCodeLength = table[1];
  var octet;
  var codeWithLength;
  var codeLength;
  while (bitsbuflen < maxCodeLength) {
    if (input.length <= ip) {
      return -1;
    }
    octet = input[ip++];
    bitsbuf |= octet << bitsbuflen;
    bitsbuflen += 8;
  }
  codeWithLength = codeTable[bitsbuf & (1 << maxCodeLength) - 1];
  codeLength = codeWithLength >>> 16;
  if (codeLength > bitsbuflen) {
    throw new Error("invalid code length: " + codeLength);
  }
  this.bitsbuf = bitsbuf >> codeLength;
  this.bitsbuflen = bitsbuflen - codeLength;
  this.ip = ip;
  return codeWithLength & 65535;
};
Zlib.RawInflateStream.prototype.readUncompressedBlockHeader = function() {
  var len2;
  var nlen;
  var input = this.input;
  var ip = this.ip;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;
  if (ip + 4 >= input.length) {
    return -1;
  }
  len2 = input[ip++] | input[ip++] << 8;
  nlen = input[ip++] | input[ip++] << 8;
  if (len2 === ~nlen) {
    throw new Error("invalid uncompressed block header: length verify");
  }
  this.bitsbuf = 0;
  this.bitsbuflen = 0;
  this.ip = ip;
  this.blockLength = len2;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
};
Zlib.RawInflateStream.prototype.parseUncompressedBlock = function() {
  var input = this.input;
  var ip = this.ip;
  var output = this.output;
  var op = this.op;
  var len2 = this.blockLength;
  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;
  while (len2--) {
    if (op === output.length) {
      output = this.expandBuffer({ fixRatio: 2 });
    }
    if (ip >= input.length) {
      this.ip = ip;
      this.op = op;
      this.blockLength = len2 + 1;
      return -1;
    }
    output[op++] = input[ip++];
  }
  if (len2 < 0) {
    this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
  }
  this.ip = ip;
  this.op = op;
  return 0;
};
Zlib.RawInflateStream.prototype.parseFixedHuffmanBlock = function() {
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;
  this.litlenTable = Zlib.RawInflateStream.FixedLiteralLengthTable;
  this.distTable = Zlib.RawInflateStream.FixedDistanceTable;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
  return 0;
};
Zlib.RawInflateStream.prototype.save_ = function() {
  this.ip_ = this.ip;
  this.bitsbuflen_ = this.bitsbuflen;
  this.bitsbuf_ = this.bitsbuf;
};
Zlib.RawInflateStream.prototype.restore_ = function() {
  this.ip = this.ip_;
  this.bitsbuflen = this.bitsbuflen_;
  this.bitsbuf = this.bitsbuf_;
};
Zlib.RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {
  var hlit;
  var hdist;
  var hclen;
  var codeLengths = new Uint8Array(Zlib.RawInflateStream.Order.length);
  var codeLengthsTable;
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_START;
  this.save_();
  hlit = this.readBits(5) + 257;
  hdist = this.readBits(5) + 1;
  hclen = this.readBits(4) + 4;
  if (hlit < 0 || hdist < 0 || hclen < 0) {
    this.restore_();
    return -1;
  }
  try {
    parseDynamicHuffmanBlockImpl.call(this);
  } catch (e) {
    this.restore_();
    return -1;
  }
  function parseDynamicHuffmanBlockImpl() {
    var bits;
    var code;
    var prev = 0;
    var repeat;
    var lengthTable;
    var i;
    var il;
    for (i = 0; i < hclen; ++i) {
      if ((bits = this.readBits(3)) < 0) {
        throw new Error("not enough input");
      }
      codeLengths[Zlib.RawInflateStream.Order[i]] = bits;
    }
    codeLengthsTable = buildHuffmanTable(codeLengths);
    lengthTable = new Uint8Array(hlit + hdist);
    for (i = 0, il = hlit + hdist; i < il; ) {
      code = this.readCodeByTable(codeLengthsTable);
      if (code < 0) {
        throw new Error("not enough input");
      }
      switch (code) {
        case 16:
          if ((bits = this.readBits(2)) < 0) {
            throw new Error("not enough input");
          }
          repeat = 3 + bits;
          while (repeat--) {
            lengthTable[i++] = prev;
          }
          break;
        case 17:
          if ((bits = this.readBits(3)) < 0) {
            throw new Error("not enough input");
          }
          repeat = 3 + bits;
          while (repeat--) {
            lengthTable[i++] = 0;
          }
          prev = 0;
          break;
        case 18:
          if ((bits = this.readBits(7)) < 0) {
            throw new Error("not enough input");
          }
          repeat = 11 + bits;
          while (repeat--) {
            lengthTable[i++] = 0;
          }
          prev = 0;
          break;
        default:
          lengthTable[i++] = code;
          prev = code;
          break;
      }
    }
    this.litlenTable = buildHuffmanTable(lengthTable.subarray(0, hlit));
    this.distTable = buildHuffmanTable(lengthTable.subarray(hlit));
  }
  this.status = Zlib.RawInflateStream.Status.BLOCK_BODY_END;
  return 0;
};
Zlib.RawInflateStream.prototype.decodeHuffman = function() {
  var output = this.output;
  var op = this.op;
  var code;
  var ti;
  var codeDist;
  var codeLength;
  var litlen = this.litlenTable;
  var dist = this.distTable;
  var olength = output.length;
  var bits;
  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_START;
  while (true) {
    this.save_();
    code = this.readCodeByTable(litlen);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    if (code === 256) {
      break;
    }
    if (code < 256) {
      if (op === olength) {
        output = this.expandBuffer();
        olength = output.length;
      }
      output[op++] = code;
      continue;
    }
    ti = code - 257;
    codeLength = Zlib.RawInflateStream.LengthCodeTable[ti];
    if (Zlib.RawInflateStream.LengthExtraTable[ti] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.LengthExtraTable[ti]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeLength += bits;
    }
    code = this.readCodeByTable(dist);
    if (code < 0) {
      this.op = op;
      this.restore_();
      return -1;
    }
    codeDist = Zlib.RawInflateStream.DistCodeTable[code];
    if (Zlib.RawInflateStream.DistExtraTable[code] > 0) {
      bits = this.readBits(Zlib.RawInflateStream.DistExtraTable[code]);
      if (bits < 0) {
        this.op = op;
        this.restore_();
        return -1;
      }
      codeDist += bits;
    }
    if (op + codeLength >= olength) {
      output = this.expandBuffer();
      olength = output.length;
    }
    while (codeLength--) {
      output[op] = output[op++ - codeDist];
    }
    if (this.ip === this.input.length) {
      this.op = op;
      return -1;
    }
  }
  while (this.bitsbuflen >= 8) {
    this.bitsbuflen -= 8;
    this.ip--;
  }
  this.op = op;
  this.status = Zlib.RawInflateStream.Status.DECODE_BLOCK_END;
};
Zlib.RawInflateStream.prototype.expandBuffer = function(opt_param) {
  var buffer;
  var ratio = this.input.length / this.ip + 1 | 0;
  var maxHuffCode;
  var newSize;
  var maxInflateSize;
  var input = this.input;
  var output = this.output;
  if (opt_param) {
    if (typeof opt_param.fixRatio === "number") {
      ratio = opt_param.fixRatio;
    }
    if (typeof opt_param.addRatio === "number") {
      ratio += opt_param.addRatio;
    }
  }
  if (ratio < 2) {
    maxHuffCode = (input.length - this.ip) / this.litlenTable[2];
    maxInflateSize = maxHuffCode / 2 * 258 | 0;
    newSize = maxInflateSize < output.length ? output.length + maxInflateSize : output.length << 1;
  } else {
    newSize = output.length * ratio;
  }
  {
    buffer = new Uint8Array(newSize);
    buffer.set(output);
  }
  this.output = buffer;
  return this.output;
};
Zlib.RawInflateStream.prototype.concatBuffer = function() {
  var buffer;
  var op = this.op;
  var tmp;
  if (this.resize) {
    {
      buffer = new Uint8Array(this.output.subarray(this.sp, op));
    }
  } else {
    buffer = this.output.subarray(this.sp, op);
  }
  this.sp = op;
  if (op > Zlib.RawInflateStream.MaxBackwardLength + this.bufferSize) {
    this.op = this.sp = Zlib.RawInflateStream.MaxBackwardLength;
    {
      tmp = /** @type {Uint8Array} */
      this.output;
      this.output = new Uint8Array(this.bufferSize + Zlib.RawInflateStream.MaxBackwardLength);
      this.output.set(tmp.subarray(op - Zlib.RawInflateStream.MaxBackwardLength, op));
    }
  }
  return buffer;
};
Zlib.Inflate = function(input, opt_params) {
  var cmf;
  var flg;
  this.input = input;
  this.ip = 0;
  this.rawinflate;
  this.verify;
  if (opt_params || !(opt_params = {})) {
    if (opt_params["index"]) {
      this.ip = opt_params["index"];
    }
    if (opt_params["verify"]) {
      this.verify = opt_params["verify"];
    }
  }
  cmf = input[this.ip++];
  flg = input[this.ip++];
  switch (cmf & 15) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error("unsupported compression method");
  }
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error("invalid fcheck flag:" + ((cmf << 8) + flg) % 31);
  }
  if (flg & 32) {
    throw new Error("fdict flag is not supported");
  }
  this.rawinflate = new Zlib.RawInflate(input, {
    "index": this.ip,
    "bufferSize": opt_params["bufferSize"],
    "bufferType": opt_params["bufferType"],
    "resize": opt_params["resize"]
  });
};
Zlib.Inflate.BufferType = Zlib.RawInflate.BufferType;
Zlib.Inflate.prototype.decompress = function() {
  var input = this.input;
  var buffer;
  var adler322;
  buffer = this.rawinflate.decompress();
  this.ip = this.rawinflate.ip;
  if (this.verify) {
    adler322 = (input[this.ip++] << 24 | input[this.ip++] << 16 | input[this.ip++] << 8 | input[this.ip++]) >>> 0;
    if (adler322 !== Zlib.Adler32(buffer)) {
      throw new Error("invalid adler-32 checksum");
    }
  }
  return buffer;
};
Zlib.InflateStream = function(input) {
  this.input = input === void 0 ? new Uint8Array() : input;
  this.ip = 0;
  this.rawinflate = new Zlib.RawInflateStream(this.input, this.ip);
  this.method;
  this.output = this.rawinflate.output;
};
Zlib.InflateStream.prototype.decompress = function(input) {
  var buffer;
  if (input !== void 0) {
    {
      var tmp = new Uint8Array(this.input.length + input.length);
      tmp.set(this.input, 0);
      tmp.set(input, this.input.length);
      this.input = tmp;
    }
  }
  if (this.method === void 0) {
    if (this.readHeader() < 0) {
      return new Uint8Array();
    }
  }
  buffer = this.rawinflate.decompress(this.input, this.ip);
  if (this.rawinflate.ip !== 0) {
    this.input = this.input.subarray(this.rawinflate.ip);
    this.ip = 0;
  }
  return buffer;
};
Zlib.InflateStream.prototype.readHeader = function() {
  var ip = this.ip;
  var input = this.input;
  var cmf = input[ip++];
  var flg = input[ip++];
  if (cmf === void 0 || flg === void 0) {
    return -1;
  }
  switch (cmf & 15) {
    case Zlib.CompressionMethod.DEFLATE:
      this.method = Zlib.CompressionMethod.DEFLATE;
      break;
    default:
      throw new Error("unsupported compression method");
  }
  if (((cmf << 8) + flg) % 31 !== 0) {
    throw new Error("invalid fcheck flag:" + ((cmf << 8) + flg) % 31);
  }
  if (flg & 32) {
    throw new Error("fdict flag is not supported");
  }
  this.ip = ip;
};
Zlib.Gunzip = function(input, opt_params) {
  this.input = input;
  this.ip = 0;
  this.member = [];
  this.decompressed = false;
};
Zlib.Gunzip.prototype.getMembers = function() {
  if (!this.decompressed) {
    this.decompress();
  }
  return this.member.slice();
};
Zlib.Gunzip.prototype.decompress = function() {
  var il = this.input.length;
  while (this.ip < il) {
    this.decodeMember();
  }
  this.decompressed = true;
  return this.concatMember();
};
Zlib.Gunzip.prototype.decodeMember = function() {
  var member = new Zlib.GunzipMember();
  var isize;
  var rawinflate;
  var inflated;
  var inflen;
  var c;
  var ci;
  var str;
  var mtime;
  var crc322;
  var input = this.input;
  var ip = this.ip;
  member.id1 = input[ip++];
  member.id2 = input[ip++];
  if (member.id1 !== 31 || member.id2 !== 139) {
    throw new Error("invalid file signature:" + member.id1 + "," + member.id2);
  }
  member.cm = input[ip++];
  switch (member.cm) {
    case 8:
      break;
    default:
      throw new Error("unknown compression method: " + member.cm);
  }
  member.flg = input[ip++];
  mtime = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;
  member.mtime = new Date(mtime * 1e3);
  member.xfl = input[ip++];
  member.os = input[ip++];
  if ((member.flg & Zlib.Gzip.FlagsMask.FEXTRA) > 0) {
    member.xlen = input[ip++] | input[ip++] << 8;
    ip = this.decodeSubField(ip, member.xlen);
  }
  if ((member.flg & Zlib.Gzip.FlagsMask.FNAME) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0; ) {
      str[ci++] = String.fromCharCode(c);
    }
    member.name = str.join("");
  }
  if ((member.flg & Zlib.Gzip.FlagsMask.FCOMMENT) > 0) {
    for (str = [], ci = 0; (c = input[ip++]) > 0; ) {
      str[ci++] = String.fromCharCode(c);
    }
    member.comment = str.join("");
  }
  if ((member.flg & Zlib.Gzip.FlagsMask.FHCRC) > 0) {
    member.crc16 = Zlib.CRC32.calc(input, 0, ip) & 65535;
    if (member.crc16 !== (input[ip++] | input[ip++] << 8)) {
      throw new Error("invalid header crc16");
    }
  }
  isize = input[input.length - 4] | input[input.length - 3] << 8 | input[input.length - 2] << 16 | input[input.length - 1] << 24;
  if (input.length - ip - /* CRC-32 */
  4 - /* ISIZE */
  4 < isize * 512) {
    inflen = isize;
  }
  rawinflate = new Zlib.RawInflate(input, { "index": ip, "bufferSize": inflen });
  member.data = inflated = rawinflate.decompress();
  ip = rawinflate.ip;
  member.crc32 = crc322 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  if (Zlib.CRC32.calc(inflated) !== crc322) {
    throw new Error("invalid CRC-32 checksum: 0x" + Zlib.CRC32.calc(inflated).toString(16) + " / 0x" + crc322.toString(16));
  }
  member.isize = isize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  if ((inflated.length & 4294967295) !== isize) {
    throw new Error("invalid input size: " + (inflated.length & 4294967295) + " / " + isize);
  }
  this.member.push(member);
  this.ip = ip;
};
Zlib.Gunzip.prototype.decodeSubField = function(ip, length) {
  return ip + length;
};
Zlib.Gunzip.prototype.concatMember = function() {
  var member = this.member;
  var i;
  var il;
  var p = 0;
  var size = 0;
  var buffer;
  for (i = 0, il = member.length; i < il; ++i) {
    size += member[i].data.length;
  }
  {
    buffer = new Uint8Array(size);
    for (i = 0; i < il; ++i) {
      buffer.set(member[i].data, p);
      p += member[i].data.length;
    }
  }
  return buffer;
};
Zlib.GunzipMember = function() {
  this.id1;
  this.id2;
  this.cm;
  this.flg;
  this.mtime;
  this.xfl;
  this.os;
  this.crc16;
  this.xlen;
  this.crc32;
  this.isize;
  this.name;
  this.comment;
  this.data;
};
Zlib.GunzipMember.prototype.getName = function() {
  return this.name;
};
Zlib.GunzipMember.prototype.getData = function() {
  return this.data;
};
Zlib.GunzipMember.prototype.getMtime = function() {
  return this.mtime;
};
Zlib.Gzip = function(input, opt_params) {
  this.input = input;
  this.ip = 0;
  this.output;
  this.op = 0;
  this.flags = {};
  this.filename;
  this.comment;
  this.deflateOptions;
  if (opt_params) {
    if (opt_params["flags"]) {
      this.flags = opt_params["flags"];
    }
    if (typeof opt_params["filename"] === "string") {
      this.filename = opt_params["filename"];
    }
    if (typeof opt_params["comment"] === "string") {
      this.comment = opt_params["comment"];
    }
    if (opt_params["deflateOptions"]) {
      this.deflateOptions = opt_params["deflateOptions"];
    }
  }
  if (!this.deflateOptions) {
    this.deflateOptions = {};
  }
};
Zlib.Gzip.DefaultBufferSize = 32768;
Zlib.Gzip.prototype.compress = function() {
  var flg;
  var mtime;
  var crc16;
  var crc322;
  var rawdeflate;
  var c;
  var i;
  var il;
  var output = new Uint8Array(Zlib.Gzip.DefaultBufferSize);
  var op = 0;
  var input = this.input;
  var ip = this.ip;
  var filename = this.filename;
  var comment = this.comment;
  output[op++] = 31;
  output[op++] = 139;
  output[op++] = 8;
  flg = 0;
  if (this.flags["fname"]) flg |= Zlib.Gzip.FlagsMask.FNAME;
  if (this.flags["fcomment"]) flg |= Zlib.Gzip.FlagsMask.FCOMMENT;
  if (this.flags["fhcrc"]) flg |= Zlib.Gzip.FlagsMask.FHCRC;
  output[op++] = flg;
  mtime = (Date.now ? Date.now() : +/* @__PURE__ */ new Date()) / 1e3 | 0;
  output[op++] = mtime & 255;
  output[op++] = mtime >>> 8 & 255;
  output[op++] = mtime >>> 16 & 255;
  output[op++] = mtime >>> 24 & 255;
  output[op++] = 0;
  output[op++] = Zlib.Gzip.OperatingSystem.UNKNOWN;
  if (this.flags["fname"] !== void 0) {
    for (i = 0, il = filename.length; i < il; ++i) {
      c = filename.charCodeAt(i);
      if (c > 255) {
        output[op++] = c >>> 8 & 255;
      }
      output[op++] = c & 255;
    }
    output[op++] = 0;
  }
  if (this.flags["comment"]) {
    for (i = 0, il = comment.length; i < il; ++i) {
      c = comment.charCodeAt(i);
      if (c > 255) {
        output[op++] = c >>> 8 & 255;
      }
      output[op++] = c & 255;
    }
    output[op++] = 0;
  }
  if (this.flags["fhcrc"]) {
    crc16 = Zlib.CRC32.calc(output, 0, op) & 65535;
    output[op++] = crc16 & 255;
    output[op++] = crc16 >>> 8 & 255;
  }
  this.deflateOptions["outputBuffer"] = output;
  this.deflateOptions["outputIndex"] = op;
  rawdeflate = new Zlib.RawDeflate(input, this.deflateOptions);
  output = rawdeflate.compress();
  op = rawdeflate.op;
  {
    if (op + 8 > output.buffer.byteLength) {
      this.output = new Uint8Array(op + 8);
      this.output.set(new Uint8Array(output.buffer));
      output = this.output;
    } else {
      output = new Uint8Array(output.buffer);
    }
  }
  crc322 = Zlib.CRC32.calc(input);
  output[op++] = crc322 & 255;
  output[op++] = crc322 >>> 8 & 255;
  output[op++] = crc322 >>> 16 & 255;
  output[op++] = crc322 >>> 24 & 255;
  il = input.length;
  output[op++] = il & 255;
  output[op++] = il >>> 8 & 255;
  output[op++] = il >>> 16 & 255;
  output[op++] = il >>> 24 & 255;
  this.ip = ip;
  if (op < output.length) {
    this.output = output = output.subarray(0, op);
  }
  return output;
};
Zlib.Gzip.OperatingSystem = {
  FAT: 0,
  AMIGA: 1,
  VMS: 2,
  UNIX: 3,
  VM_CMS: 4,
  ATARI_TOS: 5,
  HPFS: 6,
  MACINTOSH: 7,
  Z_SYSTEM: 8,
  CP_M: 9,
  TOPS_20: 10,
  NTFS: 11,
  QDOS: 12,
  ACORN_RISCOS: 13,
  UNKNOWN: 255
};
Zlib.Gzip.FlagsMask = {
  FTEXT: 1,
  FHCRC: 2,
  FEXTRA: 4,
  FNAME: 8,
  FCOMMENT: 16
};
Zlib.Heap = function(length) {
  this.buffer = new Uint16Array(length * 2);
  this.length = 0;
};
Zlib.Heap.prototype.getParent = function(index2) {
  return ((index2 - 2) / 4 | 0) * 2;
};
Zlib.Heap.prototype.getChild = function(index2) {
  return 2 * index2 + 2;
};
Zlib.Heap.prototype.push = function(index2, value) {
  var current, parent, heap = this.buffer, swap2;
  current = this.length;
  heap[this.length++] = value;
  heap[this.length++] = index2;
  while (current > 0) {
    parent = this.getParent(current);
    if (heap[current] > heap[parent]) {
      swap2 = heap[current];
      heap[current] = heap[parent];
      heap[parent] = swap2;
      swap2 = heap[current + 1];
      heap[current + 1] = heap[parent + 1];
      heap[parent + 1] = swap2;
      current = parent;
    } else {
      break;
    }
  }
  return this.length;
};
Zlib.Heap.prototype.pop = function() {
  var index2, value, heap = this.buffer, swap2, current, parent;
  value = heap[0];
  index2 = heap[1];
  this.length -= 2;
  heap[0] = heap[this.length];
  heap[1] = heap[this.length + 1];
  parent = 0;
  while (true) {
    current = this.getChild(parent);
    if (current >= this.length) {
      break;
    }
    if (current + 2 < this.length && heap[current + 2] > heap[current]) {
      current += 2;
    }
    if (heap[current] > heap[parent]) {
      swap2 = heap[parent];
      heap[parent] = heap[current];
      heap[current] = swap2;
      swap2 = heap[parent + 1];
      heap[parent + 1] = heap[current + 1];
      heap[current + 1] = swap2;
    } else {
      break;
    }
    parent = current;
  }
  return { index: index2, value, length: this.length };
};
Zlib.RawDeflate = function(input, opt_params) {
  this.compressionType = Zlib.RawDeflate.CompressionType.DYNAMIC;
  this.lazy = 0;
  this.freqsLitLen;
  this.freqsDist;
  this.input = input instanceof Array ? new Uint8Array(input) : input;
  this.output;
  this.op = 0;
  if (opt_params) {
    if (opt_params["lazy"]) {
      this.lazy = opt_params["lazy"];
    }
    if (typeof opt_params["compressionType"] === "number") {
      this.compressionType = opt_params["compressionType"];
    }
    if (opt_params["outputBuffer"]) {
      this.output = opt_params["outputBuffer"] instanceof Array ? new Uint8Array(opt_params["outputBuffer"]) : opt_params["outputBuffer"];
    }
    if (typeof opt_params["outputIndex"] === "number") {
      this.op = opt_params["outputIndex"];
    }
  }
  if (!this.output) {
    this.output = new Uint8Array(32768);
  }
};
Zlib.RawDeflate.CompressionType = {
  NONE: 0,
  FIXED: 1,
  DYNAMIC: 2,
  RESERVED: 3
};
Zlib.RawDeflate.Lz77MinLength = 3;
Zlib.RawDeflate.Lz77MaxLength = 258;
Zlib.RawDeflate.WindowSize = 32768;
Zlib.RawDeflate.MaxCodeLength = 16;
Zlib.RawDeflate.HUFMAX = 286;
Zlib.RawDeflate.FixedHuffmanTable = (function() {
  var table = [], i;
  for (i = 0; i < 288; i++) {
    switch (true) {
      case i <= 143:
        table.push([i + 48, 8]);
        break;
      case i <= 255:
        table.push([i - 144 + 400, 9]);
        break;
      case i <= 279:
        table.push([i - 256 + 0, 7]);
        break;
      case i <= 287:
        table.push([i - 280 + 192, 8]);
        break;
      default:
        throw "invalid literal: " + i;
    }
  }
  return table;
})();
Zlib.RawDeflate.prototype.compress = function() {
  var blockArray;
  var position;
  var length;
  var input = this.input;
  switch (this.compressionType) {
    case Zlib.RawDeflate.CompressionType.NONE:
      for (position = 0, length = input.length; position < length; ) {
        blockArray = input.subarray(position, position + 65535);
        position += blockArray.length;
        this.makeNocompressBlock(blockArray, position === length);
      }
      break;
    case Zlib.RawDeflate.CompressionType.FIXED:
      this.output = this.makeFixedHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    case Zlib.RawDeflate.CompressionType.DYNAMIC:
      this.output = this.makeDynamicHuffmanBlock(input, true);
      this.op = this.output.length;
      break;
    default:
      throw "invalid compression type";
  }
  return this.output;
};
Zlib.RawDeflate.prototype.makeNocompressBlock = function(blockArray, isFinalBlock) {
  var bfinal;
  var btype;
  var len2;
  var nlen;
  var output = this.output;
  var op = this.op;
  {
    output = new Uint8Array(this.output.buffer);
    while (output.length <= op + blockArray.length + 5) {
      output = new Uint8Array(output.length << 1);
    }
    output.set(this.output);
  }
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.NONE;
  output[op++] = bfinal | btype << 1;
  len2 = blockArray.length;
  nlen = ~len2 + 65536 & 65535;
  output[op++] = len2 & 255;
  output[op++] = len2 >>> 8 & 255;
  output[op++] = nlen & 255;
  output[op++] = nlen >>> 8 & 255;
  {
    output.set(blockArray, op);
    op += blockArray.length;
    output = output.subarray(0, op);
  }
  this.op = op;
  this.output = output;
  return output;
};
Zlib.RawDeflate.prototype.makeFixedHuffmanBlock = function(blockArray, isFinalBlock) {
  var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer), this.op);
  var bfinal;
  var btype;
  var data;
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.FIXED;
  stream.writeBits(bfinal, 1, true);
  stream.writeBits(btype, 2, true);
  data = this.lz77(blockArray);
  this.fixedHuffman(data, stream);
  return stream.finish();
};
Zlib.RawDeflate.prototype.makeDynamicHuffmanBlock = function(blockArray, isFinalBlock) {
  var stream = new Zlib.BitStream(new Uint8Array(this.output.buffer), this.op);
  var bfinal;
  var btype;
  var data;
  var hlit;
  var hdist;
  var hclen;
  var hclenOrder = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var litLenLengths;
  var litLenCodes;
  var distLengths;
  var distCodes;
  var treeSymbols;
  var treeLengths;
  var transLengths = new Array(19);
  var treeCodes;
  var code;
  var bitlen;
  var i;
  var il;
  bfinal = isFinalBlock ? 1 : 0;
  btype = Zlib.RawDeflate.CompressionType.DYNAMIC;
  stream.writeBits(bfinal, 1, true);
  stream.writeBits(btype, 2, true);
  data = this.lz77(blockArray);
  litLenLengths = this.getLengths_(this.freqsLitLen, 15);
  litLenCodes = this.getCodesFromLengths_(litLenLengths);
  distLengths = this.getLengths_(this.freqsDist, 7);
  distCodes = this.getCodesFromLengths_(distLengths);
  for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {
  }
  for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {
  }
  treeSymbols = this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);
  treeLengths = this.getLengths_(treeSymbols.freqs, 7);
  for (i = 0; i < 19; i++) {
    transLengths[i] = treeLengths[hclenOrder[i]];
  }
  for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {
  }
  treeCodes = this.getCodesFromLengths_(treeLengths);
  stream.writeBits(hlit - 257, 5, true);
  stream.writeBits(hdist - 1, 5, true);
  stream.writeBits(hclen - 4, 4, true);
  for (i = 0; i < hclen; i++) {
    stream.writeBits(transLengths[i], 3, true);
  }
  for (i = 0, il = treeSymbols.codes.length; i < il; i++) {
    code = treeSymbols.codes[i];
    stream.writeBits(treeCodes[code], treeLengths[code], true);
    if (code >= 16) {
      i++;
      switch (code) {
        case 16:
          bitlen = 2;
          break;
        case 17:
          bitlen = 3;
          break;
        case 18:
          bitlen = 7;
          break;
        default:
          throw "invalid code: " + code;
      }
      stream.writeBits(treeSymbols.codes[i], bitlen, true);
    }
  }
  this.dynamicHuffman(
    data,
    [litLenCodes, litLenLengths],
    [distCodes, distLengths],
    stream
  );
  return stream.finish();
};
Zlib.RawDeflate.prototype.dynamicHuffman = function(dataArray, litLen, dist, stream) {
  var index2;
  var length;
  var literal;
  var code;
  var litLenCodes;
  var litLenLengths;
  var distCodes;
  var distLengths;
  litLenCodes = litLen[0];
  litLenLengths = litLen[1];
  distCodes = dist[0];
  distLengths = dist[1];
  for (index2 = 0, length = dataArray.length; index2 < length; ++index2) {
    literal = dataArray[index2];
    stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);
    if (literal > 256) {
      stream.writeBits(dataArray[++index2], dataArray[++index2], true);
      code = dataArray[++index2];
      stream.writeBits(distCodes[code], distLengths[code], true);
      stream.writeBits(dataArray[++index2], dataArray[++index2], true);
    } else if (literal === 256) {
      break;
    }
  }
  return stream;
};
Zlib.RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {
  var index2;
  var length;
  var literal;
  for (index2 = 0, length = dataArray.length; index2 < length; index2++) {
    literal = dataArray[index2];
    Zlib.BitStream.prototype.writeBits.apply(
      stream,
      Zlib.RawDeflate.FixedHuffmanTable[literal]
    );
    if (literal > 256) {
      stream.writeBits(dataArray[++index2], dataArray[++index2], true);
      stream.writeBits(dataArray[++index2], 5);
      stream.writeBits(dataArray[++index2], dataArray[++index2], true);
    } else if (literal === 256) {
      break;
    }
  }
  return stream;
};
Zlib.RawDeflate.Lz77Match = function(length, backwardDistance) {
  this.length = length;
  this.backwardDistance = backwardDistance;
};
Zlib.RawDeflate.Lz77Match.LengthCodeTable = (function(table) {
  return new Uint32Array(table);
})((function() {
  var table = [];
  var i;
  var c;
  for (i = 3; i <= 258; i++) {
    c = code(i);
    table[i] = c[2] << 24 | c[1] << 16 | c[0];
  }
  function code(length) {
    switch (true) {
      case length === 3:
        return [257, length - 3, 0];
      case length === 4:
        return [258, length - 4, 0];
      case length === 5:
        return [259, length - 5, 0];
      case length === 6:
        return [260, length - 6, 0];
      case length === 7:
        return [261, length - 7, 0];
      case length === 8:
        return [262, length - 8, 0];
      case length === 9:
        return [263, length - 9, 0];
      case length === 10:
        return [264, length - 10, 0];
      case length <= 12:
        return [265, length - 11, 1];
      case length <= 14:
        return [266, length - 13, 1];
      case length <= 16:
        return [267, length - 15, 1];
      case length <= 18:
        return [268, length - 17, 1];
      case length <= 22:
        return [269, length - 19, 2];
      case length <= 26:
        return [270, length - 23, 2];
      case length <= 30:
        return [271, length - 27, 2];
      case length <= 34:
        return [272, length - 31, 2];
      case length <= 42:
        return [273, length - 35, 3];
      case length <= 50:
        return [274, length - 43, 3];
      case length <= 58:
        return [275, length - 51, 3];
      case length <= 66:
        return [276, length - 59, 3];
      case length <= 82:
        return [277, length - 67, 4];
      case length <= 98:
        return [278, length - 83, 4];
      case length <= 114:
        return [279, length - 99, 4];
      case length <= 130:
        return [280, length - 115, 4];
      case length <= 162:
        return [281, length - 131, 5];
      case length <= 194:
        return [282, length - 163, 5];
      case length <= 226:
        return [283, length - 195, 5];
      case length <= 257:
        return [284, length - 227, 5];
      case length === 258:
        return [285, length - 258, 0];
      default:
        throw "invalid length: " + length;
    }
  }
  return table;
})());
Zlib.RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {
  var r;
  switch (true) {
    case dist === 1:
      r = [0, dist - 1, 0];
      break;
    case dist === 2:
      r = [1, dist - 2, 0];
      break;
    case dist === 3:
      r = [2, dist - 3, 0];
      break;
    case dist === 4:
      r = [3, dist - 4, 0];
      break;
    case dist <= 6:
      r = [4, dist - 5, 1];
      break;
    case dist <= 8:
      r = [5, dist - 7, 1];
      break;
    case dist <= 12:
      r = [6, dist - 9, 2];
      break;
    case dist <= 16:
      r = [7, dist - 13, 2];
      break;
    case dist <= 24:
      r = [8, dist - 17, 3];
      break;
    case dist <= 32:
      r = [9, dist - 25, 3];
      break;
    case dist <= 48:
      r = [10, dist - 33, 4];
      break;
    case dist <= 64:
      r = [11, dist - 49, 4];
      break;
    case dist <= 96:
      r = [12, dist - 65, 5];
      break;
    case dist <= 128:
      r = [13, dist - 97, 5];
      break;
    case dist <= 192:
      r = [14, dist - 129, 6];
      break;
    case dist <= 256:
      r = [15, dist - 193, 6];
      break;
    case dist <= 384:
      r = [16, dist - 257, 7];
      break;
    case dist <= 512:
      r = [17, dist - 385, 7];
      break;
    case dist <= 768:
      r = [18, dist - 513, 8];
      break;
    case dist <= 1024:
      r = [19, dist - 769, 8];
      break;
    case dist <= 1536:
      r = [20, dist - 1025, 9];
      break;
    case dist <= 2048:
      r = [21, dist - 1537, 9];
      break;
    case dist <= 3072:
      r = [22, dist - 2049, 10];
      break;
    case dist <= 4096:
      r = [23, dist - 3073, 10];
      break;
    case dist <= 6144:
      r = [24, dist - 4097, 11];
      break;
    case dist <= 8192:
      r = [25, dist - 6145, 11];
      break;
    case dist <= 12288:
      r = [26, dist - 8193, 12];
      break;
    case dist <= 16384:
      r = [27, dist - 12289, 12];
      break;
    case dist <= 24576:
      r = [28, dist - 16385, 13];
      break;
    case dist <= 32768:
      r = [29, dist - 24577, 13];
      break;
    default:
      throw "invalid distance";
  }
  return r;
};
Zlib.RawDeflate.Lz77Match.prototype.toLz77Array = function() {
  var length = this.length;
  var dist = this.backwardDistance;
  var codeArray = [];
  var pos = 0;
  var code;
  code = Zlib.RawDeflate.Lz77Match.LengthCodeTable[length];
  codeArray[pos++] = code & 65535;
  codeArray[pos++] = code >> 16 & 255;
  codeArray[pos++] = code >> 24;
  code = this.getDistanceCode_(dist);
  codeArray[pos++] = code[0];
  codeArray[pos++] = code[1];
  codeArray[pos++] = code[2];
  return codeArray;
};
Zlib.RawDeflate.prototype.lz77 = function(dataArray) {
  var position;
  var length;
  var i;
  var il;
  var matchKey;
  var table = {};
  var windowSize = Zlib.RawDeflate.WindowSize;
  var matchList;
  var longestMatch;
  var prevMatch;
  var lz77buf = new Uint16Array(dataArray.length * 2);
  var pos = 0;
  var skipLength = 0;
  var freqsLitLen = new Uint32Array(286);
  var freqsDist = new Uint32Array(30);
  var lazy = this.lazy;
  var tmp;
  freqsLitLen[256] = 1;
  function writeMatch(match, offset2) {
    var lz77Array = match.toLz77Array();
    var i2;
    var il2;
    for (i2 = 0, il2 = lz77Array.length; i2 < il2; ++i2) {
      lz77buf[pos++] = lz77Array[i2];
    }
    freqsLitLen[lz77Array[0]]++;
    freqsDist[lz77Array[3]]++;
    skipLength = match.length + offset2 - 1;
    prevMatch = null;
  }
  for (position = 0, length = dataArray.length; position < length; ++position) {
    for (matchKey = 0, i = 0, il = Zlib.RawDeflate.Lz77MinLength; i < il; ++i) {
      if (position + i === length) {
        break;
      }
      matchKey = matchKey << 8 | dataArray[position + i];
    }
    if (table[matchKey] === void 0) {
      table[matchKey] = [];
    }
    matchList = table[matchKey];
    if (skipLength-- > 0) {
      matchList.push(position);
      continue;
    }
    while (matchList.length > 0 && position - matchList[0] > windowSize) {
      matchList.shift();
    }
    if (position + Zlib.RawDeflate.Lz77MinLength >= length) {
      if (prevMatch) {
        writeMatch(prevMatch, -1);
      }
      for (i = 0, il = length - position; i < il; ++i) {
        tmp = dataArray[position + i];
        lz77buf[pos++] = tmp;
        ++freqsLitLen[tmp];
      }
      break;
    }
    if (matchList.length > 0) {
      longestMatch = this.searchLongestMatch_(dataArray, position, matchList);
      if (prevMatch) {
        if (prevMatch.length < longestMatch.length) {
          tmp = dataArray[position - 1];
          lz77buf[pos++] = tmp;
          ++freqsLitLen[tmp];
          writeMatch(longestMatch, 0);
        } else {
          writeMatch(prevMatch, -1);
        }
      } else if (longestMatch.length < lazy) {
        prevMatch = longestMatch;
      } else {
        writeMatch(longestMatch, 0);
      }
    } else if (prevMatch) {
      writeMatch(prevMatch, -1);
    } else {
      tmp = dataArray[position];
      lz77buf[pos++] = tmp;
      ++freqsLitLen[tmp];
    }
    matchList.push(position);
  }
  lz77buf[pos++] = 256;
  freqsLitLen[256]++;
  this.freqsLitLen = freqsLitLen;
  this.freqsDist = freqsDist;
  return (
    /** @type {!(Uint16Array|Array.<number>)} */
    lz77buf.subarray(0, pos)
  );
};
Zlib.RawDeflate.prototype.searchLongestMatch_ = function(data, position, matchList) {
  var match, currentMatch, matchMax = 0, matchLength, i, j, l, dl = data.length;
  permatch:
    for (i = 0, l = matchList.length; i < l; i++) {
      match = matchList[l - i - 1];
      matchLength = Zlib.RawDeflate.Lz77MinLength;
      if (matchMax > Zlib.RawDeflate.Lz77MinLength) {
        for (j = matchMax; j > Zlib.RawDeflate.Lz77MinLength; j--) {
          if (data[match + j - 1] !== data[position + j - 1]) {
            continue permatch;
          }
        }
        matchLength = matchMax;
      }
      while (matchLength < Zlib.RawDeflate.Lz77MaxLength && position + matchLength < dl && data[match + matchLength] === data[position + matchLength]) {
        ++matchLength;
      }
      if (matchLength > matchMax) {
        currentMatch = match;
        matchMax = matchLength;
      }
      if (matchLength === Zlib.RawDeflate.Lz77MaxLength) {
        break;
      }
    }
  return new Zlib.RawDeflate.Lz77Match(matchMax, position - currentMatch);
};
Zlib.RawDeflate.prototype.getTreeSymbols_ = function(hlit, litlenLengths, hdist, distLengths) {
  var src = new Uint32Array(hlit + hdist), i, j, runLength, l, result = new Uint32Array(286 + 30), nResult, rpt, freqs = new Uint8Array(19);
  j = 0;
  for (i = 0; i < hlit; i++) {
    src[j++] = litlenLengths[i];
  }
  for (i = 0; i < hdist; i++) {
    src[j++] = distLengths[i];
  }
  nResult = 0;
  for (i = 0, l = src.length; i < l; i += j) {
    for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {
    }
    runLength = j;
    if (src[i] === 0) {
      if (runLength < 3) {
        while (runLength-- > 0) {
          result[nResult++] = 0;
          freqs[0]++;
        }
      } else {
        while (runLength > 0) {
          rpt = runLength < 138 ? runLength : 138;
          if (rpt > runLength - 3 && rpt < runLength) {
            rpt = runLength - 3;
          }
          if (rpt <= 10) {
            result[nResult++] = 17;
            result[nResult++] = rpt - 3;
            freqs[17]++;
          } else {
            result[nResult++] = 18;
            result[nResult++] = rpt - 11;
            freqs[18]++;
          }
          runLength -= rpt;
        }
      }
    } else {
      result[nResult++] = src[i];
      freqs[src[i]]++;
      runLength--;
      if (runLength < 3) {
        while (runLength-- > 0) {
          result[nResult++] = src[i];
          freqs[src[i]]++;
        }
      } else {
        while (runLength > 0) {
          rpt = runLength < 6 ? runLength : 6;
          if (rpt > runLength - 3 && rpt < runLength) {
            rpt = runLength - 3;
          }
          result[nResult++] = 16;
          result[nResult++] = rpt - 3;
          freqs[16]++;
          runLength -= rpt;
        }
      }
    }
  }
  return {
    codes: result.subarray(0, nResult),
    freqs
  };
};
Zlib.RawDeflate.prototype.getLengths_ = function(freqs, limit) {
  var nSymbols = freqs.length;
  var heap = new Zlib.Heap(2 * Zlib.RawDeflate.HUFMAX);
  var length = new Uint8Array(nSymbols);
  var nodes;
  var values;
  var codeLength;
  var i;
  var il;
  for (i = 0; i < nSymbols; ++i) {
    if (freqs[i] > 0) {
      heap.push(i, freqs[i]);
    }
  }
  nodes = new Array(heap.length / 2);
  values = new Uint32Array(heap.length / 2);
  if (nodes.length === 1) {
    length[heap.pop().index] = 1;
    return length;
  }
  for (i = 0, il = heap.length / 2; i < il; ++i) {
    nodes[i] = heap.pop();
    values[i] = nodes[i].value;
  }
  codeLength = this.reversePackageMerge_(values, values.length, limit);
  for (i = 0, il = nodes.length; i < il; ++i) {
    length[nodes[i].index] = codeLength[i];
  }
  return length;
};
Zlib.RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {
  var minimumCost = new Uint16Array(limit);
  var flag = new Uint8Array(limit);
  var codeLength = new Uint8Array(symbols);
  var value = new Array(limit);
  var type = new Array(limit);
  var currentPosition = new Array(limit);
  var excess = (1 << limit) - symbols;
  var half = 1 << limit - 1;
  var i;
  var j;
  var t;
  var weight;
  var next;
  function takePackage(j2) {
    var x = type[j2][currentPosition[j2]];
    if (x === symbols) {
      takePackage(j2 + 1);
      takePackage(j2 + 1);
    } else {
      --codeLength[x];
    }
    ++currentPosition[j2];
  }
  minimumCost[limit - 1] = symbols;
  for (j = 0; j < limit; ++j) {
    if (excess < half) {
      flag[j] = 0;
    } else {
      flag[j] = 1;
      excess -= half;
    }
    excess <<= 1;
    minimumCost[limit - 2 - j] = (minimumCost[limit - 1 - j] / 2 | 0) + symbols;
  }
  minimumCost[0] = flag[0];
  value[0] = new Array(minimumCost[0]);
  type[0] = new Array(minimumCost[0]);
  for (j = 1; j < limit; ++j) {
    if (minimumCost[j] > 2 * minimumCost[j - 1] + flag[j]) {
      minimumCost[j] = 2 * minimumCost[j - 1] + flag[j];
    }
    value[j] = new Array(minimumCost[j]);
    type[j] = new Array(minimumCost[j]);
  }
  for (i = 0; i < symbols; ++i) {
    codeLength[i] = limit;
  }
  for (t = 0; t < minimumCost[limit - 1]; ++t) {
    value[limit - 1][t] = freqs[t];
    type[limit - 1][t] = t;
  }
  for (i = 0; i < limit; ++i) {
    currentPosition[i] = 0;
  }
  if (flag[limit - 1] === 1) {
    --codeLength[0];
    ++currentPosition[limit - 1];
  }
  for (j = limit - 2; j >= 0; --j) {
    i = 0;
    weight = 0;
    next = currentPosition[j + 1];
    for (t = 0; t < minimumCost[j]; t++) {
      weight = value[j + 1][next] + value[j + 1][next + 1];
      if (weight > freqs[i]) {
        value[j][t] = weight;
        type[j][t] = symbols;
        next += 2;
      } else {
        value[j][t] = freqs[i];
        type[j][t] = i;
        ++i;
      }
    }
    currentPosition[j] = 0;
    if (flag[j] === 1) {
      takePackage(j);
    }
  }
  return codeLength;
};
Zlib.RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {
  var codes = new Uint16Array(lengths.length), count = [], startCode = [], code = 0, i, il, j, m;
  for (i = 0, il = lengths.length; i < il; i++) {
    count[lengths[i]] = (count[lengths[i]] | 0) + 1;
  }
  for (i = 1, il = Zlib.RawDeflate.MaxCodeLength; i <= il; i++) {
    startCode[i] = code;
    code += count[i] | 0;
    code <<= 1;
  }
  for (i = 0, il = lengths.length; i < il; i++) {
    code = startCode[lengths[i]];
    startCode[lengths[i]] += 1;
    codes[i] = 0;
    for (j = 0, m = lengths[i]; j < m; j++) {
      codes[i] = codes[i] << 1 | code & 1;
      code >>>= 1;
    }
  }
  return codes;
};
Zlib.Unzip = function(input, opt_params) {
  opt_params = opt_params || {};
  this.input = input instanceof Array ? new Uint8Array(input) : input;
  this.ip = 0;
  this.eocdrOffset;
  this.numberOfThisDisk;
  this.startDisk;
  this.totalEntriesThisDisk;
  this.totalEntries;
  this.centralDirectorySize;
  this.centralDirectoryOffset;
  this.commentLength;
  this.comment;
  this.fileHeaderList;
  this.filenameToIndex;
  this.verify = opt_params["verify"] || false;
  this.password = opt_params["password"];
};
Zlib.Unzip.CompressionMethod = Zlib.Zip.CompressionMethod;
Zlib.Unzip.FileHeaderSignature = Zlib.Zip.FileHeaderSignature;
Zlib.Unzip.LocalFileHeaderSignature = Zlib.Zip.LocalFileHeaderSignature;
Zlib.Unzip.CentralDirectorySignature = Zlib.Zip.CentralDirectorySignature;
Zlib.Unzip.FileHeader = function(input, ip) {
  this.input = input;
  this.offset = ip;
  this.length;
  this.version;
  this.os;
  this.needVersion;
  this.flags;
  this.compression;
  this.time;
  this.date;
  this.crc32;
  this.compressedSize;
  this.plainSize;
  this.fileNameLength;
  this.extraFieldLength;
  this.fileCommentLength;
  this.diskNumberStart;
  this.internalFileAttributes;
  this.externalFileAttributes;
  this.relativeOffset;
  this.filename;
  this.extraField;
  this.comment;
};
Zlib.Unzip.FileHeader.prototype.parse = function() {
  var input = this.input;
  var ip = this.offset;
  if (input[ip++] !== Zlib.Unzip.FileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.FileHeaderSignature[3]) {
    throw new Error("invalid file header signature");
  }
  this.version = input[ip++];
  this.os = input[ip++];
  this.needVersion = input[ip++] | input[ip++] << 8;
  this.flags = input[ip++] | input[ip++] << 8;
  this.compression = input[ip++] | input[ip++] << 8;
  this.time = input[ip++] | input[ip++] << 8;
  this.date = input[ip++] | input[ip++] << 8;
  this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.fileNameLength = input[ip++] | input[ip++] << 8;
  this.extraFieldLength = input[ip++] | input[ip++] << 8;
  this.fileCommentLength = input[ip++] | input[ip++] << 8;
  this.diskNumberStart = input[ip++] | input[ip++] << 8;
  this.internalFileAttributes = input[ip++] | input[ip++] << 8;
  this.externalFileAttributes = input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24;
  this.relativeOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.filename = String.fromCharCode.apply(
    null,
    input.subarray(ip, ip += this.fileNameLength)
  );
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);
  this.comment = input.subarray(ip, ip + this.fileCommentLength);
  this.length = ip - this.offset;
};
Zlib.Unzip.LocalFileHeader = function(input, ip) {
  this.input = input;
  this.offset = ip;
  this.length;
  this.needVersion;
  this.flags;
  this.compression;
  this.time;
  this.date;
  this.crc32;
  this.compressedSize;
  this.plainSize;
  this.fileNameLength;
  this.extraFieldLength;
  this.filename;
  this.extraField;
};
Zlib.Unzip.LocalFileHeader.Flags = Zlib.Zip.Flags;
Zlib.Unzip.LocalFileHeader.prototype.parse = function() {
  var input = this.input;
  var ip = this.offset;
  if (input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[0] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[1] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[2] || input[ip++] !== Zlib.Unzip.LocalFileHeaderSignature[3]) {
    throw new Error("invalid local file header signature");
  }
  this.needVersion = input[ip++] | input[ip++] << 8;
  this.flags = input[ip++] | input[ip++] << 8;
  this.compression = input[ip++] | input[ip++] << 8;
  this.time = input[ip++] | input[ip++] << 8;
  this.date = input[ip++] | input[ip++] << 8;
  this.crc32 = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.compressedSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.plainSize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.fileNameLength = input[ip++] | input[ip++] << 8;
  this.extraFieldLength = input[ip++] | input[ip++] << 8;
  this.filename = String.fromCharCode.apply(
    null,
    input.subarray(ip, ip += this.fileNameLength)
  );
  this.extraField = input.subarray(ip, ip += this.extraFieldLength);
  this.length = ip - this.offset;
};
Zlib.Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {
  var input = this.input;
  var ip;
  for (ip = input.length - 12; ip > 0; --ip) {
    if (input[ip] === Zlib.Unzip.CentralDirectorySignature[0] && input[ip + 1] === Zlib.Unzip.CentralDirectorySignature[1] && input[ip + 2] === Zlib.Unzip.CentralDirectorySignature[2] && input[ip + 3] === Zlib.Unzip.CentralDirectorySignature[3]) {
      this.eocdrOffset = ip;
      return;
    }
  }
  throw new Error("End of Central Directory Record not found");
};
Zlib.Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {
  var input = this.input;
  var ip;
  if (!this.eocdrOffset) {
    this.searchEndOfCentralDirectoryRecord();
  }
  ip = this.eocdrOffset;
  if (input[ip++] !== Zlib.Unzip.CentralDirectorySignature[0] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[1] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[2] || input[ip++] !== Zlib.Unzip.CentralDirectorySignature[3]) {
    throw new Error("invalid signature");
  }
  this.numberOfThisDisk = input[ip++] | input[ip++] << 8;
  this.startDisk = input[ip++] | input[ip++] << 8;
  this.totalEntriesThisDisk = input[ip++] | input[ip++] << 8;
  this.totalEntries = input[ip++] | input[ip++] << 8;
  this.centralDirectorySize = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.centralDirectoryOffset = (input[ip++] | input[ip++] << 8 | input[ip++] << 16 | input[ip++] << 24) >>> 0;
  this.commentLength = input[ip++] | input[ip++] << 8;
  this.comment = input.subarray(ip, ip + this.commentLength);
};
Zlib.Unzip.prototype.parseFileHeader = function() {
  var filelist = [];
  var filetable = {};
  var ip;
  var fileHeader;
  var i;
  var il;
  if (this.fileHeaderList) {
    return;
  }
  if (this.centralDirectoryOffset === void 0) {
    this.parseEndOfCentralDirectoryRecord();
  }
  ip = this.centralDirectoryOffset;
  for (i = 0, il = this.totalEntries; i < il; ++i) {
    fileHeader = new Zlib.Unzip.FileHeader(this.input, ip);
    fileHeader.parse();
    ip += fileHeader.length;
    filelist[i] = fileHeader;
    filetable[fileHeader.filename] = i;
  }
  if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {
    throw new Error("invalid file header size");
  }
  this.fileHeaderList = filelist;
  this.filenameToIndex = filetable;
};
Zlib.Unzip.prototype.getFileData = function(index2, opt_params) {
  opt_params = opt_params || {};
  var input = this.input;
  var fileHeaderList = this.fileHeaderList;
  var localFileHeader;
  var offset2;
  var length;
  var buffer;
  var crc322;
  var key;
  var i;
  var il;
  if (!fileHeaderList) {
    this.parseFileHeader();
  }
  if (fileHeaderList[index2] === void 0) {
    throw new Error("wrong index");
  }
  offset2 = fileHeaderList[index2].relativeOffset;
  localFileHeader = new Zlib.Unzip.LocalFileHeader(this.input, offset2);
  localFileHeader.parse();
  offset2 += localFileHeader.length;
  length = localFileHeader.compressedSize;
  if ((localFileHeader.flags & Zlib.Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {
    if (!(opt_params["password"] || this.password)) {
      throw new Error("please set password");
    }
    key = this.createDecryptionKey(opt_params["password"] || this.password);
    for (i = offset2, il = offset2 + 12; i < il; ++i) {
      this.decode(key, input[i]);
    }
    offset2 += 12;
    length -= 12;
    for (i = offset2, il = offset2 + length; i < il; ++i) {
      input[i] = this.decode(key, input[i]);
    }
  }
  switch (localFileHeader.compression) {
    case Zlib.Unzip.CompressionMethod.STORE:
      buffer = this.input.subarray(offset2, offset2 + length);
      break;
    case Zlib.Unzip.CompressionMethod.DEFLATE:
      buffer = new Zlib.RawInflate(this.input, {
        "index": offset2,
        "bufferSize": localFileHeader.plainSize
      }).decompress();
      break;
    default:
      throw new Error("unknown compression type");
  }
  if (this.verify) {
    crc322 = Zlib.CRC32.calc(buffer);
    if (localFileHeader.crc32 !== crc322) {
      throw new Error(
        "wrong crc: file=0x" + localFileHeader.crc32.toString(16) + ", data=0x" + crc322.toString(16)
      );
    }
  }
  return buffer;
};
Zlib.Unzip.prototype.getFilenames = function() {
  var filenameList = [];
  var i;
  var il;
  var fileHeaderList;
  if (!this.fileHeaderList) {
    this.parseFileHeader();
  }
  fileHeaderList = this.fileHeaderList;
  for (i = 0, il = fileHeaderList.length; i < il; ++i) {
    filenameList[i] = fileHeaderList[i].filename;
  }
  return filenameList;
};
Zlib.Unzip.prototype.decompress = function(filename, opt_params) {
  var index2;
  if (!this.filenameToIndex) {
    this.parseFileHeader();
  }
  index2 = this.filenameToIndex[filename];
  if (index2 === void 0) {
    throw new Error(filename + " not found");
  }
  return this.getFileData(index2, opt_params);
};
Zlib.Unzip.prototype.setPassword = function(password) {
  this.password = password;
};
Zlib.Unzip.prototype.decode = function(key, n) {
  n ^= this.getByte(
    /** @type {(Array.<number>|Uint32Array)} */
    key
  );
  this.updateKeys(
    /** @type {(Array.<number>|Uint32Array)} */
    key,
    n
  );
  return n;
};
Zlib.Unzip.prototype.updateKeys = Zlib.Zip.prototype.updateKeys;
Zlib.Unzip.prototype.createDecryptionKey = Zlib.Zip.prototype.createEncryptionKey;
Zlib.Unzip.prototype.getByte = Zlib.Zip.prototype.getByte;
Zlib.Util.stringToByteArray = function(str) {
  var tmp = str.split("");
  var i;
  var il;
  for (i = 0, il = tmp.length; i < il; i++) {
    tmp[i] = (tmp[i].charCodeAt(0) & 255) >>> 0;
  }
  return tmp;
};
Zlib.Adler32 = function(array) {
  if (typeof array === "string") {
    array = Zlib.Util.stringToByteArray(array);
  }
  return Zlib.Adler32.update(1, array);
};
Zlib.Adler32.update = function(adler, array) {
  var s1 = adler & 65535;
  var s2 = adler >>> 16 & 65535;
  var len2 = array.length;
  var tlen;
  var i = 0;
  while (len2 > 0) {
    tlen = len2 > Zlib.Adler32.OptimizationParameter ? Zlib.Adler32.OptimizationParameter : len2;
    len2 -= tlen;
    do {
      s1 += array[i++];
      s2 += s1;
    } while (--tlen);
    s1 %= 65521;
    s2 %= 65521;
  }
  return (s2 << 16 | s1) >>> 0;
};
Zlib.Adler32.OptimizationParameter = 1024;
Zlib.BitStream = function(buffer, bufferPosition) {
  this.index = typeof bufferPosition === "number" ? bufferPosition : 0;
  this.bitindex = 0;
  this.buffer = buffer instanceof Uint8Array ? buffer : new Uint8Array(Zlib.BitStream.DefaultBlockSize);
  if (this.buffer.length * 2 <= this.index) {
    throw new Error("invalid index");
  } else if (this.buffer.length <= this.index) {
    this.expandBuffer();
  }
};
Zlib.BitStream.DefaultBlockSize = 32768;
Zlib.BitStream.prototype.expandBuffer = function() {
  var oldbuf = this.buffer;
  var il = oldbuf.length;
  var buffer = new Uint8Array(il << 1);
  {
    buffer.set(oldbuf);
  }
  return this.buffer = buffer;
};
Zlib.BitStream.prototype.writeBits = function(number, n, reverse) {
  var buffer = this.buffer;
  var index2 = this.index;
  var bitindex = this.bitindex;
  var current = buffer[index2];
  var i;
  function rev32_(n2) {
    return Zlib.BitStream.ReverseTable[n2 & 255] << 24 | Zlib.BitStream.ReverseTable[n2 >>> 8 & 255] << 16 | Zlib.BitStream.ReverseTable[n2 >>> 16 & 255] << 8 | Zlib.BitStream.ReverseTable[n2 >>> 24 & 255];
  }
  if (reverse && n > 1) {
    number = n > 8 ? rev32_(number) >> 32 - n : Zlib.BitStream.ReverseTable[number] >> 8 - n;
  }
  if (n + bitindex < 8) {
    current = current << n | number;
    bitindex += n;
  } else {
    for (i = 0; i < n; ++i) {
      current = current << 1 | number >> n - i - 1 & 1;
      if (++bitindex === 8) {
        bitindex = 0;
        buffer[index2++] = Zlib.BitStream.ReverseTable[current];
        current = 0;
        if (index2 === buffer.length) {
          buffer = this.expandBuffer();
        }
      }
    }
  }
  buffer[index2] = current;
  this.buffer = buffer;
  this.bitindex = bitindex;
  this.index = index2;
};
Zlib.BitStream.prototype.finish = function() {
  var buffer = this.buffer;
  var index2 = this.index;
  var output;
  if (this.bitindex > 0) {
    buffer[index2] <<= 8 - this.bitindex;
    buffer[index2] = Zlib.BitStream.ReverseTable[buffer[index2]];
    index2++;
  }
  {
    output = buffer.subarray(0, index2);
  }
  return output;
};
Zlib.BitStream.ReverseTable = /* @__PURE__ */ (function(table) {
  return table;
})((function() {
  var table = new Uint8Array(256);
  var i;
  for (i = 0; i < 256; ++i) {
    table[i] = (function(n) {
      var r = n;
      var s = 7;
      for (n >>>= 1; n; n >>>= 1) {
        r <<= 1;
        r |= n & 1;
        --s;
      }
      return (r << s & 255) >>> 0;
    })(i);
  }
  return table;
})());
Zlib.CRC32.calc = function(data, pos, length) {
  return Zlib.CRC32.update(data, 0, pos, length);
};
Zlib.CRC32.update = function(data, crc, pos, length) {
  var table = Zlib.CRC32.Table;
  var i = typeof pos === "number" ? pos : pos = 0;
  var il = typeof length === "number" ? length : data.length;
  crc ^= 4294967295;
  for (i = il & 7; i--; ++pos) {
    crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 255];
  }
  for (i = il >> 3; i--; pos += 8) {
    crc = crc >>> 8 ^ table[(crc ^ data[pos]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 1]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 2]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 3]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 4]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 5]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 6]) & 255];
    crc = crc >>> 8 ^ table[(crc ^ data[pos + 7]) & 255];
  }
  return (crc ^ 4294967295) >>> 0;
};
Zlib.CRC32.single = function(num, crc) {
  return (Zlib.CRC32.Table[(num ^ crc) & 255] ^ num >>> 8) >>> 0;
};
Zlib.CRC32.Table_ = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
Zlib.CRC32.Table = new Uint32Array(Zlib.CRC32.Table_);
Zlib.Deflate = function(input, opt_params) {
  this.input = input;
  this.output = new Uint8Array(Zlib.Deflate.DefaultBufferSize);
  this.compressionType = Zlib.Deflate.CompressionType.DYNAMIC;
  this.rawDeflate;
  var rawDeflateOption = {};
  var prop;
  if (opt_params || !(opt_params = {})) {
    if (typeof opt_params["compressionType"] === "number") {
      this.compressionType = opt_params["compressionType"];
    }
  }
  for (prop in opt_params) {
    rawDeflateOption[prop] = opt_params[prop];
  }
  rawDeflateOption["outputBuffer"] = this.output;
  this.rawDeflate = new Zlib.RawDeflate(this.input, rawDeflateOption);
};
Zlib.Deflate.DefaultBufferSize = 32768;
Zlib.Deflate.CompressionType = Zlib.RawDeflate.CompressionType;
Zlib.Deflate.compress = function(input, opt_params) {
  return new Zlib.Deflate(input, opt_params).compress();
};
Zlib.Deflate.prototype.compress = function() {
  var cm;
  var cinfo;
  var cmf;
  var flg;
  var fcheck;
  var fdict;
  var flevel;
  var adler;
  var output;
  var pos = 0;
  output = this.output;
  cm = Zlib.CompressionMethod.DEFLATE;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      cinfo = Math.LOG2E * Math.log(Zlib.RawDeflate.WindowSize) - 8;
      break;
    default:
      throw new Error("invalid compression method");
  }
  cmf = cinfo << 4 | cm;
  output[pos++] = cmf;
  fdict = 0;
  switch (cm) {
    case Zlib.CompressionMethod.DEFLATE:
      switch (this.compressionType) {
        case Zlib.Deflate.CompressionType.NONE:
          flevel = 0;
          break;
        case Zlib.Deflate.CompressionType.FIXED:
          flevel = 1;
          break;
        case Zlib.Deflate.CompressionType.DYNAMIC:
          flevel = 2;
          break;
        default:
          throw new Error("unsupported compression type");
      }
      break;
    default:
      throw new Error("invalid compression method");
  }
  flg = flevel << 6 | fdict << 5;
  fcheck = 31 - (cmf * 256 + flg) % 31;
  flg |= fcheck;
  output[pos++] = flg;
  adler = Zlib.Adler32(this.input);
  this.rawDeflate.op = pos;
  output = this.rawDeflate.compress();
  pos = output.length;
  {
    output = new Uint8Array(output.buffer);
    if (output.length <= pos + 4) {
      this.output = new Uint8Array(output.length + 4);
      this.output.set(output);
      output = this.output;
    }
    output = output.subarray(0, pos + 4);
  }
  output[pos++] = adler >> 24 & 255;
  output[pos++] = adler >> 16 & 255;
  output[pos++] = adler >> 8 & 255;
  output[pos++] = adler & 255;
  return output;
};
class BrowserLocalFile {
  constructor(blob) {
    this.file = blob;
  }
  async read(position, length) {
    const file = this.file;
    if (position !== void 0) {
      return file.slice(position, position + length).arrayBuffer();
    } else {
      return file.arrayBuffer();
    }
  }
}
typeof process !== "undefined" && process.versions != null && process.versions.node != null;
class RemoteFile2 {
  constructor(args) {
    this.config = args;
    this.url = mapUrl(args.path || args.url);
  }
  async read(position, length) {
    length = Math.ceil(length);
    const headers = this.config.headers || {};
    const rangeString = "bytes=" + position + "-" + (position + length - 1);
    headers["Range"] = rangeString;
    let url = this.url.slice();
    if (this.config.oauthToken) {
      const token = resolveToken(this.config.oauthToken);
      headers["Authorization"] = `Bearer ${token}`;
    }
    if (this.config.apiKey) {
      url = addParameter(url, "key", this.config.apiKey);
    }
    const response = await fetch(url, {
      method: "GET",
      headers,
      redirect: "follow",
      mode: "cors"
    });
    const status = response.status;
    if (status >= 400) {
      console.error(`${status}  ${this.config.url}`);
      const err2 = Error(response.statusText);
      err2.code = status;
      throw err2;
    } else {
      return response.arrayBuffer();
    }
    async function resolveToken(token) {
      if (typeof token === "function") {
        return await Promise.resolve(token());
      } else {
        return token;
      }
    }
  }
}
function mapUrl(url) {
  if (url.includes("//www.dropbox.com")) {
    return url.replace("//www.dropbox.com", "//dl.dropboxusercontent.com");
  } else if (url.startsWith("ftp://ftp.ncbi.nlm.nih.gov")) {
    return url.replace("ftp://", "https://");
  } else {
    return url;
  }
}
function addParameter(url, name2, value) {
  const paramSeparator = url.includes("?") ? "&" : "?";
  return url + paramSeparator + name2 + "=" + value;
}
class ThrottledFile {
  constructor(file, rateLimiter) {
    this.file = file;
    this.rateLimiter = rateLimiter;
  }
  async read(position, length) {
    const file = this.file;
    const rateLimiter = this.rateLimiter;
    return new Promise(function(fulfill, reject) {
      rateLimiter.limiter(async function(f) {
        try {
          const result = await f.read(position, length);
          fulfill(result);
        } catch (e) {
          reject(e);
        }
      })(file);
    });
  }
}
class RateLimiter {
  constructor(wait) {
    this.wait = wait === void 0 ? 100 : wait;
    this.isCalled = false;
    this.calls = [];
  }
  limiter(fn2) {
    const self2 = this;
    let caller = function() {
      if (self2.calls.length && !self2.isCalled) {
        self2.isCalled = true;
        self2.calls.shift().call();
        setTimeout(function() {
          self2.isCalled = false;
          caller();
        }, self2.wait);
      }
    };
    return function() {
      self2.calls.push(fn2.bind(this, ...arguments));
      caller();
    };
  }
}
class BufferedFile2 {
  constructor(args) {
    this.file = args.file;
    this.size = args.size || 64e3;
    this.position = 0;
    this.bufferStart = 0;
    this.bufferLength = 0;
    this.buffer = void 0;
  }
  async read(position, length) {
    const start = position;
    const end = position + length;
    const bufferStart = this.bufferStart;
    const bufferEnd = this.bufferStart + this.bufferLength;
    if (length > this.size) {
      this.buffer = void 0;
      this.bufferStart = 0;
      this.bufferLength = 0;
      return this.file.read(position, length);
    }
    if (start >= bufferStart && end <= bufferEnd) {
      const sliceStart = start - bufferStart;
      const sliceEnd = sliceStart + length;
      return this.buffer.slice(sliceStart, sliceEnd);
    } else if (start < bufferStart && end > bufferStart) {
      const l1 = bufferStart - start;
      const a1 = await this.file.read(position, l1);
      const l2 = length - l1;
      if (l2 > 0) {
        const a2 = this.buffer.slice(0, l2);
        return concatBuffers(a1, a2);
      } else {
        return a1;
      }
    } else if (start < bufferEnd && end > bufferEnd) {
      const l1 = bufferEnd - start;
      const sliceStart = this.bufferLength - l1;
      const a1 = this.buffer.slice(sliceStart, this.bufferLength);
      const l2 = length - l1;
      if (l2 > 0) {
        try {
          this.buffer = await this.file.read(bufferEnd, this.size);
          this.bufferStart = bufferEnd;
          this.bufferLength = this.buffer.byteLength;
          const a2 = this.buffer.slice(0, l2);
          return concatBuffers(a1, a2);
        } catch (e) {
          if (e.code && e.code === 416) {
            return a1;
          } else {
            throw e;
          }
        }
      } else {
        return a1;
      }
    } else {
      this.buffer = await this.file.read(position, this.size);
      this.bufferStart = position;
      this.bufferLength = this.buffer.byteLength;
      return this.buffer.slice(0, length);
    }
  }
}
var concatBuffers = function(buffer1, buffer2) {
  var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};
const BinaryParser2 = function(dataView, littleEndian) {
  this.littleEndian = littleEndian !== void 0 ? littleEndian : true;
  this.position = 0;
  this.view = dataView;
  this.length = dataView.byteLength;
};
BinaryParser2.prototype.available = function() {
  return this.length - this.position;
};
BinaryParser2.prototype.remLength = function() {
  return this.length - this.position;
};
BinaryParser2.prototype.hasNext = function() {
  return this.position < this.length - 1;
};
BinaryParser2.prototype.getByte = function() {
  var retValue = this.view.getUint8(this.position, this.littleEndian);
  this.position++;
  return retValue;
};
BinaryParser2.prototype.getShort = function() {
  var retValue = this.view.getInt16(this.position, this.littleEndian);
  this.position += 2;
  return retValue;
};
BinaryParser2.prototype.getUShort = function() {
  var retValue = this.view.getUint16(this.position, this.littleEndian);
  this.position += 2;
  return retValue;
};
BinaryParser2.prototype.getInt = function() {
  var retValue = this.view.getInt32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;
};
BinaryParser2.prototype.getUInt = function() {
  var retValue = this.view.getUint32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;
};
BinaryParser2.prototype.getLong = function() {
  var b = [];
  b[0] = this.view.getUint8(this.position);
  b[1] = this.view.getUint8(this.position + 1);
  b[2] = this.view.getUint8(this.position + 2);
  b[3] = this.view.getUint8(this.position + 3);
  b[4] = this.view.getUint8(this.position + 4);
  b[5] = this.view.getUint8(this.position + 5);
  b[6] = this.view.getUint8(this.position + 6);
  b[7] = this.view.getUint8(this.position + 7);
  var value = 0;
  if (this.littleEndian) {
    for (var i = b.length - 1; i >= 0; i--) {
      value = value * 256 + b[i];
    }
  } else {
    for (var i = 0; i < b.length; i++) {
      value = value * 256 + b[i];
    }
  }
  this.position += 8;
  return value;
};
BinaryParser2.prototype.getString = function(len2) {
  var s = "";
  var c;
  while ((c = this.view.getUint8(this.position++)) != 0) {
    s += String.fromCharCode(c);
    if (len2 && s.length == len2) break;
  }
  return s;
};
BinaryParser2.prototype.getFixedLengthString = function(len2) {
  var s = "";
  var i;
  var c;
  for (i = 0; i < len2; i++) {
    c = this.view.getUint8(this.position++);
    if (c > 0) {
      s += String.fromCharCode(c);
    }
  }
  return s;
};
BinaryParser2.prototype.getFixedLengthTrimmedString = function(len2) {
  var s = "";
  var i;
  var c;
  for (i = 0; i < len2; i++) {
    c = this.view.getUint8(this.position++);
    if (c > 32) {
      s += String.fromCharCode(c);
    }
  }
  return s;
};
BinaryParser2.prototype.getFloat = function() {
  var retValue = this.view.getFloat32(this.position, this.littleEndian);
  this.position += 4;
  return retValue;
};
BinaryParser2.prototype.getDouble = function() {
  var retValue = this.view.getFloat64(this.position, this.littleEndian);
  this.position += 8;
  return retValue;
};
BinaryParser2.prototype.skip = function(n) {
  this.position += n;
  return this.position;
};
BinaryParser2.prototype.getVPointer = function() {
  var position = this.position, offset2 = this.view.getUint8(position + 1) << 8 | this.view.getUint8(position), byte6 = (this.view.getUint8(position + 6) & 255) * 4294967296, byte5 = (this.view.getUint8(position + 5) & 255) * 16777216, byte4 = (this.view.getUint8(position + 4) & 255) * 65536, byte3 = (this.view.getUint8(position + 3) & 255) * 256, byte2 = this.view.getUint8(position + 2) & 255, block = byte6 + byte5 + byte4 + byte3 + byte2;
  this.position += 8;
  return new VPointer2(block, offset2);
};
function VPointer2(block, offset2) {
  this.block = block;
  this.offset = offset2;
}
VPointer2.prototype.isLessThan = function(vp) {
  return this.block < vp.block || this.block === vp.block && this.offset < vp.offset;
};
VPointer2.prototype.isGreaterThan = function(vp) {
  return this.block > vp.block || this.block === vp.block && this.offset > vp.offset;
};
VPointer2.prototype.print = function() {
  return "" + this.block + ":" + this.offset;
};
class MatrixZoomData {
  constructor(chr1, chr2) {
    this.chr1 = chr1;
    this.chr2 = chr2;
  }
  getKey() {
    return this.chr1.name + "_" + this.chr2.name + "_" + this.zoom.unit + "_" + this.zoom.binSize;
  }
  getBlockNumbers(region1, region2, version2) {
    if (region1.chr == this.chr2 && region2.chr === this.chr1) {
      const tmp = region1;
      region1 = region2;
      region2 = tmp;
    }
    const sameChr = this.chr1 === this.chr2;
    const binsize = this.zoom.binSize;
    const blockBinCount = this.blockBinCount;
    const blockColumnCount = this.blockColumnCount;
    return version2 < 9 || !sameChr ? getBlockNumbersV8() : getBlockNumbersV9();
    function getBlockNumbersV8() {
      const x1 = region1.start / binsize;
      const x2 = region1.end / binsize;
      const y1 = region2.start / binsize;
      const y2 = region2.end / binsize;
      const col1 = Math.floor(x1 / blockBinCount);
      const col2 = Math.floor((x2 - 1) / blockBinCount);
      const row1 = Math.floor(y1 / blockBinCount);
      const row2 = Math.floor((y2 - 1) / blockBinCount);
      const blockNumbers = [];
      for (let row = row1; row <= row2; row++) {
        for (let column = col1; column <= col2; column++) {
          let blockNumber;
          if (sameChr && row < column) {
            blockNumber = column * blockColumnCount + row;
          } else {
            blockNumber = row * blockColumnCount + column;
          }
          if (!blockNumbers.includes(blockNumber)) {
            blockNumbers.push(blockNumber);
          }
        }
      }
      return blockNumbers;
    }
    function getBlockNumbersV9() {
      const binX1 = region1.start / binsize;
      const binX2 = region1.end / binsize;
      const binY1 = region2.start / binsize;
      const binY2 = region2.end / binsize;
      const translatedLowerPAD = Math.floor((binX1 + binY1) / 2 / blockBinCount);
      const translatedHigherPAD = Math.floor((binX2 + binY2) / 2 / blockBinCount);
      const translatedNearerDepth = Math.floor(Math.log2(1 + Math.abs(binX1 - binY2) / Math.sqrt(2) / blockBinCount));
      const translatedFurtherDepth = Math.floor(Math.log2(1 + Math.abs(binX2 - binY1) / Math.sqrt(2) / blockBinCount));
      const containsDiagonal = (binX2 - binY1) * (binX1 - binY2) < 0;
      const nearerDepth = containsDiagonal ? 0 : Math.min(translatedNearerDepth, translatedFurtherDepth);
      const furtherDepth = Math.max(translatedNearerDepth, translatedFurtherDepth);
      const blockNumbers = [];
      for (let depth = nearerDepth; depth <= furtherDepth; depth++) {
        for (let pad = translatedLowerPAD; pad <= translatedHigherPAD; pad++) {
          const block_number = depth * blockColumnCount + pad;
          blockNumbers.push(block_number);
        }
      }
      return blockNumbers;
    }
  }
  static parseMatrixZoomData(chr1, chr2, dis) {
    const zd = new MatrixZoomData(chr1, chr2);
    const unit = dis.getString();
    const zoomIndex = dis.getInt();
    const sumCounts = dis.getFloat();
    const occupiedCellCount = dis.getFloat();
    const stdDev = dis.getFloat();
    const percent95 = dis.getFloat();
    const binSize = dis.getInt();
    zd.blockBinCount = dis.getInt();
    zd.blockColumnCount = dis.getInt();
    const nBlocks = dis.getInt();
    zd.zoom = { index: zoomIndex, unit, binSize };
    zd.blockIndex = new StaticBlockIndex(nBlocks, dis);
    const nBins1 = chr1.size / binSize;
    const nBins2 = chr2.size / binSize;
    const avgCount = sumCounts / nBins1 / nBins2;
    zd.averageCount = avgCount;
    zd.sumCounts = sumCounts;
    zd.stdDev = stdDev;
    zd.occupiedCellCount = occupiedCellCount;
    zd.percent95 = percent95;
    return zd;
  }
}
class StaticBlockIndex {
  constructor(nBlocks, dis) {
    this.blockIndex = {};
    while (nBlocks-- > 0) {
      const blockNumber = dis.getInt();
      const filePosition = dis.getLong();
      const size = dis.getInt();
      this.blockIndex[blockNumber] = { filePosition, size };
    }
  }
  getBlockIndexEntry(blockNumber) {
    return this.blockIndex[blockNumber];
  }
}
class Matrix {
  constructor(chr1, chr2, zoomDataList) {
    this.chr1 = chr1;
    this.chr2 = chr2;
    this.bpZoomData = [];
    this.fragZoomData = [];
    for (let zd of zoomDataList) {
      if (zd.zoom.unit === "BP") {
        this.bpZoomData.push(zd);
      } else {
        this.fragZoomData.push(zd);
      }
    }
  }
  /**
   * Find the best zoom level for the given bin size
   * @param binSize
   * @param unit
   * @returns {number}
   */
  findZoomForResolution(binSize, unit) {
    const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;
    for (let i = 1; i < zdArray.length; i++) {
      var zd = zdArray[i];
      if (zd.zoom.binSize < binSize) {
        return i - 1;
      }
    }
    return zdArray.length - 1;
  }
  /**
   * Fetch zoom data by bin size.  If no matching level exists return undefined.
   *
   * @param unit
   * @param binSize
   * @param zoom
   * @returns {undefined|*}
   */
  getZoomData(binSize, unit) {
    unit = unit || "BP";
    const zdArray = unit === "BP" ? this.bpZoomData : this.fragZoomData;
    for (let i = 0; i < zdArray.length; i++) {
      var zd = zdArray[i];
      if (binSize === zd.zoom.binSize) {
        return zd;
      }
    }
    return void 0;
  }
  /**
   * Return zoom data by resolution index.
   * @param index
   * @param unit
   * @returns {*}
   */
  getZoomDataByIndex(index2, unit) {
    const zdArray = "FRAG" === unit ? this.fragZoomData : this.bpZoomData;
    return zdArray[index2];
  }
  static getKey(chrIdx1, chrIdx2) {
    if (chrIdx1 > chrIdx2) {
      const tmp = chrIdx1;
      chrIdx1 = chrIdx2;
      chrIdx2 = tmp;
    }
    return `${chrIdx1}_${chrIdx2}`;
  }
  static parseMatrix(data, chromosomes) {
    const dis = new BinaryParser2(new DataView(data));
    const c1 = dis.getInt();
    const c2 = dis.getInt();
    const chr1 = chromosomes[c1];
    const chr2 = chromosomes[c2];
    let nResolutions = dis.getInt();
    const zdList = [];
    while (nResolutions-- > 0) {
      const zd = MatrixZoomData.parseMatrixZoomData(chr1, chr2, dis);
      zdList.push(zd);
    }
    return new Matrix(c1, c2, zdList);
  }
}
class ContactRecord {
  constructor(bin1, bin2, counts) {
    this.bin1 = bin1;
    this.bin2 = bin2;
    this.counts = counts;
  }
  getKey() {
    return "" + this.bin1 + "_" + this.bin2;
  }
}
class LRU {
  constructor(max = 10) {
    this.max = max;
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    let item = this.map.get(key);
    if (item) {
      this.map.delete(key);
      this.map.set(key, item);
    }
    return item;
  }
  set(key, val) {
    if (this.map.has(key)) this.map.delete(key);
    else if (this.map.size === this.max) {
      this.map.delete(this.first());
    }
    this.map.set(key, val);
  }
  has(key) {
    return this.map.has(key);
  }
  clear() {
    this.map.clear();
  }
  first() {
    return this.map.keys().next().value;
  }
}
const DOUBLE$1 = 8;
class NormalizationVector {
  constructor(file, filePosition, nValues, dataType) {
    this.file = file;
    this.filePosition = filePosition;
    this.nValues = nValues;
    this.dataType = dataType;
    this.cache = void 0;
  }
  async getValues(start, end) {
    if (!this.cache || start < this.cache.start || end > this.cache.end) {
      const adjustedStart = Math.max(0, start - 1e3);
      const adjustedEnd = Math.min(this.nValues, end + 1e3);
      const startPosition = this.filePosition + adjustedStart * this.dataType;
      const n = adjustedEnd - adjustedStart;
      const sizeInBytes = n * this.dataType;
      const data = await this.file.read(startPosition, sizeInBytes);
      if (!data) {
        return void 0;
      }
      const parser = new BinaryParser2(new DataView(data));
      const values = [];
      for (let i = 0; i < n; i++) {
        values[i] = this.dataType === DOUBLE$1 ? parser.getDouble() : parser.getFloat();
      }
      this.cache = {
        start: adjustedStart,
        end: adjustedEnd,
        values
      };
    }
    const sliceStart = start - this.cache.start;
    const sliceEnd = sliceStart + (end - start);
    return this.cache.values.slice(sliceStart, sliceEnd);
  }
  getKey() {
    return NormalizationVector.getKey(this.type, this.chrIdx, this.unit, this.resolution);
  }
  static getNormalizationVectorKey(type, chrIdx, unit, resolution) {
    return type + "_" + chrIdx + "_" + unit + "_" + resolution;
  }
}
const nvi$1 = {
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined.hic": "54386046426,55860",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fprimary.hic": "33860030033,37504",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Freplicate.hic": "30849652794,55832",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fmaternal.hic": "1380542661,17185",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fpaternal.hic": "1389001777,17185",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2Fcombined.hic": "13433880319,35723",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC001.hic": "3409347253,35975",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC002.hic": "4529947083,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC003.hic": "6894962500,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC004.hic": "3395593338,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC005.hic": "5204128636,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC006.hic": "3278363811,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC007.hic": "3585547340,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC008.hic": "4134197273,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC009.hic": "2851728310,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC010.hic": "1754216102,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC011.hic": "1716829574,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC012.hic": "4367980375,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC013.hic": "2309654671,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC014.hic": "5324950266,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC015.hic": "3132333594,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC016.hic": "3159154704,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC017.hic": "3262554627,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC018.hic": "3014216364,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC019.hic": "5025753246,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC020.hic": "5861584507,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC021.hic": "3542263275,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC022.hic": "5061949378,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC023.hic": "4816423919,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC024.hic": "2683781104,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC025.hic": "6522701781,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC026.hic": "6748846520,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC027.hic": "5642693007,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC028.hic": "2098921691,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC029.hic": "3886454027,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fagar%2FHIC030.hic": "2288984204,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fagar%2FHIC031.hic": "2115342419,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fpellet%2FHIC032.hic": "2063314324,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fsupernatant%2FHIC033.hic": "1933908457,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC034.hic": "13555514595,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC035.hic": "6129650900,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC036.hic": "4307445019,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC037.hic": "9375139867,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2Fcombined.hic": "11664249584,33929",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined_DpnII.hic": "7003537290,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC038.hic": "2099825544,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC039.hic": "2096900138,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC040.hic": "2593642141,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC041.hic": "2263919098,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC042.hic": "2684774693,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined_noXlink.hic": "5574807456,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC043.hic": "2986114347,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC044.hic": "1916378621,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC045.hic": "746463126,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC046.hic": "2338476164,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC047.hic": "1167496250,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC048.hic": "2231690794,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC049.hic": "2782308678,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC050.hic": "3633531346,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC051.hic": "4063486444,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC052.hic": "929756278,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC053.hic": "2489657204,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC054.hic": "4036419444,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC055.hic": "4284185549,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC056.hic": "4410546240,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fdilution%2FHIC057.hic": "1491998259,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2Fcombined.hic": "7266425111,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC058.hic": "6532635593,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC059.hic": "400684530,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC060.hic": "645352187,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC061.hic": "736291871,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC062.hic": "762731037,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC063.hic": "682917431,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fdilution%2FHIC064.hic": "4550171307,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2Fcombined.hic": "11897184911,35789",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC065.hic": "5425943567,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC066.hic": "5942869818,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC067.hic": "5191049261,35647",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fdilution%2FHIC068.hic": "2713318801,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2Fcombined.hic": "12641555389,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC069.hic": "5630177461,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC070.hic": "5926611269,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC071.hic": "2486191351,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC072.hic": "2281343366,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC073.hic": "2173074239,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC074.hic": "2463700999,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2Fcombined.hic": "14661922519,35639",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC075.hic": "3685310515,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC076.hic": "5833658487,35891",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC077.hic": "2406346486,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC078.hic": "5241454987,35919",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC079.hic": "6297234263,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2Fcombined.hic": "9193858096,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC080.hic": "5171405536,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC081.hic": "3489767688,35891",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC082.hic": "4243339375,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fdilution%2FHIC083.hic": "1497495406,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2Fcombined.hic": "7923332224,35593",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC084.hic": "867699123,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC085.hic": "3669518514,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC086.hic": "5306474712,35595",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC087.hic": "1490963755,36397",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2Fcombined.hic": "8956382853,50248",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC088.hic": "1874185366,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC089.hic": "1301165236,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC090.hic": "1105246282,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC091.hic": "1338325770,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC092.hic": "1307918730,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC093.hic": "755136918,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC094.hic": "1606583694,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC095.hic": "2039711245,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC096.hic": "1909573053,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC097.hic": "1826710712,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC098.hic": "1998793575,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC099.hic": "1007740962,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC100.hic": "736464120,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC101.hic": "980505082,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC102.hic": "1116083646,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fdilution%2FHIC103.hic": "1096994310,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fdilution%2FHIC104.hic": "841063882,32102",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC105.hic": "107742864,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC106.hic": "134295912,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC107.hic": "110228014,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC108.hic": "102761401,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC109.hic": "100461491,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC110.hic": "88828472,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC111.hic": "81471064,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC112.hic": "92297035,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC113.hic": "65503916,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC114.hic": "49181188,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC115.hic": "46471102,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC116.hic": "64284432,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC117.hic": "60434076,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC118.hic": "45248563,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC119.hic": "60288782,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC120.hic": "136888414,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC121.hic": "125009003,33681",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC122.hic": "154011688,34127",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC123.hic": "177663372,35293",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC124.hic": "382186226,35245",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC125.hic": "158160717,35271",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC127.hic": "110261177,34659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC128.hic": "246131875,35509",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC129.hic": "260160119,35667",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC130.hic": "117479562,34681",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC131.hic": "81508929,34673",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC132.hic": "105959102,34895",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC133.hic": "91504812,33451",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC134.hic": "52222546,33737",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC135.hic": "57763085,34159",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC136.hic": "50618489,33731",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC137.hic": "193163606,33363",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC138.hic": "229876152,33777",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC139.hic": "201783666,33571",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC140.hic": "281163862,34125",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC141.hic": "275969727,33935",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC142.hic": "275020431,34125",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC144.hic": "223834810,34177",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC145.hic": "296632653,33937",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC146.hic": "290945216,33961",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC147.hic": "234459964,34231",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC148.hic": "295457850,34039",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC149.hic": "113569632,35695",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC150.hic": "304381897,33963",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC151.hic": "289314545,33805",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC152.hic": "284320182,33803",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC153.hic": "401393947,34659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC154.hic": "188065488,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC155.hic": "299157119,33967",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC156.hic": "279289244,33787",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC157.hic": "254852119,33917",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC158.hic": "195969660,33477",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC159.hic": "185720388,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC160.hic": "227709279,33599",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC161.hic": "157225076,33209",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC162.hic": "105703444,32033",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC163.hic": "122665658,32121",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC164.hic": "228048231,33761",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC165.hic": "114440819,32011",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC166.hic": "285147558,33891",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC167.hic": "363116754,33943",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC168.hic": "119592158,31937",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC169.hic": "236853872,33785",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC170.hic": "195187639,33395",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC171.hic": "208044058,33309",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC172.hic": "144645916,32877",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC173.hic": "119115941,32203",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC175.hic": "178030481,33525",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC176.hic": "117220136,32169",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC177.hic": "128586196,32659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC178.hic": "191419141,33629",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC179.hic": "141556748,32959",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC180.hic": "199825102,33185",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC181.hic": "301022688,33783",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC182.hic": "185384453,33205",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC183.hic": "202189264,36367",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC184.hic": "37464475,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC185.hic": "161938278,36099",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC186.hic": "133853166,36179",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC188.hic": "128068030,36237",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC189.hic": "148053886,36177",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC190.hic": "198946958,35803",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC191.hic": "226584564,36063",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC192.hic": "194412797,36341",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC193.hic": "176408194,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC194.hic": "207215649,36055",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC195.hic": "175185530,36315",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC196.hic": "168969337,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC197.hic": "121231252,36339",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC198.hic": "92713752,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC199.hic": "105130500,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC200.hic": "114526350,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC201.hic": "122689717,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhap1%2Fin-situ%2Fcombined.hic": "9614983328,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fctbp_8_4_17%2Fall_intra_megabase_michrom.hic": "154205644,10960",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2Fdel-Xa-combined.hic": "8843305329,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FdelXa-chrX-diploid.hic": "11173520,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FWT-combined.hic": "13365182403,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FWT-chrX-diploid.hic": "17343459,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC002.hic": "4279298739,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC003.hic": "3027365532,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC004.hic": "2896130835,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC005.hic": "4717830071,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC006.hic": "5066210154,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC007.hic": "3069516128,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2Fdel-Xi-combined.hic": "14551096423,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FdelXi-chrX-diploid.hic": "17362477,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC008.hic": "2572386655,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC009.hic": "2935931663,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC010.hic": "2019085070,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC011.hic": "6087610814,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC012.hic": "2809618194,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC013.hic": "2572386655,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fcombined.hic": "6950423609,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fpaternal.hic": "220592749,15691",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fmaternal.hic": "323233095,15691",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC014.hic": "3183235800,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC015.hic": "1739539801,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC016.hic": "1105912758,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC017.hic": "1060773319,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC018.hic": "1203679874,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC019.hic": "3321955269,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frhesus%2FDarrowHuntley-2015%2FHIC020.hic": "7108980626,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fcola%2FDarrowHuntley-2015%2FHIC021.hic": "3906448676,34955",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2Faedes%2Fcombined.hic": "390780490,2245",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2Fhs2-hic.hic": "1960284186,33561",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2FCpipJ3.hic": "766279097,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fphanstiel%2Fupdated_O%2FSnyder_O.hic": "8046980555,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fphanstiel%2FA_inter.hic": "10986005145,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2Fcombined.hic": "30439217680,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2Fcombined.hic": "33255540403,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F20min_withdraw_combined.hic": "11078436933,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F40min_withdraw_combined.hic": "11031830038,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F60min_withdraw_combined.hic": "10312725340,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F180min_withdraw_combined.hic": "10038610214,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC001.hic": "8004335785,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC002.hic": "8453215933,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC003.hic": "9118406189,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC004.hic": "5973342894,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC005.hic": "6846576837,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC006.hic": "6075148017,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC007.hic": "8192366992,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC008.hic": "6844159653,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC009.hic": "7282063059,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC010.hic": "10410578833,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC011.hic": "8192366992,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC012.hic": "7223422850,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC013.hic": "7435986997,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC014.hic": "9120113605,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2Fcombined.hic": "4170577904,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC015.hic": "1504084990,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC016.hic": "1686244500,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC017.hic": "1804802410,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC018.hic": "1533942067,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2Fcombined.hic": "4572390198,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC019.hic": "1543609666,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC020.hic": "1814133288,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC021.hic": "1942698243,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC022.hic": "1873587413,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC049.hic": "405127557,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC060.hic": "326681741,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC061.hic": "300908673,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_20min%2FRao-2017-HIC050.hic": "481758242,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_20min%2FRao-2017-HIC051.hic": "417577401,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_40min%2FRao-2017-HIC052.hic": "419353227,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_40min%2FRao-2017-HIC053.hic": "411554953,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_60min%2FRao-2017-HIC054.hic": "386655891,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_60min%2FRao-2017-HIC055.hic": "402170701,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_240min%2FRao-2017-HIC057.hic": "735906308,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC058.hic": "443789827,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC059.hic": "491422615,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC062.hic": "320261375,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC063.hic": "306590499,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_20min%2FRao-2017-HIC032S.hic": "367051742,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_20min%2FRao-2017-HIC033S.hic": "344555339,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_40min%2FRao-2017-HIC036S.hic": "349392947,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_40min%2FRao-2017-HIC037S.hic": "317714554,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_60min%2FRao-2017-HIC040S.hic": "266786397,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_60min%2FRao-2017-HIC041S.hic": "279445530,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_180min%2FRao-2017-HIC044S.hic": "898418269,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_180min%2FRao-2017-HIC045S.hic": "961006347,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_360min%2FRao-2017-HIC064.hic": "833576408,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_360min%2FRao-2017-HIC065.hic": "840881418,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1080min%2FRao-2017-HIC066.hic": "980958864,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1080min%2FRao-2017-HIC067.hic": "882023129,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1440min%2FRao-2017-HIC068.hic": "1110292630,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1440min%2FRao-2017-HIC069.hic": "1001747023,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FCP190_HiChIP.hic": "144107588,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FH3K27ac_HiChIP_combined.hic": "43171370,5233",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FH3K27me3_HiChIP_combined.hic": "42906472,5233",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPol2_ChIAPET.hic": "41992430,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPol2S2_HiChIP.hic": "145842743,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FArabidopsis_Wang2015_Liu2016.hic": "1134391078,4984",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FElegans_Crane2015.hic": "387127568,8758",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FNcrassa_Galazka2016.hic": "26555511,27725",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPfalciparum_trophozoite_Ay2014.hic": "15640893,13948",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Me-A.hic": "6897251,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Me-B.hic": "4959088,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Mp-A.hic": "5232286,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Mp-B.hic": "5105292,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Me-A.hic": "6900072,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Me-B.hic": "8653258,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Mp-A.hic": "7999058,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Mp-B.hic": "8774657,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc.hic": "23671753603,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc_rep1.hic": "23671754721,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc_rep2.hic": "22269909910,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fhffc6_rep1.hic": "19016661622,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_NcoI.hic": "480725203,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2F302NH.hic": "99948617,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FK562.hic": "470263605,36151",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_HindIII.hic": "293706559,36289",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_rep_HindIII.hic": "309673862,36087",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fcanis-lupus-rep1.hic": "1531151371,56905",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fcanis-lupus-rep2.hic": "2851437676,56905",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmouse-rep1.hic": "582052544,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmacaque-rep1.hic": "698509182,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmacaque-rep2.hic": "461410393,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Frabbit-rep1.hic": "691045338,33561",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Frabbit-rep2.hic": "668888336,33561",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsexton%2Fcombined.hic": "50650087,4486",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-hindiii.hic": "1071142023,16500",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-mboi.hic": "1508851093,16448",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Fnon-tcc-hindiii.hic": "395179229,36093",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-combined.hic": "1050423847,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fmm9-hindiii%2Fsplit-read-run.hic": "9599984876,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fhesc-hindiii.hic": "1952555632,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fimr90-hindiii.hic": "9691260435,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fmm9-cortex.hic": "3712072953,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr18.hic": "2083350075,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr2.hic": "3362049644,16360",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr7.hic": "1658399854,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fwt-i-scei-chr15.hic": "866691249,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fwt-i-scei-chr2.hic": "3304782795,16386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-1.hic": "23673506,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-2.hic": "26873280,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-3.hic": "31066362,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-4.hic": "16807724,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-5.hic": "28665065,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-6.hic": "13124158,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-7.hic": "15118945,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-8.hic": "68316814,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-9.hic": "18965101,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-10.hic": "17020666,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Fcombined.hic": "6526601242,36427",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep1.hic": "1861562891,36401",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep2.hic": "3061013635,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep3.hic": "1564588211,35969",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep4.hic": "1255543175,36153",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep5.hic": "974683253,36179",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep6.hic": "1040805629,36053",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Fcombined.hic": "8424080116,36401",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep1.hic": "2697976702,36295",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep3.hic": "1718610467,36159",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep4.hic": "2029519405,36101",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep5.hic": "985310855,36069",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep6.hic": "1418750480,35967",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fmhh-call-4-cell-line.hic": "538380253,35351",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fprimary-b-all.hic": "773764191,35793",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fnormal-b-cell-line.hic": "336271459,35005",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Frl-cell-line.hic": "484807998,35351",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-biorep.hic": "135932435,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-techrep1.hic": "160355961,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-techrep2.hic": "188809887,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fpre-prob-egs.hic": "2237792858,15483",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fprob-egs.hic": "5744720377,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fprob-fa.hic": "2174866215,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fhct116-rnapii-pilot.hic": "396366166,35999",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fhela-rnapii-pilot.hic": "882516759,35107",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fk562-rnapii-pilot.hic": "1131576189,35969",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fk562-rnapii-saturated.hic": "571583828,36291",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fmcf7-rnapii-saturated.hic": "1282547841,36035",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fnb4-rnapii-pilot.hic": "761614686,34861",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjung%2Fmouse_sperm.hic": "1730231642,29184",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ftang%2Fgm12878.hic": "1953518212,20505",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frutledge%2FSRR1791299.hic": "5723484,11956",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frutledge%2FSRR1791297.hic": "16534743,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv.hic": "5094525579,36289",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv-rep1.hic": "2574358912,36373",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv-rep2.hic": "3417099433,36243",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev.hic": "4785157552,36323",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev-rep1.hic": "2648268465,36321",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev-rep2.hic": "2994727980,36107",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf.hic": "5391791815,36063",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf-rep1.hic": "3325842095,36269",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf-rep2.hic": "3096215920,36167",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl.hic": "3830902383,36167",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl-rep1.hic": "1346712252,36079",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl_rep2.hic": "3098067367,36271",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-0h-hiseq.hic": "38174042,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-18h-hiseq.hic": "26506099,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-18h-hiseq-non-crosslinked_control.hic": "3545496,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-36h-hiseq.hic": "70754194,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fg1mid-r1.hic": "200863476,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fm-r1.hic": "249021190,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fm-r2.hic": "212341157,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fg1-0-25fa.hic": "583572265,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fg1-1fa.hic": "354502306,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-0-25fa.hic": "149308791,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-98percent.hic": "778175225,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-1fa.hic": "158091047,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhff1%2Fcchic-hff1-ns-r1.hic": "801670039,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhff1%2Fcchic-hff1-m-r1.hic": "875922086,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fk562%2Fm-r1.hic": "130959943,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fk562%2Fm-r2.hic": "237861106,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-WT.hic": "496104039,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-WT-adv-cre.hic": "438608517,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-floxed-rep1.hic": "446205712,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-floxed-rep2.hic": "386354767,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-deleted-rep1.hic": "621998722,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-deleted-rep2.hic": "583840829,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-floxed-rep1.hic": "801290988,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-floxed-rep2.hic": "819406658,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-deleted-rep1.hic": "792825269,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-deleted-rep2.hic": "746189884,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-WT.hic": "309353372,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-WT-OHT.hic": "274229679,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21KO-R1.hic": "1490362251,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21KO-R3.hic": "2403664421,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21WT-R1.hic": "1377124538,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21WT-R3.hic": "2646201369,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmoissiard%2Fcrh6-mutant.hic": "105261071,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmoissiard%2FWT.hic": "127506388,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2FCol.hic": "153638500,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2Fcrwn1.hic": "211213220,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2Fcrwn4.hic": "134236837,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fxie%2Fprimary.hic": "92936173,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt-control6wt337.hic": "318737891,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt-control6wt67.hic": "348123956,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt337.hic": "251107279,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt67.hic": "351840994,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2FCol0.hic": "345969497,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fclf28-swn7.hic": "299585025,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fcmt3-11.hic": "253427706,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fddm1-2.hic": "303626924,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fmet1-3.hic": "347697973,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fsuvh4-suvh5-suvh6.hic": "263122019,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FDNase-HiC-WG-K562.hic": "892955840,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FDNaseHiC-WG-H1.hic": "696922695,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-K562-rep1.hic": "341917716,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargeredDNaseHiC-lincRNA-K562-rep2.hic": "214841185,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-H1-rep1.hic": "616326137,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-H1-rep2.hic": "579654013,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-pe-H1-rep1.hic": "519810544,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-pe-K562-rep1.hic": "199553123,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_DpnII.hic": "1319373594,6976",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_HinfI.hic": "1465493873,6976",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_DpnII_HinfI_combo.hic": "753062558,5814",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbarutcu%2FMCF-10A.hic": "2784956115,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbarutcu%2FMCF-7.hic": "2700457411,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbatullin%2Fsperm.hic": "501052169,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2FWT_hiC_rep1.hic": "1450697530,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2FWT_hiC_rep2.hic": "1189371558,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Fcombined.hic": "2262007875,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Finactive.hic": "4444564,751",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Factive.hic": "3993495,751",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_rep1.hic": "1650838357,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_rep2.hic": "1258038606,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski.hic": "499827296,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_active.hic": "79175714,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_inactive.hic": "98947881,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_dnase.hic": "4298088401,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_in_situ_dnase.hic": "609321852,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain.hic": "1028196506,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_active.hic": "79175714,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_inactive.hic": "98947881,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FBglII_rep1.hic": "1283306,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FBglII_rep2.hic": "1263227,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FNcoI_rep1.hic": "4380906,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Feagen%2FGSE89112_Kc167combined.hic": "1829549643,25624",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Feagen%2FGSE89112_Kc167combined_randomized.hic": "1859742654,25624",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_GM_cohesin.hic": "1231264781,17932",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_mES_cohesin_all.hic": "1152008628,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_mES_Oct4.hic": "912828146,16438",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FSCC4KO.hic": "1767906138,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FDKO.hic": "1487228787,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWaplKO_1.14.hic": "1189751862,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWaplKO_3.3.hic": "1155057696,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWT.hic": "1522401568,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2Fmega_Liverpool%2Fmega.hic": "2612171975,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2836_Liverpool1%2FLiverpool1.hic": "191729195,2245",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2861_Liverpool2%2FLiverpool2.hic": "1637096030,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2862_Liverpool3%2FLiverpool3.hic": "1160045602,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2FHSPC.hic": "11857786247,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2FHSPC_CanyonDel.hic": "8139168836,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2Ftcell.hic": "9871547081,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2Fep.hic": "17479335373,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2FTh1_ensemble.hic": "1690592868,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FES_mapq30.hic": "32930498831,32386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FNPC_mapq30.hic": "55053730986,32386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FCN_mapq30.hic": "53138031154,32386",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_72_hours_WT.hic": "16492991184,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-resting_B_cells_WT.hic": "23057795398,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_24_hours_MYC_KO.hic": "21245554876,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-resting_B_cells_TSA.hic": "13933346059,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_24_hours_oligomycin.hic": "21902506832,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-mES_WT.hic": "9451969795,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_24_hours_WT.hic": "3600188564,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_30_hours_WT.hic": "1309503359,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_30_hours_HU_treated.hic": "1477252396,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_24_hours_flavopiridol.hic": "15711773490,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FPGP1F_mega_090118%2FPGP1F_mega_090118_30.hic": "24786676166,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7145%2FHIC7145_30.hic": "4554644616,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7146%2FHIC7146_30.hic": "4174848944,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7147%2FHIC7147_30.hic": "5062229182,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7862%2FHIC7862_30.hic": "4520990620,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7863%2FHIC7863_30.hic": "4330354773,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7864%2FHIC7864_30.hic": "5880640268,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7865%2FHIC7865_30.hic": "4431632469,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7866%2FHIC7866_30.hic": "4686000222,36479",
  "encode-public.s3.amazonaws.com%2F2018%2F10%2F19%2Fb122542b-306c-4631-bdc3-2e155e89af55%2FENCFF718AWL.hic": "39544267907,58932",
  "encode-public.s3.amazonaws.com%2F2019%2F02%2F15%2F8e787cd8-e388-4bc2-a236-7a5e6f39e0c0%2FENCFF999YXX.hic": "9255069996,56883",
  "encode-public.s3.amazonaws.com%2F2019%2F02%2F08%2Ffc1d9d5d-8fa0-4e29-9080-3da674d9490d%2FENCFF543USQ.hic": "5005263062,36479",
  "s3.us-east-1.wasabisys.com%2Fhicfiles%2Finternal%2FLCL_mega_42B_500bp_30.hic": "106482584851,22829",
  "www.encodeproject.org%2Ffiles%2FENCFF925QIF%2F%40%40download%2FENCFF925QIF.hic": "51712684396,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF259YUS%2F%40%40download%2FENCFF259YUS.hic": "24640030444,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF783KQI%2F%40%40download%2FENCFF783KQI.hic": "27209249856,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF318JAP%2F%40%40download%2FENCFF318JAP.hic": "28636979242,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF512PQA%2F%40%40download%2FENCFF512PQA.hic": "28124104361,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF591MHA%2F%40%40download%2FENCFF591MHA.hic": "37373387202,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF197OWW%2F%40%40download%2FENCFF197OWW.hic": "41826180893,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF317OIA%2F%40%40download%2FENCFF317OIA.hic": "34741636038,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF522YLZ%2F%40%40download%2FENCFF522YLZ.hic": "24064692329,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF420JTA%2F%40%40download%2FENCFF420JTA.hic": "21202405177,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF871ZDJ%2F%40%40download%2FENCFF871ZDJ.hic": "10124815680,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF349RZY%2F%40%40download%2FENCFF349RZY.hic": "4446702705,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF738YON%2F%40%40download%2FENCFF738YON.hic": "3338049584,35947",
  "www.encodeproject.org%2Ffiles%2FENCFF406KJN%2F%40%40download%2FENCFF406KJN.hic": "4132875306,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF081NPN%2F%40%40download%2FENCFF081NPN.hic": "34495587443,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF946RZW%2F%40%40download%2FENCFF946RZW.hic": "34571955193,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF602CHT%2F%40%40download%2FENCFF602CHT.hic": "30674798032,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF150DKS%2F%40%40download%2FENCFF150DKS.hic": "12618769864,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF614IPZ%2F%40%40download%2FENCFF614IPZ.hic": "42450060331,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF571ZQR%2F%40%40download%2FENCFF571ZQR.hic": "15230068871,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF705MKK%2F%40%40download%2FENCFF705MKK.hic": "38686554702,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF658KTB%2F%40%40download%2FENCFF658KTB.hic": "13195884405,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF435JYN%2F%40%40download%2FENCFF435JYN.hic": "17192139674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF016JKX%2F%40%40download%2FENCFF016JKX.hic": "37266736642,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF294GFP%2F%40%40download%2FENCFF294GFP.hic": "36389843399,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF700CYI%2F%40%40download%2FENCFF700CYI.hic": "60482012152,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF962EDB%2F%40%40download%2FENCFF962EDB.hic": "39394328182,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF467OGP%2F%40%40download%2FENCFF467OGP.hic": "35572788855,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF556RLR%2F%40%40download%2FENCFF556RLR.hic": "34826921187,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF309UNV%2F%40%40download%2FENCFF309UNV.hic": "48510618174,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF653HCO%2F%40%40download%2FENCFF653HCO.hic": "41079007620,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF120DSV%2F%40%40download%2FENCFF120DSV.hic": "12790195576,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF284OEA%2F%40%40download%2FENCFF284OEA.hic": "46007570339,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF035BLF%2F%40%40download%2FENCFF035BLF.hic": "63868871985,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF094KKX%2F%40%40download%2FENCFF094KKX.hic": "42151419971,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF965BPU%2F%40%40download%2FENCFF965BPU.hic": "42717376107,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF842DUO%2F%40%40download%2FENCFF842DUO.hic": "39553892515,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF417GBZ%2F%40%40download%2FENCFF417GBZ.hic": "45544785452,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF499BVX%2F%40%40download%2FENCFF499BVX.hic": "40900674170,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF136XCV%2F%40%40download%2FENCFF136XCV.hic": "47700392974,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF224HKR%2F%40%40download%2FENCFF224HKR.hic": "40426005932,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF711XSR%2F%40%40download%2FENCFF711XSR.hic": "41434581949,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF660JWA%2F%40%40download%2FENCFF660JWA.hic": "54201632697,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF081PMO%2F%40%40download%2FENCFF081PMO.hic": "53428285130,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF799QGA%2F%40%40download%2FENCFF799QGA.hic": "1228682189,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF473CAA%2F%40%40download%2FENCFF473CAA.hic": "1077514950,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF663FRL%2F%40%40download%2FENCFF663FRL.hic": "39843938245,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF341WOY%2F%40%40download%2FENCFF341WOY.hic": "34792598619,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF515ZBF%2F%40%40download%2FENCFF515ZBF.hic": "41779230923,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF545GBW%2F%40%40download%2FENCFF545GBW.hic": "38351980358,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF252ANV%2F%40%40download%2FENCFF252ANV.hic": "37668839771,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF912NDK%2F%40%40download%2FENCFF912NDK.hic": "21196851956,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF683PLM%2F%40%40download%2FENCFF683PLM.hic": "21849338763,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF355NFJ%2F%40%40download%2FENCFF355NFJ.hic": "47880627268,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF507WEW%2F%40%40download%2FENCFF507WEW.hic": "35777782924,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF241MSL%2F%40%40download%2FENCFF241MSL.hic": "22507408288,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF135MUT%2F%40%40download%2FENCFF135MUT.hic": "24168734040,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF459FRB%2F%40%40download%2FENCFF459FRB.hic": "37166770103,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF705YZH%2F%40%40download%2FENCFF705YZH.hic": "44679182442,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF395INO%2F%40%40download%2FENCFF395INO.hic": "56727346538,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF736ITL%2F%40%40download%2FENCFF736ITL.hic": "49036286185,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF546TZN%2F%40%40download%2FENCFF546TZN.hic": "33195126348,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF706SFK%2F%40%40download%2FENCFF706SFK.hic": "3271831702,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF922ERE%2F%40%40download%2FENCFF922ERE.hic": "12476647122,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF876OWE%2F%40%40download%2FENCFF876OWE.hic": "1538692704,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF227XJZ%2F%40%40download%2FENCFF227XJZ.hic": "1925617685,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF053BXY%2F%40%40download%2FENCFF053BXY.hic": "1032237652,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF014VMM%2F%40%40download%2FENCFF014VMM.hic": "1564021703,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF563XES%2F%40%40download%2FENCFF563XES.hic": "1489180508,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF482LGO%2F%40%40download%2FENCFF482LGO.hic": "1208778887,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF216QQM%2F%40%40download%2FENCFF216QQM.hic": "6293163571,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF256UOW%2F%40%40download%2FENCFF256UOW.hic": "6293163571,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF791UZC%2F%40%40download%2FENCFF791UZC.hic": "37029615181,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF911AHQ%2F%40%40download%2FENCFF911AHQ.hic": "34246649165,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF491AOR%2F%40%40download%2FENCFF491AOR.hic": "558663570,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF307PDL%2F%40%40download%2FENCFF307PDL.hic": "525321519,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF773ITV%2F%40%40download%2FENCFF773ITV.hic": "295464771,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF198SSL%2F%40%40download%2FENCFF198SSL.hic": "500142476,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF251UEF%2F%40%40download%2FENCFF251UEF.hic": "567443575,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF942LTN%2F%40%40download%2FENCFF942LTN.hic": "4430960222,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF543USQ%2F%40%40download%2FENCFF543USQ.hic": "5005263062,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF434XQU%2F%40%40download%2FENCFF434XQU.hic": "25506511674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF318GOM%2F%40%40download%2FENCFF318GOM.hic": "44750824314,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF004TKY%2F%40%40download%2FENCFF004TKY.hic": "20705661833,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF493YNC%2F%40%40download%2FENCFF493YNC.hic": "53407154984,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF334XXU%2F%40%40download%2FENCFF334XXU.hic": "14341194962,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF569RJM%2F%40%40download%2FENCFF569RJM.hic": "1922066634,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF076LWH%2F%40%40download%2FENCFF076LWH.hic": "39406255845,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF977XWK%2F%40%40download%2FENCFF977XWK.hic": "20563512962,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF127TPS%2F%40%40download%2FENCFF127TPS.hic": "21032070512,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF480KLP%2F%40%40download%2FENCFF480KLP.hic": "33115569647,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF281ILS%2F%40%40download%2FENCFF281ILS.hic": "28236353584,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF129LMU%2F%40%40download%2FENCFF129LMU.hic": "35247096013,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF759YCW%2F%40%40download%2FENCFF759YCW.hic": "16058537743,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF045YOM%2F%40%40download%2FENCFF045YOM.hic": "19775445828,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF013TGD%2F%40%40download%2FENCFF013TGD.hic": "4208420532,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF929RPW%2F%40%40download%2FENCFF929RPW.hic": "1974260276,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF996XEO%2F%40%40download%2FENCFF996XEO.hic": "2072918865,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF097SKJ%2F%40%40download%2FENCFF097SKJ.hic": "1983524001,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF464KRA%2F%40%40download%2FENCFF464KRA.hic": "1957300131,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF406HHC%2F%40%40download%2FENCFF406HHC.hic": "3854527235,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF080DPJ%2F%40%40download%2FENCFF080DPJ.hic": "19953768024,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF621AIY%2F%40%40download%2FENCFF621AIY.hic": "26781700010,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF366ERB%2F%40%40download%2FENCFF366ERB.hic": "1049184239,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF997RGL%2F%40%40download%2FENCFF997RGL.hic": "2521167549,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF029MPB%2F%40%40download%2FENCFF029MPB.hic": "1854711185,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF043EEE%2F%40%40download%2FENCFF043EEE.hic": "2924133032,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF920CJR%2F%40%40download%2FENCFF920CJR.hic": "3011577886,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF928NJV%2F%40%40download%2FENCFF928NJV.hic": "2778936244,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF894GLR%2F%40%40download%2FENCFF894GLR.hic": "2831733099,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF303PCK%2F%40%40download%2FENCFF303PCK.hic": "688704435,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF999YXX%2F%40%40download%2FENCFF999YXX.hic": "9255069996,56883",
  "www.encodeproject.org%2Ffiles%2FENCFF685BLG%2F%40%40download%2FENCFF685BLG.hic": "16797022992,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF188SSH%2F%40%40download%2FENCFF188SSH.hic": "16797023050,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF465ESX%2F%40%40download%2FENCFF465ESX.hic": "13489465953,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF493SFI%2F%40%40download%2FENCFF493SFI.hic": "30033046818,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF235LCO%2F%40%40download%2FENCFF235LCO.hic": "38572174589,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF625VNK%2F%40%40download%2FENCFF625VNK.hic": "45202258438,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF304HMS%2F%40%40download%2FENCFF304HMS.hic": "36994445315,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF605CEN%2F%40%40download%2FENCFF605CEN.hic": "40358346301,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF086ORS%2F%40%40download%2FENCFF086ORS.hic": "22650781304,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF237UKR%2F%40%40download%2FENCFF237UKR.hic": "41516707246,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF004YZQ%2F%40%40download%2FENCFF004YZQ.hic": "71900665326,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF104THR%2F%40%40download%2FENCFF104THR.hic": "15172410632,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF807IRK%2F%40%40download%2FENCFF807IRK.hic": "17346637451,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF193CQL%2F%40%40download%2FENCFF193CQL.hic": "55726903245,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF700DEX%2F%40%40download%2FENCFF700DEX.hic": "20231399798,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF234MDO%2F%40%40download%2FENCFF234MDO.hic": "24635312640,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF181ROW%2F%40%40download%2FENCFF181ROW.hic": "26883606497,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF896OFN%2F%40%40download%2FENCFF896OFN.hic": "36952196833,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF573OPJ%2F%40%40download%2FENCFF573OPJ.hic": "36685546919,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF028RXH%2F%40%40download%2FENCFF028RXH.hic": "31053919206,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF156GGD%2F%40%40download%2FENCFF156GGD.hic": "35284134289,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF496GEU%2F%40%40download%2FENCFF496GEU.hic": "44659660933,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF945TUH%2F%40%40download%2FENCFF945TUH.hic": "3898570191,35639",
  "www.encodeproject.org%2Ffiles%2FENCFF698KFV%2F%40%40download%2FENCFF698KFV.hic": "4427896684,35751",
  "www.encodeproject.org%2Ffiles%2FENCFF239BHZ%2F%40%40download%2FENCFF239BHZ.hic": "1718552021,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF277LAN%2F%40%40download%2FENCFF277LAN.hic": "4542391336,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF397CMD%2F%40%40download%2FENCFF397CMD.hic": "2832016430,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF778OYA%2F%40%40download%2FENCFF778OYA.hic": "14067187484,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF775VSU%2F%40%40download%2FENCFF775VSU.hic": "14067187484,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF812THZ%2F%40%40download%2FENCFF812THZ.hic": "9667720429,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF777KBU%2F%40%40download%2FENCFF777KBU.hic": "5058284320,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF688KOY%2F%40%40download%2FENCFF688KOY.hic": "4198695833,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF223UBX%2F%40%40download%2FENCFF223UBX.hic": "1206064037,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF273XBU%2F%40%40download%2FENCFF273XBU.hic": "44085607579,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF952JZV%2F%40%40download%2FENCFF952JZV.hic": "44728845246,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF643NDM%2F%40%40download%2FENCFF643NDM.hic": "35877886780,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF586MQY%2F%40%40download%2FENCFF586MQY.hic": "71158037547,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF251VFA%2F%40%40download%2FENCFF251VFA.hic": "40089479399,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF033WGK%2F%40%40download%2FENCFF033WGK.hic": "30802023728,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF649OHR%2F%40%40download%2FENCFF649OHR.hic": "28203184265,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF782WVZ%2F%40%40download%2FENCFF782WVZ.hic": "37248221674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF579CAR%2F%40%40download%2FENCFF579CAR.hic": "39662025395,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF514XWQ%2F%40%40download%2FENCFF514XWQ.hic": "1319613701,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF666USK%2F%40%40download%2FENCFF666USK.hic": "15051670107,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF047SDP%2F%40%40download%2FENCFF047SDP.hic": "1357076705,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF584LEP%2F%40%40download%2FENCFF584LEP.hic": "9314176858,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF671SOE%2F%40%40download%2FENCFF671SOE.hic": "3273732256,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF702LAP%2F%40%40download%2FENCFF702LAP.hic": "1800427500,31682",
  "www.encodeproject.org%2Ffiles%2FENCFF339PON%2F%40%40download%2FENCFF339PON.hic": "5394351199,31514",
  "www.encodeproject.org%2Ffiles%2FENCFF741QPR%2F%40%40download%2FENCFF741QPR.hic": "4271510019,30139",
  "www.encodeproject.org%2Ffiles%2FENCFF103ANX%2F%40%40download%2FENCFF103ANX.hic": "4439745804,30083",
  "www.encodeproject.org%2Ffiles%2FENCFF395SBC%2F%40%40download%2FENCFF395SBC.hic": "1596732351,31850",
  "www.encodeproject.org%2Ffiles%2FENCFF289WNN%2F%40%40download%2FENCFF289WNN.hic": "8632980535,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF381EAU%2F%40%40download%2FENCFF381EAU.hic": "1702476311,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF976FEY%2F%40%40download%2FENCFF976FEY.hic": "1448279040,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF485LVS%2F%40%40download%2FENCFF485LVS.hic": "1593610856,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF143VJV%2F%40%40download%2FENCFF143VJV.hic": "1422312076,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF588NHX%2F%40%40download%2FENCFF588NHX.hic": "3943637009,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF768UBD%2F%40%40download%2FENCFF768UBD.hic": "24786676166,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF965PEE%2F%40%40download%2FENCFF965PEE.hic": "29387092778,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF702IFC%2F%40%40download%2FENCFF702IFC.hic": "29387092778,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF288DNV%2F%40%40download%2FENCFF288DNV.hic": "10313429504,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF698HWZ%2F%40%40download%2FENCFF698HWZ.hic": "10962849269,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF355OWW%2F%40%40download%2FENCFF355OWW.hic": "3219571601,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF177TYX%2F%40%40download%2FENCFF177TYX.hic": "10325679706,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF542BHD%2F%40%40download%2FENCFF542BHD.hic": "11085397879,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF684IFW%2F%40%40download%2FENCFF684IFW.hic": "11085397879,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF592UHE%2F%40%40download%2FENCFF592UHE.hic": "21363948089,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF779XIS%2F%40%40download%2FENCFF779XIS.hic": "9517383271,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF518PSL%2F%40%40download%2FENCFF518PSL.hic": "7500581463,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF275GBB%2F%40%40download%2FENCFF275GBB.hic": "7889407162,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF634KXI%2F%40%40download%2FENCFF634KXI.hic": "6430702966,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF337QPM%2F%40%40download%2FENCFF337QPM.hic": "8529733887,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF162KMP%2F%40%40download%2FENCFF162KMP.hic": "5615896908,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF992VTE%2F%40%40download%2FENCFF992VTE.hic": "7328975027,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF464WXY%2F%40%40download%2FENCFF464WXY.hic": "5715339664,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF752EGH%2F%40%40download%2FENCFF752EGH.hic": "1733758743,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF474UJM%2F%40%40download%2FENCFF474UJM.hic": "222309548,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF531UPZ%2F%40%40download%2FENCFF531UPZ.hic": "1827756846,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF022VHA%2F%40%40download%2FENCFF022VHA.hic": "244983451,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF732NGR%2F%40%40download%2FENCFF732NGR.hic": "1679484567,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF513VSF%2F%40%40download%2FENCFF513VSF.hic": "28397932940,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF750AOC%2F%40%40download%2FENCFF750AOC.hic": "36471430712,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF219YOB%2F%40%40download%2FENCFF219YOB.hic": "2859767211,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF604YDD%2F%40%40download%2FENCFF604YDD.hic": "3549694085,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF746AMV%2F%40%40download%2FENCFF746AMV.hic": "2954867135,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF845ZEB%2F%40%40download%2FENCFF845ZEB.hic": "2763039282,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF570LWS%2F%40%40download%2FENCFF570LWS.hic": "2861588289,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF883YVR%2F%40%40download%2FENCFF883YVR.hic": "2433679887,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF056VLK%2F%40%40download%2FENCFF056VLK.hic": "2502986910,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF532DUQ%2F%40%40download%2FENCFF532DUQ.hic": "3172615899,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF723PYJ%2F%40%40download%2FENCFF723PYJ.hic": "10292839095,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF991SGJ%2F%40%40download%2FENCFF991SGJ.hic": "13072407683,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF885UZI%2F%40%40download%2FENCFF885UZI.hic": "1201881201,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF287KXA%2F%40%40download%2FENCFF287KXA.hic": "14705801988,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF335HYI%2F%40%40download%2FENCFF335HYI.hic": "20366756545,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF121YPY%2F%40%40download%2FENCFF121YPY.hic": "2760104016,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF675SJE%2F%40%40download%2FENCFF675SJE.hic": "3751779995,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF876LAW%2F%40%40download%2FENCFF876LAW.hic": "4032376256,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF740KVX%2F%40%40download%2FENCFF740KVX.hic": "3202490322,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF977OQV%2F%40%40download%2FENCFF977OQV.hic": "2919735477,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF525EFN%2F%40%40download%2FENCFF525EFN.hic": "2394748073,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF690QRC%2F%40%40download%2FENCFF690QRC.hic": "3183023394,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF452FWS%2F%40%40download%2FENCFF452FWS.hic": "2951805127,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF089KBG%2F%40%40download%2FENCFF089KBG.hic": "2531936700,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF939ARM%2F%40%40download%2FENCFF939ARM.hic": "3066385212,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF401ZAN%2F%40%40download%2FENCFF401ZAN.hic": "3008677144,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF378RZT%2F%40%40download%2FENCFF378RZT.hic": "2830232168,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF304AVD%2F%40%40download%2FENCFF304AVD.hic": "6164439305,50358",
  "www.encodeproject.org%2Ffiles%2FENCFF453DBX%2F%40%40download%2FENCFF453DBX.hic": "6775246670,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF590VOM%2F%40%40download%2FENCFF590VOM.hic": "6443478922,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF246DOF%2F%40%40download%2FENCFF246DOF.hic": "6837914659,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF125FXX%2F%40%40download%2FENCFF125FXX.hic": "9736232550,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF241RAY%2F%40%40download%2FENCFF241RAY.hic": "7686758397,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF415XWQ%2F%40%40download%2FENCFF415XWQ.hic": "6973092068,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF374EBH%2F%40%40download%2FENCFF374EBH.hic": "8557459058,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF263YWR%2F%40%40download%2FENCFF263YWR.hic": "331586820,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF280CGS%2F%40%40download%2FENCFF280CGS.hic": "1743569614,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF553ZNS%2F%40%40download%2FENCFF553ZNS.hic": "1717253636,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF451VOI%2F%40%40download%2FENCFF451VOI.hic": "1626927468,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF420MQO%2F%40%40download%2FENCFF420MQO.hic": "31055961677,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF301BWY%2F%40%40download%2FENCFF301BWY.hic": "38902429246,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF606XNW%2F%40%40download%2FENCFF606XNW.hic": "1009699327,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF439ZOU%2F%40%40download%2FENCFF439ZOU.hic": "12381714313,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF499SYK%2F%40%40download%2FENCFF499SYK.hic": "13182654663,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF532LFI%2F%40%40download%2FENCFF532LFI.hic": "8286030286,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF020DPP%2F%40%40download%2FENCFF020DPP.hic": "23521952420,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF306VTV%2F%40%40download%2FENCFF306VTV.hic": "23521952480,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF399IHE%2F%40%40download%2FENCFF399IHE.hic": "10216571232,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF944AII%2F%40%40download%2FENCFF944AII.hic": "12567308552,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF230HVV%2F%40%40download%2FENCFF230HVV.hic": "8629849711,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF174LAF%2F%40%40download%2FENCFF174LAF.hic": "9446506633,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF898HRO%2F%40%40download%2FENCFF898HRO.hic": "9446506633,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF429MOR%2F%40%40download%2FENCFF429MOR.hic": "1455757398,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF061NXV%2F%40%40download%2FENCFF061NXV.hic": "1710915891,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF434PYS%2F%40%40download%2FENCFF434PYS.hic": "1832274903,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF704HHX%2F%40%40download%2FENCFF704HHX.hic": "1768142834,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF349DPM%2F%40%40download%2FENCFF349DPM.hic": "4316041260,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF718AWL%2F%40%40download%2FENCFF718AWL.hic": "39544267907,58932",
  "www.encodeproject.org%2Ffiles%2FENCFF065LSP%2F%40%40download%2FENCFF065LSP.hic": "24929805283,55874",
  "www.encodeproject.org%2Ffiles%2FENCFF632MFV%2F%40%40download%2FENCFF632MFV.hic": "22333105467,55798",
  "www.encodeproject.org%2Ffiles%2FENCFF179HVU%2F%40%40download%2FENCFF179HVU.hic": "2659219603,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF791SPZ%2F%40%40download%2FENCFF791SPZ.hic": "2537491657,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF211ZWF%2F%40%40download%2FENCFF211ZWF.hic": "3512141227,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF614BNU%2F%40%40download%2FENCFF614BNU.hic": "5252155462,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF891DLM%2F%40%40download%2FENCFF891DLM.hic": "2549095612,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF056EXT%2F%40%40download%2FENCFF056EXT.hic": "2219014704,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF776DSS%2F%40%40download%2FENCFF776DSS.hic": "3920308353,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF814LQF%2F%40%40download%2FENCFF814LQF.hic": "1349480197,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF513ZNA%2F%40%40download%2FENCFF513ZNA.hic": "2638868195,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF692IOL%2F%40%40download%2FENCFF692IOL.hic": "3106768498,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF294WZY%2F%40%40download%2FENCFF294WZY.hic": "2211089761,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF339UWS%2F%40%40download%2FENCFF339UWS.hic": "2142759055,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF835FSK%2F%40%40download%2FENCFF835FSK.hic": "3919821739,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF328BMB%2F%40%40download%2FENCFF328BMB.hic": "2550686152,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF897RTY%2F%40%40download%2FENCFF897RTY.hic": "1323294397,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF306MWH%2F%40%40download%2FENCFF306MWH.hic": "1665386199,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF039YUJ%2F%40%40download%2FENCFF039YUJ.hic": "2335679939,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF468QIN%2F%40%40download%2FENCFF468QIN.hic": "3352516594,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF364WXU%2F%40%40download%2FENCFF364WXU.hic": "3959043175,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF373MSH%2F%40%40download%2FENCFF373MSH.hic": "4429550624,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF959EGQ%2F%40%40download%2FENCFF959EGQ.hic": "2475218228,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF624XMK%2F%40%40download%2FENCFF624XMK.hic": "3527855681,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF445OKS%2F%40%40download%2FENCFF445OKS.hic": "3369125589,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF239QDV%2F%40%40download%2FENCFF239QDV.hic": "1960069888,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF645AVM%2F%40%40download%2FENCFF645AVM.hic": "4969006589,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF494IPI%2F%40%40download%2FENCFF494IPI.hic": "1565483792,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF753IXE%2F%40%40download%2FENCFF753IXE.hic": "2892400648,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF731GXX%2F%40%40download%2FENCFF731GXX.hic": "5131381303,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF369CAQ%2F%40%40download%2FENCFF369CAQ.hic": "4236629448,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF053VBX%2F%40%40download%2FENCFF053VBX.hic": "54305946375,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF555ISR%2F%40%40download%2FENCFF555ISR.hic": "54305946434,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF964RSP%2F%40%40download%2FENCFF964RSP.hic": "12065485229,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF234MZQ%2F%40%40download%2FENCFF234MZQ.hic": "17507142760,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF994CEG%2F%40%40download%2FENCFF994CEG.hic": "17507142760,47429",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb068e787-bbdd-49e2-9f6d-7a0e9f065d6e%2F4DNFIHSUIRFY.hic": "2701182442,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3768b89a-e124-40eb-8acd-94a4fdd35807%2F4DNFIXTAS6EE.hic": "3283740601,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9c513602-5abb-4088-8415-c827c381ab0d%2F4DNFIC3JD6O2.hic": "4896075767,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fde954dad-1849-4c23-beb4-bf893b7d76c9%2F4DNFIGY85S4W.hic": "3364151996,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe1befa6e-8067-4296-8db2-67d2a2458985%2F4DNFI2LTNXME.hic": "3699291418,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbb3307fd-7162-477a-87c5-52f12d03befc%2F4DNFID162B9J.hic": "3576428773,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8597cdae-8319-42d9-9175-3f77aaee34e1%2F4DNFIQWS3632.hic": "4022561190,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F327f091d-6a63-47c4-9752-2dff303a13d9%2F4DNFI6GFHB6G.hic": "4239331168,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd70dc3b8-48a7-42c2-bd23-80bc44fc2266%2F4DNFIS5F6EBL.hic": "4404671861,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F77df7bf8-6a3d-407a-8968-4ca1e78d2269%2F4DNFIF2D3TL9.hic": "4793989394,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8f7cc35-d2ef-4717-9009-c02154050fbf%2F4DNFI6EIFUZI.hic": "3370273763,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F98449d79-30d1-4e32-801d-07435819a42f%2F4DNFIRKGMZRQ.hic": "4669813207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd4fe1844-2493-4722-8b98-34a93a4bb7d8%2F4DNFIQWD8ZYD.hic": "5379889057,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1ee40499-1de4-47ff-b540-d9a65943c6b8%2F4DNFIX7H3CE2.hic": "4857679239,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac016170-23a7-4111-8773-353d6c150f34%2F4DNFIO21YDCV.hic": "4695989644,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1faea4e7-9a32-466e-a826-0bfdab6cd915%2F4DNFIUE5RAS6.hic": "4788044799,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcbd396ed-11bb-404f-aed9-ef10abc258e6%2F4DNFIFI6NIKJ.hic": "2069414927,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf3f78db-ae92-4215-bcae-76d30c617e5d%2F4DNFIL5K3MA1.hic": "2585598247,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66fc2893-224e-48b4-bdb0-25e022dedd03%2F4DNFIPV5KFMK.hic": "2060965679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2b39781d-aadc-434f-abe3-562d61308fdd%2F4DNFIW8TIFI5.hic": "1694424195,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6d28f7b-27d3-486f-b5ac-32567416560d%2F4DNFIA6NSSBJ.hic": "2219532611,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F08785616-722e-46bb-ade2-2fdd21324e11%2F4DNFIBKZK63V.hic": "2429136232,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F904b13d3-1203-42a4-812c-963e80c159b1%2F4DNFI3CFMRID.hic": "1233390166,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb0ed4afe-5ecf-451d-bb1f-444697e3f558%2F4DNFIYIAUEPW.hic": "1753567534,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4bb9a9b3-12a8-4d2f-8071-4722294c88ea%2F4DNFIC3HAU11.hic": "2271375254,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5abf9c36-c1d1-44dc-8197-74d860d896c0%2F4DNFIM2BMJ33.hic": "1770471113,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa68475db-7816-4cec-b2da-d4ce4a0c7a0e%2F4DNFIBY3UHJB.hic": "2095528423,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F07c40943-0d0b-4b3e-94a0-8583b0e00b47%2F4DNFIWZEN3FF.hic": "1558559508,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd8a39553-2718-4866-9b2a-45d8e9c5ac6f%2F4DNFIE5TEYK7.hic": "1323063102,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F294b61ef-5565-4f04-ade9-f921a6686cce%2F4DNFI7H4II2V.hic": "1436947982,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87a70ad7-7d34-4302-9c03-eb824bd4e633%2F4DNFIAS8LV1C.hic": "1263105698,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9db804c6-5a91-4cf5-8ae9-e054223afb77%2F4DNFIBXWIH8J.hic": "1587059951,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd1e55906-ec8f-444b-8ce1-2de22a431a76%2F4DNFIO2HBDAI.hic": "1666436393,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a4b9b37-8e38-470c-8190-fd4d513c0bbb%2F4DNFIXWCLD4M.hic": "1513511880,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c7615b2-5310-4bbf-a605-98761d3a3079%2F4DNFINASC4NQ.hic": "1420358914,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F20454014-49cd-4e2d-93da-f40ad52776d5%2F4DNFIZF1KI43.hic": "1377041630,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5df04e86-ee2a-45f2-b878-bf1648e2cca5%2F4DNFIQBHR9XC.hic": "1179502734,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9d1cc910-bb3f-4106-802a-73184c58d5ba%2F4DNFIQVMVRP6.hic": "1811976991,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe431986b-0732-460f-92ff-0abd1694d2d0%2F4DNFIJ7OAIFQ.hic": "1685503856,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F56d0c575-4962-4ea3-92c3-55bd0e17c096%2F4DNFIE8E4ANZ.hic": "1598369564,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb1502fb-a989-4ef9-b800-7eaa7be172ae%2F4DNFIOUSETUP.hic": "1493294709,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Facc2f1c3-8c96-4d21-814a-3a8ba81e7741%2F4DNFIVJ3IIQL.hic": "1472376655,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F037fb4c3-8641-4953-a977-cc71f2137582%2F4DNFIHN2QSMX.hic": "1179632606,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F16d2c3c0-6d29-4815-b074-b142af90b615%2F4DNFIILDWK8M.hic": "2280059989,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31789849-e4db-45d8-9730-66a048c02d8a%2F4DNFI6XD6JAQ.hic": "2253961696,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fff04947e-e6e8-4d62-8374-ef2ee4104809%2F4DNFIALNLR78.hic": "1914687914,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F53e6c1e7-9410-4158-84e6-57c2e683b095%2F4DNFIBT4EAKN.hic": "2296378356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0127900a-258f-4815-97d2-6fd2b043d853%2F4DNFIDJ2JZ7Q.hic": "2558945393,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F89f95693-3d28-44eb-9d45-14932f8e258c%2F4DNFI8JFOAJT.hic": "1726440253,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd803d818-b0d4-4796-8d61-a9f3943f3b10%2F4DNFIRZA6EV6.hic": "1805017504,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff9165fb1-0782-4757-a740-5b929e0252bb%2F4DNFIB7QTIMH.hic": "2541020707,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff8d916b2-b58e-4cdf-894c-ffcb3bf6ebd9%2F4DNFIJ5DQZVK.hic": "2445734043,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F14066a5b-e01a-43c2-a468-b18826174df3%2F4DNFISTWNV9C.hic": "2499319890,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd0692151-7f9a-4475-b059-f8802616dded%2F4DNFIBN9K4V9.hic": "1591570769,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70a7ef36-a514-4e45-918f-47c4e9e30ef4%2F4DNFIR8OU6QJ.hic": "1689882108,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F180306cd-8593-413a-ae83-24f19209c5d2%2F4DNFIDSWKFF5.hic": "1596696630,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6e7b9be7-f465-4434-8e9c-68d1e44a76af%2F4DNFIV239W4L.hic": "2345867406,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F55df948c-941d-4930-854c-6a07557a0c1d%2F4DNFIREVU1Z5.hic": "2254683002,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3f590cb7-df3a-498f-81c3-d5ed4179b8ad%2F4DNFIFHU75I5.hic": "2497670883,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8f064770-6008-4f74-bfca-268d4a22d745%2F4DNFIMROE6N4.hic": "9850583704,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa93d0588-76b7-4ccf-933c-4325876b0a53%2F4DNFI5SUHCGZ.hic": "10364705187,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2f5f0d6b-0b22-4936-93c9-0944d49c037b%2F4DNFII84FBKM.hic": "8836986129,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F12e90fc5-0b76-4e42-b346-58d267f9ad6e%2F4DNFI2J1ODWB.hic": "13410858286,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff2702a45-3e8b-4980-bcd5-6bb0e291614f%2F4DNFIJWBWE41.hic": "20515676755,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa0859349-5f06-4ad3-b56f-b1166b34a9eb%2F4DNFIIMZB6Y9.hic": "15350325963,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F12685c57-d54a-46fa-9efb-acf34ed77574%2F4DNFICJECID5.hic": "1525002266,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd101a58e-89aa-44fd-96c5-6bf1e2476272%2F4DNFIR6UW2QA.hic": "1264999913,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d8c73bf-1335-4af4-b124-e3622d48c5f6%2F4DNFIGOEKBUZ.hic": "1905947578,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcd2477cf-6ed0-4d7b-b4e9-88fb38b0df48%2F4DNFIMDNAEW4.hic": "996444147,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0f03953e-29da-4f2e-8c05-572d0edf4525%2F4DNFI5OSZ3JC.hic": "369361754,22829",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F29d95dbb-005a-4ae1-8b9c-0fec9ec0bbd0%2F4DNFI7KOUGFM.hic": "1227434049,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa441ab7b-afbe-437d-bf98-b6b916558642%2F4DNFIGKX4A32.hic": "883933242,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F941b2f94-2fff-4d3c-aceb-fee4a5ae41a9%2F4DNFI1ORHOTA.hic": "1140970677,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8720ede9-093f-4c00-912f-373283260a16%2F4DNFIWSVLZED.hic": "458091151,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9e17155-2b62-4a68-afb2-31dfa674e169%2F4DNFI6H926RO.hic": "3552863515,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F22f22778-987a-4dc0-97bc-f26eae0156d9%2F4DNFIKTYSPOF.hic": "2939475400,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F40f40192-0acb-44cb-8778-8d21afe593fb%2F4DNFIZ4S52BV.hic": "3067438113,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd8767374-7018-4e11-9226-bf5612d39ebb%2F4DNFI3APMXHF.hic": "3258874744,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8c5140ec-a65a-4186-8c59-2927233eecaa%2F4DNFIQLIKDSD.hic": "2746398416,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8cdedda6-d7d8-4231-a85b-d56fcd962366%2F4DNFIKYXMF1E.hic": "14442148774,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa4d4497-7c6c-4dad-8040-be13ba07ea32%2F4DNFI9815EEJ.hic": "17960817603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9b7b95f-190b-49fe-8047-ef4a8fc59746%2F4DNFIQ2687RT.hic": "15954277087,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F59863d3a-8d7c-49c7-9a41-7f2a58ad24d1%2F4DNFIYDBBSE3.hic": "16499534862,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3e80ca41-b3e0-4f4f-a05e-8f95fe96d938%2F4DNFIMOCN1YS.hic": "863725312,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F96f97a01-0020-4f09-93e8-fc8a9fd07218%2F4DNFI6558CM8.hic": "1597967345,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fce9e9334-ee0b-4549-a845-110470ba5986%2F4DNFIQZRKS7Y.hic": "907626411,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdaac8209-1015-48da-9e31-2e252dfd8fe0%2F4DNFIX4DLXSE.hic": "1369766288,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F268b7d52-9655-474c-9467-8ba31bb2195c%2F4DNFII3JV8I1.hic": "856656441,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9681f9b5-335a-4f56-afa1-15b58bbb41e8%2F4DNFI5IAH9H1.hic": "1495185175,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3e082eab-95aa-4677-88ed-9d7adcc1effb%2F4DNFIK5HY1GP.hic": "2135337789,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31af1ead-4520-4669-957e-424b4b197c33%2F4DNFIFA89L5B.hic": "1975593640,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcc2b78fd-52d4-4e0c-ac93-b84ee82daf7e%2F4DNFICXCFGEI.hic": "2628202920,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff54efece-280f-46ca-95e3-1f8a3cd18820%2F4DNFIK4CECUH.hic": "1901129375,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1181c0c4-afb7-4b6a-9fdc-d868fb2253fc%2F4DNFI1EYIGOC.hic": "1947135384,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1d3e2905-b9b9-4b91-bcb4-8d34746e78f6%2F4DNFI7TLEWUI.hic": "1185758726,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faba3d42f-39cd-4a85-9d3f-835aefb5c803%2F4DNFIVCJKHMN.hic": "687240974,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F27f54fcb-54fe-41a4-b25a-2f8944c89044%2F4DNFIN8F14CS.hic": "1304082029,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb75fedb5-88f4-4bc0-8e38-298df7847a7f%2F4DNFI5LCW273.hic": "12497258313,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2f22b2a0-3712-496e-92d2-63775ec0e421%2F4DNFIVSCH2CH.hic": "12594733778,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F07e47261-5863-44f5-9198-76e263081bea%2F4DNFIZ268JGC.hic": "1499059135,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F682b1ae1-3ac3-40e4-a330-c49f63946952%2F4DNFIJ1P4HBI.hic": "1190211725,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F197e7c89-ea73-41de-8cb2-8c0b1e3bb945%2F4DNFITEGKBIW.hic": "2061501971,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F191f6928-c9a8-44b2-8516-ee4d6005f24b%2F4DNFIE1P6RVH.hic": "1711447310,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F94435086-3701-4b28-a6d0-4a59b24d7615%2F4DNFICJ6I4DO.hic": "1557899940,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa9ac173-d233-41c7-8985-ca91949664e4%2F4DNFIKUG8MEW.hic": "1339072088,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fba6d8ab6-ee18-4ba2-8da9-d631888dd50a%2F4DNFICFZGFAV.hic": "1261083478,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87a3ab04-7094-4673-81e4-ac8c9add8eb5%2F4DNFIQXCZVVA.hic": "1084913802,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbc1ff488-82af-4579-9424-959184edb139%2F4DNFIB6PJFJ3.hic": "1114571343,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1f7026ee-987a-41e7-8a61-45510ee3f86b%2F4DNFIX97731O.hic": "1246860402,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6186787c-2e72-4925-9729-02121e2e4597%2F4DNFIYQYZOTO.hic": "1212210849,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3b98a946-0109-4efa-a13e-cc7a36772125%2F4DNFIPXU7V25.hic": "1696288217,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fea17d041-c6ed-43a1-8047-535f3d19ad44%2F4DNFIL39PR76.hic": "1719284710,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72774afe-f166-42ac-9849-4070b0dadf6d%2F4DNFIYLJ3R3B.hic": "1106419640,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4a45e733-55f8-4a8e-be24-2ef34c976e25%2F4DNFIL51WBN6.hic": "1327651164,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F086c62b0-a26f-41ae-a5ff-88b8be2bd2aa%2F4DNFI6SFPUDA.hic": "1336964405,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4d9b79c7-af62-4070-84a9-b953903f2732%2F4DNFI2KM22QR.hic": "953067310,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3c9889d1-f49e-4639-8e15-2d99d6cd22e7%2F4DNFIVF8Q45U.hic": "984193565,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa080dd7b-b7bb-4eae-a275-572a8b45b2d0%2F4DNFI2RN3WFP.hic": "1046525527,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb81860ca-c227-4b68-a298-1907fd32300a%2F4DNFI4TJTL7A.hic": "1160373401,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F74ab47dc-7b52-421c-845e-6feb33457adf%2F4DNFIYJ4TWB8.hic": "1268416204,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc6582128-a930-4bcc-941e-5c0733bdd4d5%2F4DNFIM6RGKPV.hic": "863347067,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F11a75514-4450-4295-9eda-18e3678a575a%2F4DNFIL2VWWL5.hic": "860731581,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5eb52a8c-bf14-4225-bf34-14a0aa47c369%2F4DNFIX6ZXCA8.hic": "893462267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66aaa4c0-1f62-4040-8ecc-4e95da23cd18%2F4DNFIEVR81FS.hic": "879736207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F821c6e7f-96f7-47de-b7d9-4970562b3c8e%2F4DNFIAUI6BBI.hic": "996313881,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9252c362-31ab-413d-a47a-cc97bdbf243a%2F4DNFIAFEE9G2.hic": "1103265750,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc1a0bf52-2e65-4deb-871f-ede736babd41%2F4DNFIPZBEXCP.hic": "1081257762,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F729f5ce3-d7e0-466d-b781-d18049e63bfa%2F4DNFIWPKRZGU.hic": "973779283,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F80b769ee-a717-4825-9db0-dca86f913173%2F4DNFIMD9QNDX.hic": "1158688208,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F266290c0-2767-4158-85ab-7274368905b9%2F4DNFIATA1HD5.hic": "1073361089,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc46f18a8-eb24-4d35-b112-36db72bde2f5%2F4DNFIH9U4I7I.hic": "1111124316,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fec91a79e-7de7-49f7-9b3d-d28313aeddc8%2F4DNFIZ95S6TR.hic": "1242494051,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9e9390b9-da20-43bb-a8f4-9830f354ddf9%2F4DNFI5ERM9J7.hic": "1271051397,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fee8ea82e-b9e4-41ad-bced-5f4fbdaa4fec%2F4DNFI15FPSQL.hic": "1216714120,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbed7eb86-8990-42f2-b3ee-5992d6361f7c%2F4DNFIJ3DZPGM.hic": "1035089437,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdaa8a324-3bf8-424c-8a86-b8ad325cc20d%2F4DNFINW9P6XF.hic": "1215712740,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70631758-6bf8-47a0-92b6-132574886faa%2F4DNFITS16HW8.hic": "1105283847,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe473304b-7bc8-49b8-bba1-ecb9f06914ee%2F4DNFIS3DIH4V.hic": "1036056660,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F10f9224a-111c-402a-ac25-e221ad0af9ef%2F4DNFIY3KDHP6.hic": "1071761024,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F17519b96-2bdd-4294-98f0-1535f1aef28e%2F4DNFIO8HVKOL.hic": "953793750,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffb18f896-4730-4909-86a3-867fc8e76cd6%2F4DNFIMF6CFOM.hic": "708717889,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcfee4d87-0873-40b0-b79f-35dcc8669c1c%2F4DNFIZZ77KD2.hic": "732668723,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8b5d909-8a1b-41bb-bcdd-d108a0bde762%2F4DNFIOLO226X.hic": "951271932,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9ce81f6e-b9cf-4ec9-8bd3-517539e4b662%2F4DNFIJMS2ODT.hic": "932509067,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F506aa952-5d41-49ff-b658-916bcf88a395%2F4DNFI49F3LJ4.hic": "1208494817,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe4dc392d-ca36-4bdf-a27d-173cae34f520%2F4DNFI65MQOIJ.hic": "854630155,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F149ef8d7-e0b4-4e4f-b7e5-7226e2603746%2F4DNFIM4KEPRD.hic": "882790622,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa436f0a8-4f9a-4524-90ac-795c5b8491cf%2F4DNFIIXBIZFC.hic": "848244425,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbc8a05dc-7449-4b01-8330-a55db37ca8e6%2F4DNFIWDOOBVE.hic": "1116239020,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faef8b881-28fe-4694-9a95-1d31940e6726%2F4DNFIDT9EB5M.hic": "888289053,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff66f3162-a53d-46f2-8800-3752935d5400%2F4DNFIX2VUNV8.hic": "1226661451,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F36c782e6-2c48-4298-aa43-bd6624da003d%2F4DNFIEQHTV1R.hic": "804665819,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff15d571e-605d-4bcc-a359-0350b57a6815%2F4DNFIFW7GA64.hic": "901568712,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc2aa2e8b-ac7f-4acb-b4b5-ac5f845840fe%2F4DNFIXGXD67I.hic": "970995551,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F71b6fd7d-b249-4d65-a597-b80b95845399%2F4DNFIA7GB1NB.hic": "956785837,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6cbb1418-34db-427f-9273-5174eac81529%2F4DNFIVOJGWNP.hic": "890415052,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc69c2ee7-b6c3-4a62-8d4f-913491c9dab8%2F4DNFIW22BNB5.hic": "1075499540,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa268f28f-c6d9-4324-8989-75d2d317af1b%2F4DNFIIFBC8WN.hic": "1045459440,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c7361d4-60a6-440b-b5be-072cada98663%2F4DNFI9ZBEBJH.hic": "759395398,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcceaad1a-e01e-4430-8bd6-24ffa6891802%2F4DNFID4SLU53.hic": "921288444,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9eee5854-b33e-4d5a-9ba8-ceffd47e7488%2F4DNFIODI1NUJ.hic": "733159777,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5e1089b0-42e8-441c-99bb-4be99bcec28b%2F4DNFIJL26LFN.hic": "723567970,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F298a429e-ea29-49d3-bfed-fa851e1e7c4c%2F4DNFI5KTF553.hic": "2213661745,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F965d29f0-e4a3-477c-8ae4-faf4a654e69a%2F4DNFIYSPGFGV.hic": "2274989349,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd88acbc1-37b9-4266-9f97-d8fed576d0f3%2F4DNFILOR6D2D.hic": "2595459358,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7b6ddbce-0ed1-4272-b8ae-32793e4ea4e4%2F4DNFI1WMMPJQ.hic": "2262433890,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fedc0c8c4-97d8-4372-9a4f-5e0cdf09d7d0%2F4DNFI47P5978.hic": "2146314403,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0edcc389-43a4-44d7-b946-fe3496f93d56%2F4DNFI7XGW6IH.hic": "2302805723,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0a802926-e235-4c80-b521-83a1774dfb46%2F4DNFIK1EJG8I.hic": "2374943035,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3c36aedb-6a58-4aa2-9b11-bb440ec174f1%2F4DNFIDQ3THN9.hic": "2341188249,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F846123cd-8828-4e51-8b8a-27deaf293858%2F4DNFI3WPNFWT.hic": "775145629,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd06e3ad-0e37-48a3-8367-c7d5912cab03%2F4DNFI9DCUOQ1.hic": "870487824,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc2eaf9bf-9584-4cec-8685-bd74038a6c01%2F4DNFIU8AF5ZY.hic": "1276224366,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F219497b5-3f35-473b-9d4e-e1cf21c69561%2F4DNFIHW8NTQX.hic": "28864787856,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4be13558-114a-4f2d-abca-7598e2ff4757%2F4DNFI4OUMWZ8.hic": "17061013588,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F49aed637-87a1-4d4d-ae68-e5da82aec05b%2F4DNFIEYQ5ZIR.hic": "13555272651,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa2f48779-4eff-44a6-8a9d-96435aca1ddc%2F4DNFIDZT7PR8.hic": "13425047093,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6ec6b71-27b8-4891-b10a-ab06a5270468%2F4DNFIEJEFCAM.hic": "15394960208,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F68b9a7b5-8413-44fc-8c2d-59a67b1c4166%2F4DNFIJ8JKKWJ.hic": "17012681779,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F294d45a4-8b5e-456f-a9cb-1cbbbad3a7d2%2F4DNFINEQY95T.hic": "13966775978,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd7f3a48-b822-41e2-bd9c-f52b3aff7b6a%2F4DNFII6AN691.hic": "12367300362,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7da44594-0dc8-4e74-8e10-a957aeaea51a%2F4DNFIDBIEXI7.hic": "2015474981,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F085a0453-3784-4eba-80b2-3556e53e2f52%2F4DNFIDKJFK2S.hic": "1983111659,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc370c78c-0a99-4c3f-a29b-2dfafc6a3e86%2F4DNFIPAF4PYT.hic": "3041434294,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F907ce45f-baa5-416d-92de-e86db4bacff1%2F4DNFIWIYYNQ5.hic": "7082321112,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff13afc6b-cf69-4c9d-881f-eed4dd3c28ee%2F4DNFIHMCILEN.hic": "1739157603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7575d891-0e3d-4a77-896a-3e1b3a8d330b%2F4DNFIJBJ6QVH.hic": "5213499748,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff0daa830-60d5-4c7c-a2e1-a4ee70b3fee7%2F4DNFIH2A7IKF.hic": "4099503507,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff4970a25-91d8-49a7-9a4a-fe0f12cb2b0f%2F4DNFIOL8KGQ2.hic": "2256042055,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F879f1850-d175-4a86-8a97-12658482e3d1%2F4DNFIWILLD6C.hic": "5476286356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F787f538e-d619-4c8f-985b-78753fb7e57c%2F4DNFIZBXXJAF.hic": "5946467856,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8ee785f-1016-4989-9e64-78352621d32f%2F4DNFI8PZOJHN.hic": "8307204961,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d8997fa-528c-4531-b25b-a412de6bd472%2F4DNFIGXAMSJY.hic": "6577588285,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87aede55-7610-4283-af0e-c6840429a31e%2F4DNFIWNNO89O.hic": "2871061417,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93b8e020-b337-4685-81dc-40cc8a12b5e9%2F4DNFIXU2KPNQ.hic": "3401717686,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffb5cf1bd-59d6-46fe-857d-b86d9756029d%2F4DNFIHBGD6N6.hic": "840028421,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2d1bc088-d838-49b8-85fc-fea78a7353c4%2F4DNFI7J8NI4A.hic": "675705256,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21a27b63-fd67-401b-9aa2-2798e6588d21%2F4DNFISFM9VFK.hic": "800145922,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F656c0a9d-7058-4c4b-a3ce-701d929561c1%2F4DNFIJU5XBK7.hic": "966593603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2efacfbd-9c81-4e62-8df7-847d1ab774d5%2F4DNFIPKY8ED1.hic": "3401629450,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa50b6a26-56b5-43f2-b525-fa219fd716f1%2F4DNFIQRTP7NM.hic": "5358852759,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff5dc7a59-b998-4490-8a76-afbf3b258a49%2F4DNFIBCIA62Q.hic": "5779049277,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F62b2b237-cb02-45f7-89d9-616cf9ffb678%2F4DNFIV56OFE3.hic": "5818844506,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ac79b4f-cfbf-4b2a-9fc2-898ed6c3e5e1%2F4DNFILIM6FDL.hic": "19637469163,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1cff8afa-5a13-4ad4-bcad-91fc3ced759c%2F4DNFIP71EWXC.hic": "17934647326,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F000789fe-9a22-4280-a71c-7ad228fd4cac%2F4DNFIM7ZVQOQ.hic": "700134697,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8d78457f-0c2b-4358-b08c-4d4ef4d9f59d%2F4DNFIS6EYHCX.hic": "628314484,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ca3b4a0-2478-49c9-b4a2-a28430417a32%2F4DNFIKKCMS1Q.hic": "584050634,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff5041473-18ec-439d-92b1-8ad98c9b25c0%2F4DNFIBIV8OUN.hic": "522632731,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcf474ec6-abd4-431e-a21c-252fcf5ee6b3%2F4DNFIAUMRM2S.hic": "313395531,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2bb1c73e-fb0f-41c4-8620-a938cc8d24a0%2F4DNFI9ZUXG61.hic": "332217525,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F26dfa41e-7e4f-457a-a3ac-72daf8059f3c%2F4DNFIDBFENL7.hic": "359604894,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ed2e68b-189e-4988-bb6d-94e63240a231%2F4DNFI7XAZNNQ.hic": "5312422266,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6f2b1ce0-5205-4680-981e-d91b694dc3e4%2F4DNFISNGDB53.hic": "2008546759,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F73c8147f-bc7d-4d33-8a10-a9e7b413ecc6%2F4DNFI1CIGHYC.hic": "2221847625,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F526ae3e3-32cc-4670-970f-1faa9cfafd4d%2F4DNFIQD2DP2F.hic": "5295591503,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6e803530-47f8-4c56-bb19-fbdcd578d2f0%2F4DNFINHT8P7C.hic": "3159499486,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffe705f38-903f-47b7-9b38-f80ebd18a479%2F4DNFIGF8EM7M.hic": "3490552542,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa197328-d6da-4299-a0fd-409ac9892668%2F4DNFIUPG2ZBJ.hic": "5382003751,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffe5d52c4-2be7-4812-bca0-cd4bb3025e6b%2F4DNFIH3OTR14.hic": "3224693110,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21935f61-daa8-4df2-aa69-fcd27953b405%2F4DNFIUATRW3Z.hic": "3835865655,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72147527-e3e8-4967-bc45-8251249d76c9%2F4DNFI6V7ZQAE.hic": "4382708138,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F589f0919-f54d-49ff-a482-e2f453ef7f34%2F4DNFICKMT1CY.hic": "4479068191,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F861946ca-bad8-4a87-96e1-b2eb20b9ef10%2F4DNFIF9BDCNI.hic": "3698151402,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff76346ac-97ec-4893-8984-2b75ce1cdc51%2F4DNFIG5O1OQS.hic": "5704288175,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe8b43826-f049-4c3f-b83a-e75fa7aacc85%2F4DNFIHS2SVBQ.hic": "990025510,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46316260-f555-4dd4-9e40-8ae06ca52822%2F4DNFIU95B69H.hic": "1275878544,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff62ef491-a3ae-4f66-ab33-c5673c9e0b65%2F4DNFIYRROFCR.hic": "1522530503,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1cd617e1-fad4-4fdc-8b4e-cb277650123c%2F4DNFIF7JN3IU.hic": "1463443128,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb20fe2a-0078-4d4a-8a52-d76043d06f40%2F4DNFIB2RYULQ.hic": "1269529700,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d386fcf-1d22-47de-a0d6-0c3a641ca174%2F4DNFIMVDK3SI.hic": "1185489599,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F00e470bd-c533-41b1-923a-4b471824da12%2F4DNFIRLOTXSC.hic": "978217499,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8774fb3-d0c5-43cc-a6c9-eb0ca39841fb%2F4DNFIZAPX6J8.hic": "1100356082,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fab3b826e-614c-448b-860f-a3ebef68a82f%2F4DNFIQD5VCSD.hic": "1322319877,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66c78d2b-993a-4937-95ed-9e2d302ceb3e%2F4DNFIIF6VAGN.hic": "868885799,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5d106fe1-2d80-466e-87aa-46b38ba142c5%2F4DNFI86IEZXH.hic": "751443267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc99490b6-faf9-413f-9c38-3f53018089d6%2F4DNFIP881SR2.hic": "754427927,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F39c7e387-e710-4b1d-b757-357dec03f6ad%2F4DNFI42NNCW8.hic": "1166392978,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4742a211-43b1-4325-af6f-82490aeb766b%2F4DNFIEV4PKP6.hic": "1102227476,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feaa73842-1c86-4ad9-8a9e-c189c0b4c01d%2F4DNFIF1DUQHE.hic": "1206699207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd25f24df-0298-4079-bb6f-1c8e1e32392b%2F4DNFIGW55EAY.hic": "1033358104,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc57a7ab5-2778-4fe2-9d64-9a4e95135f12%2F4DNFISZRU6I4.hic": "1539570262,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd89f494a-27ca-46b6-89be-7583f3f6d18c%2F4DNFIBKKDTAP.hic": "350372180,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F06725280-cb24-4f22-a267-18b434bfa79e%2F4DNFIJSRQW24.hic": "314361467,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8fe5c3c5-006f-425b-ac6d-ea475e29be78%2F4DNFI3REN89E.hic": "299665258,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8b6ac5c-13b4-427e-9158-cec0b890b6d8%2F4DNFIF5XLHKM.hic": "235668364,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F01ff33fc-fc23-48aa-a6c6-b720d6fe0768%2F4DNFIB6Q538N.hic": "316494853,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F552978c8-abbc-424a-9187-3e34cf802a97%2F4DNFI3ST3F7Y.hic": "296298411,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72e66520-5170-4f2e-844a-fbfd0e23b480%2F4DNFIQT4M6UI.hic": "307691265,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb3eb3953-ffe8-4d5a-970c-a16f3b7b9ec3%2F4DNFIFNCC7M2.hic": "364160436,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F37d413fb-afab-41ff-99aa-1678830f7dde%2F4DNFITM9MDJL.hic": "252412426,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf5db92c-aaf1-4086-a0d2-79b28648f172%2F4DNFI3NTD7B3.hic": "227586640,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6892f7b-1f8a-4d7d-9605-c67932cd5654%2F4DNFIBED48O1.hic": "328344868,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd64afb07-5ab1-4c4f-8438-2fee37afa86a%2F4DNFISATK9PF.hic": "379669025,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fad11bb63-8692-461c-b698-89c601451321%2F4DNFISRP84FE.hic": "298491537,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F63710ec5-35d2-47dd-bf9a-08d3daa83d67%2F4DNFI2LY7B73.hic": "303150299,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76077d9e-ca75-4301-ab79-88aa49bda495%2F4DNFIXEB4UZO.hic": "711757090,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F34dd4c0e-3487-4fb4-b95f-c4bb66e0fa31%2F4DNFIQWWATGK.hic": "221304476,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F48a8cf86-3248-4a8e-8e85-472ec219d49c%2F4DNFI44JLUSL.hic": "284772724,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fee399fbf-2a9e-46e2-8364-457713bff508%2F4DNFIM7Q2FQQ.hic": "330729464,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F124d191a-c5c7-49b6-b84b-0d1bad8bef2b%2F4DNFIZK7W8GZ.hic": "293166018,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe351f7cc-7a2c-4515-ae0b-3bb2f91c986a%2F4DNFIMIMLMD3.hic": "240094740,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffd1ae249-57b1-41d6-81a6-16b21dcd8f12%2F4DNFI7QUSU5J.hic": "681762505,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46c92c5c-9ad8-4d49-beba-f35c5cd99208%2F4DNFINXUOI5H.hic": "375594313,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd7350d40-4e9e-4131-9151-bb539d39b431%2F4DNFIIJR2296.hic": "331322302,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbfacf37b-1665-45f3-a046-e29e1544e9b0%2F4DNFIJMZUTXR.hic": "361313244,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F234e18fb-9990-43bf-9a48-f72722cfa232%2F4DNFIZQPT9EL.hic": "540421873,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4b35ab09-2e79-4876-b2bc-d3a8faa26257%2F4DNFIZIXSZ9J.hic": "545066813,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2ae5118e-807a-46e0-8e92-143d4b282b3d%2F4DNFIDD9IF9T.hic": "237409149,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb34d7f6f-73f7-4b6b-80c7-c8af0f991549%2F4DNFIVC8OQPG.hic": "355121712,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9ab169fd-cbdd-4f60-8553-a4c6912ad89e%2F4DNFITUPI4HA.hic": "313085022,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4e53712b-d0d9-40c5-afe1-ffa0fad71e59%2F4DNFI5IZNXIO.hic": "341863906,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a91477f-45eb-4a16-affb-fc131f9326b8%2F4DNFII16KXA7.hic": "248904495,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F153729de-0eca-43cc-9b61-61aa8d775b38%2F4DNFIAAH19VM.hic": "668047244,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F879fd78a-7165-43d9-a0de-ca158b53df30%2F4DNFIVKIY3KV.hic": "247571318,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67f901a4-040b-4b04-9fff-94a1780423cd%2F4DNFIVVCWL6C.hic": "198355985,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd5b30c5a-654a-463c-9474-39bdc3ce4500%2F4DNFIJRF2273.hic": "343971277,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7070280a-8f03-40d0-9fef-e9d9f4d3dae7%2F4DNFI6FCC9ZA.hic": "312013061,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F47049719-9407-4d76-9048-26231045f642%2F4DNFI1CPQ4O3.hic": "352923267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F862c2b5f-44c2-4bd7-9264-b3ca032d3d8d%2F4DNFISXFEDE9.hic": "271745977,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feffbe052-39ff-4217-9871-44199ed90818%2F4DNFIF9L6QEQ.hic": "668409334,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa7791854-1b35-4258-90fb-603c55f24642%2F4DNFIPKASX1Q.hic": "312727920,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F79cccad6-a78e-4de9-9fe7-08f7e8df663d%2F4DNFIWXZ4JQZ.hic": "151808553,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7e86e0cc-d6f1-4ce0-aba4-c36c6ebb3c4c%2F4DNFIEMQ1O8V.hic": "700533280,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4a1b58d3-9ae6-43e4-91cf-49f1fcbbab33%2F4DNFIYWONU7A.hic": "729050356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67bff264-0b0c-4c5c-9d4d-ff5abef2bbe4%2F4DNFISNIE5FH.hic": "7987657997,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3a6a943f-2cc0-4433-a27d-c89f3fdd3309%2F4DNFIV8MLWJB.hic": "6646216171,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9e235711-ba90-404d-b4ac-b15990ea8e33%2F4DNFIXSTDPHL.hic": "3146468238,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c89f4bc-e9fc-4ecf-b868-26108dbb7bb2%2F4DNFIQJNOH8U.hic": "2919703928,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1856ff9e-de7a-4fa1-ae0b-3e04b837b5e1%2F4DNFI57XB4A8.hic": "13417594377,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F099bb5b9-6315-4650-8f78-d603f5a046b3%2F4DNFIQ7UKVZV.hic": "9016468637,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf3c7a30-0fc4-410d-8d41-247da3eb105d%2F4DNFIWJY8GHD.hic": "7921314766,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fda99f429-20ab-4d91-bbfe-f8bdea8ed7b1%2F4DNFIN8NKRNF.hic": "4247121358,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0ca0f4e3-30ca-4332-b735-e32dce08e1a4%2F4DNFIZYGEHNZ.hic": "4910404663,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F243f48b0-6b59-4f37-ad39-a12e0986f530%2F4DNFIRPYGAV8.hic": "4220073636,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F49f1a890-d458-42a6-9c78-99c38b6c7a8f%2F4DNFI6MZTDM1.hic": "375035361,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76bd4768-9343-44ba-a99d-5500e184e39d%2F4DNFIG3BCGPL.hic": "2422923206,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9d1ed866-eaf6-4906-aa8c-9e39616dde38%2F4DNFIS9YPJ3L.hic": "1593271574,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1e7a5636-bdb6-45fb-85d8-87a7e908de43%2F4DNFIOWGA9AX.hic": "1632314387,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5ecc552a-0a6b-49a9-9aa5-9f3fd9b535fd%2F4DNFINKEDSBF.hic": "1458761024,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c03f1d2-bb25-4c94-b5f5-d5cdd01c14b6%2F4DNFIVIXVUK7.hic": "1504818271,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1a4616ff-6d04-4a6a-9773-b80e81da2471%2F4DNFIANHFY16.hic": "1850724180,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd2231870-a78d-4c8b-9cfd-084f2468acb1%2F4DNFIJ67ZFBI.hic": "1473864703,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F859c2dd3-df8a-42b7-86ea-bf6524f75e80%2F4DNFIG3YQQ4V.hic": "1539822829,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8bad667e-6003-4828-9a20-07585fa9c811%2F4DNFIOLKEOME.hic": "3036353747,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F92ea551b-5779-4d31-a0f5-621e4bd0eb21%2F4DNFIVLN8WJE.hic": "2710426318,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F61ee79fa-0617-4083-b121-f92ef3a8905c%2F4DNFI2111XQA.hic": "2589549183,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F83ebb98d-e5db-403d-aa23-875293156c0e%2F4DNFI88HXX7D.hic": "2462367030,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6d63671a-8f1d-4159-82c0-931b43464772%2F4DNFIUBM6QK8.hic": "2486020469,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcccb9014-ce15-4032-81ac-222b3d621cb4%2F4DNFIVILEERC.hic": "2052537210,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21a07867-4007-4ca5-b066-25d3168208dc%2F4DNFIF7Q43N4.hic": "2091773428,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff738de0f-358b-44bf-97dd-644c8d9b1b1c%2F4DNFID56VJGW.hic": "878913568,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fda97c1d4-bb92-4a77-92a7-f7960f88b9dc%2F4DNFIYUR29KO.hic": "983915575,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F54ea363a-99e7-4f55-861e-1644acab7939%2F4DNFIUDPGHO8.hic": "905253594,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdcd66a07-55ee-48d9-a157-419cf4ee3eef%2F4DNFISWC2N8T.hic": "1233576358,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F40363837-7466-4a1d-b20d-a66d1670b700%2F4DNFICMPHDMI.hic": "516590777,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0b3fa4e6-caeb-40b4-8942-e9c0b03dfe4f%2F4DNFIKMKN736.hic": "634310295,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6a34050-d52b-4880-91cf-d3fe4b0ce982%2F4DNFIN5NLS49.hic": "650451131,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8e63a47b-9fd4-4772-8b0c-10ee589ffb16%2F4DNFI4P8UBRL.hic": "705655033,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7d92b666-30cc-4838-9d46-c1f11cee3d3c%2F4DNFISNC3LAI.hic": "176146197,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F17f7dc63-a1bc-4970-b389-87d9ee93b753%2F4DNFIVBWPFD7.hic": "749678512,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff8897333-4791-4a83-9444-a653e24aee13%2F4DNFITMQRXB7.hic": "254477361,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8712bf31-33d0-4562-ab0b-a1e9cf4fd30c%2F4DNFIUYD3HBY.hic": "995625724,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbfaf6383-9cc6-4b5c-9b20-d3bf2e8c3495%2F4DNFIRRSC7P9.hic": "1149985362,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb0b70598-5d17-4e0a-8831-6cbe697e69e2%2F4DNFIWKR8FP6.hic": "1151628407,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fccc094a8-23ce-4fd8-9c4a-41f07c045c8f%2F4DNFIQ74RSUY.hic": "931695969,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8eda16f3-af5e-4f1f-b46d-c74df44b76aa%2F4DNFI9IIO5PW.hic": "1077740364,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff283637b-cf2c-4412-ba00-0e3d7e279fad%2F4DNFI8WGJG19.hic": "812086456,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7ad8438f-d3d9-42d8-88bf-42845a0dc2d0%2F4DNFIQ5CCESJ.hic": "652559720,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70e3bdcc-caf4-4822-b9c5-85234873db7a%2F4DNFIWTZHB4H.hic": "760694196,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F56ed767d-cd8a-4d38-8047-ed1e8bc8cd19%2F4DNFIENYQCDP.hic": "1159428005,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa912fff9-5f90-42b1-a3a6-cbb9eb2cf861%2F4DNFIFATZWPD.hic": "1033325746,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21338ea5-fdee-4ad8-b61c-608fc6cec4bc%2F4DNFI7YRXKEO.hic": "388142539,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff0f88647-5631-437b-b48a-4603915e3714%2F4DNFIUY3J7EW.hic": "407344788,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F16926af8-ac3b-4f32-97d5-6c0dc6f1596a%2F4DNFIRKUYKP4.hic": "893352368,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93e39aec-6cde-4c5b-bcdf-283faa3163a2%2F4DNFIAQDBJZP.hic": "489922022,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0dc0b1ba-5509-4464-9814-dfe103ff09a0%2F4DNFIC1CLPK7.hic": "565748333,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb50964c7-b025-49d9-b1ed-289bedb59678%2F4DNFI3A3VYWU.hic": "4597459343,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff4390cea-b330-4022-88c1-9ff8c0a786f7%2F4DNFI6JJQKFJ.hic": "3678393678,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70c0f730-5da1-4863-9b7a-6cdd31066cff%2F4DNFIK61ILGM.hic": "3324300994,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F14b14ac4-ab59-4754-9c43-eacd9d0638e2%2F4DNFIYD8LO9Z.hic": "3227227120,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7386f953-8da9-47b0-acb2-931cba810544%2F4DNFIOTPSS3L.hic": "253942497,7557",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6b5d8bd-27dc-4415-a320-53405a16db85%2F4DNFI525PKU5.hic": "305089653,7557",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1f922dbc-637b-4c43-b816-f604f0e79ad1%2F4DNFI8Y9SRP2.hic": "1438589609,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6a36d686-716c-4ba8-a9c3-fa8311791d3c%2F4DNFIP25GZGA.hic": "1419100109,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0e535542-2cf2-46e4-ba10-7a0b946a7fb2%2F4DNFITPO1WTY.hic": "3885296184,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c17d228-5052-4c83-880e-af05118e6929%2F4DNFIG4X5Z5F.hic": "2159245890,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc3977c00-525b-4556-9a27-061707f8cb76%2F4DNFIXLYR32S.hic": "587852728,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3f856506-cbc5-4211-a29d-48a7530c622e%2F4DNFIWI3V5LI.hic": "2318237793,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F38f77979-5eb7-4b6f-9a60-c2451185db98%2F4DNFI2DGL7LH.hic": "2068150664,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe0992a75-7727-405e-95ac-aa97141b51c1%2F4DNFI1VSO8JP.hic": "1807949651,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe925f1aa-2e7b-44e7-bfa8-2084a613ab13%2F4DNFIV5O2ZYO.hic": "2242134377,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F803a6d3c-3972-4939-8ff2-d195c5192090%2F4DNFIEWEWQ8D.hic": "2981341325,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F25104375-a588-46e6-a382-663cee6c332f%2F4DNFICSTCJQZ.hic": "14592996888,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F927aa8a5-24a5-43b7-807a-1e99ac321459%2F4DNFICEGAHRC.hic": "15431307603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8c380474-12cd-41f4-b86f-2a29faf12eec%2F4DNFIY3XPKPO.hic": "2550999291,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F77da562e-d0ec-45a8-8764-14fa16d995a1%2F4DNFIK9PS9GM.hic": "3401011629,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F11b26222-d480-40a7-8d53-3ad8500396cb%2F4DNFIF4Y74JR.hic": "2127593378,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93df02c6-1047-43f6-afae-d3598b61eeea%2F4DNFIBBKG9KD.hic": "5724446278,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6cd4378a-8f51-4e65-99eb-15f5c80abf8d%2F4DNFIT4I5C6Z.hic": "5419655766,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F067881e5-563d-40de-a9e3-caccad887fbc%2F4DNFI2U38HCE.hic": "14749043471,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcb3da9ad-7afe-4d0c-9c2d-261181e7a95c%2F4DNFIETP228R.hic": "9401474797,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F185b7bcc-7bb7-41b7-9ebe-92d4fe159431%2F4DNFIXKC48TK.hic": "11624295594,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F18459b84-dd43-4af6-a05f-bcb773096322%2F4DNFIFPGOWJ6.hic": "2843730862,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffde1e48c-4a0d-4bb1-b84a-e0e45f9a0aa3%2F4DNFIIRMBE8Y.hic": "5820677927,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbabed539-1f0f-4e87-8815-fde596e6024c%2F4DNFIVUGNDD7.hic": "5170782436,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7d00531a-e616-469b-af52-5b028270e2ce%2F4DNFIFLJLIS5.hic": "18917549985,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a9dad53-b8af-4cb6-9ce3-5c38e4a855c7%2F4DNFIOX3BGNE.hic": "5482775936,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F82fd7b7e-5f47-48d5-bf0d-daaa48a4674d%2F4DNFISPUVQHA.hic": "2177864938,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4c6680f3-9cf6-452f-9dc5-ecebf376775d%2F4DNFI8649RQJ.hic": "3288850368,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2395f001-19d9-4000-9f00-dae3dea708d6%2F4DNFIE8T8JZ8.hic": "1383191843,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F24464fa8-bf96-483c-8e9a-c2f626ad6e19%2F4DNFIBM714BP.hic": "1765204569,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F918fc048-fa27-41d2-a63a-d50c511fbb9a%2F4DNFI6CWNUFL.hic": "2431120602,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7ff5a0d1-8e54-4cf0-9fe7-339f147c78da%2F4DNFIZ4F74QR.hic": "3211825957,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F355f0412-cb17-452a-b15c-aba16c5a742c%2F4DNFIOUVOX3R.hic": "5547401083,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3cac91c5-160a-4b91-a91e-edc309318dd5%2F4DNFIVTDXW6X.hic": "4797344498,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9ac9ec5-6221-4f39-951a-1c5054fc9f1c%2F4DNFICA8Y9TN.hic": "4277557869,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46f62222-b50a-428b-938b-5444951600eb%2F4DNFIDWM3HN5.hic": "4374808431,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F50e4f2a1-9cb6-4192-8199-64d354bfdf96%2F4DNFIBK5TB3N.hic": "3757387253,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe4cdd5a8-1a45-4c6a-906b-a9603260d4c8%2F4DNFI3JYF9VS.hic": "5260534916,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8164e99-5778-427d-be26-f0e1b62400f0%2F4DNFIP1GNKUO.hic": "7589365689,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0d72e78a-fc87-4716-8b8e-6dc5650ff2ef%2F4DNFIQYQWPF5.hic": "22022259901,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac58fc15-48c2-4eec-a689-23b677b4b6e7%2F4DNFIW6H9U3S.hic": "6810897169,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31811e40-e3ca-4456-8ba6-2ee66d6c7104%2F4DNFI7J8BQ4P.hic": "7188744676,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F62d81a52-d2cb-4bbd-8510-0fe120e786e0%2F4DNFIA3AKFSU.hic": "1763730692,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fae0b7513-d1a0-4f27-a9d3-348837f42cb6%2F4DNFID68JQY9.hic": "2422880133,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fae6a1a7e-1d2d-4fd2-a89f-1799abac8a9c%2F4DNFIL1FQDXE.hic": "1543814834,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F80d343c9-bd60-468a-803d-c3e351a958bc%2F4DNFITSIPCSK.hic": "2344682115,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff2d61195-a3a6-4d50-b928-546ca67546cb%2F4DNFIJ88LYHR.hic": "3362742962,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31052aba-773a-4500-961b-e0a518245b0c%2F4DNFIJIPWD63.hic": "2529548812,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc93d0710-3fbf-40cc-b0eb-878e2aa659e4%2F4DNFIZUP2BBI.hic": "491996147,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8660baeb-5be1-4ba5-93e4-66499e9a4587%2F4DNFIEBC4AF3.hic": "2993048734,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6d08fbc-b836-4776-82ad-8b1b277ae837%2F4DNFI5VO3E1W.hic": "1949322679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3af004a2-a6fa-46dc-8be8-898b847a77be%2F4DNFIFDGVWLU.hic": "2456400803,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd613b4b-2422-492c-8d8f-8afba9c8a182%2F4DNFITVGFNYZ.hic": "1411204423,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc340694f-14f3-4638-b09b-98220c20039a%2F4DNFIOW9TTC1.hic": "2611370588,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3effa71b-6aa3-4265-87ba-f8d709d778d7%2F4DNFIOAA3ZEQ.hic": "3123195980,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fde75cf8b-9ce1-44fc-8b7b-ca0adea6bae9%2F4DNFIA5ID1S6.hic": "3496246968,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F714f775d-a5a4-4314-83f8-016b9d73200b%2F4DNFIZYU7V81.hic": "4245592042,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5ca518af-6e1e-4777-b67b-0fe7f039ce58%2F4DNFIRV6PVUX.hic": "3981520466,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc29b57d5-c263-4372-b396-ab4f55682f5d%2F4DNFIMEANFBY.hic": "3999623376,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4196d3ef-161a-4c18-a57e-005165c6b32a%2F4DNFIGLGQXLC.hic": "4105683321,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe10828b5-9519-4ceb-81e7-7228bfd890de%2F4DNFILS2HLXC.hic": "3804942111,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feaac88c7-9bdc-4b1e-aa9f-e675520dfffa%2F4DNFIQS8853L.hic": "5287726781,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faab371b1-bc8d-4e83-998e-5bb977c443ca%2F4DNFIVBYCYGS.hic": "4657988157,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb116add-af8c-4a3b-b106-9f704ba0a175%2F4DNFIE4WWHMF.hic": "5116727268,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F033366e2-05a2-4381-9d48-90122892a9e0%2F4DNFIKDUUC3C.hic": "45638237,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7284a446-442d-4a46-aae5-84987e75a7af%2F4DNFIJ5HIRA2.hic": "62201052,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F876649a3-6dd3-463a-8b17-5752a98a89c5%2F4DNFIXDFC7EM.hic": "69878143,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3cb4ce4d-d474-459f-8b8a-2159d8df8068%2F4DNFIO35EOVR.hic": "70153114,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5c5612fa-18c2-47fb-8074-693b1054e254%2F4DNFI57QGL6U.hic": "54605055,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70c1472d-cf3a-41d7-8682-cd03b7cc978d%2F4DNFI2AGEBE5.hic": "67930121,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2bf4cce8-6e03-422b-a190-e51d4a07d501%2F4DNFI1E6NJQJ.hic": "4893181511,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0eb3aa56-8a23-435d-a07b-8bb545e8d708%2F4DNFI2DNFM1A.hic": "60466977,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1201682a-a223-482d-913d-3c3972b8eb65%2F4DNFIIRIHBR2.hic": "48961678,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6aee7913-6356-43cf-affa-f2b60dd478f6%2F4DNFIKXNMT46.hic": "39095246,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F357139a3-c9a5-4343-b0a4-b41c45fd03fd%2F4DNFIRV7IRJP.hic": "70916718,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76be3061-6259-42be-a917-19dcba41517b%2F4DNFIFX1XYKZ.hic": "229197441,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff60c348a-a62c-43c3-ac85-f6c28b5f823f%2F4DNFI64CJUZ5.hic": "112428610,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd0b0a14-9703-49af-bb36-2359f96d4d0e%2F4DNFIBPL2HL1.hic": "73972428,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F79ac278d-83f7-4c1f-91b2-05c8018c1426%2F4DNFIBRSIPE4.hic": "415430378,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c3b8141-8e67-4211-80dd-3bae88f9e537%2F4DNFIDLDVY14.hic": "112747303,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2ae703d2-d85c-4ac4-9ce1-14d653927675%2F4DNFI4R1II4P.hic": "210565448,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76e641af-90be-49f8-b126-12c20f856159%2F4DNFINMLRY95.hic": "1590865292,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3b416382-ae5d-469f-9e9a-85a3e2ce9793%2F4DNFI8KBXYNL.hic": "4626496956,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa27589a6-86b2-43a2-8218-1f2232d551e6%2F4DNFI53R5IKA.hic": "1536016455,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdd3999f5-b36e-4154-a6b9-446656959a3a%2F4DNFIAWVDQ8C.hic": "2210273411,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc377953b-0e61-426b-a905-abab2d5a3002%2F4DNFI9VXTBE2.hic": "3384365692,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2dbe0377-1db2-4aae-af2b-d87dff728035%2F4DNFIT96Z365.hic": "7692311974,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdcfcb009-f006-4ab8-a4c7-af72be58c12c%2F4DNFITUOMFUQ.hic": "6592120312,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67f9073d-b2c5-474e-b3d5-7d72cde555cd%2F4DNFIHLQKDN8.hic": "2647703964,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76968cc8-fb9f-485b-85b2-c9289067194b%2F4DNFIL9M97T2.hic": "6186798917,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87d9330b-8d2c-4e9d-85bb-02e572de7a68%2F4DNFIDWGZLHX.hic": "4379708168,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffc01b381-3665-4225-88ee-2e5e9ecb7324%2F4DNFIMEG1QIC.hic": "3587146533,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3144a03c-15c3-4bf9-95f8-ffad2640a1bf%2F4DNFIWSB66VX.hic": "1529739069,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd7d3aac0-ba66-494b-ba0c-147631084b98%2F4DNFIH7TH4MF.hic": "6896300679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4b13bd19-fbd1-4c68-8855-4f0158d1ce47%2F4DNFIHKWIZ9T.hic": "1954878455,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d04e286-30d4-4add-a806-7a929d36419e%2F4DNFIZBBX795.hic": "1350142414,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa26f261-a88a-4cac-9118-ff8e90ab6f61%2F4DNFI9ZWZ5BS.hic": "3410552807,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F24e516ce-0b49-4476-b818-cc96471d8765%2F4DNFIPAI8XB5.hic": "4168518737,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac3b06b5-46d4-4c1e-97e9-9a4f353473a7%2F4DNFI1OUWFSC.hic": "10766406904,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76c6aa27-895f-4e82-8ed8-7a85aca84490%2F4DNFIX4PJKXZ.hic": "1463157350,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe6fbe03a-997b-4d72-a3cc-f1ed7bd88a92%2F4DNFIZGCA8AH.hic": "1597664180,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F61d99a87-4ec6-4116-be99-b483999641c4%2F4DNFI5CGQ46V.hic": "2870576870,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F271ea8cd-53b9-44c9-9fff-1bb5c444b54c%2F4DNFIOCW5AEM.hic": "2463600138,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa98ca64a-861a-4a8c-92e9-586af457b1fb%2F4DNFI1UEG1HD.hic": "22480709268,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5809b32e-0aea-4cf5-a174-cf162d591a35%2F4DNFI9YAVTI1.hic": "3141182061,25900"
};
const isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
const Short_MIN_VALUE = -32768;
const DOUBLE = 8;
const FLOAT = 4;
const INT = 4;
const GoogleRateLimiter = new RateLimiter(100);
class HicFile {
  constructor(args) {
    if (args.alert) {
      this.alert = args.alert;
    }
    this.config = args;
    this.loadFragData = args.loadFragData;
    this.fragmentSitesCache = {};
    this.normVectorCache = new LRU(10);
    this.normalizationTypes = ["NONE"];
    this.matrixCache = new LRU(10);
    this.blockCache = new BlockCache();
    if (args.file) {
      this.file = args.file;
    } else if (args.blob) {
      this.file = new BrowserLocalFile(args.blob);
    } else if (args.url || args.path && !isNode) {
      this.url = args.url || this.path;
      this.remote = true;
      const remoteFile = new RemoteFile2(args);
      if (isGoogleDrive(this.url)) {
        this.file = new ThrottledFile(remoteFile, GoogleRateLimiter);
      } else {
        this.file = remoteFile;
      }
    } else if (args.path) {
      throw Error(`path property is deprecated, use NodeLocalFile`);
    } else {
      throw Error("Arguments must include file, blob, url, or path");
    }
  }
  async init() {
    if (this.initialized) {
      return;
    } else {
      await this.readHeaderAndFooter();
      this.initialized = true;
    }
  }
  async getVersion() {
    if (this.version === void 0) {
      const data = await this.file.read(0, 128);
      if (!data) {
        return void 0;
      }
      const binaryParser = new BinaryParser2(new DataView(data));
      this.magic = binaryParser.getString();
      this.version = binaryParser.getInt();
      return this.version;
    } else {
      return this.version;
    }
  }
  async getMetaData() {
    await this.init();
    return this.meta;
  }
  async readHeaderAndFooter() {
    let data = await this.file.read(0, 16);
    if (!data || data.byteLength === 0) {
      throw Error("File content is empty");
    }
    let binaryParser = new BinaryParser2(new DataView(data));
    this.magic = binaryParser.getString();
    this.version = binaryParser.getInt();
    if (this.version < 5) {
      throw Error("Unsupported hic version: " + this.version);
    }
    this.footerPosition = binaryParser.getLong();
    await this.readFooter();
    const bodyPostion = Object.values(this.masterIndex).reduce((min, currentValue) => {
      return Math.min(min, currentValue.start);
    }, Number.MAX_VALUE);
    const remainingSize = bodyPostion - 16;
    data = await this.file.read(16, remainingSize);
    binaryParser = new BinaryParser2(new DataView(data));
    this.genomeId = binaryParser.getString();
    if (this.version >= 9) {
      this.normVectorIndexPosition = binaryParser.getLong();
      this.normVectorIndexSize = binaryParser.getLong();
    }
    this.attributes = {};
    let nAttributes = binaryParser.getInt();
    while (nAttributes-- > 0) {
      this.attributes[binaryParser.getString()] = binaryParser.getString();
    }
    this.chromosomes = [];
    this.chromosomeIndexMap = {};
    let nChrs = binaryParser.getInt();
    let i = 0;
    while (nChrs-- > 0) {
      const chr = {
        index: i,
        name: binaryParser.getString(),
        size: this.version < 9 ? binaryParser.getInt() : binaryParser.getLong()
      };
      if (chr.name.toLowerCase() === "all") {
        this.wholeGenomeChromosome = chr;
        this.wholeGenomeResolution = Math.round(chr.size * (1e3 / 500));
      }
      this.chromosomes.push(chr);
      this.chromosomeIndexMap[chr.name] = chr.index;
      i++;
    }
    this.bpResolutions = [];
    let nBpResolutions = binaryParser.getInt();
    while (nBpResolutions-- > 0) {
      this.bpResolutions.push(binaryParser.getInt());
    }
    if (this.loadFragData) {
      this.fragResolutions = [];
      let nFragResolutions = binaryParser.getInt();
      if (nFragResolutions > 0) {
        while (nFragResolutions-- > 0) {
          this.fragResolutions.push(binaryParser.getInt());
        }
      }
    }
    this.chrAliasTable = {};
    for (let chrName of Object.keys(this.chromosomeIndexMap)) {
      if (chrName.startsWith("chr")) {
        this.chrAliasTable[chrName.substr(3)] = chrName;
      } else if (chrName === "MT") {
        this.chrAliasTable["chrM"] = chrName;
      } else {
        this.chrAliasTable["chr" + chrName] = chrName;
      }
    }
    this.meta = {
      "version": this.version,
      "genome": this.genomeId,
      "chromosomes": this.chromosomes,
      "resolutions": this.bpResolutions
    };
  }
  async readFooter() {
    const skip = this.version < 9 ? 8 : 12;
    let data = await this.file.read(this.footerPosition, skip);
    if (!data) {
      return null;
    }
    let binaryParser = new BinaryParser2(new DataView(data));
    const nBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();
    let nEntries = binaryParser.getInt();
    const miSize = nEntries * (100 + 64 + 32);
    data = await this.file.read(this.footerPosition + skip, Math.min(miSize, nBytes));
    binaryParser = new BinaryParser2(new DataView(data));
    this.masterIndex = {};
    while (nEntries-- > 0) {
      const key = binaryParser.getString();
      const pos = binaryParser.getLong();
      const size = binaryParser.getInt();
      this.masterIndex[key] = { start: pos, size };
    }
    this.expectedValueVectors = {};
    if (this.version > 5) {
      const skip2 = this.version < 9 ? 4 : 8;
      this.normExpectedValueVectorsPosition = this.footerPosition + skip2 + nBytes;
    }
    return this;
  }
  async printIndexStats() {
    let totalSize = 0;
    let maxSize = 0;
    let maxKey;
    await await this.init();
    for (let key of Object.keys(this.masterIndex)) {
      const entry = this.masterIndex[key];
      totalSize += entry.size;
      if (entry.size > maxSize) {
        maxSize = entry.size;
        maxKey = key;
      }
    }
    console.log(`${maxSize}  ${maxKey}  ${this.config.url}`);
  }
  async getMatrix(chrIdx1, chrIdx2) {
    const key = Matrix.getKey(chrIdx1, chrIdx2);
    if (this.matrixCache.has(key)) {
      return this.matrixCache.get(key);
    } else {
      const matrix = await this.readMatrix(chrIdx1, chrIdx2);
      this.matrixCache.set(key, matrix);
      return matrix;
    }
  }
  async readMatrix(chrIdx1, chrIdx2) {
    await this.init();
    if (chrIdx1 > chrIdx2) {
      const tmp = chrIdx1;
      chrIdx1 = chrIdx2;
      chrIdx2 = tmp;
    }
    const key = Matrix.getKey(chrIdx1, chrIdx2);
    const idx = this.masterIndex[key];
    if (!idx) {
      return void 0;
    }
    const data = await this.file.read(idx.start, idx.size);
    if (!data) {
      return void 0;
    }
    return Matrix.parseMatrix(data, this.chromosomes);
  }
  async getContactRecords(normalization, region1, region2, units, binsize, allRecords = false) {
    await this.init();
    const idx1 = this.chromosomeIndexMap[this.getFileChrName(region1.chr)];
    const idx2 = this.chromosomeIndexMap[this.getFileChrName(region2.chr)];
    const transpose = idx1 > idx2 || idx1 === idx2 && region1.start >= region2.end;
    if (transpose) {
      const tmp = region1;
      region1 = region2;
      region2 = tmp;
    }
    const blocks = await this.getBlocks(region1, region2, units, binsize);
    if (!blocks || blocks.length === 0) {
      return [];
    }
    const contactRecords = [];
    const x1 = region1.start / binsize;
    const x2 = region1.end / binsize;
    const y1 = region2.start / binsize;
    const y2 = region2.end / binsize;
    const nvX1 = Math.floor(x1);
    const nvX2 = Math.ceil(x2);
    const nvY1 = Math.floor(y1);
    const nvY2 = Math.ceil(y2);
    for (let block of blocks) {
      if (block) {
        let normVector1;
        let normVector2;
        let isNorm = normalization && normalization !== "NONE";
        const chr1 = this.getFileChrName(region1.chr);
        const chr2 = this.getFileChrName(region2.chr);
        if (isNorm) {
          const nv1 = await this.getNormalizationVector(normalization, chr1, units, binsize);
          const nv2 = chr1 === chr2 ? nv1 : await this.getNormalizationVector(normalization, chr2, units, binsize);
          if (nv1 && nv2) {
            normVector1 = await nv1.getValues(nvX1, nvX2);
            normVector2 = await nv2.getValues(nvY1, nvY2);
          } else {
            isNorm = false;
          }
        }
        for (let rec of block.records) {
          if (allRecords || rec.bin1 >= x1 && rec.bin1 < x2 && rec.bin2 >= y1 && rec.bin2 < y2) {
            if (isNorm) {
              const x = rec.bin1;
              const y = rec.bin2;
              const nvnv = normVector1[x - nvX1] * normVector2[y - nvY1];
              if (nvnv !== 0 && !isNaN(nvnv)) {
                const counts = rec.counts / nvnv;
                contactRecords.push(new ContactRecord(x, y, counts));
              }
            } else {
              contactRecords.push(rec);
            }
          }
        }
      }
    }
    return contactRecords;
  }
  async getBlocks(region1, region2, unit, binSize) {
    const blockKey = (blockNumber, zd2) => `${zd2.getKey()}_${blockNumber}`;
    await this.init();
    const chr1 = this.getFileChrName(region1.chr);
    const chr2 = this.getFileChrName(region2.chr);
    const idx1 = this.chromosomeIndexMap[chr1];
    const idx2 = this.chromosomeIndexMap[chr2];
    if (idx1 === void 0) {
      console.log("No chromosome named: " + region1.chr);
      return [];
    }
    if (idx2 === void 0) {
      console.log("No chromosome named: " + region2.chr);
      return [];
    }
    const matrix = await this.getMatrix(idx1, idx2);
    if (!matrix) {
      console.log("No matrix for " + region1.chr + "-" + region2.chr);
      return [];
    }
    const zd = matrix.getZoomData(binSize, unit);
    if (!zd) {
      let msg = `No data avalailble for resolution: ${binSize}  for map ${region1.chr}-${region2.chr}`;
      throw new Error(msg);
    }
    const blockNumbers = zd.getBlockNumbers(region1, region2, this.version);
    const blocks = [];
    const blockNumbersToQuery = [];
    for (let num of blockNumbers) {
      const key = blockKey(num, zd);
      if (this.blockCache.has(binSize, key)) {
        blocks.push(this.blockCache.get(binSize, key));
      } else {
        blockNumbersToQuery.push(num);
      }
    }
    const promises = blockNumbersToQuery.map((blockNumber) => this.readBlock(blockNumber, zd));
    const newBlocks = await Promise.all(promises);
    for (let block of newBlocks) {
      if (block) {
        this.blockCache.set(binSize, blockKey(block.blockNumber, zd), block);
      }
    }
    return blocks.concat(newBlocks);
  }
  async readBlock(blockNumber, zd) {
    const idx = await zd.blockIndex.getBlockIndexEntry(blockNumber);
    if (!idx) {
      return void 0;
    } else {
      let data = await this.file.read(idx.filePosition, idx.size);
      if (!data) {
        return void 0;
      }
      const inflate2 = new Zlib.Inflate(new Uint8Array(data));
      const plain = inflate2.decompress();
      data = plain.buffer;
      const parser = new BinaryParser2(new DataView(data));
      const nRecords = parser.getInt();
      const records = [];
      if (this.version < 7) {
        for (let i = 0; i < nRecords; i++) {
          const binX = parser.getInt();
          const binY = parser.getInt();
          const counts = parser.getFloat();
          records.push(new ContactRecord(binX, binY, counts));
        }
      } else {
        const binXOffset = parser.getInt();
        const binYOffset = parser.getInt();
        const useFloatContact = parser.getByte() === 1;
        const useIntXPos = this.version < 9 ? false : parser.getByte() == 1;
        const useIntYPos = this.version < 9 ? false : parser.getByte() == 1;
        const type = parser.getByte();
        if (type === 1) {
          const rowCount = useIntYPos ? parser.getInt() : parser.getShort();
          for (let i = 0; i < rowCount; i++) {
            const dy = useIntYPos ? parser.getInt() : parser.getShort();
            const binY = binYOffset + dy;
            const colCount = useIntXPos ? parser.getInt() : parser.getShort();
            for (let j = 0; j < colCount; j++) {
              const dx = useIntXPos ? parser.getInt() : parser.getShort();
              const binX = binXOffset + dx;
              const counts = useFloatContact ? parser.getFloat() : parser.getShort();
              records.push(new ContactRecord(binX, binY, counts));
            }
          }
        } else if (type == 2) {
          const nPts = parser.getInt();
          const w = parser.getShort();
          for (let i = 0; i < nPts; i++) {
            const row = Math.floor(i / w);
            const col = i - row * w;
            const bin1 = binXOffset + col;
            const bin2 = binYOffset + row;
            if (useFloatContact) {
              const counts = parser.getFloat();
              if (!isNaN(counts)) {
                records.push(new ContactRecord(bin1, bin2, counts));
              }
            } else {
              const counts = parser.getShort();
              if (counts != Short_MIN_VALUE) {
                records.push(new ContactRecord(bin1, bin2, counts));
              }
            }
          }
        } else {
          throw new Error("Unknown block type: " + type);
        }
      }
      return new Block(blockNumber, zd, records, idx);
    }
  }
  async hasNormalizationVector(type, chr, unit, binSize) {
    await this.init();
    let chrIdx;
    if (Number.isInteger(chr)) {
      chrIdx = chr;
    } else {
      const canonicalName = this.getFileChrName(chr);
      chrIdx = this.chromosomeIndexMap[canonicalName];
    }
    const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);
    const normVectorIndex = await this.getNormVectorIndex();
    return normVectorIndex && normVectorIndex[key];
  }
  async isNormalizationValueAvailableAtResolution(normalization, chr, unit, resolution) {
    let chromosomeIndex;
    if (Number.isInteger(chr)) {
      chromosomeIndex = chr;
    } else {
      const canonicalName = this.getFileChrName(chr);
      chromosomeIndex = this.chromosomeIndexMap[canonicalName];
    }
    const normVectorIndex = await this.getNormVectorIndex();
    const key = getNormalizationVectorKey(normalization, chromosomeIndex, unit.toString(), resolution);
    const index2 = normVectorIndex[key];
    return void 0 !== index2;
  }
  async getNormalizationVector(type, chr, unit, binSize) {
    await this.init();
    let chrIdx;
    if (Number.isInteger(chr)) {
      chrIdx = chr;
    } else {
      const canonicalName = this.getFileChrName(chr);
      chrIdx = this.chromosomeIndexMap[canonicalName];
    }
    const key = getNormalizationVectorKey(type, chrIdx, unit.toString(), binSize);
    if (this.normVectorCache.has(key)) {
      return this.normVectorCache.get(key);
    }
    const normVectorIndex = await this.getNormVectorIndex();
    if (!normVectorIndex) {
      console.log("Normalization vectors not present in this file");
      return void 0;
    }
    const status = await this.isNormalizationValueAvailableAtResolution(type, chr, unit, binSize);
    if (false === status) {
      const str = `Normalization option ${type} not available at resolution ${binSize}. Will use NONE.`;
      console.log(str);
      if (this.alert) {
        this.alert(str);
      }
      return void 0;
    }
    const idx = normVectorIndex[key];
    const data = await this.file.read(idx.filePosition, 8);
    if (!data) {
      return void 0;
    }
    const parser = new BinaryParser2(new DataView(data));
    const nValues = this.version < 9 ? parser.getInt() : parser.getLong();
    const dataType = this.version < 9 ? DOUBLE : FLOAT;
    const filePosition = this.version < 9 ? idx.filePosition + 4 : idx.filePosition + 8;
    const nv = new NormalizationVector(this.file, filePosition, nValues, dataType);
    this.normVectorCache.set(key, nv);
    return nv;
  }
  async getNormVectorIndex() {
    if (this.version < 6) {
      return void 0;
    }
    if (!this.normVectorIndex) {
      if (!this.config.nvi && this.remote && this.url) {
        const url = new URL(this.url);
        const key = encodeURIComponent(url.hostname + url.pathname);
        if (nvi$1.hasOwnProperty(key)) {
          this.config.nvi = nvi$1[key];
        }
      }
      if (this.config.nvi) {
        const nviArray = decodeURIComponent(this.config.nvi).split(",");
        const range = { start: parseInt(nviArray[0]), size: parseInt(nviArray[1]) };
        return this.readNormVectorIndex(range);
      } else {
        try {
          await this.readNormExpectedValuesAndNormVectorIndex();
          return this.normVectorIndex;
        } catch (e) {
          if (e.code === "416" || e.code === 416) {
            this.normExpectedValueVectorsPosition = void 0;
          } else {
            console.error(e);
          }
        }
      }
    }
    return this.normVectorIndex;
  }
  async getNormalizationOptions() {
    await this.getNormVectorIndex();
    return this.normalizationTypes;
  }
  /**
   * Return a promise to load the normalization vector index
   *
   * @param dataset
   * @param range  -- file range {position, size}
   * @returns Promise for the normalization vector index
   */
  async readNormVectorIndex(range) {
    await this.init();
    this.normalizationVectorIndexRange = range;
    const data = await this.file.read(range.start, range.size);
    const binaryParser = new BinaryParser2(new DataView(data));
    this.normVectorIndex = {};
    let nEntries = binaryParser.getInt();
    while (nEntries-- > 0) {
      this.parseNormVectorEntry(binaryParser);
    }
    return this.normVectorIndex;
  }
  /**
   * This function is used when the position of the norm vector index is unknown.  We must read through the expected
   * values to find the index
   *
   * @param dataset
   * @returns {Promise}
   */
  async readNormExpectedValuesAndNormVectorIndex() {
    await this.init();
    if (this.normExpectedValueVectorsPosition === void 0) {
      return;
    }
    const nviStart = await this.skipExpectedValues(this.normExpectedValueVectorsPosition);
    let byteCount = INT;
    let data = await this.file.read(nviStart, INT);
    if (data.byteLength === 0) {
      return;
    }
    const binaryParser = new BinaryParser2(new DataView(data));
    const nEntries = binaryParser.getInt();
    const sizeEstimate = nEntries * 30;
    const range = { start: nviStart + byteCount, size: sizeEstimate };
    data = await this.file.read(range.start, range.size);
    this.normalizedExpectedValueVectors = {};
    this.normVectorIndex = {};
    await processEntries.call(this, nEntries, data);
    this.config.nvi = nviStart.toString() + "," + byteCount;
    async function processEntries(nEntries2, data2) {
      const binaryParser2 = new BinaryParser2(new DataView(data2));
      while (nEntries2-- > 0) {
        if (binaryParser2.available() < 100) {
          nEntries2++;
          byteCount += binaryParser2.position;
          const sizeEstimate2 = Math.max(1e3, nEntries2 * 30);
          const range2 = { start: nviStart + byteCount, size: sizeEstimate2 };
          const data3 = await this.file.read(range2.start, range2.size);
          return processEntries.call(this, nEntries2, data3);
        }
        this.parseNormVectorEntry(binaryParser2);
      }
      byteCount += binaryParser2.position;
    }
  }
  /**
   * This function is used when the position of the norm vector index is unknown.  We must read through the
   * normalized expected values to find the index
   *
   * @param dataset
   * @returns {Promise}
   */
  async skipExpectedValues(start) {
    const version2 = this.version;
    const file = new BufferedFile2({ file: this.file, size: 256e3 });
    const range = { start, size: INT };
    const data = await file.read(range.start, range.size);
    const binaryParser = new BinaryParser2(new DataView(data));
    const nEntries = binaryParser.getInt();
    if (nEntries === 0) {
      return start + INT;
    } else {
      return parseNext(start + INT, nEntries);
    }
    async function parseNext(start2, nEntries2) {
      let range2 = { start: start2, size: 500 };
      let chunkSize = 0;
      let p0 = start2;
      let data2 = await file.read(range2.start, range2.size);
      let binaryParser2 = new BinaryParser2(new DataView(data2));
      binaryParser2.getString();
      binaryParser2.getString();
      binaryParser2.getInt();
      const nValues = version2 < 9 ? binaryParser2.getInt() : binaryParser2.getLong();
      chunkSize += binaryParser2.position + nValues * (version2 < 9 ? DOUBLE : FLOAT);
      range2 = { start: start2 + chunkSize, size: INT };
      data2 = await file.read(range2.start, range2.size);
      binaryParser2 = new BinaryParser2(new DataView(data2));
      const nChrScaleFactors = binaryParser2.getInt();
      chunkSize += INT + nChrScaleFactors * (INT + (version2 < 9 ? DOUBLE : FLOAT));
      nEntries2--;
      if (nEntries2 === 0) {
        return p0 + chunkSize;
      } else {
        return parseNext(p0 + chunkSize, nEntries2);
      }
    }
  }
  getZoomIndexForBinSize(binSize, unit) {
    unit = unit || "BP";
    let resolutionArray;
    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }
    for (let i = 0; i < resolutionArray.length; i++) {
      if (resolutionArray[i] === binSize) return i;
    }
    return -1;
  }
  parseNormVectorEntry(binaryParser) {
    const type = binaryParser.getString();
    const chrIdx = binaryParser.getInt();
    const unit = binaryParser.getString();
    const binSize = binaryParser.getInt();
    const filePosition = binaryParser.getLong();
    const sizeInBytes = this.version < 9 ? binaryParser.getInt() : binaryParser.getLong();
    const key = type + "_" + chrIdx + "_" + unit + "_" + binSize;
    if (!this.normalizationTypes.includes(type)) {
      this.normalizationTypes.push(type);
    }
    this.normVectorIndex[key] = { filePosition, size: sizeInBytes };
  }
  getFileChrName(chrAlias) {
    if (this.chrAliasTable.hasOwnProperty(chrAlias)) {
      return this.chrAliasTable[chrAlias];
    } else {
      return chrAlias;
    }
  }
  // NOTE sties are not currently used
  // async getSites(chrName) {
  //     let sites = this.fragmentSitesCache[chrName];
  //     if (!sites) {
  //         if (this.fragmentSitesIndex) {
  //             const entry = self.fragmentSitesIndex[chrName];
  //             if (entry && entry.nSites > 0) {
  //                 sites = await this.readSites(entry.position, entry.nSites)
  //                 this.fragmentSitesCache[chrName] = sites;
  //             }
  //         }
  //     }
  //     return sites;
  // }
  //
}
function getNormalizationVectorKey(type, chrIdx, unit, resolution) {
  return type + "_" + chrIdx + "_" + unit + "_" + resolution;
}
function isGoogleDrive(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
}
class Block {
  constructor(blockNumber, zoomData, records, idx) {
    this.blockNumber = blockNumber;
    this.zoomData = zoomData;
    this.records = records;
    this.idx = idx;
  }
}
class BlockCache {
  constructor() {
    this.resolution = void 0;
    this.map = new LRU(6);
  }
  set(resolution, key, value) {
    if (this.resolution !== resolution) {
      this.map.clear();
    }
    this.resolution = resolution;
    this.map.set(key, value);
  }
  get(resolution, key) {
    return this.resolution === resolution ? this.map.get(key) : void 0;
  }
  has(resolution, key) {
    return this.resolution === resolution && this.map.has(key);
  }
}
class Straw {
  constructor(config) {
    this.config = config;
    this.hicFile = new HicFile(config);
  }
  async getMetaData() {
    return await this.hicFile.getMetaData();
  }
  //straw <NONE/VC/VC_SQRT/KR> <ile> <chr1>[:x1:x2] <chr2>[:y1:y2] <BP/FRAG> <binsize>
  async getContactRecords(normalization, region1, region2, units, binsize) {
    return this.hicFile.getContactRecords(normalization, region1, region2, units, binsize);
  }
  async getNormalizationOptions() {
    return this.hicFile.getNormalizationOptions();
  }
  async getNVI() {
    await this.hicFile.getNormVectorIndex();
    return this.hicFile.config.nvi;
  }
  async printIndexStats() {
    await this.hicFile.printIndexStats();
  }
  getFileChrName(chrAlias) {
    if (this.hicFile.chrAliasTable.hasOwnProperty(chrAlias)) {
      return this.hicFile.chrAliasTable[chrAlias];
    } else {
      return chrAlias;
    }
  }
}
function isGoogleURL(url) {
  return url.includes("googleapis") && !url.includes("urlshortener") || isGoogleStorageURL(url) || isGoogleDriveURL(url);
}
function isGoogleStorageURL(url) {
  return url.startsWith("gs://") || url.startsWith("https://www.googleapis.com/storage") || url.startsWith("https://storage.cloud.google.com") || url.startsWith("https://storage.googleapis.com");
}
function isGoogleDriveURL(url) {
  return url.indexOf("drive.google.com") >= 0 || url.indexOf("www.googleapis.com/drive") > 0;
}
const encodings = /* @__PURE__ */ new Map();
encodings.set("!", "%21");
encodings.set("#", "%23");
encodings.set("$", "%24");
encodings.set("%", "%25");
encodings.set("&", "%26");
encodings.set("'", "%27");
encodings.set("(", "%28");
encodings.set(")", "%29");
encodings.set("*", "%2A");
encodings.set("+", "%2B");
encodings.set(",", "%2C");
encodings.set("/", "%2F");
encodings.set(":", "%3A");
encodings.set(";", "%3B");
encodings.set("=", "%3D");
encodings.set("?", "%3F");
encodings.set("@", "%40");
encodings.set("[", "%5B");
encodings.set("]", "%5D");
encodings.set(" ", "%20");
function getDriveDownloadURL(link2) {
  var id = getGoogleDriveFileID(link2);
  return id ? "https://www.googleapis.com/drive/v3/files/" + id + "?alt=media&supportsTeamDrives=true" : link2;
}
function getGoogleDriveFileID(link2) {
  if (link2.includes("/open?id=")) {
    const i1 = link2.indexOf("/open?id=") + 9;
    const i2 = link2.indexOf("&");
    if (i1 > 0 && i2 > i1) {
      return link2.substring(i1, i2);
    } else if (i1 > 0) {
      return link2.substring(i1);
    }
  } else if (link2.includes("/file/d/")) {
    const i1 = link2.indexOf("/file/d/") + 8;
    const i2 = link2.lastIndexOf("/");
    return link2.substring(i1, i2);
  } else if (link2.startsWith("https://www.googleapis.com/drive")) {
    let i1 = link2.indexOf("/files/");
    const i2 = link2.indexOf("?");
    if (i1 > 0) {
      i1 += 7;
      return i2 > 0 ? link2.substring(i1, i2) : link2.substring(i1);
    }
  }
  throw Error("Unknown Google Drive url format: " + link2);
}
class IGVRemoteFile {
  constructor(args) {
    this.config = args;
    this.url = args.path || args.url;
  }
  async read(position, length) {
    const range = { start: position, size: length };
    return igvxhr$1.loadArrayBuffer(this.url, { range });
  }
}
const knownGenomes = {
  "hg19": [249250621, 243199373, 198022430],
  "hg38": [248956422, 242193529, 198295559],
  "mm10": [195471971, 182113224, 160039680],
  "mm9": [197195432, 181748087, 159599783],
  "dm6": [23513712, 25286936, 28110227]
};
class Dataset2 {
  constructor(config) {
    this.straw = new Straw(config);
  }
  async init() {
    this.hicFile = this.straw.hicFile;
    await this.hicFile.init();
    this.normalizationTypes = ["NONE"];
    this.genomeId = this.hicFile.genomeId;
    this.chromosomes = this.hicFile.chromosomes;
    this.bpResolutions = this.hicFile.bpResolutions;
    this.wholeGenomeChromosome = this.hicFile.wholeGenomeChromosome;
    this.wholeGenomeResolution = this.hicFile.wholeGenomeResolution;
    const tmp = matchGenome(this.chromosomes);
    if (tmp) this.genomeId = tmp;
  }
  async getContactRecords(normalization, region1, region2, units, binsize) {
    return this.straw.getContactRecords(normalization, region1, region2, units, binsize);
  }
  async hasNormalizationVector(type, chr, unit, binSize) {
    return this.straw.hicFile.hasNormalizationVector(type, chr, unit, binSize);
  }
  clearCaches() {
    this.colorScaleCache = {};
  }
  async getMatrix(chr1, chr2) {
    return this.hicFile.getMatrix(chr1, chr2);
  }
  getZoomIndexForBinSize(binSize, unit) {
    var i, resolutionArray;
    unit = unit || "BP";
    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }
    for (i = 0; i < resolutionArray.length; i++) {
      if (resolutionArray[i] === binSize) return i;
    }
    return -1;
  }
  getBinSizeForZoomIndex(zoomIndex, unit) {
    var resolutionArray;
    unit = unit || "BP";
    if (unit === "BP") {
      resolutionArray = this.bpResolutions;
    } else if (unit === "FRAG") {
      resolutionArray = this.fragResolutions;
    } else {
      throw new Error("Invalid unit: " + unit);
    }
    return resolutionArray[zoomIndex];
  }
  getChrIndexFromName(chrName) {
    var i;
    for (i = 0; i < this.chromosomes.length; i++) {
      if (chrName === this.chromosomes[i].name) return i;
    }
    return void 0;
  }
  compareChromosomes(otherDataset) {
    const chrs = this.chromosomes;
    const otherChrs = otherDataset.chromosomes;
    if (chrs.length !== otherChrs.length) {
      return false;
    }
    for (let i = 0; i < chrs.length; i++) {
      if (chrs[i].size !== otherChrs[i].size) {
        return false;
      }
    }
    return true;
  }
  isWholeGenome(chrIndex) {
    return this.wholeGenomeChromosome != null && this.wholeGenomeChromosome.index === chrIndex;
  }
  async getNormVectorIndex() {
    return this.hicFile.getNormVectorIndex();
  }
  async getNormalizationOptions() {
    return this.hicFile.getNormalizationOptions();
  }
  /**
   * Compare 2 datasets for compatibility.  Compatibility is defined as from the same assembly, even if
   * different IDs are used (e.g. GRCh38 vs hg38).
   *
   * Trust the ID for well-known assemblies (hg19, etc).  However, for others compare chromosome lengths
   * as its been observed that uniqueness of ID is not guaranteed.
   *
   * @param d1
   * @param d2
   */
  isCompatible(d2) {
    const id1 = this.genomeId;
    const id2 = d2.genomeId;
    return (id1 === "hg38" || id1 === "GRCh38") && (id2 === "hg38" || id2 === "GRCh38") || (id1 === "hg19" || id1 === "GRCh37") && (id2 === "hg19" || id2 === "GRCh37") || (id1 === "mm10" || id1 === "GRCm38") && (id2 === "mm10" || id2 === "GRCm38") || this.compareChromosomes(d2);
  }
  static async loadDataset(config) {
    if (isFile(config.url)) {
      config.blob = config.url;
      delete config.url;
    } else {
      if (isGoogleURL(config.url)) {
        if (isGoogleDriveURL(config.url)) {
          config.url = getDriveDownloadURL(config.url);
        }
        const copy = Object.assign({}, config);
        config.file = new IGVRemoteFile(copy);
      }
    }
    const dataset = new Dataset2(config);
    await dataset.init();
    dataset.url = config.url;
    return dataset;
  }
}
function matchGenome(chromosomes) {
  if (chromosomes.length < 4) return void 0;
  const keys = Object.keys(knownGenomes);
  let candidate;
  for (let chr of chromosomes) {
    for (let key of keys) {
      if (knownGenomes[key].includes(chr.size)) {
        candidate = key;
        break;
      }
    }
  }
  if (candidate) {
    const chrSizes = new Set(chromosomes.map((chr) => chr.size));
    for (let sz of knownGenomes[candidate]) {
      if (!chrSizes.has(sz)) {
        return void 0;
      }
    }
    return candidate;
  } else {
    return void 0;
  }
}
class Genome2 {
  constructor(id, chromosomes) {
    this.id = id;
    this.chromosomes = chromosomes;
    this.wgChromosomeNames = [];
    this.chromosomeLookupTable = {};
    this.genomeLength = 0;
    for (let c of this.chromosomes) {
      c.bpLength = c.size;
      if ("all" !== c.name.toLowerCase()) {
        this.genomeLength += c.size;
        this.wgChromosomeNames.push(c.name);
      }
    }
    var chrAliasTable = {};
    for (let chromosome of chromosomes) {
      const name2 = chromosome.name;
      if (name2.startsWith("arm_")) {
        const officialName = name2.substring(4);
        chrAliasTable[officialName] = name2;
        chrAliasTable["chr" + officialName] = name2;
      } else {
        const alias = name2.startsWith("chr") ? name2.substring(3) : "chr" + name2;
        chrAliasTable[alias] = name2;
        if (name2 === "chrM") chrAliasTable["MT"] = "chrM";
        if (name2 === "MT") chrAliasTable["chrmM"] = "MT";
      }
      this.chromosomeLookupTable[name2.toLowerCase()] = chromosome;
    }
    this.chrAliasTable = chrAliasTable;
    this.featureDB = /* @__PURE__ */ new Map();
  }
  getChromosomeName(str) {
    var chr = this.chrAliasTable[str];
    return chr ? chr : str;
  }
  getChromosome(str) {
    var chrname = this.getChromosomeName(str).toLowerCase();
    return this.chromosomeLookupTable[chrname];
  }
  /**
   * Return the genome coordinate for the give chromosome and position.
   */
  getGenomeCoordinate(chr, bp) {
    return this.getCumulativeOffset(chr.name) + bp;
  }
  getChromosomeForCoordinate(bp) {
    var i = 0, offset2 = 0, l;
    for (i = 1; i < this.chromosomes.length; i++) {
      l = this.chromosomes[i].size;
      if (offset2 + l > bp) return this.chromosomes[i];
      offset2 += l;
    }
    return this.chromosomes[this.chromosomes.length - 1];
  }
  /**
   * Return the offset in genome coordinates (kb) of the start of the given chromosome
   */
  getCumulativeOffset(chr) {
    const queryChr = this.getChromosomeName(chr);
    if (this.cumulativeOffsets === void 0) {
      computeCumulativeOffsets$1.call(this);
    }
    return this.cumulativeOffsets[queryChr];
  }
  // Required for igv.js
  getGenomeLength() {
    return this.genomeLength;
  }
  // Required for igv.js
  addFeaturesToDB(featureList, config) {
    const insertFeature = (name2, feature2) => {
      const current = this.featureDB.get(name2);
      if (current) {
        feature2 = feature2.end - feature2.start > current.end - current.start ? feature2 : current;
      }
      this.featureDB.set(name2, feature2);
    };
    for (let feature2 of featureList) {
      if (feature2.name) {
        insertFeature(feature2.name.toUpperCase(), feature2);
      }
      if (feature2.gene && feature2.gene.name) {
        insertFeature(feature2.gene.name.toUpperCase(), feature2);
      }
    }
  }
}
function computeCumulativeOffsets$1() {
  const cumulativeOffsets = {};
  let offset2 = 0;
  for (let chromosome of this.chromosomes) {
    if (chromosome.name === "all") continue;
    cumulativeOffsets[chromosome.name] = Math.floor(offset2);
    offset2 += chromosome.size;
  }
  this.cumulativeOffsets = cumulativeOffsets;
}
class State {
  constructor(chr1, chr2, locus, zoom, x, y, pixelSize, normalization) {
    if (chr1 <= chr2) {
      this.chr1 = chr1;
      this["x"] = x;
      this.chr2 = chr2;
      this["y"] = y;
    } else {
      this.chr1 = chr2;
      this["x"] = y;
      this.chr2 = chr1;
      this["y"] = x;
    }
    this.zoom = zoom;
    if (void 0 === normalization) {
      console.warn("Normalization is undefined. Will use NONE");
      normalization = "NONE";
    }
    this.normalization = normalization;
    if (Number.isNaN(pixelSize)) {
      pixelSize = 1;
    }
    this.pixelSize = pixelSize;
    this.locus = locus;
  }
  // Getters and setters for width and height
  // get width() {
  //     return this._width;
  // }
  //
  // set width(value) {
  //     this._width = value;
  // }
  //
  // get height() {
  //     return this._height;
  // }
  //
  // set height(value) {
  //     this._height = value;
  // }
  clampXY(dataset, viewDimensions) {
    const { width, height } = viewDimensions;
    const { chromosomes, bpResolutions } = dataset;
    const binSize = bpResolutions[this.zoom];
    const maxX = Math.max(0, chromosomes[this.chr1].size / binSize - width / this.pixelSize);
    const maxY = Math.max(0, chromosomes[this.chr2].size / binSize - height / this.pixelSize);
    this.x = Math.min(Math.max(0, this.x), maxX);
    this.y = Math.min(Math.max(0, this.y), maxY);
  }
  async panWithZoom(zoom, pixelSize, anchorPx, anchorPy, binSize, browser, dataset, viewDimensions, bpResolutions) {
    const minPixelSize = await browser.minPixelSize(this.chr1, this.chr2, zoom);
    pixelSize = Math.max(pixelSize, minPixelSize);
    bpResolutions[this.zoom];
    const gx = (this.x + anchorPx / this.pixelSize) * bpResolutions[this.zoom].binSize;
    const gy = (this.y + anchorPy / this.pixelSize) * bpResolutions[this.zoom].binSize;
    this.x = gx / binSize - anchorPx / pixelSize;
    this.y = gy / binSize - anchorPy / pixelSize;
    this.zoom = zoom;
    this.pixelSize = pixelSize;
    this.clampXY(dataset, viewDimensions);
  }
  panShift(dx, dy, browser, dataset, viewDimensions) {
    this.x += dx / this.pixelSize;
    this.y += dy / this.pixelSize;
    this.clampXY(dataset, viewDimensions);
    this.configureLocus(browser, dataset, viewDimensions);
  }
  async setWithZoom(zoom, viewDimensions, browser, dataset) {
    const { width, height } = viewDimensions;
    const xCenter = this.x + width / 2 / this.pixelSize;
    const yCenter = this.y + height / 2 / this.pixelSize;
    const binSize = dataset.bpResolutions[this.zoom];
    const binSizeNew = dataset.bpResolutions[zoom];
    const scaleFactor = binSize / binSizeNew;
    const xCenterNew = xCenter * scaleFactor;
    const yCenterNew = yCenter * scaleFactor;
    const minPixelSize = await browser.minPixelSize(this.chr1, this.chr2, zoom);
    this.pixelSize = Math.max(DEFAULT_PIXEL_SIZE, minPixelSize);
    const resolutionChanged = this.zoom !== zoom;
    this.zoom = zoom;
    this.x = Math.max(0, xCenterNew - width / (2 * this.pixelSize));
    this.y = Math.max(0, yCenterNew - height / (2 * this.pixelSize));
    this.clampXY(dataset, viewDimensions);
    this.configureLocus(browser, dataset, viewDimensions);
    return resolutionChanged;
  }
  configureLocus(browser, dataset, viewDimensions) {
    const bpPerBin = dataset.bpResolutions[this.zoom];
    const startBP1 = Math.round(this.x * bpPerBin);
    const startBP2 = Math.round(this.y * bpPerBin);
    const chr1 = dataset.chromosomes[this.chr1];
    const chr2 = dataset.chromosomes[this.chr2];
    const pixelsPerBin = this.pixelSize;
    const endBP1 = Math.min(chr1.size, Math.round(viewDimensions.width / pixelsPerBin * bpPerBin) + startBP1);
    const endBP2 = Math.min(chr2.size, Math.round(viewDimensions.height / pixelsPerBin * bpPerBin) + startBP2);
    const x = { chr: chr1.name, start: startBP1, end: endBP1 };
    const y = { chr: chr2.name, start: startBP2, end: endBP2 };
    this.locus = { x, y };
  }
  updateWithLoci(chr1Name, bpX, bpXMax, chr2Name, bpY, bpYMax, browser, width, height) {
    const bpResolutions = browser.getResolutions();
    let bpPerPixelTarget = Math.max((bpXMax - bpX) / width, (bpYMax - bpY) / height);
    let resolutionChanged;
    let zoomNew;
    if (true === browser.resolutionLocked) {
      resolutionChanged = false;
      zoomNew = this.zoom;
    } else {
      zoomNew = browser.findMatchingZoomIndex(bpPerPixelTarget, bpResolutions);
      resolutionChanged = zoomNew !== this.zoom;
    }
    const { binSize: binSizeNew } = bpResolutions[zoomNew];
    const pixelSize = Math.min(MAX_PIXEL_SIZE, Math.max(1, binSizeNew / bpPerPixelTarget));
    const newXBin = bpX / binSizeNew;
    const newYBin = bpY / binSizeNew;
    const { index: chr1Index } = browser.genome.getChromosome(chr1Name);
    const { index: chr2Index } = browser.genome.getChromosome(chr2Name);
    const chrChanged = this.chr1 !== chr1Index || this.chr2 !== chr2Index;
    this.chr1 = chr1Index;
    this.chr2 = chr2Index;
    this.zoom = zoomNew;
    this.x = newXBin;
    this.y = newYBin;
    this.pixelSize = pixelSize;
    this.locus = {
      x: { chr: chr1Name, start: bpX, end: bpXMax },
      y: { chr: chr2Name, start: bpY, end: bpYMax }
    };
    return { chrChanged, resolutionChanged };
  }
  sync(targetState, browser, genome, dataset) {
    const chr1 = genome.getChromosome(targetState.chr1Name);
    const chr2 = genome.getChromosome(targetState.chr2Name);
    const bpPerPixelTarget = targetState.binSize / targetState.pixelSize;
    const zoomNew = browser.findMatchingZoomIndex(bpPerPixelTarget, dataset.bpResolutions);
    const binSizeNew = dataset.bpResolutions[zoomNew];
    const pixelSizeNew = Math.min(MAX_PIXEL_SIZE, Math.max(1, binSizeNew / bpPerPixelTarget));
    const xBinNew = targetState.binX * (targetState.binSize / binSizeNew);
    const yBinNew = targetState.binY * (targetState.binSize / binSizeNew);
    const zoomChanged = browser.state.zoom !== zoomNew;
    const chrChanged = browser.state.chr1 !== chr1.index || browser.state.chr2 !== chr2.index;
    this.chr1 = chr1.index;
    this.chr2 = chr2.index;
    this.zoom = zoomNew;
    this.x = xBinNew;
    this.y = yBinNew;
    this.pixelSize = pixelSizeNew;
    this.configureLocus(browser, dataset, browser.contactMatrixView.getViewDimensions());
    return { zoomChanged, chrChanged };
  }
  stringify() {
    if (this.normalization) {
      return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},0,0,${this.pixelSize},${this.normalization}`;
    } else {
      return `${this.chr1},${this.chr2},${this.zoom},${this.x},${this.y},0,0,${this.pixelSize}`;
    }
  }
  clone() {
    return Object.assign(new State(), this);
  }
  equals(state) {
    const s1 = JSON.stringify(this);
    const s2 = JSON.stringify(state);
    return s1 === s2;
  }
  async sizeBP(dataset, zoomIndex, pixels) {
    const matrix = await dataset.getMatrix(this.chr1, this.chr2);
    const { zoom } = matrix.getZoomDataByIndex(zoomIndex, "BP");
    return pixels * (zoom.binSize / this.pixelSize);
  }
  static parse(string) {
    const tokens = string.split(",");
    if (tokens.length <= 7) {
      return new State(
        parseInt(tokens[0]),
        // chr1
        parseInt(tokens[1]),
        // chr2
        void 0,
        // locus
        parseFloat(tokens[2]),
        // zoom
        parseFloat(tokens[3]),
        // x
        parseFloat(tokens[4]),
        // y
        parseFloat(tokens[5]),
        // pixelSize
        tokens.length > 6 ? tokens[6] : "NONE"
        // normalization
      );
    } else {
      return new State(
        parseInt(tokens[0]),
        // chr1
        parseInt(tokens[1]),
        // chr2
        void 0,
        // locus
        parseFloat(tokens[2]),
        // zoom
        parseFloat(tokens[3]),
        // x
        parseFloat(tokens[4]),
        // y
        parseFloat(tokens[7]),
        // pixelSize
        tokens.length > 8 ? tokens[8] : "NONE"
        // normalization
      );
    }
  }
  // Method 1: Convert the State object to a JSON object
  toJSON() {
    const json = {
      chr1: this.chr1,
      chr2: this.chr2,
      zoom: this.zoom,
      x: this.x,
      y: this.y,
      pixelSize: this.pixelSize,
      normalization: this.normalization || "NONE"
    };
    if (this.locus) {
      json.locus = this.locus;
    }
    return json;
  }
  // Method 2: Parse a JSON object and create an instance of the State class
  static fromJSON(json) {
    return new State(
      json.chr1,
      json.chr2,
      json.locus,
      json.zoom,
      json.x,
      json.y,
      json.pixelSize,
      json.normalization
    );
  }
  static default(configOrUndefined) {
    const state = new State(0, 0, void 0, 0, 0, 1, "NONE");
    return state;
  }
}
const nvi = {
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined.hic": "54386046426,55860",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fprimary.hic": "33860030033,37504",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Freplicate.hic": "30849652794,55832",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fmaternal.hic": "1380542661,17185",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fpaternal.hic": "1389001777,17185",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2Fcombined.hic": "13433880319,35723",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC001.hic": "3409347253,35975",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC002.hic": "4529947083,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC003.hic": "6894962500,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC004.hic": "3395593338,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC005.hic": "5204128636,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC006.hic": "3278363811,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC007.hic": "3585547340,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC008.hic": "4134197273,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC009.hic": "2851728310,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC010.hic": "1754216102,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC011.hic": "1716829574,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC012.hic": "4367980375,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC013.hic": "2309654671,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC014.hic": "5324950266,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC015.hic": "3132333594,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC016.hic": "3159154704,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC017.hic": "3262554627,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC018.hic": "3014216364,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC019.hic": "5025753246,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC020.hic": "5861584507,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC021.hic": "3542263275,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC022.hic": "5061949378,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC023.hic": "4816423919,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC024.hic": "2683781104,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC025.hic": "6522701781,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC026.hic": "6748846520,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC027.hic": "5642693007,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC028.hic": "2098921691,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC029.hic": "3886454027,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fagar%2FHIC030.hic": "2288984204,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fagar%2FHIC031.hic": "2115342419,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fpellet%2FHIC032.hic": "2063314324,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fsupernatant%2FHIC033.hic": "1933908457,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC034.hic": "13555514595,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC035.hic": "6129650900,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC036.hic": "4307445019,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2FHIC037.hic": "9375139867,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fdilution%2Fcombined.hic": "11664249584,33929",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined_DpnII.hic": "7003537290,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC038.hic": "2099825544,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC039.hic": "2096900138,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC040.hic": "2593642141,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC041.hic": "2263919098,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC042.hic": "2684774693,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2Fcombined_noXlink.hic": "5574807456,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC043.hic": "2986114347,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC044.hic": "1916378621,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC045.hic": "746463126,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC046.hic": "2338476164,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC047.hic": "1167496250,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC048.hic": "2231690794,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fin-situ%2FHIC049.hic": "2782308678,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC050.hic": "3633531346,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC051.hic": "4063486444,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC052.hic": "929756278,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC053.hic": "2489657204,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC054.hic": "4036419444,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC055.hic": "4284185549,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fin-situ%2FHIC056.hic": "4410546240,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fimr90%2Fdilution%2FHIC057.hic": "1491998259,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2Fcombined.hic": "7266425111,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC058.hic": "6532635593,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC059.hic": "400684530,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC060.hic": "645352187,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC061.hic": "736291871,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC062.hic": "762731037,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fin-situ%2FHIC063.hic": "682917431,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhmec%2Fdilution%2FHIC064.hic": "4550171307,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2Fcombined.hic": "11897184911,35789",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC065.hic": "5425943567,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC066.hic": "5942869818,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fin-situ%2FHIC067.hic": "5191049261,35647",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fnhek%2Fdilution%2FHIC068.hic": "2713318801,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2Fcombined.hic": "12641555389,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC069.hic": "5630177461,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC070.hic": "5926611269,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC071.hic": "2486191351,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC072.hic": "2281343366,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC073.hic": "2173074239,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fk562%2Fin-situ%2FHIC074.hic": "2463700999,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2Fcombined.hic": "14661922519,35639",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC075.hic": "3685310515,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC076.hic": "5833658487,35891",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC077.hic": "2406346486,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC078.hic": "5241454987,35919",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fkbm7%2Fin-situ%2FHIC079.hic": "6297234263,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2Fcombined.hic": "9193858096,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC080.hic": "5171405536,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC081.hic": "3489767688,35891",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fin-situ%2FHIC082.hic": "4243339375,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhuvec%2Fdilution%2FHIC083.hic": "1497495406,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2Fcombined.hic": "7923332224,35593",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC084.hic": "867699123,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC085.hic": "3669518514,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC086.hic": "5306474712,35595",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhela%2Fin-situ%2FHIC087.hic": "1490963755,36397",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2Fcombined.hic": "8956382853,50248",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC088.hic": "1874185366,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC089.hic": "1301165236,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC090.hic": "1105246282,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC091.hic": "1338325770,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC092.hic": "1307918730,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC093.hic": "755136918,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC094.hic": "1606583694,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC095.hic": "2039711245,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC096.hic": "1909573053,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC097.hic": "1826710712,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC098.hic": "1998793575,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC099.hic": "1007740962,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC100.hic": "736464120,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC101.hic": "980505082,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fin-situ%2FHIC102.hic": "1116083646,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fdilution%2FHIC103.hic": "1096994310,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fch12-lx-b-lymphoblasts%2Fdilution%2FHIC104.hic": "841063882,32102",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC105.hic": "107742864,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC106.hic": "134295912,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC107.hic": "110228014,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC108.hic": "102761401,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC109.hic": "100461491,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC110.hic": "88828472,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC111.hic": "81471064,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC112.hic": "92297035,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC113.hic": "65503916,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC114.hic": "49181188,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC115.hic": "46471102,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC116.hic": "64284432,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC117.hic": "60434076,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC118.hic": "45248563,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC119.hic": "60288782,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC120.hic": "136888414,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC121.hic": "125009003,33681",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC122.hic": "154011688,34127",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC123.hic": "177663372,35293",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC124.hic": "382186226,35245",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC125.hic": "158160717,35271",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC127.hic": "110261177,34659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC128.hic": "246131875,35509",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC129.hic": "260160119,35667",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC130.hic": "117479562,34681",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC131.hic": "81508929,34673",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC132.hic": "105959102,34895",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC133.hic": "91504812,33451",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC134.hic": "52222546,33737",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC135.hic": "57763085,34159",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC136.hic": "50618489,33731",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC137.hic": "193163606,33363",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC138.hic": "229876152,33777",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC139.hic": "201783666,33571",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC140.hic": "281163862,34125",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC141.hic": "275969727,33935",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC142.hic": "275020431,34125",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC144.hic": "223834810,34177",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC145.hic": "296632653,33937",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC146.hic": "290945216,33961",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC147.hic": "234459964,34231",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC148.hic": "295457850,34039",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC149.hic": "113569632,35695",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC150.hic": "304381897,33963",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC151.hic": "289314545,33805",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC152.hic": "284320182,33803",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC153.hic": "401393947,34659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC154.hic": "188065488,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC155.hic": "299157119,33967",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC156.hic": "279289244,33787",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC157.hic": "254852119,33917",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC158.hic": "195969660,33477",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC159.hic": "185720388,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC160.hic": "227709279,33599",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC161.hic": "157225076,33209",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC162.hic": "105703444,32033",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC163.hic": "122665658,32121",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC164.hic": "228048231,33761",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC165.hic": "114440819,32011",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC166.hic": "285147558,33891",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC167.hic": "363116754,33943",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC168.hic": "119592158,31937",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC169.hic": "236853872,33785",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC170.hic": "195187639,33395",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC171.hic": "208044058,33309",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC172.hic": "144645916,32877",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC173.hic": "119115941,32203",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC175.hic": "178030481,33525",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC176.hic": "117220136,32169",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC177.hic": "128586196,32659",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC178.hic": "191419141,33629",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC179.hic": "141556748,32959",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC180.hic": "199825102,33185",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC181.hic": "301022688,33783",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC182.hic": "185384453,33205",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC183.hic": "202189264,36367",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC184.hic": "37464475,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC185.hic": "161938278,36099",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC186.hic": "133853166,36179",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC188.hic": "128068030,36237",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC189.hic": "148053886,36177",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC190.hic": "198946958,35803",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC191.hic": "226584564,36063",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC192.hic": "194412797,36341",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC193.hic": "176408194,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC194.hic": "207215649,36055",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC195.hic": "175185530,36315",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC196.hic": "168969337,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC197.hic": "121231252,36339",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC198.hic": "92713752,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC199.hic": "105130500,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC200.hic": "114526350,36479",
  "hicfiles.s3.amazonaws.com%2Fmiseq%2Frh2014%2FHIC201.hic": "122689717,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fhap1%2Fin-situ%2Fcombined.hic": "9614983328,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fctbp_8_4_17%2Fall_intra_megabase_michrom.hic": "154205644,10960",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2Fdel-Xa-combined.hic": "8843305329,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FdelXa-chrX-diploid.hic": "11173520,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FWT-combined.hic": "13365182403,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FWT-chrX-diploid.hic": "17343459,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC002.hic": "4279298739,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC003.hic": "3027365532,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC004.hic": "2896130835,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC005.hic": "4717830071,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC006.hic": "5066210154,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC007.hic": "3069516128,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2Fdel-Xi-combined.hic": "14551096423,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FdelXi-chrX-diploid.hic": "17362477,1498",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC008.hic": "2572386655,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC009.hic": "2935931663,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC010.hic": "2019085070,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC011.hic": "6087610814,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC012.hic": "2809618194,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frpe1%2FDarrowHuntley-2015%2FHIC013.hic": "2572386655,36479",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fcombined.hic": "6950423609,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fpaternal.hic": "220592749,15691",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2Fmaternal.hic": "323233095,15691",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC014.hic": "3183235800,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC015.hic": "1739539801,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC016.hic": "1105912758,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC017.hic": "1060773319,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC018.hic": "1203679874,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fpatski%2FDarrowHuntley-2015%2FHIC019.hic": "3321955269,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Frhesus%2FDarrowHuntley-2015%2FHIC020.hic": "7108980626,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fgm12878%2Fcola%2FDarrowHuntley-2015%2FHIC021.hic": "3906448676,34955",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2Faedes%2Fcombined.hic": "390780490,2245",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2Fhs2-hic.hic": "1960284186,33561",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2Fassembly%2FCpipJ3.hic": "766279097,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fphanstiel%2Fupdated_O%2FSnyder_O.hic": "8046980555,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fphanstiel%2FA_inter.hic": "10986005145,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2Fcombined.hic": "30439217680,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2Fcombined.hic": "33255540403,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F20min_withdraw_combined.hic": "11078436933,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F40min_withdraw_combined.hic": "11031830038,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F60min_withdraw_combined.hic": "10312725340,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Fdeep%2F180min_withdraw_combined.hic": "10038610214,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC001.hic": "8004335785,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC002.hic": "8453215933,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC003.hic": "9118406189,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC004.hic": "5973342894,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC005.hic": "6846576837,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC006.hic": "6075148017,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Funsynchronized%2FHIC007.hic": "8192366992,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC008.hic": "6844159653,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC009.hic": "7282063059,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC010.hic": "10410578833,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC011.hic": "8192366992,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC012.hic": "7223422850,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC013.hic": "7435986997,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Funsynchronized%2FHIC014.hic": "9120113605,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2Fcombined.hic": "4170577904,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC015.hic": "1504084990,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC016.hic": "1686244500,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC017.hic": "1804802410,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Funtreated%2Fsynchronized%2FHIC018.hic": "1533942067,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2Fcombined.hic": "4572390198,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC019.hic": "1543609666,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC020.hic": "1814133288,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC021.hic": "1942698243,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftreated_6hr%2Fsynchronized%2FHIC022.hic": "1873587413,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC049.hic": "405127557,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC060.hic": "326681741,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2Funtreated%2FRao-2017-HIC061.hic": "300908673,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_20min%2FRao-2017-HIC050.hic": "481758242,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_20min%2FRao-2017-HIC051.hic": "417577401,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_40min%2FRao-2017-HIC052.hic": "419353227,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_40min%2FRao-2017-HIC053.hic": "411554953,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_60min%2FRao-2017-HIC054.hic": "386655891,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_60min%2FRao-2017-HIC055.hic": "402170701,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_240min%2FRao-2017-HIC057.hic": "735906308,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC058.hic": "443789827,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC059.hic": "491422615,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC062.hic": "320261375,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min%2FRao-2017-HIC063.hic": "306590499,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_20min%2FRao-2017-HIC032S.hic": "367051742,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_20min%2FRao-2017-HIC033S.hic": "344555339,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_40min%2FRao-2017-HIC036S.hic": "349392947,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_40min%2FRao-2017-HIC037S.hic": "317714554,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_60min%2FRao-2017-HIC040S.hic": "266786397,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_60min%2FRao-2017-HIC041S.hic": "279445530,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_180min%2FRao-2017-HIC044S.hic": "898418269,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_180min%2FRao-2017-HIC045S.hic": "961006347,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_360min%2FRao-2017-HIC064.hic": "833576408,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_360min%2FRao-2017-HIC065.hic": "840881418,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1080min%2FRao-2017-HIC066.hic": "980958864,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1080min%2FRao-2017-HIC067.hic": "882023129,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1440min%2FRao-2017-HIC068.hic": "1110292630,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fdegron%2Ftime_course%2FAuxin_treated_360min_withdraw_1440min%2FRao-2017-HIC069.hic": "1001747023,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FCP190_HiChIP.hic": "144107588,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FH3K27ac_HiChIP_combined.hic": "43171370,5233",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FH3K27me3_HiChIP_combined.hic": "42906472,5233",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPol2_ChIAPET.hic": "41992430,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPol2S2_HiChIP.hic": "145842743,6976",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FArabidopsis_Wang2015_Liu2016.hic": "1134391078,4984",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FElegans_Crane2015.hic": "387127568,8758",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FNcrassa_Galazka2016.hic": "26555511,27725",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fexternal%2Frowley_nichols_mol_cell_2017%2FPfalciparum_trophozoite_Ay2014.hic": "15640893,13948",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Me-A.hic": "6897251,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Me-B.hic": "4959088,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Mp-A.hic": "5232286,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FE-Mp-B.hic": "5105292,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Me-A.hic": "6900072,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Me-B.hic": "8653258,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Mp-A.hic": "7999058,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fduan%2FH-Mp-B.hic": "8774657,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc.hic": "23671753603,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc_rep1.hic": "23671754721,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fh1hesc_rep2.hic": "22269909910,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdekker%2F4dn%2Fhffc6_rep1.hic": "19016661622,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_NcoI.hic": "480725203,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2F302NH.hic": "99948617,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FK562.hic": "470263605,36151",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_HindIII.hic": "293706559,36289",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flieberman_aiden_van_berkum%2FGM06990_rep_HindIII.hic": "309673862,36087",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fcanis-lupus-rep1.hic": "1531151371,56905",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fcanis-lupus-rep2.hic": "2851437676,56905",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmouse-rep1.hic": "582052544,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmacaque-rep1.hic": "698509182,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Fmacaque-rep2.hic": "461410393,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Frabbit-rep1.hic": "691045338,33561",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frudan%2Frabbit-rep2.hic": "668888336,33561",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsexton%2Fcombined.hic": "50650087,4486",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-hindiii.hic": "1071142023,16500",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-mboi.hic": "1508851093,16448",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Fnon-tcc-hindiii.hic": "395179229,36093",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fkalhor%2Ftcc-combined.hic": "1050423847,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fmm9-hindiii%2Fsplit-read-run.hic": "9599984876,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fhesc-hindiii.hic": "1952555632,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fimr90-hindiii.hic": "9691260435,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdixon%2Fmm9-cortex.hic": "3712072953,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr18.hic": "2083350075,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr2.hic": "3362049644,16360",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fatm-i-scei-chr7.hic": "1658399854,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fwt-i-scei-chr15.hic": "866691249,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzhang%2Fwt-i-scei-chr2.hic": "3304782795,16386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-1.hic": "23673506,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-2.hic": "26873280,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-3.hic": "31066362,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-4.hic": "16807724,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-5.hic": "28665065,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-6.hic": "13124158,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-7.hic": "15118945,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-8.hic": "68316814,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-9.hic": "18965101,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2Fcell-10.hic": "17020666,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Fcombined.hic": "6526601242,36427",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep1.hic": "1861562891,36401",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep2.hic": "3061013635,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep3.hic": "1564588211,35969",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep4.hic": "1255543175,36153",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep5.hic": "974683253,36179",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90%2Frep6.hic": "1040805629,36053",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Fcombined.hic": "8424080116,36401",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep1.hic": "2697976702,36295",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep3.hic": "1718610467,36159",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep4.hic": "2029519405,36101",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep5.hic": "985310855,36069",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjin%2Fimr90-tnf-alpha%2Frep6.hic": "1418750480,35967",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fmhh-call-4-cell-line.hic": "538380253,35351",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fprimary-b-all.hic": "773764191,35793",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Fnormal-b-cell-line.hic": "336271459,35005",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fcheng%2Frl-cell-line.hic": "484807998,35351",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-biorep.hic": "135932435,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-techrep1.hic": "160355961,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fhou%2Fkc167-techrep2.hic": "188809887,8758",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fpre-prob-egs.hic": "2237792858,15483",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fprob-egs.hic": "5744720377,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Flin%2Fprob-fa.hic": "2174866215,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fhct116-rnapii-pilot.hic": "396366166,35999",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fhela-rnapii-pilot.hic": "882516759,35107",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fk562-rnapii-pilot.hic": "1131576189,35969",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fk562-rnapii-saturated.hic": "571583828,36291",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fmcf7-rnapii-saturated.hic": "1282547841,36035",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fli%2Fnb4-rnapii-pilot.hic": "761614686,34861",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fjung%2Fmouse_sperm.hic": "1730231642,29184",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ftang%2Fgm12878.hic": "1953518212,20505",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frutledge%2FSRR1791299.hic": "5723484,11956",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frutledge%2FSRR1791297.hic": "16534743,23348",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv.hic": "5094525579,36289",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv-rep1.hic": "2574358912,36373",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-hrv-rep2.hic": "3417099433,36243",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev.hic": "4785157552,36323",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev-rep1.hic": "2648268465,36321",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-rad21cv-tev-rep2.hic": "2994727980,36107",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf.hic": "5391791815,36063",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf-rep1.hic": "3325842095,36269",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctcf-rep2.hic": "3096215920,36167",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl.hic": "3830902383,36167",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl-rep1.hic": "1346712252,36079",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fzuin%2Fhek293t-sirna-ctrl_rep2.hic": "3098067367,36271",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-0h-hiseq.hic": "38174042,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-18h-hiseq.hic": "26506099,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-18h-hiseq-non-crosslinked_control.hic": "3545496,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fay%2Fp-falciparum-3d7-36h-hiseq.hic": "70754194,21889",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fg1mid-r1.hic": "200863476,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fm-r1.hic": "249021190,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3%2Fm-r2.hic": "212341157,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fg1-0-25fa.hic": "583572265,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fg1-1fa.hic": "354502306,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-0-25fa.hic": "149308791,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-98percent.hic": "778175225,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhelas3ccl2p2%2Fm-1fa.hic": "158091047,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhff1%2Fcchic-hff1-ns-r1.hic": "801670039,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fhff1%2Fcchic-hff1-m-r1.hic": "875922086,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fk562%2Fm-r1.hic": "130959943,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnaumova%2Fk562%2Fm-r2.hic": "237861106,17185",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-WT.hic": "496104039,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-WT-adv-cre.hic": "438608517,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-floxed-rep1.hic": "446205712,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-floxed-rep2.hic": "386354767,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-deleted-rep1.hic": "621998722,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmAST-deleted-rep2.hic": "583840829,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-floxed-rep1.hic": "801290988,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-floxed-rep2.hic": "819406658,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-deleted-rep1.hic": "792825269,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-deleted-rep2.hic": "746189884,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-WT.hic": "309353372,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fsofueva%2FmNSC-WT-OHT.hic": "274229679,30643",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21KO-R1.hic": "1490362251,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21KO-R3.hic": "2403664421,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21WT-R1.hic": "1377124538,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fseitan%2FTcell-Rad21WT-R3.hic": "2646201369,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmoissiard%2Fcrh6-mutant.hic": "105261071,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmoissiard%2FWT.hic": "127506388,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2FCol.hic": "153638500,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2Fcrwn1.hic": "211213220,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fgrob%2Fcrwn4.hic": "134236837,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fxie%2Fprimary.hic": "92936173,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt-control6wt337.hic": "318737891,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt-control6wt67.hic": "348123956,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt337.hic": "251107279,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2F6wt67.hic": "351840994,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2FCol0.hic": "345969497,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fclf28-swn7.hic": "299585025,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fcmt3-11.hic": "253427706,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fddm1-2.hic": "303626924,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fmet1-3.hic": "347697973,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Ffeng%2Fsuvh4-suvh5-suvh6.hic": "263122019,10217",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FDNase-HiC-WG-K562.hic": "892955840,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FDNaseHiC-WG-H1.hic": "696922695,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-K562-rep1.hic": "341917716,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargeredDNaseHiC-lincRNA-K562-rep2.hic": "214841185,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-H1-rep1.hic": "616326137,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-lincRNA-H1-rep2.hic": "579654013,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-pe-H1-rep1.hic": "519810544,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fma%2FtargetedDNaseHiC-pe-K562-rep1.hic": "199553123,18679",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_DpnII.hic": "1319373594,6976",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_HinfI.hic": "1465493873,6976",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Frowley%2FKc167_DpnII_HinfI_combo.hic": "753062558,5814",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbarutcu%2FMCF-10A.hic": "2784956115,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbarutcu%2FMCF-7.hic": "2700457411,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbatullin%2Fsperm.hic": "501052169,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2FWT_hiC_rep1.hic": "1450697530,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2FWT_hiC_rep2.hic": "1189371558,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Fcombined.hic": "2262007875,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Finactive.hic": "4444564,751",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fminajigi%2Factive.hic": "3993495,751",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_rep1.hic": "1650838357,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_rep2.hic": "1258038606,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski.hic": "499827296,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_active.hic": "79175714,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fpatski_inactive.hic": "98947881,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_dnase.hic": "4298088401,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_in_situ_dnase.hic": "609321852,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain.hic": "1028196506,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_active.hic": "79175714,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fdeng%2Fbrain_inactive.hic": "98947881,15691",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FBglII_rep1.hic": "1283306,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FBglII_rep2.hic": "1263227,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fle%2FNcoI_rep1.hic": "4380906,1463",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Feagen%2FGSE89112_Kc167combined.hic": "1829549643,25624",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Feagen%2FGSE89112_Kc167combined_randomized.hic": "1859742654,25624",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_GM_cohesin.hic": "1231264781,17932",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_mES_cohesin_all.hic": "1152008628,16438",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fmumbach%2FGSE80820_HiChIP_mES_Oct4.hic": "912828146,16438",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FSCC4KO.hic": "1767906138,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FDKO.hic": "1487228787,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWaplKO_1.14.hic": "1189751862,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWaplKO_3.3.hic": "1155057696,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fwapl_hic%2FWT.hic": "1522401568,18679",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2Fmega_Liverpool%2Fmega.hic": "2612171975,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2836_Liverpool1%2FLiverpool1.hic": "191729195,2245",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2861_Liverpool2%2FLiverpool2.hic": "1637096030,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fhiseq%2Fskfuwi4fnsjkdf9jekrw2%2FHIC2862_Liverpool3%2FLiverpool3.hic": "1160045602,4381",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2FHSPC.hic": "11857786247,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2FHSPC_CanyonDel.hic": "8139168836,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2Ftcell.hic": "9871547081,36479",
  "s3.amazonaws.com%2Fhicfiles%2Fexternal%2Fgoodell%2Fep.hic": "17479335373,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fnagano%2FTh1_ensemble.hic": "1690592868,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FES_mapq30.hic": "32930498831,32386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FNPC_mapq30.hic": "55053730986,32386",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fbonev%2FCN_mapq30.hic": "53138031154,32386",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_72_hours_WT.hic": "16492991184,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-resting_B_cells_WT.hic": "23057795398,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_24_hours_MYC_KO.hic": "21245554876,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-resting_B_cells_TSA.hic": "13933346059,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-activated_B_cells_24_hours_oligomycin.hic": "21902506832,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FKieffer-Kwon_et_al_2017%2FMain_maps%2FKieffer-Kwon-2017-mES_WT.hic": "9451969795,32102",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_24_hours_WT.hic": "3600188564,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_30_hours_WT.hic": "1309503359,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_30_hours_HU_treated.hic": "1477252396,16438",
  "hicfiles.s3.amazonaws.com%2Fhiseq%2FVian_et_al_2018%2FMain_maps%2FVian-2018-activated_B_cells_24_hours_flavopiridol.hic": "15711773490,32102",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FPGP1F_mega_090118%2FPGP1F_mega_090118_30.hic": "24786676166,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7145%2FHIC7145_30.hic": "4554644616,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7146%2FHIC7146_30.hic": "4174848944,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7147%2FHIC7147_30.hic": "5062229182,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7862%2FHIC7862_30.hic": "4520990620,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7863%2FHIC7863_30.hic": "4330354773,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7864%2FHIC7864_30.hic": "5880640268,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7865%2FHIC7865_30.hic": "4431632469,36479",
  "hicfiles.s3.amazonaws.com%2Fexternal%2Fpgp%2FHIC7866%2FHIC7866_30.hic": "4686000222,36479",
  "encode-public.s3.amazonaws.com%2F2018%2F10%2F19%2Fb122542b-306c-4631-bdc3-2e155e89af55%2FENCFF718AWL.hic": "39544267907,58932",
  "encode-public.s3.amazonaws.com%2F2019%2F02%2F15%2F8e787cd8-e388-4bc2-a236-7a5e6f39e0c0%2FENCFF999YXX.hic": "9255069996,56883",
  "encode-public.s3.amazonaws.com%2F2019%2F02%2F08%2Ffc1d9d5d-8fa0-4e29-9080-3da674d9490d%2FENCFF543USQ.hic": "5005263062,36479",
  "s3.us-east-1.wasabisys.com%2Fhicfiles%2Finternal%2FLCL_mega_42B_500bp_30.hic": "106482584851,22829",
  "www.encodeproject.org%2Ffiles%2FENCFF925QIF%2F%40%40download%2FENCFF925QIF.hic": "51712684396,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF259YUS%2F%40%40download%2FENCFF259YUS.hic": "24640030444,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF783KQI%2F%40%40download%2FENCFF783KQI.hic": "27209249856,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF318JAP%2F%40%40download%2FENCFF318JAP.hic": "28636979242,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF512PQA%2F%40%40download%2FENCFF512PQA.hic": "28124104361,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF591MHA%2F%40%40download%2FENCFF591MHA.hic": "37373387202,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF197OWW%2F%40%40download%2FENCFF197OWW.hic": "41826180893,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF317OIA%2F%40%40download%2FENCFF317OIA.hic": "34741636038,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF522YLZ%2F%40%40download%2FENCFF522YLZ.hic": "24064692329,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF420JTA%2F%40%40download%2FENCFF420JTA.hic": "21202405177,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF871ZDJ%2F%40%40download%2FENCFF871ZDJ.hic": "10124815680,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF349RZY%2F%40%40download%2FENCFF349RZY.hic": "4446702705,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF738YON%2F%40%40download%2FENCFF738YON.hic": "3338049584,35947",
  "www.encodeproject.org%2Ffiles%2FENCFF406KJN%2F%40%40download%2FENCFF406KJN.hic": "4132875306,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF081NPN%2F%40%40download%2FENCFF081NPN.hic": "34495587443,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF946RZW%2F%40%40download%2FENCFF946RZW.hic": "34571955193,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF602CHT%2F%40%40download%2FENCFF602CHT.hic": "30674798032,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF150DKS%2F%40%40download%2FENCFF150DKS.hic": "12618769864,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF614IPZ%2F%40%40download%2FENCFF614IPZ.hic": "42450060331,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF571ZQR%2F%40%40download%2FENCFF571ZQR.hic": "15230068871,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF705MKK%2F%40%40download%2FENCFF705MKK.hic": "38686554702,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF658KTB%2F%40%40download%2FENCFF658KTB.hic": "13195884405,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF435JYN%2F%40%40download%2FENCFF435JYN.hic": "17192139674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF016JKX%2F%40%40download%2FENCFF016JKX.hic": "37266736642,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF294GFP%2F%40%40download%2FENCFF294GFP.hic": "36389843399,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF700CYI%2F%40%40download%2FENCFF700CYI.hic": "60482012152,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF962EDB%2F%40%40download%2FENCFF962EDB.hic": "39394328182,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF467OGP%2F%40%40download%2FENCFF467OGP.hic": "35572788855,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF556RLR%2F%40%40download%2FENCFF556RLR.hic": "34826921187,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF309UNV%2F%40%40download%2FENCFF309UNV.hic": "48510618174,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF653HCO%2F%40%40download%2FENCFF653HCO.hic": "41079007620,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF120DSV%2F%40%40download%2FENCFF120DSV.hic": "12790195576,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF284OEA%2F%40%40download%2FENCFF284OEA.hic": "46007570339,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF035BLF%2F%40%40download%2FENCFF035BLF.hic": "63868871985,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF094KKX%2F%40%40download%2FENCFF094KKX.hic": "42151419971,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF965BPU%2F%40%40download%2FENCFF965BPU.hic": "42717376107,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF842DUO%2F%40%40download%2FENCFF842DUO.hic": "39553892515,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF417GBZ%2F%40%40download%2FENCFF417GBZ.hic": "45544785452,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF499BVX%2F%40%40download%2FENCFF499BVX.hic": "40900674170,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF136XCV%2F%40%40download%2FENCFF136XCV.hic": "47700392974,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF224HKR%2F%40%40download%2FENCFF224HKR.hic": "40426005932,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF711XSR%2F%40%40download%2FENCFF711XSR.hic": "41434581949,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF660JWA%2F%40%40download%2FENCFF660JWA.hic": "54201632697,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF081PMO%2F%40%40download%2FENCFF081PMO.hic": "53428285130,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF799QGA%2F%40%40download%2FENCFF799QGA.hic": "1228682189,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF473CAA%2F%40%40download%2FENCFF473CAA.hic": "1077514950,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF663FRL%2F%40%40download%2FENCFF663FRL.hic": "39843938245,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF341WOY%2F%40%40download%2FENCFF341WOY.hic": "34792598619,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF515ZBF%2F%40%40download%2FENCFF515ZBF.hic": "41779230923,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF545GBW%2F%40%40download%2FENCFF545GBW.hic": "38351980358,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF252ANV%2F%40%40download%2FENCFF252ANV.hic": "37668839771,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF912NDK%2F%40%40download%2FENCFF912NDK.hic": "21196851956,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF683PLM%2F%40%40download%2FENCFF683PLM.hic": "21849338763,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF355NFJ%2F%40%40download%2FENCFF355NFJ.hic": "47880627268,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF507WEW%2F%40%40download%2FENCFF507WEW.hic": "35777782924,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF241MSL%2F%40%40download%2FENCFF241MSL.hic": "22507408288,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF135MUT%2F%40%40download%2FENCFF135MUT.hic": "24168734040,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF459FRB%2F%40%40download%2FENCFF459FRB.hic": "37166770103,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF705YZH%2F%40%40download%2FENCFF705YZH.hic": "44679182442,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF395INO%2F%40%40download%2FENCFF395INO.hic": "56727346538,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF736ITL%2F%40%40download%2FENCFF736ITL.hic": "49036286185,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF546TZN%2F%40%40download%2FENCFF546TZN.hic": "33195126348,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF706SFK%2F%40%40download%2FENCFF706SFK.hic": "3271831702,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF922ERE%2F%40%40download%2FENCFF922ERE.hic": "12476647122,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF876OWE%2F%40%40download%2FENCFF876OWE.hic": "1538692704,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF227XJZ%2F%40%40download%2FENCFF227XJZ.hic": "1925617685,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF053BXY%2F%40%40download%2FENCFF053BXY.hic": "1032237652,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF014VMM%2F%40%40download%2FENCFF014VMM.hic": "1564021703,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF563XES%2F%40%40download%2FENCFF563XES.hic": "1489180508,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF482LGO%2F%40%40download%2FENCFF482LGO.hic": "1208778887,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF216QQM%2F%40%40download%2FENCFF216QQM.hic": "6293163571,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF256UOW%2F%40%40download%2FENCFF256UOW.hic": "6293163571,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF791UZC%2F%40%40download%2FENCFF791UZC.hic": "37029615181,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF911AHQ%2F%40%40download%2FENCFF911AHQ.hic": "34246649165,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF491AOR%2F%40%40download%2FENCFF491AOR.hic": "558663570,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF307PDL%2F%40%40download%2FENCFF307PDL.hic": "525321519,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF773ITV%2F%40%40download%2FENCFF773ITV.hic": "295464771,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF198SSL%2F%40%40download%2FENCFF198SSL.hic": "500142476,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF251UEF%2F%40%40download%2FENCFF251UEF.hic": "567443575,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF942LTN%2F%40%40download%2FENCFF942LTN.hic": "4430960222,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF543USQ%2F%40%40download%2FENCFF543USQ.hic": "5005263062,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF434XQU%2F%40%40download%2FENCFF434XQU.hic": "25506511674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF318GOM%2F%40%40download%2FENCFF318GOM.hic": "44750824314,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF004TKY%2F%40%40download%2FENCFF004TKY.hic": "20705661833,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF493YNC%2F%40%40download%2FENCFF493YNC.hic": "53407154984,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF334XXU%2F%40%40download%2FENCFF334XXU.hic": "14341194962,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF569RJM%2F%40%40download%2FENCFF569RJM.hic": "1922066634,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF076LWH%2F%40%40download%2FENCFF076LWH.hic": "39406255845,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF977XWK%2F%40%40download%2FENCFF977XWK.hic": "20563512962,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF127TPS%2F%40%40download%2FENCFF127TPS.hic": "21032070512,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF480KLP%2F%40%40download%2FENCFF480KLP.hic": "33115569647,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF281ILS%2F%40%40download%2FENCFF281ILS.hic": "28236353584,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF129LMU%2F%40%40download%2FENCFF129LMU.hic": "35247096013,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF759YCW%2F%40%40download%2FENCFF759YCW.hic": "16058537743,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF045YOM%2F%40%40download%2FENCFF045YOM.hic": "19775445828,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF013TGD%2F%40%40download%2FENCFF013TGD.hic": "4208420532,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF929RPW%2F%40%40download%2FENCFF929RPW.hic": "1974260276,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF996XEO%2F%40%40download%2FENCFF996XEO.hic": "2072918865,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF097SKJ%2F%40%40download%2FENCFF097SKJ.hic": "1983524001,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF464KRA%2F%40%40download%2FENCFF464KRA.hic": "1957300131,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF406HHC%2F%40%40download%2FENCFF406HHC.hic": "3854527235,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF080DPJ%2F%40%40download%2FENCFF080DPJ.hic": "19953768024,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF621AIY%2F%40%40download%2FENCFF621AIY.hic": "26781700010,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF366ERB%2F%40%40download%2FENCFF366ERB.hic": "1049184239,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF997RGL%2F%40%40download%2FENCFF997RGL.hic": "2521167549,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF029MPB%2F%40%40download%2FENCFF029MPB.hic": "1854711185,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF043EEE%2F%40%40download%2FENCFF043EEE.hic": "2924133032,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF920CJR%2F%40%40download%2FENCFF920CJR.hic": "3011577886,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF928NJV%2F%40%40download%2FENCFF928NJV.hic": "2778936244,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF894GLR%2F%40%40download%2FENCFF894GLR.hic": "2831733099,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF303PCK%2F%40%40download%2FENCFF303PCK.hic": "688704435,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF999YXX%2F%40%40download%2FENCFF999YXX.hic": "9255069996,56883",
  "www.encodeproject.org%2Ffiles%2FENCFF685BLG%2F%40%40download%2FENCFF685BLG.hic": "16797022992,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF188SSH%2F%40%40download%2FENCFF188SSH.hic": "16797023050,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF465ESX%2F%40%40download%2FENCFF465ESX.hic": "13489465953,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF493SFI%2F%40%40download%2FENCFF493SFI.hic": "30033046818,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF235LCO%2F%40%40download%2FENCFF235LCO.hic": "38572174589,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF625VNK%2F%40%40download%2FENCFF625VNK.hic": "45202258438,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF304HMS%2F%40%40download%2FENCFF304HMS.hic": "36994445315,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF605CEN%2F%40%40download%2FENCFF605CEN.hic": "40358346301,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF086ORS%2F%40%40download%2FENCFF086ORS.hic": "22650781304,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF237UKR%2F%40%40download%2FENCFF237UKR.hic": "41516707246,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF004YZQ%2F%40%40download%2FENCFF004YZQ.hic": "71900665326,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF104THR%2F%40%40download%2FENCFF104THR.hic": "15172410632,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF807IRK%2F%40%40download%2FENCFF807IRK.hic": "17346637451,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF193CQL%2F%40%40download%2FENCFF193CQL.hic": "55726903245,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF700DEX%2F%40%40download%2FENCFF700DEX.hic": "20231399798,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF234MDO%2F%40%40download%2FENCFF234MDO.hic": "24635312640,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF181ROW%2F%40%40download%2FENCFF181ROW.hic": "26883606497,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF896OFN%2F%40%40download%2FENCFF896OFN.hic": "36952196833,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF573OPJ%2F%40%40download%2FENCFF573OPJ.hic": "36685546919,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF028RXH%2F%40%40download%2FENCFF028RXH.hic": "31053919206,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF156GGD%2F%40%40download%2FENCFF156GGD.hic": "35284134289,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF496GEU%2F%40%40download%2FENCFF496GEU.hic": "44659660933,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF945TUH%2F%40%40download%2FENCFF945TUH.hic": "3898570191,35639",
  "www.encodeproject.org%2Ffiles%2FENCFF698KFV%2F%40%40download%2FENCFF698KFV.hic": "4427896684,35751",
  "www.encodeproject.org%2Ffiles%2FENCFF239BHZ%2F%40%40download%2FENCFF239BHZ.hic": "1718552021,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF277LAN%2F%40%40download%2FENCFF277LAN.hic": "4542391336,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF397CMD%2F%40%40download%2FENCFF397CMD.hic": "2832016430,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF778OYA%2F%40%40download%2FENCFF778OYA.hic": "14067187484,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF775VSU%2F%40%40download%2FENCFF775VSU.hic": "14067187484,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF812THZ%2F%40%40download%2FENCFF812THZ.hic": "9667720429,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF777KBU%2F%40%40download%2FENCFF777KBU.hic": "5058284320,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF688KOY%2F%40%40download%2FENCFF688KOY.hic": "4198695833,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF223UBX%2F%40%40download%2FENCFF223UBX.hic": "1206064037,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF273XBU%2F%40%40download%2FENCFF273XBU.hic": "44085607579,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF952JZV%2F%40%40download%2FENCFF952JZV.hic": "44728845246,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF643NDM%2F%40%40download%2FENCFF643NDM.hic": "35877886780,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF586MQY%2F%40%40download%2FENCFF586MQY.hic": "71158037547,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF251VFA%2F%40%40download%2FENCFF251VFA.hic": "40089479399,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF033WGK%2F%40%40download%2FENCFF033WGK.hic": "30802023728,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF649OHR%2F%40%40download%2FENCFF649OHR.hic": "28203184265,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF782WVZ%2F%40%40download%2FENCFF782WVZ.hic": "37248221674,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF579CAR%2F%40%40download%2FENCFF579CAR.hic": "39662025395,54779",
  "www.encodeproject.org%2Ffiles%2FENCFF514XWQ%2F%40%40download%2FENCFF514XWQ.hic": "1319613701,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF666USK%2F%40%40download%2FENCFF666USK.hic": "15051670107,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF047SDP%2F%40%40download%2FENCFF047SDP.hic": "1357076705,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF584LEP%2F%40%40download%2FENCFF584LEP.hic": "9314176858,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF671SOE%2F%40%40download%2FENCFF671SOE.hic": "3273732256,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF702LAP%2F%40%40download%2FENCFF702LAP.hic": "1800427500,31682",
  "www.encodeproject.org%2Ffiles%2FENCFF339PON%2F%40%40download%2FENCFF339PON.hic": "5394351199,31514",
  "www.encodeproject.org%2Ffiles%2FENCFF741QPR%2F%40%40download%2FENCFF741QPR.hic": "4271510019,30139",
  "www.encodeproject.org%2Ffiles%2FENCFF103ANX%2F%40%40download%2FENCFF103ANX.hic": "4439745804,30083",
  "www.encodeproject.org%2Ffiles%2FENCFF395SBC%2F%40%40download%2FENCFF395SBC.hic": "1596732351,31850",
  "www.encodeproject.org%2Ffiles%2FENCFF289WNN%2F%40%40download%2FENCFF289WNN.hic": "8632980535,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF381EAU%2F%40%40download%2FENCFF381EAU.hic": "1702476311,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF976FEY%2F%40%40download%2FENCFF976FEY.hic": "1448279040,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF485LVS%2F%40%40download%2FENCFF485LVS.hic": "1593610856,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF143VJV%2F%40%40download%2FENCFF143VJV.hic": "1422312076,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF588NHX%2F%40%40download%2FENCFF588NHX.hic": "3943637009,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF768UBD%2F%40%40download%2FENCFF768UBD.hic": "24786676166,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF965PEE%2F%40%40download%2FENCFF965PEE.hic": "29387092778,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF702IFC%2F%40%40download%2FENCFF702IFC.hic": "29387092778,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF288DNV%2F%40%40download%2FENCFF288DNV.hic": "10313429504,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF698HWZ%2F%40%40download%2FENCFF698HWZ.hic": "10962849269,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF355OWW%2F%40%40download%2FENCFF355OWW.hic": "3219571601,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF177TYX%2F%40%40download%2FENCFF177TYX.hic": "10325679706,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF542BHD%2F%40%40download%2FENCFF542BHD.hic": "11085397879,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF684IFW%2F%40%40download%2FENCFF684IFW.hic": "11085397879,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF592UHE%2F%40%40download%2FENCFF592UHE.hic": "21363948089,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF779XIS%2F%40%40download%2FENCFF779XIS.hic": "9517383271,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF518PSL%2F%40%40download%2FENCFF518PSL.hic": "7500581463,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF275GBB%2F%40%40download%2FENCFF275GBB.hic": "7889407162,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF634KXI%2F%40%40download%2FENCFF634KXI.hic": "6430702966,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF337QPM%2F%40%40download%2FENCFF337QPM.hic": "8529733887,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF162KMP%2F%40%40download%2FENCFF162KMP.hic": "5615896908,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF992VTE%2F%40%40download%2FENCFF992VTE.hic": "7328975027,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF464WXY%2F%40%40download%2FENCFF464WXY.hic": "5715339664,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF752EGH%2F%40%40download%2FENCFF752EGH.hic": "1733758743,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF474UJM%2F%40%40download%2FENCFF474UJM.hic": "222309548,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF531UPZ%2F%40%40download%2FENCFF531UPZ.hic": "1827756846,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF022VHA%2F%40%40download%2FENCFF022VHA.hic": "244983451,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF732NGR%2F%40%40download%2FENCFF732NGR.hic": "1679484567,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF513VSF%2F%40%40download%2FENCFF513VSF.hic": "28397932940,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF750AOC%2F%40%40download%2FENCFF750AOC.hic": "36471430712,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF219YOB%2F%40%40download%2FENCFF219YOB.hic": "2859767211,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF604YDD%2F%40%40download%2FENCFF604YDD.hic": "3549694085,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF746AMV%2F%40%40download%2FENCFF746AMV.hic": "2954867135,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF845ZEB%2F%40%40download%2FENCFF845ZEB.hic": "2763039282,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF570LWS%2F%40%40download%2FENCFF570LWS.hic": "2861588289,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF883YVR%2F%40%40download%2FENCFF883YVR.hic": "2433679887,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF056VLK%2F%40%40download%2FENCFF056VLK.hic": "2502986910,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF532DUQ%2F%40%40download%2FENCFF532DUQ.hic": "3172615899,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF723PYJ%2F%40%40download%2FENCFF723PYJ.hic": "10292839095,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF991SGJ%2F%40%40download%2FENCFF991SGJ.hic": "13072407683,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF885UZI%2F%40%40download%2FENCFF885UZI.hic": "1201881201,16438",
  "www.encodeproject.org%2Ffiles%2FENCFF287KXA%2F%40%40download%2FENCFF287KXA.hic": "14705801988,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF335HYI%2F%40%40download%2FENCFF335HYI.hic": "20366756545,32102",
  "www.encodeproject.org%2Ffiles%2FENCFF121YPY%2F%40%40download%2FENCFF121YPY.hic": "2760104016,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF675SJE%2F%40%40download%2FENCFF675SJE.hic": "3751779995,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF876LAW%2F%40%40download%2FENCFF876LAW.hic": "4032376256,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF740KVX%2F%40%40download%2FENCFF740KVX.hic": "3202490322,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF977OQV%2F%40%40download%2FENCFF977OQV.hic": "2919735477,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF525EFN%2F%40%40download%2FENCFF525EFN.hic": "2394748073,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF690QRC%2F%40%40download%2FENCFF690QRC.hic": "3183023394,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF452FWS%2F%40%40download%2FENCFF452FWS.hic": "2951805127,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF089KBG%2F%40%40download%2FENCFF089KBG.hic": "2531936700,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF939ARM%2F%40%40download%2FENCFF939ARM.hic": "3066385212,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF401ZAN%2F%40%40download%2FENCFF401ZAN.hic": "3008677144,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF378RZT%2F%40%40download%2FENCFF378RZT.hic": "2830232168,26979",
  "www.encodeproject.org%2Ffiles%2FENCFF304AVD%2F%40%40download%2FENCFF304AVD.hic": "6164439305,50358",
  "www.encodeproject.org%2Ffiles%2FENCFF453DBX%2F%40%40download%2FENCFF453DBX.hic": "6775246670,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF590VOM%2F%40%40download%2FENCFF590VOM.hic": "6443478922,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF246DOF%2F%40%40download%2FENCFF246DOF.hic": "6837914659,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF125FXX%2F%40%40download%2FENCFF125FXX.hic": "9736232550,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF241RAY%2F%40%40download%2FENCFF241RAY.hic": "7686758397,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF415XWQ%2F%40%40download%2FENCFF415XWQ.hic": "6973092068,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF374EBH%2F%40%40download%2FENCFF374EBH.hic": "8557459058,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF263YWR%2F%40%40download%2FENCFF263YWR.hic": "331586820,18679",
  "www.encodeproject.org%2Ffiles%2FENCFF280CGS%2F%40%40download%2FENCFF280CGS.hic": "1743569614,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF553ZNS%2F%40%40download%2FENCFF553ZNS.hic": "1717253636,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF451VOI%2F%40%40download%2FENCFF451VOI.hic": "1626927468,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF420MQO%2F%40%40download%2FENCFF420MQO.hic": "31055961677,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF301BWY%2F%40%40download%2FENCFF301BWY.hic": "38902429246,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF606XNW%2F%40%40download%2FENCFF606XNW.hic": "1009699327,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF439ZOU%2F%40%40download%2FENCFF439ZOU.hic": "12381714313,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF499SYK%2F%40%40download%2FENCFF499SYK.hic": "13182654663,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF532LFI%2F%40%40download%2FENCFF532LFI.hic": "8286030286,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF020DPP%2F%40%40download%2FENCFF020DPP.hic": "23521952420,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF306VTV%2F%40%40download%2FENCFF306VTV.hic": "23521952480,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF399IHE%2F%40%40download%2FENCFF399IHE.hic": "10216571232,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF944AII%2F%40%40download%2FENCFF944AII.hic": "12567308552,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF230HVV%2F%40%40download%2FENCFF230HVV.hic": "8629849711,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF174LAF%2F%40%40download%2FENCFF174LAF.hic": "9446506633,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF898HRO%2F%40%40download%2FENCFF898HRO.hic": "9446506633,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF429MOR%2F%40%40download%2FENCFF429MOR.hic": "1455757398,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF061NXV%2F%40%40download%2FENCFF061NXV.hic": "1710915891,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF434PYS%2F%40%40download%2FENCFF434PYS.hic": "1832274903,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF704HHX%2F%40%40download%2FENCFF704HHX.hic": "1768142834,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF349DPM%2F%40%40download%2FENCFF349DPM.hic": "4316041260,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF718AWL%2F%40%40download%2FENCFF718AWL.hic": "39544267907,58932",
  "www.encodeproject.org%2Ffiles%2FENCFF065LSP%2F%40%40download%2FENCFF065LSP.hic": "24929805283,55874",
  "www.encodeproject.org%2Ffiles%2FENCFF632MFV%2F%40%40download%2FENCFF632MFV.hic": "22333105467,55798",
  "www.encodeproject.org%2Ffiles%2FENCFF179HVU%2F%40%40download%2FENCFF179HVU.hic": "2659219603,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF791SPZ%2F%40%40download%2FENCFF791SPZ.hic": "2537491657,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF211ZWF%2F%40%40download%2FENCFF211ZWF.hic": "3512141227,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF614BNU%2F%40%40download%2FENCFF614BNU.hic": "5252155462,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF891DLM%2F%40%40download%2FENCFF891DLM.hic": "2549095612,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF056EXT%2F%40%40download%2FENCFF056EXT.hic": "2219014704,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF776DSS%2F%40%40download%2FENCFF776DSS.hic": "3920308353,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF814LQF%2F%40%40download%2FENCFF814LQF.hic": "1349480197,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF513ZNA%2F%40%40download%2FENCFF513ZNA.hic": "2638868195,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF692IOL%2F%40%40download%2FENCFF692IOL.hic": "3106768498,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF294WZY%2F%40%40download%2FENCFF294WZY.hic": "2211089761,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF339UWS%2F%40%40download%2FENCFF339UWS.hic": "2142759055,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF835FSK%2F%40%40download%2FENCFF835FSK.hic": "3919821739,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF328BMB%2F%40%40download%2FENCFF328BMB.hic": "2550686152,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF897RTY%2F%40%40download%2FENCFF897RTY.hic": "1323294397,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF306MWH%2F%40%40download%2FENCFF306MWH.hic": "1665386199,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF039YUJ%2F%40%40download%2FENCFF039YUJ.hic": "2335679939,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF468QIN%2F%40%40download%2FENCFF468QIN.hic": "3352516594,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF364WXU%2F%40%40download%2FENCFF364WXU.hic": "3959043175,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF373MSH%2F%40%40download%2FENCFF373MSH.hic": "4429550624,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF959EGQ%2F%40%40download%2FENCFF959EGQ.hic": "2475218228,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF624XMK%2F%40%40download%2FENCFF624XMK.hic": "3527855681,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF445OKS%2F%40%40download%2FENCFF445OKS.hic": "3369125589,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF239QDV%2F%40%40download%2FENCFF239QDV.hic": "1960069888,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF645AVM%2F%40%40download%2FENCFF645AVM.hic": "4969006589,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF494IPI%2F%40%40download%2FENCFF494IPI.hic": "1565483792,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF753IXE%2F%40%40download%2FENCFF753IXE.hic": "2892400648,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF731GXX%2F%40%40download%2FENCFF731GXX.hic": "5131381303,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF369CAQ%2F%40%40download%2FENCFF369CAQ.hic": "4236629448,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF053VBX%2F%40%40download%2FENCFF053VBX.hic": "54305946375,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF555ISR%2F%40%40download%2FENCFF555ISR.hic": "54305946434,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF964RSP%2F%40%40download%2FENCFF964RSP.hic": "12065485229,36479",
  "www.encodeproject.org%2Ffiles%2FENCFF234MZQ%2F%40%40download%2FENCFF234MZQ.hic": "17507142760,47429",
  "www.encodeproject.org%2Ffiles%2FENCFF994CEG%2F%40%40download%2FENCFF994CEG.hic": "17507142760,47429",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb068e787-bbdd-49e2-9f6d-7a0e9f065d6e%2F4DNFIHSUIRFY.hic": "2701182442,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3768b89a-e124-40eb-8acd-94a4fdd35807%2F4DNFIXTAS6EE.hic": "3283740601,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9c513602-5abb-4088-8415-c827c381ab0d%2F4DNFIC3JD6O2.hic": "4896075767,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fde954dad-1849-4c23-beb4-bf893b7d76c9%2F4DNFIGY85S4W.hic": "3364151996,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe1befa6e-8067-4296-8db2-67d2a2458985%2F4DNFI2LTNXME.hic": "3699291418,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbb3307fd-7162-477a-87c5-52f12d03befc%2F4DNFID162B9J.hic": "3576428773,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8597cdae-8319-42d9-9175-3f77aaee34e1%2F4DNFIQWS3632.hic": "4022561190,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F327f091d-6a63-47c4-9752-2dff303a13d9%2F4DNFI6GFHB6G.hic": "4239331168,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd70dc3b8-48a7-42c2-bd23-80bc44fc2266%2F4DNFIS5F6EBL.hic": "4404671861,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F77df7bf8-6a3d-407a-8968-4ca1e78d2269%2F4DNFIF2D3TL9.hic": "4793989394,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8f7cc35-d2ef-4717-9009-c02154050fbf%2F4DNFI6EIFUZI.hic": "3370273763,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F98449d79-30d1-4e32-801d-07435819a42f%2F4DNFIRKGMZRQ.hic": "4669813207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd4fe1844-2493-4722-8b98-34a93a4bb7d8%2F4DNFIQWD8ZYD.hic": "5379889057,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1ee40499-1de4-47ff-b540-d9a65943c6b8%2F4DNFIX7H3CE2.hic": "4857679239,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac016170-23a7-4111-8773-353d6c150f34%2F4DNFIO21YDCV.hic": "4695989644,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1faea4e7-9a32-466e-a826-0bfdab6cd915%2F4DNFIUE5RAS6.hic": "4788044799,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcbd396ed-11bb-404f-aed9-ef10abc258e6%2F4DNFIFI6NIKJ.hic": "2069414927,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf3f78db-ae92-4215-bcae-76d30c617e5d%2F4DNFIL5K3MA1.hic": "2585598247,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66fc2893-224e-48b4-bdb0-25e022dedd03%2F4DNFIPV5KFMK.hic": "2060965679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2b39781d-aadc-434f-abe3-562d61308fdd%2F4DNFIW8TIFI5.hic": "1694424195,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6d28f7b-27d3-486f-b5ac-32567416560d%2F4DNFIA6NSSBJ.hic": "2219532611,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F08785616-722e-46bb-ade2-2fdd21324e11%2F4DNFIBKZK63V.hic": "2429136232,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F904b13d3-1203-42a4-812c-963e80c159b1%2F4DNFI3CFMRID.hic": "1233390166,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb0ed4afe-5ecf-451d-bb1f-444697e3f558%2F4DNFIYIAUEPW.hic": "1753567534,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4bb9a9b3-12a8-4d2f-8071-4722294c88ea%2F4DNFIC3HAU11.hic": "2271375254,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5abf9c36-c1d1-44dc-8197-74d860d896c0%2F4DNFIM2BMJ33.hic": "1770471113,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa68475db-7816-4cec-b2da-d4ce4a0c7a0e%2F4DNFIBY3UHJB.hic": "2095528423,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F07c40943-0d0b-4b3e-94a0-8583b0e00b47%2F4DNFIWZEN3FF.hic": "1558559508,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd8a39553-2718-4866-9b2a-45d8e9c5ac6f%2F4DNFIE5TEYK7.hic": "1323063102,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F294b61ef-5565-4f04-ade9-f921a6686cce%2F4DNFI7H4II2V.hic": "1436947982,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87a70ad7-7d34-4302-9c03-eb824bd4e633%2F4DNFIAS8LV1C.hic": "1263105698,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9db804c6-5a91-4cf5-8ae9-e054223afb77%2F4DNFIBXWIH8J.hic": "1587059951,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd1e55906-ec8f-444b-8ce1-2de22a431a76%2F4DNFIO2HBDAI.hic": "1666436393,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a4b9b37-8e38-470c-8190-fd4d513c0bbb%2F4DNFIXWCLD4M.hic": "1513511880,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c7615b2-5310-4bbf-a605-98761d3a3079%2F4DNFINASC4NQ.hic": "1420358914,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F20454014-49cd-4e2d-93da-f40ad52776d5%2F4DNFIZF1KI43.hic": "1377041630,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5df04e86-ee2a-45f2-b878-bf1648e2cca5%2F4DNFIQBHR9XC.hic": "1179502734,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9d1cc910-bb3f-4106-802a-73184c58d5ba%2F4DNFIQVMVRP6.hic": "1811976991,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe431986b-0732-460f-92ff-0abd1694d2d0%2F4DNFIJ7OAIFQ.hic": "1685503856,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F56d0c575-4962-4ea3-92c3-55bd0e17c096%2F4DNFIE8E4ANZ.hic": "1598369564,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb1502fb-a989-4ef9-b800-7eaa7be172ae%2F4DNFIOUSETUP.hic": "1493294709,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Facc2f1c3-8c96-4d21-814a-3a8ba81e7741%2F4DNFIVJ3IIQL.hic": "1472376655,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F037fb4c3-8641-4953-a977-cc71f2137582%2F4DNFIHN2QSMX.hic": "1179632606,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F16d2c3c0-6d29-4815-b074-b142af90b615%2F4DNFIILDWK8M.hic": "2280059989,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31789849-e4db-45d8-9730-66a048c02d8a%2F4DNFI6XD6JAQ.hic": "2253961696,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fff04947e-e6e8-4d62-8374-ef2ee4104809%2F4DNFIALNLR78.hic": "1914687914,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F53e6c1e7-9410-4158-84e6-57c2e683b095%2F4DNFIBT4EAKN.hic": "2296378356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0127900a-258f-4815-97d2-6fd2b043d853%2F4DNFIDJ2JZ7Q.hic": "2558945393,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F89f95693-3d28-44eb-9d45-14932f8e258c%2F4DNFI8JFOAJT.hic": "1726440253,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd803d818-b0d4-4796-8d61-a9f3943f3b10%2F4DNFIRZA6EV6.hic": "1805017504,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff9165fb1-0782-4757-a740-5b929e0252bb%2F4DNFIB7QTIMH.hic": "2541020707,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff8d916b2-b58e-4cdf-894c-ffcb3bf6ebd9%2F4DNFIJ5DQZVK.hic": "2445734043,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F14066a5b-e01a-43c2-a468-b18826174df3%2F4DNFISTWNV9C.hic": "2499319890,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd0692151-7f9a-4475-b059-f8802616dded%2F4DNFIBN9K4V9.hic": "1591570769,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70a7ef36-a514-4e45-918f-47c4e9e30ef4%2F4DNFIR8OU6QJ.hic": "1689882108,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F180306cd-8593-413a-ae83-24f19209c5d2%2F4DNFIDSWKFF5.hic": "1596696630,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6e7b9be7-f465-4434-8e9c-68d1e44a76af%2F4DNFIV239W4L.hic": "2345867406,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F55df948c-941d-4930-854c-6a07557a0c1d%2F4DNFIREVU1Z5.hic": "2254683002,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3f590cb7-df3a-498f-81c3-d5ed4179b8ad%2F4DNFIFHU75I5.hic": "2497670883,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8f064770-6008-4f74-bfca-268d4a22d745%2F4DNFIMROE6N4.hic": "9850583704,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa93d0588-76b7-4ccf-933c-4325876b0a53%2F4DNFI5SUHCGZ.hic": "10364705187,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2f5f0d6b-0b22-4936-93c9-0944d49c037b%2F4DNFII84FBKM.hic": "8836986129,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F12e90fc5-0b76-4e42-b346-58d267f9ad6e%2F4DNFI2J1ODWB.hic": "13410858286,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff2702a45-3e8b-4980-bcd5-6bb0e291614f%2F4DNFIJWBWE41.hic": "20515676755,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa0859349-5f06-4ad3-b56f-b1166b34a9eb%2F4DNFIIMZB6Y9.hic": "15350325963,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F12685c57-d54a-46fa-9efb-acf34ed77574%2F4DNFICJECID5.hic": "1525002266,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd101a58e-89aa-44fd-96c5-6bf1e2476272%2F4DNFIR6UW2QA.hic": "1264999913,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d8c73bf-1335-4af4-b124-e3622d48c5f6%2F4DNFIGOEKBUZ.hic": "1905947578,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcd2477cf-6ed0-4d7b-b4e9-88fb38b0df48%2F4DNFIMDNAEW4.hic": "996444147,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0f03953e-29da-4f2e-8c05-572d0edf4525%2F4DNFI5OSZ3JC.hic": "369361754,22829",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F29d95dbb-005a-4ae1-8b9c-0fec9ec0bbd0%2F4DNFI7KOUGFM.hic": "1227434049,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa441ab7b-afbe-437d-bf98-b6b916558642%2F4DNFIGKX4A32.hic": "883933242,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F941b2f94-2fff-4d3c-aceb-fee4a5ae41a9%2F4DNFI1ORHOTA.hic": "1140970677,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8720ede9-093f-4c00-912f-373283260a16%2F4DNFIWSVLZED.hic": "458091151,26979",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9e17155-2b62-4a68-afb2-31dfa674e169%2F4DNFI6H926RO.hic": "3552863515,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F22f22778-987a-4dc0-97bc-f26eae0156d9%2F4DNFIKTYSPOF.hic": "2939475400,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F40f40192-0acb-44cb-8778-8d21afe593fb%2F4DNFIZ4S52BV.hic": "3067438113,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd8767374-7018-4e11-9226-bf5612d39ebb%2F4DNFI3APMXHF.hic": "3258874744,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8c5140ec-a65a-4186-8c59-2927233eecaa%2F4DNFIQLIKDSD.hic": "2746398416,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8cdedda6-d7d8-4231-a85b-d56fcd962366%2F4DNFIKYXMF1E.hic": "14442148774,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa4d4497-7c6c-4dad-8040-be13ba07ea32%2F4DNFI9815EEJ.hic": "17960817603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9b7b95f-190b-49fe-8047-ef4a8fc59746%2F4DNFIQ2687RT.hic": "15954277087,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F59863d3a-8d7c-49c7-9a41-7f2a58ad24d1%2F4DNFIYDBBSE3.hic": "16499534862,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3e80ca41-b3e0-4f4f-a05e-8f95fe96d938%2F4DNFIMOCN1YS.hic": "863725312,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F96f97a01-0020-4f09-93e8-fc8a9fd07218%2F4DNFI6558CM8.hic": "1597967345,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fce9e9334-ee0b-4549-a845-110470ba5986%2F4DNFIQZRKS7Y.hic": "907626411,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdaac8209-1015-48da-9e31-2e252dfd8fe0%2F4DNFIX4DLXSE.hic": "1369766288,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F268b7d52-9655-474c-9467-8ba31bb2195c%2F4DNFII3JV8I1.hic": "856656441,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9681f9b5-335a-4f56-afa1-15b58bbb41e8%2F4DNFI5IAH9H1.hic": "1495185175,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3e082eab-95aa-4677-88ed-9d7adcc1effb%2F4DNFIK5HY1GP.hic": "2135337789,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31af1ead-4520-4669-957e-424b4b197c33%2F4DNFIFA89L5B.hic": "1975593640,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcc2b78fd-52d4-4e0c-ac93-b84ee82daf7e%2F4DNFICXCFGEI.hic": "2628202920,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff54efece-280f-46ca-95e3-1f8a3cd18820%2F4DNFIK4CECUH.hic": "1901129375,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1181c0c4-afb7-4b6a-9fdc-d868fb2253fc%2F4DNFI1EYIGOC.hic": "1947135384,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1d3e2905-b9b9-4b91-bcb4-8d34746e78f6%2F4DNFI7TLEWUI.hic": "1185758726,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faba3d42f-39cd-4a85-9d3f-835aefb5c803%2F4DNFIVCJKHMN.hic": "687240974,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F27f54fcb-54fe-41a4-b25a-2f8944c89044%2F4DNFIN8F14CS.hic": "1304082029,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb75fedb5-88f4-4bc0-8e38-298df7847a7f%2F4DNFI5LCW273.hic": "12497258313,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2f22b2a0-3712-496e-92d2-63775ec0e421%2F4DNFIVSCH2CH.hic": "12594733778,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F07e47261-5863-44f5-9198-76e263081bea%2F4DNFIZ268JGC.hic": "1499059135,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F682b1ae1-3ac3-40e4-a330-c49f63946952%2F4DNFIJ1P4HBI.hic": "1190211725,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F197e7c89-ea73-41de-8cb2-8c0b1e3bb945%2F4DNFITEGKBIW.hic": "2061501971,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F191f6928-c9a8-44b2-8516-ee4d6005f24b%2F4DNFIE1P6RVH.hic": "1711447310,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F94435086-3701-4b28-a6d0-4a59b24d7615%2F4DNFICJ6I4DO.hic": "1557899940,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa9ac173-d233-41c7-8985-ca91949664e4%2F4DNFIKUG8MEW.hic": "1339072088,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fba6d8ab6-ee18-4ba2-8da9-d631888dd50a%2F4DNFICFZGFAV.hic": "1261083478,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87a3ab04-7094-4673-81e4-ac8c9add8eb5%2F4DNFIQXCZVVA.hic": "1084913802,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbc1ff488-82af-4579-9424-959184edb139%2F4DNFIB6PJFJ3.hic": "1114571343,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1f7026ee-987a-41e7-8a61-45510ee3f86b%2F4DNFIX97731O.hic": "1246860402,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6186787c-2e72-4925-9729-02121e2e4597%2F4DNFIYQYZOTO.hic": "1212210849,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3b98a946-0109-4efa-a13e-cc7a36772125%2F4DNFIPXU7V25.hic": "1696288217,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fea17d041-c6ed-43a1-8047-535f3d19ad44%2F4DNFIL39PR76.hic": "1719284710,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72774afe-f166-42ac-9849-4070b0dadf6d%2F4DNFIYLJ3R3B.hic": "1106419640,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4a45e733-55f8-4a8e-be24-2ef34c976e25%2F4DNFIL51WBN6.hic": "1327651164,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F086c62b0-a26f-41ae-a5ff-88b8be2bd2aa%2F4DNFI6SFPUDA.hic": "1336964405,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4d9b79c7-af62-4070-84a9-b953903f2732%2F4DNFI2KM22QR.hic": "953067310,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3c9889d1-f49e-4639-8e15-2d99d6cd22e7%2F4DNFIVF8Q45U.hic": "984193565,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa080dd7b-b7bb-4eae-a275-572a8b45b2d0%2F4DNFI2RN3WFP.hic": "1046525527,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb81860ca-c227-4b68-a298-1907fd32300a%2F4DNFI4TJTL7A.hic": "1160373401,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F74ab47dc-7b52-421c-845e-6feb33457adf%2F4DNFIYJ4TWB8.hic": "1268416204,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc6582128-a930-4bcc-941e-5c0733bdd4d5%2F4DNFIM6RGKPV.hic": "863347067,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F11a75514-4450-4295-9eda-18e3678a575a%2F4DNFIL2VWWL5.hic": "860731581,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5eb52a8c-bf14-4225-bf34-14a0aa47c369%2F4DNFIX6ZXCA8.hic": "893462267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66aaa4c0-1f62-4040-8ecc-4e95da23cd18%2F4DNFIEVR81FS.hic": "879736207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F821c6e7f-96f7-47de-b7d9-4970562b3c8e%2F4DNFIAUI6BBI.hic": "996313881,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9252c362-31ab-413d-a47a-cc97bdbf243a%2F4DNFIAFEE9G2.hic": "1103265750,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc1a0bf52-2e65-4deb-871f-ede736babd41%2F4DNFIPZBEXCP.hic": "1081257762,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F729f5ce3-d7e0-466d-b781-d18049e63bfa%2F4DNFIWPKRZGU.hic": "973779283,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F80b769ee-a717-4825-9db0-dca86f913173%2F4DNFIMD9QNDX.hic": "1158688208,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F266290c0-2767-4158-85ab-7274368905b9%2F4DNFIATA1HD5.hic": "1073361089,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc46f18a8-eb24-4d35-b112-36db72bde2f5%2F4DNFIH9U4I7I.hic": "1111124316,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fec91a79e-7de7-49f7-9b3d-d28313aeddc8%2F4DNFIZ95S6TR.hic": "1242494051,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9e9390b9-da20-43bb-a8f4-9830f354ddf9%2F4DNFI5ERM9J7.hic": "1271051397,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fee8ea82e-b9e4-41ad-bced-5f4fbdaa4fec%2F4DNFI15FPSQL.hic": "1216714120,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbed7eb86-8990-42f2-b3ee-5992d6361f7c%2F4DNFIJ3DZPGM.hic": "1035089437,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdaa8a324-3bf8-424c-8a86-b8ad325cc20d%2F4DNFINW9P6XF.hic": "1215712740,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70631758-6bf8-47a0-92b6-132574886faa%2F4DNFITS16HW8.hic": "1105283847,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe473304b-7bc8-49b8-bba1-ecb9f06914ee%2F4DNFIS3DIH4V.hic": "1036056660,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F10f9224a-111c-402a-ac25-e221ad0af9ef%2F4DNFIY3KDHP6.hic": "1071761024,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F17519b96-2bdd-4294-98f0-1535f1aef28e%2F4DNFIO8HVKOL.hic": "953793750,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffb18f896-4730-4909-86a3-867fc8e76cd6%2F4DNFIMF6CFOM.hic": "708717889,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcfee4d87-0873-40b0-b79f-35dcc8669c1c%2F4DNFIZZ77KD2.hic": "732668723,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8b5d909-8a1b-41bb-bcdd-d108a0bde762%2F4DNFIOLO226X.hic": "951271932,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9ce81f6e-b9cf-4ec9-8bd3-517539e4b662%2F4DNFIJMS2ODT.hic": "932509067,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F506aa952-5d41-49ff-b658-916bcf88a395%2F4DNFI49F3LJ4.hic": "1208494817,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe4dc392d-ca36-4bdf-a27d-173cae34f520%2F4DNFI65MQOIJ.hic": "854630155,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F149ef8d7-e0b4-4e4f-b7e5-7226e2603746%2F4DNFIM4KEPRD.hic": "882790622,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa436f0a8-4f9a-4524-90ac-795c5b8491cf%2F4DNFIIXBIZFC.hic": "848244425,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbc8a05dc-7449-4b01-8330-a55db37ca8e6%2F4DNFIWDOOBVE.hic": "1116239020,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faef8b881-28fe-4694-9a95-1d31940e6726%2F4DNFIDT9EB5M.hic": "888289053,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff66f3162-a53d-46f2-8800-3752935d5400%2F4DNFIX2VUNV8.hic": "1226661451,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F36c782e6-2c48-4298-aa43-bd6624da003d%2F4DNFIEQHTV1R.hic": "804665819,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff15d571e-605d-4bcc-a359-0350b57a6815%2F4DNFIFW7GA64.hic": "901568712,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc2aa2e8b-ac7f-4acb-b4b5-ac5f845840fe%2F4DNFIXGXD67I.hic": "970995551,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F71b6fd7d-b249-4d65-a597-b80b95845399%2F4DNFIA7GB1NB.hic": "956785837,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6cbb1418-34db-427f-9273-5174eac81529%2F4DNFIVOJGWNP.hic": "890415052,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc69c2ee7-b6c3-4a62-8d4f-913491c9dab8%2F4DNFIW22BNB5.hic": "1075499540,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa268f28f-c6d9-4324-8989-75d2d317af1b%2F4DNFIIFBC8WN.hic": "1045459440,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c7361d4-60a6-440b-b5be-072cada98663%2F4DNFI9ZBEBJH.hic": "759395398,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcceaad1a-e01e-4430-8bd6-24ffa6891802%2F4DNFID4SLU53.hic": "921288444,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9eee5854-b33e-4d5a-9ba8-ceffd47e7488%2F4DNFIODI1NUJ.hic": "733159777,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5e1089b0-42e8-441c-99bb-4be99bcec28b%2F4DNFIJL26LFN.hic": "723567970,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F298a429e-ea29-49d3-bfed-fa851e1e7c4c%2F4DNFI5KTF553.hic": "2213661745,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F965d29f0-e4a3-477c-8ae4-faf4a654e69a%2F4DNFIYSPGFGV.hic": "2274989349,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd88acbc1-37b9-4266-9f97-d8fed576d0f3%2F4DNFILOR6D2D.hic": "2595459358,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7b6ddbce-0ed1-4272-b8ae-32793e4ea4e4%2F4DNFI1WMMPJQ.hic": "2262433890,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fedc0c8c4-97d8-4372-9a4f-5e0cdf09d7d0%2F4DNFI47P5978.hic": "2146314403,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0edcc389-43a4-44d7-b946-fe3496f93d56%2F4DNFI7XGW6IH.hic": "2302805723,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0a802926-e235-4c80-b521-83a1774dfb46%2F4DNFIK1EJG8I.hic": "2374943035,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3c36aedb-6a58-4aa2-9b11-bb440ec174f1%2F4DNFIDQ3THN9.hic": "2341188249,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F846123cd-8828-4e51-8b8a-27deaf293858%2F4DNFI3WPNFWT.hic": "775145629,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd06e3ad-0e37-48a3-8367-c7d5912cab03%2F4DNFI9DCUOQ1.hic": "870487824,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc2eaf9bf-9584-4cec-8685-bd74038a6c01%2F4DNFIU8AF5ZY.hic": "1276224366,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F219497b5-3f35-473b-9d4e-e1cf21c69561%2F4DNFIHW8NTQX.hic": "28864787856,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4be13558-114a-4f2d-abca-7598e2ff4757%2F4DNFI4OUMWZ8.hic": "17061013588,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F49aed637-87a1-4d4d-ae68-e5da82aec05b%2F4DNFIEYQ5ZIR.hic": "13555272651,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa2f48779-4eff-44a6-8a9d-96435aca1ddc%2F4DNFIDZT7PR8.hic": "13425047093,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6ec6b71-27b8-4891-b10a-ab06a5270468%2F4DNFIEJEFCAM.hic": "15394960208,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F68b9a7b5-8413-44fc-8c2d-59a67b1c4166%2F4DNFIJ8JKKWJ.hic": "17012681779,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F294d45a4-8b5e-456f-a9cb-1cbbbad3a7d2%2F4DNFINEQY95T.hic": "13966775978,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd7f3a48-b822-41e2-bd9c-f52b3aff7b6a%2F4DNFII6AN691.hic": "12367300362,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7da44594-0dc8-4e74-8e10-a957aeaea51a%2F4DNFIDBIEXI7.hic": "2015474981,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F085a0453-3784-4eba-80b2-3556e53e2f52%2F4DNFIDKJFK2S.hic": "1983111659,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc370c78c-0a99-4c3f-a29b-2dfafc6a3e86%2F4DNFIPAF4PYT.hic": "3041434294,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F907ce45f-baa5-416d-92de-e86db4bacff1%2F4DNFIWIYYNQ5.hic": "7082321112,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff13afc6b-cf69-4c9d-881f-eed4dd3c28ee%2F4DNFIHMCILEN.hic": "1739157603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7575d891-0e3d-4a77-896a-3e1b3a8d330b%2F4DNFIJBJ6QVH.hic": "5213499748,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff0daa830-60d5-4c7c-a2e1-a4ee70b3fee7%2F4DNFIH2A7IKF.hic": "4099503507,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff4970a25-91d8-49a7-9a4a-fe0f12cb2b0f%2F4DNFIOL8KGQ2.hic": "2256042055,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F879f1850-d175-4a86-8a97-12658482e3d1%2F4DNFIWILLD6C.hic": "5476286356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F787f538e-d619-4c8f-985b-78753fb7e57c%2F4DNFIZBXXJAF.hic": "5946467856,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8ee785f-1016-4989-9e64-78352621d32f%2F4DNFI8PZOJHN.hic": "8307204961,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d8997fa-528c-4531-b25b-a412de6bd472%2F4DNFIGXAMSJY.hic": "6577588285,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87aede55-7610-4283-af0e-c6840429a31e%2F4DNFIWNNO89O.hic": "2871061417,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93b8e020-b337-4685-81dc-40cc8a12b5e9%2F4DNFIXU2KPNQ.hic": "3401717686,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffb5cf1bd-59d6-46fe-857d-b86d9756029d%2F4DNFIHBGD6N6.hic": "840028421,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2d1bc088-d838-49b8-85fc-fea78a7353c4%2F4DNFI7J8NI4A.hic": "675705256,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21a27b63-fd67-401b-9aa2-2798e6588d21%2F4DNFISFM9VFK.hic": "800145922,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F656c0a9d-7058-4c4b-a3ce-701d929561c1%2F4DNFIJU5XBK7.hic": "966593603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2efacfbd-9c81-4e62-8df7-847d1ab774d5%2F4DNFIPKY8ED1.hic": "3401629450,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa50b6a26-56b5-43f2-b525-fa219fd716f1%2F4DNFIQRTP7NM.hic": "5358852759,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff5dc7a59-b998-4490-8a76-afbf3b258a49%2F4DNFIBCIA62Q.hic": "5779049277,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F62b2b237-cb02-45f7-89d9-616cf9ffb678%2F4DNFIV56OFE3.hic": "5818844506,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ac79b4f-cfbf-4b2a-9fc2-898ed6c3e5e1%2F4DNFILIM6FDL.hic": "19637469163,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1cff8afa-5a13-4ad4-bcad-91fc3ced759c%2F4DNFIP71EWXC.hic": "17934647326,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F000789fe-9a22-4280-a71c-7ad228fd4cac%2F4DNFIM7ZVQOQ.hic": "700134697,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8d78457f-0c2b-4358-b08c-4d4ef4d9f59d%2F4DNFIS6EYHCX.hic": "628314484,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ca3b4a0-2478-49c9-b4a2-a28430417a32%2F4DNFIKKCMS1Q.hic": "584050634,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff5041473-18ec-439d-92b1-8ad98c9b25c0%2F4DNFIBIV8OUN.hic": "522632731,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcf474ec6-abd4-431e-a21c-252fcf5ee6b3%2F4DNFIAUMRM2S.hic": "313395531,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2bb1c73e-fb0f-41c4-8620-a938cc8d24a0%2F4DNFI9ZUXG61.hic": "332217525,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F26dfa41e-7e4f-457a-a3ac-72daf8059f3c%2F4DNFIDBFENL7.hic": "359604894,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8ed2e68b-189e-4988-bb6d-94e63240a231%2F4DNFI7XAZNNQ.hic": "5312422266,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6f2b1ce0-5205-4680-981e-d91b694dc3e4%2F4DNFISNGDB53.hic": "2008546759,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F73c8147f-bc7d-4d33-8a10-a9e7b413ecc6%2F4DNFI1CIGHYC.hic": "2221847625,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F526ae3e3-32cc-4670-970f-1faa9cfafd4d%2F4DNFIQD2DP2F.hic": "5295591503,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6e803530-47f8-4c56-bb19-fbdcd578d2f0%2F4DNFINHT8P7C.hic": "3159499486,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffe705f38-903f-47b7-9b38-f80ebd18a479%2F4DNFIGF8EM7M.hic": "3490552542,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa197328-d6da-4299-a0fd-409ac9892668%2F4DNFIUPG2ZBJ.hic": "5382003751,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffe5d52c4-2be7-4812-bca0-cd4bb3025e6b%2F4DNFIH3OTR14.hic": "3224693110,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21935f61-daa8-4df2-aa69-fcd27953b405%2F4DNFIUATRW3Z.hic": "3835865655,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72147527-e3e8-4967-bc45-8251249d76c9%2F4DNFI6V7ZQAE.hic": "4382708138,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F589f0919-f54d-49ff-a482-e2f453ef7f34%2F4DNFICKMT1CY.hic": "4479068191,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F861946ca-bad8-4a87-96e1-b2eb20b9ef10%2F4DNFIF9BDCNI.hic": "3698151402,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff76346ac-97ec-4893-8984-2b75ce1cdc51%2F4DNFIG5O1OQS.hic": "5704288175,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe8b43826-f049-4c3f-b83a-e75fa7aacc85%2F4DNFIHS2SVBQ.hic": "990025510,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46316260-f555-4dd4-9e40-8ae06ca52822%2F4DNFIU95B69H.hic": "1275878544,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff62ef491-a3ae-4f66-ab33-c5673c9e0b65%2F4DNFIYRROFCR.hic": "1522530503,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1cd617e1-fad4-4fdc-8b4e-cb277650123c%2F4DNFIF7JN3IU.hic": "1463443128,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb20fe2a-0078-4d4a-8a52-d76043d06f40%2F4DNFIB2RYULQ.hic": "1269529700,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d386fcf-1d22-47de-a0d6-0c3a641ca174%2F4DNFIMVDK3SI.hic": "1185489599,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F00e470bd-c533-41b1-923a-4b471824da12%2F4DNFIRLOTXSC.hic": "978217499,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb8774fb3-d0c5-43cc-a6c9-eb0ca39841fb%2F4DNFIZAPX6J8.hic": "1100356082,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fab3b826e-614c-448b-860f-a3ebef68a82f%2F4DNFIQD5VCSD.hic": "1322319877,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F66c78d2b-993a-4937-95ed-9e2d302ceb3e%2F4DNFIIF6VAGN.hic": "868885799,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5d106fe1-2d80-466e-87aa-46b38ba142c5%2F4DNFI86IEZXH.hic": "751443267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc99490b6-faf9-413f-9c38-3f53018089d6%2F4DNFIP881SR2.hic": "754427927,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F39c7e387-e710-4b1d-b757-357dec03f6ad%2F4DNFI42NNCW8.hic": "1166392978,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4742a211-43b1-4325-af6f-82490aeb766b%2F4DNFIEV4PKP6.hic": "1102227476,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feaa73842-1c86-4ad9-8a9e-c189c0b4c01d%2F4DNFIF1DUQHE.hic": "1206699207,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd25f24df-0298-4079-bb6f-1c8e1e32392b%2F4DNFIGW55EAY.hic": "1033358104,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc57a7ab5-2778-4fe2-9d64-9a4e95135f12%2F4DNFISZRU6I4.hic": "1539570262,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd89f494a-27ca-46b6-89be-7583f3f6d18c%2F4DNFIBKKDTAP.hic": "350372180,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F06725280-cb24-4f22-a267-18b434bfa79e%2F4DNFIJSRQW24.hic": "314361467,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8fe5c3c5-006f-425b-ac6d-ea475e29be78%2F4DNFI3REN89E.hic": "299665258,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8b6ac5c-13b4-427e-9158-cec0b890b6d8%2F4DNFIF5XLHKM.hic": "235668364,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F01ff33fc-fc23-48aa-a6c6-b720d6fe0768%2F4DNFIB6Q538N.hic": "316494853,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F552978c8-abbc-424a-9187-3e34cf802a97%2F4DNFI3ST3F7Y.hic": "296298411,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F72e66520-5170-4f2e-844a-fbfd0e23b480%2F4DNFIQT4M6UI.hic": "307691265,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb3eb3953-ffe8-4d5a-970c-a16f3b7b9ec3%2F4DNFIFNCC7M2.hic": "364160436,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F37d413fb-afab-41ff-99aa-1678830f7dde%2F4DNFITM9MDJL.hic": "252412426,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf5db92c-aaf1-4086-a0d2-79b28648f172%2F4DNFI3NTD7B3.hic": "227586640,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6892f7b-1f8a-4d7d-9605-c67932cd5654%2F4DNFIBED48O1.hic": "328344868,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd64afb07-5ab1-4c4f-8438-2fee37afa86a%2F4DNFISATK9PF.hic": "379669025,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fad11bb63-8692-461c-b698-89c601451321%2F4DNFISRP84FE.hic": "298491537,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F63710ec5-35d2-47dd-bf9a-08d3daa83d67%2F4DNFI2LY7B73.hic": "303150299,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76077d9e-ca75-4301-ab79-88aa49bda495%2F4DNFIXEB4UZO.hic": "711757090,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F34dd4c0e-3487-4fb4-b95f-c4bb66e0fa31%2F4DNFIQWWATGK.hic": "221304476,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F48a8cf86-3248-4a8e-8e85-472ec219d49c%2F4DNFI44JLUSL.hic": "284772724,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fee399fbf-2a9e-46e2-8364-457713bff508%2F4DNFIM7Q2FQQ.hic": "330729464,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F124d191a-c5c7-49b6-b84b-0d1bad8bef2b%2F4DNFIZK7W8GZ.hic": "293166018,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe351f7cc-7a2c-4515-ae0b-3bb2f91c986a%2F4DNFIMIMLMD3.hic": "240094740,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffd1ae249-57b1-41d6-81a6-16b21dcd8f12%2F4DNFI7QUSU5J.hic": "681762505,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46c92c5c-9ad8-4d49-beba-f35c5cd99208%2F4DNFINXUOI5H.hic": "375594313,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd7350d40-4e9e-4131-9151-bb539d39b431%2F4DNFIIJR2296.hic": "331322302,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbfacf37b-1665-45f3-a046-e29e1544e9b0%2F4DNFIJMZUTXR.hic": "361313244,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F234e18fb-9990-43bf-9a48-f72722cfa232%2F4DNFIZQPT9EL.hic": "540421873,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4b35ab09-2e79-4876-b2bc-d3a8faa26257%2F4DNFIZIXSZ9J.hic": "545066813,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2ae5118e-807a-46e0-8e92-143d4b282b3d%2F4DNFIDD9IF9T.hic": "237409149,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb34d7f6f-73f7-4b6b-80c7-c8af0f991549%2F4DNFIVC8OQPG.hic": "355121712,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9ab169fd-cbdd-4f60-8553-a4c6912ad89e%2F4DNFITUPI4HA.hic": "313085022,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4e53712b-d0d9-40c5-afe1-ffa0fad71e59%2F4DNFI5IZNXIO.hic": "341863906,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a91477f-45eb-4a16-affb-fc131f9326b8%2F4DNFII16KXA7.hic": "248904495,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F153729de-0eca-43cc-9b61-61aa8d775b38%2F4DNFIAAH19VM.hic": "668047244,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F879fd78a-7165-43d9-a0de-ca158b53df30%2F4DNFIVKIY3KV.hic": "247571318,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67f901a4-040b-4b04-9fff-94a1780423cd%2F4DNFIVVCWL6C.hic": "198355985,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd5b30c5a-654a-463c-9474-39bdc3ce4500%2F4DNFIJRF2273.hic": "343971277,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7070280a-8f03-40d0-9fef-e9d9f4d3dae7%2F4DNFI6FCC9ZA.hic": "312013061,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F47049719-9407-4d76-9048-26231045f642%2F4DNFI1CPQ4O3.hic": "352923267,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F862c2b5f-44c2-4bd7-9264-b3ca032d3d8d%2F4DNFISXFEDE9.hic": "271745977,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feffbe052-39ff-4217-9871-44199ed90818%2F4DNFIF9L6QEQ.hic": "668409334,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa7791854-1b35-4258-90fb-603c55f24642%2F4DNFIPKASX1Q.hic": "312727920,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F79cccad6-a78e-4de9-9fe7-08f7e8df663d%2F4DNFIWXZ4JQZ.hic": "151808553,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7e86e0cc-d6f1-4ce0-aba4-c36c6ebb3c4c%2F4DNFIEMQ1O8V.hic": "700533280,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4a1b58d3-9ae6-43e4-91cf-49f1fcbbab33%2F4DNFIYWONU7A.hic": "729050356,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67bff264-0b0c-4c5c-9d4d-ff5abef2bbe4%2F4DNFISNIE5FH.hic": "7987657997,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3a6a943f-2cc0-4433-a27d-c89f3fdd3309%2F4DNFIV8MLWJB.hic": "6646216171,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9e235711-ba90-404d-b4ac-b15990ea8e33%2F4DNFIXSTDPHL.hic": "3146468238,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c89f4bc-e9fc-4ecf-b868-26108dbb7bb2%2F4DNFIQJNOH8U.hic": "2919703928,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1856ff9e-de7a-4fa1-ae0b-3e04b837b5e1%2F4DNFI57XB4A8.hic": "13417594377,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F099bb5b9-6315-4650-8f78-d603f5a046b3%2F4DNFIQ7UKVZV.hic": "9016468637,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faf3c7a30-0fc4-410d-8d41-247da3eb105d%2F4DNFIWJY8GHD.hic": "7921314766,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fda99f429-20ab-4d91-bbfe-f8bdea8ed7b1%2F4DNFIN8NKRNF.hic": "4247121358,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0ca0f4e3-30ca-4332-b735-e32dce08e1a4%2F4DNFIZYGEHNZ.hic": "4910404663,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F243f48b0-6b59-4f37-ad39-a12e0986f530%2F4DNFIRPYGAV8.hic": "4220073636,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F49f1a890-d458-42a6-9c78-99c38b6c7a8f%2F4DNFI6MZTDM1.hic": "375035361,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76bd4768-9343-44ba-a99d-5500e184e39d%2F4DNFIG3BCGPL.hic": "2422923206,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F9d1ed866-eaf6-4906-aa8c-9e39616dde38%2F4DNFIS9YPJ3L.hic": "1593271574,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1e7a5636-bdb6-45fb-85d8-87a7e908de43%2F4DNFIOWGA9AX.hic": "1632314387,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5ecc552a-0a6b-49a9-9aa5-9f3fd9b535fd%2F4DNFINKEDSBF.hic": "1458761024,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6c03f1d2-bb25-4c94-b5f5-d5cdd01c14b6%2F4DNFIVIXVUK7.hic": "1504818271,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1a4616ff-6d04-4a6a-9773-b80e81da2471%2F4DNFIANHFY16.hic": "1850724180,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd2231870-a78d-4c8b-9cfd-084f2468acb1%2F4DNFIJ67ZFBI.hic": "1473864703,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F859c2dd3-df8a-42b7-86ea-bf6524f75e80%2F4DNFIG3YQQ4V.hic": "1539822829,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8bad667e-6003-4828-9a20-07585fa9c811%2F4DNFIOLKEOME.hic": "3036353747,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F92ea551b-5779-4d31-a0f5-621e4bd0eb21%2F4DNFIVLN8WJE.hic": "2710426318,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F61ee79fa-0617-4083-b121-f92ef3a8905c%2F4DNFI2111XQA.hic": "2589549183,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F83ebb98d-e5db-403d-aa23-875293156c0e%2F4DNFI88HXX7D.hic": "2462367030,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6d63671a-8f1d-4159-82c0-931b43464772%2F4DNFIUBM6QK8.hic": "2486020469,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcccb9014-ce15-4032-81ac-222b3d621cb4%2F4DNFIVILEERC.hic": "2052537210,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21a07867-4007-4ca5-b066-25d3168208dc%2F4DNFIF7Q43N4.hic": "2091773428,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff738de0f-358b-44bf-97dd-644c8d9b1b1c%2F4DNFID56VJGW.hic": "878913568,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fda97c1d4-bb92-4a77-92a7-f7960f88b9dc%2F4DNFIYUR29KO.hic": "983915575,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F54ea363a-99e7-4f55-861e-1644acab7939%2F4DNFIUDPGHO8.hic": "905253594,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdcd66a07-55ee-48d9-a157-419cf4ee3eef%2F4DNFISWC2N8T.hic": "1233576358,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F40363837-7466-4a1d-b20d-a66d1670b700%2F4DNFICMPHDMI.hic": "516590777,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0b3fa4e6-caeb-40b4-8942-e9c0b03dfe4f%2F4DNFIKMKN736.hic": "634310295,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb6a34050-d52b-4880-91cf-d3fe4b0ce982%2F4DNFIN5NLS49.hic": "650451131,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8e63a47b-9fd4-4772-8b0c-10ee589ffb16%2F4DNFI4P8UBRL.hic": "705655033,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7d92b666-30cc-4838-9d46-c1f11cee3d3c%2F4DNFISNC3LAI.hic": "176146197,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F17f7dc63-a1bc-4970-b389-87d9ee93b753%2F4DNFIVBWPFD7.hic": "749678512,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff8897333-4791-4a83-9444-a653e24aee13%2F4DNFITMQRXB7.hic": "254477361,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8712bf31-33d0-4562-ab0b-a1e9cf4fd30c%2F4DNFIUYD3HBY.hic": "995625724,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbfaf6383-9cc6-4b5c-9b20-d3bf2e8c3495%2F4DNFIRRSC7P9.hic": "1149985362,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb0b70598-5d17-4e0a-8831-6cbe697e69e2%2F4DNFIWKR8FP6.hic": "1151628407,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fccc094a8-23ce-4fd8-9c4a-41f07c045c8f%2F4DNFIQ74RSUY.hic": "931695969,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8eda16f3-af5e-4f1f-b46d-c74df44b76aa%2F4DNFI9IIO5PW.hic": "1077740364,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff283637b-cf2c-4412-ba00-0e3d7e279fad%2F4DNFI8WGJG19.hic": "812086456,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7ad8438f-d3d9-42d8-88bf-42845a0dc2d0%2F4DNFIQ5CCESJ.hic": "652559720,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70e3bdcc-caf4-4822-b9c5-85234873db7a%2F4DNFIWTZHB4H.hic": "760694196,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F56ed767d-cd8a-4d38-8047-ed1e8bc8cd19%2F4DNFIENYQCDP.hic": "1159428005,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa912fff9-5f90-42b1-a3a6-cbb9eb2cf861%2F4DNFIFATZWPD.hic": "1033325746,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F21338ea5-fdee-4ad8-b61c-608fc6cec4bc%2F4DNFI7YRXKEO.hic": "388142539,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff0f88647-5631-437b-b48a-4603915e3714%2F4DNFIUY3J7EW.hic": "407344788,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F16926af8-ac3b-4f32-97d5-6c0dc6f1596a%2F4DNFIRKUYKP4.hic": "893352368,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93e39aec-6cde-4c5b-bcdf-283faa3163a2%2F4DNFIAQDBJZP.hic": "489922022,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0dc0b1ba-5509-4464-9814-dfe103ff09a0%2F4DNFIC1CLPK7.hic": "565748333,37769",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fb50964c7-b025-49d9-b1ed-289bedb59678%2F4DNFI3A3VYWU.hic": "4597459343,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff4390cea-b330-4022-88c1-9ff8c0a786f7%2F4DNFI6JJQKFJ.hic": "3678393678,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70c0f730-5da1-4863-9b7a-6cdd31066cff%2F4DNFIK61ILGM.hic": "3324300994,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F14b14ac4-ab59-4754-9c43-eacd9d0638e2%2F4DNFIYD8LO9Z.hic": "3227227120,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7386f953-8da9-47b0-acb2-931cba810544%2F4DNFIOTPSS3L.hic": "253942497,7557",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6b5d8bd-27dc-4415-a320-53405a16db85%2F4DNFI525PKU5.hic": "305089653,7557",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1f922dbc-637b-4c43-b816-f604f0e79ad1%2F4DNFI8Y9SRP2.hic": "1438589609,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6a36d686-716c-4ba8-a9c3-fa8311791d3c%2F4DNFIP25GZGA.hic": "1419100109,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0e535542-2cf2-46e4-ba10-7a0b946a7fb2%2F4DNFITPO1WTY.hic": "3885296184,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c17d228-5052-4c83-880e-af05118e6929%2F4DNFIG4X5Z5F.hic": "2159245890,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc3977c00-525b-4556-9a27-061707f8cb76%2F4DNFIXLYR32S.hic": "587852728,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3f856506-cbc5-4211-a29d-48a7530c622e%2F4DNFIWI3V5LI.hic": "2318237793,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F38f77979-5eb7-4b6f-9a60-c2451185db98%2F4DNFI2DGL7LH.hic": "2068150664,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe0992a75-7727-405e-95ac-aa97141b51c1%2F4DNFI1VSO8JP.hic": "1807949651,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe925f1aa-2e7b-44e7-bfa8-2084a613ab13%2F4DNFIV5O2ZYO.hic": "2242134377,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F803a6d3c-3972-4939-8ff2-d195c5192090%2F4DNFIEWEWQ8D.hic": "2981341325,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F25104375-a588-46e6-a382-663cee6c332f%2F4DNFICSTCJQZ.hic": "14592996888,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F927aa8a5-24a5-43b7-807a-1e99ac321459%2F4DNFICEGAHRC.hic": "15431307603,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8c380474-12cd-41f4-b86f-2a29faf12eec%2F4DNFIY3XPKPO.hic": "2550999291,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F77da562e-d0ec-45a8-8764-14fa16d995a1%2F4DNFIK9PS9GM.hic": "3401011629,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F11b26222-d480-40a7-8d53-3ad8500396cb%2F4DNFIF4Y74JR.hic": "2127593378,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F93df02c6-1047-43f6-afae-d3598b61eeea%2F4DNFIBBKG9KD.hic": "5724446278,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6cd4378a-8f51-4e65-99eb-15f5c80abf8d%2F4DNFIT4I5C6Z.hic": "5419655766,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F067881e5-563d-40de-a9e3-caccad887fbc%2F4DNFI2U38HCE.hic": "14749043471,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fcb3da9ad-7afe-4d0c-9c2d-261181e7a95c%2F4DNFIETP228R.hic": "9401474797,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F185b7bcc-7bb7-41b7-9ebe-92d4fe159431%2F4DNFIXKC48TK.hic": "11624295594,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F18459b84-dd43-4af6-a05f-bcb773096322%2F4DNFIFPGOWJ6.hic": "2843730862,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffde1e48c-4a0d-4bb1-b84a-e0e45f9a0aa3%2F4DNFIIRMBE8Y.hic": "5820677927,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbabed539-1f0f-4e87-8815-fde596e6024c%2F4DNFIVUGNDD7.hic": "5170782436,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7d00531a-e616-469b-af52-5b028270e2ce%2F4DNFIFLJLIS5.hic": "18917549985,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7a9dad53-b8af-4cb6-9ce3-5c38e4a855c7%2F4DNFIOX3BGNE.hic": "5482775936,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F82fd7b7e-5f47-48d5-bf0d-daaa48a4674d%2F4DNFISPUVQHA.hic": "2177864938,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4c6680f3-9cf6-452f-9dc5-ecebf376775d%2F4DNFI8649RQJ.hic": "3288850368,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2395f001-19d9-4000-9f00-dae3dea708d6%2F4DNFIE8T8JZ8.hic": "1383191843,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F24464fa8-bf96-483c-8e9a-c2f626ad6e19%2F4DNFIBM714BP.hic": "1765204569,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F918fc048-fa27-41d2-a63a-d50c511fbb9a%2F4DNFI6CWNUFL.hic": "2431120602,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7ff5a0d1-8e54-4cf0-9fe7-339f147c78da%2F4DNFIZ4F74QR.hic": "3211825957,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F355f0412-cb17-452a-b15c-aba16c5a742c%2F4DNFIOUVOX3R.hic": "5547401083,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3cac91c5-160a-4b91-a91e-edc309318dd5%2F4DNFIVTDXW6X.hic": "4797344498,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe9ac9ec5-6221-4f39-951a-1c5054fc9f1c%2F4DNFICA8Y9TN.hic": "4277557869,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F46f62222-b50a-428b-938b-5444951600eb%2F4DNFIDWM3HN5.hic": "4374808431,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F50e4f2a1-9cb6-4192-8199-64d354bfdf96%2F4DNFIBK5TB3N.hic": "3757387253,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe4cdd5a8-1a45-4c6a-906b-a9603260d4c8%2F4DNFI3JYF9VS.hic": "5260534916,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc8164e99-5778-427d-be26-f0e1b62400f0%2F4DNFIP1GNKUO.hic": "7589365689,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0d72e78a-fc87-4716-8b8e-6dc5650ff2ef%2F4DNFIQYQWPF5.hic": "22022259901,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac58fc15-48c2-4eec-a689-23b677b4b6e7%2F4DNFIW6H9U3S.hic": "6810897169,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31811e40-e3ca-4456-8ba6-2ee66d6c7104%2F4DNFI7J8BQ4P.hic": "7188744676,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F62d81a52-d2cb-4bbd-8510-0fe120e786e0%2F4DNFIA3AKFSU.hic": "1763730692,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fae0b7513-d1a0-4f27-a9d3-348837f42cb6%2F4DNFID68JQY9.hic": "2422880133,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fae6a1a7e-1d2d-4fd2-a89f-1799abac8a9c%2F4DNFIL1FQDXE.hic": "1543814834,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F80d343c9-bd60-468a-803d-c3e351a958bc%2F4DNFITSIPCSK.hic": "2344682115,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff2d61195-a3a6-4d50-b928-546ca67546cb%2F4DNFIJ88LYHR.hic": "3362742962,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F31052aba-773a-4500-961b-e0a518245b0c%2F4DNFIJIPWD63.hic": "2529548812,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc93d0710-3fbf-40cc-b0eb-878e2aa659e4%2F4DNFIZUP2BBI.hic": "491996147,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F8660baeb-5be1-4ba5-93e4-66499e9a4587%2F4DNFIEBC4AF3.hic": "2993048734,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff6d08fbc-b836-4776-82ad-8b1b277ae837%2F4DNFI5VO3E1W.hic": "1949322679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3af004a2-a6fa-46dc-8be8-898b847a77be%2F4DNFIFDGVWLU.hic": "2456400803,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd613b4b-2422-492c-8d8f-8afba9c8a182%2F4DNFITVGFNYZ.hic": "1411204423,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc340694f-14f3-4638-b09b-98220c20039a%2F4DNFIOW9TTC1.hic": "2611370588,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3effa71b-6aa3-4265-87ba-f8d709d778d7%2F4DNFIOAA3ZEQ.hic": "3123195980,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fde75cf8b-9ce1-44fc-8b7b-ca0adea6bae9%2F4DNFIA5ID1S6.hic": "3496246968,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F714f775d-a5a4-4314-83f8-016b9d73200b%2F4DNFIZYU7V81.hic": "4245592042,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5ca518af-6e1e-4777-b67b-0fe7f039ce58%2F4DNFIRV6PVUX.hic": "3981520466,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc29b57d5-c263-4372-b396-ab4f55682f5d%2F4DNFIMEANFBY.hic": "3999623376,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4196d3ef-161a-4c18-a57e-005165c6b32a%2F4DNFIGLGQXLC.hic": "4105683321,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe10828b5-9519-4ceb-81e7-7228bfd890de%2F4DNFILS2HLXC.hic": "3804942111,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Feaac88c7-9bdc-4b1e-aa9f-e675520dfffa%2F4DNFIQS8853L.hic": "5287726781,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faab371b1-bc8d-4e83-998e-5bb977c443ca%2F4DNFIVBYCYGS.hic": "4657988157,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdb116add-af8c-4a3b-b106-9f704ba0a175%2F4DNFIE4WWHMF.hic": "5116727268,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F033366e2-05a2-4381-9d48-90122892a9e0%2F4DNFIKDUUC3C.hic": "45638237,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F7284a446-442d-4a46-aae5-84987e75a7af%2F4DNFIJ5HIRA2.hic": "62201052,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F876649a3-6dd3-463a-8b17-5752a98a89c5%2F4DNFIXDFC7EM.hic": "69878143,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3cb4ce4d-d474-459f-8b8a-2159d8df8068%2F4DNFIO35EOVR.hic": "70153114,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5c5612fa-18c2-47fb-8074-693b1054e254%2F4DNFI57QGL6U.hic": "54605055,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F70c1472d-cf3a-41d7-8682-cd03b7cc978d%2F4DNFI2AGEBE5.hic": "67930121,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2bf4cce8-6e03-422b-a190-e51d4a07d501%2F4DNFI1E6NJQJ.hic": "4893181511,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0eb3aa56-8a23-435d-a07b-8bb545e8d708%2F4DNFI2DNFM1A.hic": "60466977,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F1201682a-a223-482d-913d-3c3972b8eb65%2F4DNFIIRIHBR2.hic": "48961678,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F6aee7913-6356-43cf-affa-f2b60dd478f6%2F4DNFIKXNMT46.hic": "39095246,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F357139a3-c9a5-4343-b0a4-b41c45fd03fd%2F4DNFIRV7IRJP.hic": "70916718,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76be3061-6259-42be-a917-19dcba41517b%2F4DNFIFX1XYKZ.hic": "229197441,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ff60c348a-a62c-43c3-ac85-f6c28b5f823f%2F4DNFI64CJUZ5.hic": "112428610,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fbd0b0a14-9703-49af-bb36-2359f96d4d0e%2F4DNFIBPL2HL1.hic": "73972428,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F79ac278d-83f7-4c1f-91b2-05c8018c1426%2F4DNFIBRSIPE4.hic": "415430378,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F0c3b8141-8e67-4211-80dd-3bae88f9e537%2F4DNFIDLDVY14.hic": "112747303,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2ae703d2-d85c-4ac4-9ce1-14d653927675%2F4DNFI4R1II4P.hic": "210565448,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76e641af-90be-49f8-b126-12c20f856159%2F4DNFINMLRY95.hic": "1590865292,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3b416382-ae5d-469f-9e9a-85a3e2ce9793%2F4DNFI8KBXYNL.hic": "4626496956,22663",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa27589a6-86b2-43a2-8218-1f2232d551e6%2F4DNFI53R5IKA.hic": "1536016455,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdd3999f5-b36e-4154-a6b9-446656959a3a%2F4DNFIAWVDQ8C.hic": "2210273411,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fc377953b-0e61-426b-a905-abab2d5a3002%2F4DNFI9VXTBE2.hic": "3384365692,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F2dbe0377-1db2-4aae-af2b-d87dff728035%2F4DNFIT96Z365.hic": "7692311974,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fdcfcb009-f006-4ab8-a4c7-af72be58c12c%2F4DNFITUOMFUQ.hic": "6592120312,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F67f9073d-b2c5-474e-b3d5-7d72cde555cd%2F4DNFIHLQKDN8.hic": "2647703964,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76968cc8-fb9f-485b-85b2-c9289067194b%2F4DNFIL9M97T2.hic": "6186798917,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F87d9330b-8d2c-4e9d-85bb-02e572de7a68%2F4DNFIDWGZLHX.hic": "4379708168,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Ffc01b381-3665-4225-88ee-2e5e9ecb7324%2F4DNFIMEG1QIC.hic": "3587146533,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3144a03c-15c3-4bf9-95f8-ffad2640a1bf%2F4DNFIWSB66VX.hic": "1529739069,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fd7d3aac0-ba66-494b-ba0c-147631084b98%2F4DNFIH7TH4MF.hic": "6896300679,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F4b13bd19-fbd1-4c68-8855-4f0158d1ce47%2F4DNFIHKWIZ9T.hic": "1954878455,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F3d04e286-30d4-4add-a806-7a929d36419e%2F4DNFIZBBX795.hic": "1350142414,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Faa26f261-a88a-4cac-9118-ff8e90ab6f61%2F4DNFI9ZWZ5BS.hic": "3410552807,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F24e516ce-0b49-4476-b818-cc96471d8765%2F4DNFIPAI8XB5.hic": "4168518737,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fac3b06b5-46d4-4c1e-97e9-9a4f353473a7%2F4DNFI1OUWFSC.hic": "10766406904,21916",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F76c6aa27-895f-4e82-8ed8-7a85aca84490%2F4DNFIX4PJKXZ.hic": "1463157350,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fe6fbe03a-997b-4d72-a3cc-f1ed7bd88a92%2F4DNFIZGCA8AH.hic": "1597664180,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F61d99a87-4ec6-4116-be99-b483999641c4%2F4DNFI5CGQ46V.hic": "2870576870,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F271ea8cd-53b9-44c9-9fff-1bb5c444b54c%2F4DNFIOCW5AEM.hic": "2463600138,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2Fa98ca64a-861a-4a8c-92e9-586af457b1fb%2F4DNFI1UEG1HD.hic": "22480709268,25900",
  "4dn-open-data-public.s3.amazonaws.com%2Ffourfront-webprod%2Fwfoutput%2F5809b32e-0aea-4cf5-a174-cf162d591a35%2F4DNFI9YAVTI1.hic": "3141182061,25900"
};
class LocusGoto {
  constructor(browser, hicNavbarContainer) {
    this.browser = browser;
    const parentElement = hicNavbarContainer.querySelector("div[id$='upper-hic-nav-bar-widget-container']");
    this.containerElement = document.createElement("div");
    this.containerElement.className = "hic-chromosome-goto-container";
    this.containerElement.title = "Chromosome Goto";
    parentElement.appendChild(this.containerElement);
    this.resolutionSelectorElement = document.createElement("input");
    this.resolutionSelectorElement.type = "text";
    this.resolutionSelectorElement.placeholder = "chr-x-axis chr-y-axis";
    this.containerElement.appendChild(this.resolutionSelectorElement);
    this.resolutionSelectorElement.addEventListener("change", (e) => {
      this.browser.parseGotoInput(this.resolutionSelectorElement.value);
      this.resolutionSelectorElement.blur();
    });
    this.browser.eventBus.subscribe("LocusChange", this);
  }
  receiveEvent(event) {
    if (event.type === "LocusChange") {
      let loci;
      const state = event.data.state || this.browser.state;
      const isWholeGenome = this.browser.dataset.isWholeGenome(state.chr1);
      if (isWholeGenome) {
        loci = "All";
      } else {
        const { chr: chrX, start: sX, end: eX } = state.locus.x;
        const strX = `${chrX}:${prettyPrint(1 + sX)}-${prettyPrint(eX)}`;
        const { chr: chrY, start: sY, end: eY } = state.locus.y;
        const strY = `${chrY}:${prettyPrint(1 + sY)}-${prettyPrint(eY)}`;
        loci = `${strX} ${strY}`;
      }
      this.resolutionSelectorElement.value = loci;
    }
  }
}
class ResolutionSelector {
  constructor(browser, hicNavbarContainer) {
    this.browser = browser;
    const parentElement = hicNavbarContainer.querySelector("div[id$='upper-hic-nav-bar-widget-container']");
    this.containerElement = document.createElement("div");
    this.containerElement.className = "hic-resolution-selector-container";
    this.containerElement.title = "Resolution";
    parentElement.appendChild(this.containerElement);
    this.labelContainerElement = document.createElement("div");
    this.labelContainerElement.id = "hic-resolution-label-container";
    this.containerElement.appendChild(this.labelContainerElement);
    this.labelElement = document.createElement("div");
    this.labelElement.textContent = "Resolution (kb)";
    this.labelElement.style.display = "none";
    this.labelContainerElement.appendChild(this.labelElement);
    this.resolutionLockElement = document.createElement("i");
    this.resolutionLockElement.id = "hic-resolution-lock";
    this.resolutionLockElement.className = "fa fa-unlock";
    this.resolutionLockElement.setAttribute("aria-hidden", "true");
    this.labelContainerElement.appendChild(this.resolutionLockElement);
    this.labelContainerElement.addEventListener("click", () => {
      this.browser.resolutionLocked = !this.browser.resolutionLocked;
      this.setResolutionLock(this.browser.resolutionLocked);
    });
    this.resolutionSelectorElement = document.createElement("select");
    this.resolutionSelectorElement.name = "resolution_selector";
    this.containerElement.appendChild(this.resolutionSelectorElement);
    this.resolutionSelectorElement.addEventListener("change", () => {
      const zoomIndex = parseInt(this.resolutionSelectorElement.value);
      this.browser.setZoom(zoomIndex);
    });
    this.browser.eventBus.subscribe("LocusChange", this);
    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("ControlMapLoad", this);
  }
  setResolutionLock(resolutionLocked) {
    this.resolutionLockElement.classList.remove(resolutionLocked ? "fa-unlock" : "fa-lock");
    this.resolutionLockElement.classList.add(resolutionLocked ? "fa-lock" : "fa-unlock");
  }
  receiveEvent(event) {
    const browser = this.browser;
    if (event.type === "LocusChange") {
      if (event.data.resolutionChanged) {
        browser.resolutionLocked = false;
        this.setResolutionLock(browser.resolutionLocked);
      }
      if (event.data.chrChanged !== false) {
        const isWholeGenome = browser.dataset.isWholeGenome(event.data.state.chr1);
        this.labelElement.textContent = isWholeGenome ? "Resolution (mb)" : "Resolution (kb)";
        this.updateResolutions(browser.state.zoom);
      } else {
        const selectedIndex = browser.state.zoom;
        Array.from(this.resolutionSelectorElement.options).forEach((option, index2) => {
          option.selected = index2 === selectedIndex;
        });
      }
    } else if (event.type === "MapLoad") {
      browser.resolutionLocked = false;
      this.setResolutionLock(false);
      this.updateResolutions(browser.state.zoom);
    } else if (event.type === "ControlMapLoad") {
      this.updateResolutions(browser.state.zoom);
    }
  }
  async updateResolutions(zoomIndex) {
    const browser = this.browser;
    const resolutions = browser.isWholeGenome() ? [{ index: 0, binSize: browser.dataset.wholeGenomeResolution }] : browser.getResolutions();
    this.resolutionSelectorElement.innerHTML = "";
    resolutions.forEach((resolution) => {
      const binSize = resolution.binSize;
      const index2 = resolution.index;
      let divisor, unit;
      if (binSize >= 1e6) {
        divisor = 1e6;
        unit = "mb";
      } else if (binSize >= 1e3) {
        divisor = 1e3;
        unit = "kb";
      } else {
        divisor = 1;
        unit = "bp";
      }
      const pretty = `${numberFormatter$2(Math.round(binSize / divisor))} ${unit}`;
      const option = document.createElement("option");
      option.dataset.resolution = binSize;
      option.value = index2;
      option.textContent = pretty;
      if (zoomIndex === index2) option.selected = true;
      this.resolutionSelectorElement.appendChild(option);
    });
  }
}
const defaultColorScaleConfig = { threshold: 2e3, r: 255, g: 0, b: 0 };
class ColorScale {
  constructor(scale) {
    this.threshold = scale.threshold;
    this.r = scale.r;
    this.g = scale.g;
    this.b = scale.b;
    this.cache = [];
    this.nbins = 2e3;
    this.binsize = this.threshold / this.nbins;
  }
  setThreshold(threshold) {
    this.threshold = threshold;
    this.cache = [];
    this.binsize = this.threshold / this.nbins;
  }
  getThreshold() {
    return this.threshold;
  }
  setColorComponents(components) {
    this.r = components.r;
    this.g = components.g;
    this.b = components.b;
    this.cache = [];
  }
  getColorComponents() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    };
  }
  equals(cs) {
    return JSON.stringify(this) === JSON.stringify(cs);
  }
  getColor(value) {
    const low = 0;
    const bin = Math.floor(Math.min(this.threshold, value) / this.binsize);
    if (void 0 === this.cache[bin]) {
      const alpha = Math.floor(255 * (IGVMath$1.clamp(value, low, this.threshold) - low) / (this.threshold - low));
      this.cache[bin] = {
        red: this.r,
        green: this.g,
        blue: this.b,
        alpha,
        rgbaString: `rgba(${this.r},${this.g},${this.b}, ${alpha})`
      };
    }
    return this.cache[bin];
  }
  stringify() {
    return "" + this.threshold + "," + this.r + "," + this.g + "," + this.b;
  }
  static parse(string) {
    var pnstr, ratioCS;
    if (string.startsWith("R:")) {
      pnstr = string.substring(2).split(":");
      ratioCS = new RatioColorScale(Number.parseFloat(pnstr[0]));
      ratioCS.positiveScale = foo(pnstr[1]);
      ratioCS.negativeScale = foo(pnstr[2]);
      return ratioCS;
    } else {
      return foo(string);
    }
    function foo(str) {
      var cs, tokens;
      tokens = str.split(",");
      cs = {
        threshold: tokens[0],
        r: tokens[1],
        g: tokens[2],
        b: tokens[3]
      };
      return new ColorScale(cs);
    }
  }
}
const defaultRatioColorScaleConfig = { threshold: 5, positive: { r: 255, g: 0, b: 0 }, negative: { r: 0, g: 0, b: 255 } };
class RatioColorScale {
  constructor(threshold) {
    this.threshold = threshold;
    this.positiveScale = new ColorScale({
      threshold: Math.log(threshold),
      r: 255,
      g: 0,
      b: 0
    });
    this.negativeScale = new ColorScale(
      {
        threshold: Math.log(threshold),
        r: 0,
        g: 0,
        b: 255
      }
    );
  }
  setThreshold(threshold) {
    this.threshold = threshold;
    this.positiveScale.setThreshold(Math.log(threshold));
    this.negativeScale.setThreshold(Math.log(threshold));
  }
  getThreshold() {
    return this.threshold;
  }
  setColorComponents(components, plusOrMinus) {
    if ("-" === plusOrMinus) {
      return this.negativeScale.setColorComponents(components);
    } else {
      return this.positiveScale.setColorComponents(components);
    }
  }
  getColorComponents(plusOrMinus) {
    if ("-" === plusOrMinus) {
      return this.negativeScale.getColorComponents();
    } else {
      return this.positiveScale.getColorComponents();
    }
  }
  getColor(score) {
    var logScore = Math.log(score);
    if (logScore < 0) {
      return this.negativeScale.getColor(-logScore);
    } else {
      return this.positiveScale.getColor(logScore);
    }
  }
  stringify() {
    return "R:" + this.threshold + ":" + this.positiveScale.stringify() + ":" + this.negativeScale.stringify();
  }
}
function getLocus(dataset, state, width, height, bpPerPixel) {
  const bpPerBin = bpPerPixel * state.pixelSize;
  const xStartBP = 1 + Math.round(state.x * bpPerBin);
  const yStartBP = 1 + Math.round(state.y * bpPerBin);
  const chromosome1 = dataset.chromosomes[state.chr1];
  const chromosome2 = dataset.chromosomes[state.chr2];
  const widthBP = Math.round(bpPerPixel * width);
  const heightBP = Math.round(bpPerPixel * height);
  const xEndBP = Math.min(chromosome1.size, widthBP + xStartBP - 1);
  const yEndBP = Math.min(chromosome2.size, heightBP + yStartBP - 1);
  return { xStartBP, yStartBP, xEndBP, yEndBP, chromosome1, chromosome2, pixelSize: state.pixelSize };
}
const DRAG_THRESHOLD = 2;
const DOUBLE_TAP_DIST_THRESHOLD = 20;
const DOUBLE_TAP_TIME_THRESHOLD = 300;
const imageTileDimension = 685;
const doLegacyTrack2DRendering = false;
class ContactMatrixView {
  constructor(browser, viewportElement, sweepZoom, scrollbarWidget, colorScale, ratioColorScale, backgroundColor) {
    this.browser = browser;
    this.viewportElement = viewportElement;
    this.sweepZoom = sweepZoom;
    this.scrollbarWidget = scrollbarWidget;
    this.colorScale = colorScale;
    this.ratioColorScale = ratioColorScale;
    this.backgroundColor = backgroundColor;
    this.backgroundRGBString = IGVColor$1.rgbColor(backgroundColor.r, backgroundColor.g, backgroundColor.b);
    this.canvasElement = viewportElement.querySelector("canvas");
    this.ctx = this.canvasElement.getContext("2d");
    this.faSpinnerElement = viewportElement.querySelector(".fa-spinner");
    this.spinnerCount = 0;
    this.xGuideElement = viewportElement.querySelector("div[id$='-x-guide']");
    this.yGuideElement = viewportElement.querySelector("div[id$='-y-guide']");
    this.displayMode = "A";
    this.imageTileCache = {};
    this.imageTileCacheKeys = [];
    this.imageTileCacheLimit = 8;
    this.colorScaleThresholdCache = {};
    this.browser.eventBus.subscribe("NormalizationChange", this);
    this.browser.eventBus.subscribe("TrackLoad2D", this);
    this.browser.eventBus.subscribe("TrackState2D", this);
    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("ControlMapLoad", this);
    this.browser.eventBus.subscribe("ColorChange", this);
    this.drawsInProgress = /* @__PURE__ */ new Set();
  }
  setBackgroundColor(rgb) {
    this.backgroundColor = rgb;
    this.backgroundRGBString = IGVColor$1.rgbColor(rgb.r, rgb.g, rgb.b);
    this.update();
  }
  stringifyBackgroundColor() {
    return `${this.backgroundColor.r},${this.backgroundColor.g},${this.backgroundColor.b}`;
  }
  static parseBackgroundColor(rgbString) {
    const [r, g, b] = rgbString.split(",").map((str) => parseInt(str));
    return { r, g, b };
  }
  setColorScale(colorScale) {
    switch (this.displayMode) {
      case "AOB":
      case "BOA":
        this.ratioColorScale = colorScale;
        break;
      case "AMB":
        this.diffColorScale = colorScale;
        break;
      default:
        this.colorScale = colorScale;
    }
    this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = colorScale.threshold;
  }
  async setColorScaleThreshold(threshold) {
    this.getColorScale().setThreshold(threshold);
    this.colorScaleThresholdCache[colorScaleKey(this.browser.state, this.displayMode)] = threshold;
    this.imageTileCache = {};
    await this.update();
  }
  getColorScale() {
    switch (this.displayMode) {
      case "AOB":
      case "BOA":
        return this.ratioColorScale;
      case "AMB":
        return this.diffColorScale;
      default:
        return this.colorScale;
    }
  }
  async setDisplayMode(mode) {
    this.displayMode = mode;
    this.clearImageCaches();
    await this.update();
  }
  clearImageCaches() {
    this.imageTileCache = {};
    this.imageTileCacheKeys = [];
  }
  getViewDimensions() {
    return {
      width: this.viewportElement.offsetWidth,
      height: this.viewportElement.offsetHeight
    };
  }
  async receiveEvent(event) {
    if (event.type === "MapLoad" || event.type === "ControlMapLoad") {
      if (!this.mouseHandlersEnabled) {
        this.addTouchHandlers(this.viewportElement);
        this.addMouseHandlers(this.viewportElement);
        this.mouseHandlersEnabled = true;
      }
      this.clearImageCaches();
      this.colorScaleThresholdCache = {};
    } else {
      if (event.type !== "LocusChange") {
        this.clearImageCaches();
      }
      this.update();
    }
  }
  async update() {
    if (this.disableUpdates) return;
    await this.repaint();
    if (this.browser.dataset && false === doLegacyTrack2DRendering) {
      await this.render2DTracks(this.browser.tracks2D, this.browser.dataset, this.browser.state);
    }
  }
  async repaint() {
    if (!this.browser.dataset) return;
    const viewportWidth = this.viewportElement.offsetWidth;
    const viewportHeight = this.viewportElement.offsetHeight;
    const canvasWidth = this.canvasElement.width;
    const canvasHeight = this.canvasElement.height;
    if (canvasWidth !== viewportWidth || canvasHeight !== viewportHeight) {
      this.canvasElement.width = viewportWidth;
      this.canvasElement.height = viewportHeight;
      this.canvasElement.setAttribute("width", viewportWidth);
      this.canvasElement.setAttribute("height", viewportHeight);
    }
    const { state, dataset, controlDataset } = this.browser;
    let ds = dataset, dsControl = null, zdControl = null;
    let zoom = state.zoom, controlZoom;
    switch (this.displayMode) {
      case "B":
        zoom = getBZoomIndex(state.zoom);
        ds = controlDataset;
        break;
      case "AOB":
      case "AMB":
        controlZoom = getBZoomIndex(state.zoom);
        dsControl = controlDataset;
        break;
      case "BOA":
        zoom = getBZoomIndex(state.zoom);
        controlZoom = state.zoom;
        ds = controlDataset;
        dsControl = dataset;
        break;
    }
    const matrix = await ds.getMatrix(state.chr1, state.chr2);
    const zd = matrix.getZoomDataByIndex(zoom, "BP");
    if (dsControl) {
      const matrixControl = await dsControl.getMatrix(state.chr1, state.chr2);
      zdControl = matrixControl.getZoomDataByIndex(controlZoom, "BP");
    }
    const pixelSizeInt = Math.max(1, Math.floor(state.pixelSize));
    const widthInBins = viewportWidth / pixelSizeInt;
    const heightInBins = viewportHeight / pixelSizeInt;
    const blockCol1 = Math.floor(state.x / imageTileDimension);
    const blockCol2 = Math.floor((state.x + widthInBins) / imageTileDimension);
    const blockRow1 = Math.floor(state.y / imageTileDimension);
    const blockRow2 = Math.floor((state.y + heightInBins) / imageTileDimension);
    if (state.normalization !== "NONE") {
      if (!ds.hasNormalizationVector(state.normalization, zd.chr1.name, zd.zoom.unit, zd.zoom.binSize)) {
        Alert.presentAlert(`Normalization option ${state.normalization} unavailable at this resolution.`);
        this.browser.eventBus.post(new HICEvent("NormalizationExternalChange", "NONE"));
        state.normalization = "NONE";
      }
    }
    await this.checkColorScale(ds, zd, blockRow1, blockRow2, blockCol1, blockCol2, state.normalization);
    this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);
    for (let r = blockRow1; r <= blockRow2; r++) {
      for (let c = blockCol1; c <= blockCol2; c++) {
        const tile = await this.getImageTile(ds, dsControl, zd, zdControl, r, c, state);
        if (tile.image) this.paintTile(tile);
      }
    }
    this.genomicExtent = {
      chr1: state.chr1,
      chr2: state.chr2,
      x: state.x * zd.zoom.binSize,
      y: state.y * zd.zoom.binSize,
      w: viewportWidth * zd.zoom.binSize / state.pixelSize,
      h: viewportHeight * zd.zoom.binSize / state.pixelSize
    };
    function getBZoomIndex(zoom2) {
      const binSize = dataset.getBinSizeForZoomIndex(zoom2);
      if (!binSize) throw new Error(`Invalid zoom (resolution) index: ${zoom2}`);
      const bZoom = controlDataset.getZoomIndexForBinSize(binSize);
      if (bZoom < 0) throw new Error(`Invalid binSize for "B" map: ${binSize}`);
      return bZoom;
    }
  }
  /**
   * This is where the image tile is actually drawn, if not in the cache
   *
   * @param ds
   * @param dsControl
   * @param zd
   * @param zdControl
   * @param row
   * @param column
   * @param state
   * @returns {Promise<{image: HTMLCanvasElement, column: *, row: *, blockBinCount}|{image, inProgress: boolean, column: *, row: *, blockBinCount}|*>}
   */
  async getImageTile(ds, dsControl, zd, zdControl, row, column, state) {
    const key = `${zd.chr1.name}_${zd.chr2.name}_${zd.zoom.binSize}_${zd.zoom.unit}_${row}_${column}_${state.normalization}_${this.displayMode}`;
    if (this.imageTileCache.hasOwnProperty(key)) {
      return this.imageTileCache[key];
    } else {
      if (this.drawsInProgress.has(key)) {
        const imageSize = imageTileDimension;
        const image = inProgressTile(imageSize);
        return {
          row,
          column,
          blockBinCount: imageTileDimension,
          image,
          inProgress: true
        };
      }
      this.drawsInProgress.add(key);
      try {
        this.startSpinner();
        const sameChr = zd.chr1.index === zd.chr2.index;
        const transpose = sameChr && row < column;
        const averageCount = zd.averageCount;
        const ctrlAverageCount = zdControl ? zdControl.averageCount : 1;
        const averageAcrossMapAndControl = (averageCount + ctrlAverageCount) / 2;
        const imageSize = imageTileDimension;
        const image = document.createElement("canvas");
        image.width = imageSize;
        image.height = imageSize;
        const ctx2 = image.getContext("2d");
        const widthInBP = imageTileDimension * zd.zoom.binSize;
        const x0bp = column * widthInBP;
        const region1 = { chr: zd.chr1.name, start: x0bp, end: x0bp + widthInBP };
        const y0bp = row * widthInBP;
        const region2 = { chr: zd.chr2.name, start: y0bp, end: y0bp + widthInBP };
        const records = await ds.getContactRecords(state.normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize);
        let cRecords;
        if (zdControl) {
          cRecords = await dsControl.getContactRecords(state.normalization, region1, region2, zdControl.zoom.unit, zdControl.zoom.binSize);
        }
        if (records.length > 0) {
          const controlRecords = {};
          if ("AOB" === this.displayMode || "BOA" === this.displayMode || "AMB" === this.displayMode) {
            for (let record of cRecords) {
              controlRecords[record.getKey()] = record;
            }
          }
          let id = ctx2.getImageData(0, 0, image.width, image.height);
          const x0 = transpose ? row * imageTileDimension : column * imageTileDimension;
          const y0 = transpose ? column * imageTileDimension : row * imageTileDimension;
          for (let i = 0; i < records.length; i++) {
            const rec = records[i];
            let x = Math.floor(rec.bin1 - x0);
            let y = Math.floor(rec.bin2 - y0);
            if (transpose) {
              const t = y;
              y = x;
              x = t;
            }
            let rgba;
            switch (this.displayMode) {
              case "AOB":
              case "BOA":
                let key2 = rec.getKey();
                let controlRec = controlRecords[key2];
                if (!controlRec) {
                  continue;
                }
                let score = rec.counts / averageCount / (controlRec.counts / ctrlAverageCount);
                rgba = this.ratioColorScale.getColor(score);
                break;
              case "AMB":
                key2 = rec.getKey();
                controlRec = controlRecords[key2];
                if (!controlRec) {
                  continue;
                }
                score = averageAcrossMapAndControl * (rec.counts / averageCount - controlRec.counts / ctrlAverageCount);
                rgba = this.diffColorScale.getColor(score);
                break;
              default:
                rgba = this.colorScale.getColor(rec.counts);
            }
            setPixel(id, x, y, rgba.red, rgba.green, rgba.blue, rgba.alpha);
            if (sameChr && row === column) {
              setPixel(id, y, x, rgba.red, rgba.green, rgba.blue, rgba.alpha);
            }
          }
          ctx2.putImageData(id, 0, 0);
        }
        if (true === doLegacyTrack2DRendering) ;
        const imageTile = { row, column, blockBinCount: imageTileDimension, image };
        if (this.imageTileCacheLimit > 0) {
          if (this.imageTileCacheKeys.length > this.imageTileCacheLimit) {
            delete this.imageTileCache[this.imageTileCacheKeys[0]];
            this.imageTileCacheKeys.shift();
          }
          this.imageTileCache[key] = imageTile;
        }
        return imageTile;
      } finally {
        this.drawsInProgress.delete(key);
        this.stopSpinner();
      }
    }
    function setPixel(imageData, x, y, r, g, b, a) {
      const index2 = (x + y * imageData.width) * 4;
      imageData.data[index2 + 0] = r;
      imageData.data[index2 + 1] = g;
      imageData.data[index2 + 2] = b;
      imageData.data[index2 + 3] = a;
    }
  }
  /**
   * Return a promise to adjust the color scale, if needed.  This function might need to load the contact
   * data to computer scale.
   *
   * @param zd
   * @param row1
   * @param row2
   * @param col1
   * @param col2
   * @param normalization
   * @returns {*}
   */
  async checkColorScale(ds, zd, row1, row2, col1, col2, normalization) {
    const colorKey = colorScaleKey(this.browser.state, this.displayMode);
    if ("AOB" === this.displayMode || "BOA" === this.displayMode) {
      return this.ratioColorScale;
    }
    if (this.colorScaleThresholdCache[colorKey]) {
      const changed = this.colorScale.threshold !== this.colorScaleThresholdCache[colorKey];
      this.colorScale.setThreshold(this.colorScaleThresholdCache[colorKey]);
      if (changed) {
        this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
      }
      return this.colorScale;
    } else {
      try {
        const widthInBP = imageTileDimension * zd.zoom.binSize;
        const x0bp = col1 * widthInBP;
        const xWidthInBP = (col2 - col1 + 1) * widthInBP;
        const region1 = { chr: zd.chr1.name, start: x0bp, end: x0bp + xWidthInBP };
        const y0bp = row1 * widthInBP;
        const yWidthInBp = (row2 - row1 + 1) * widthInBP;
        const region2 = { chr: zd.chr2.name, start: y0bp, end: y0bp + yWidthInBp };
        const records = await ds.getContactRecords(normalization, region1, region2, zd.zoom.unit, zd.zoom.binSize, true);
        let s = computePercentile(records, 95);
        if (!isNaN(s)) {
          if (0 === zd.chr1.index) s *= 4;
          this.colorScale = new ColorScale(this.colorScale);
          this.colorScale.setThreshold(s);
          this.computeColorScale = false;
          this.browser.eventBus.post(HICEvent("ColorScale", this.colorScale));
          this.colorScaleThresholdCache[colorKey] = s;
        }
        return this.colorScale;
      } finally {
        this.stopSpinner();
      }
    }
  }
  async zoomIn() {
    const state = this.browser.state;
    const viewportWidth = this.viewportElement.offsetWidth;
    const viewportHeight = this.viewportElement.offsetHeight;
    const matrices = await getMatrices.call(this, state.chr1, state.chr2);
    const matrix = matrices[0];
    if (matrix) {
      const unit = "BP";
      const zd = await matrix.getZoomDataByIndex(state.zoom, unit);
      const newGenomicExtent = {
        x: state.x * zd.zoom.binSize,
        y: state.y * zd.zoom.binSize,
        w: viewportWidth * zd.zoom.binSize / state.pixelSize,
        h: viewportHeight * zd.zoom.binSize / state.pixelSize
      };
      if (newGenomicExtent.w > this.genomicExtent.w) return;
      const sx = (newGenomicExtent.x - this.genomicExtent.x) / this.genomicExtent.w * viewportWidth;
      const sy = (newGenomicExtent.y - this.genomicExtent.y) / this.genomicExtent.w * viewportHeight;
      const sWidth = newGenomicExtent.w / this.genomicExtent.w * viewportWidth;
      const sHeight = newGenomicExtent.h / this.genomicExtent.h * viewportHeight;
      const img = this.canvasElement;
      const backCanvas = document.createElement("canvas");
      backCanvas.width = img.width;
      backCanvas.height = img.height;
      const backCtx = backCanvas.getContext("2d");
      backCtx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, viewportWidth, viewportHeight);
      this.ctx.clearRect(0, 0, viewportWidth, viewportHeight);
      this.ctx.drawImage(backCanvas, 0, 0);
    }
  }
  paintTile({ image, row, column, blockBinCount }) {
    const x0 = blockBinCount * column;
    const y0 = blockBinCount * row;
    const { x, y, pixelSize } = this.browser.state;
    const offsetX = (x0 - x) * pixelSize;
    const offsetY = (y0 - y) * pixelSize;
    const scale = pixelSize;
    const scaledWidth = image.width * scale;
    const scaledHeight = image.height * scale;
    if (offsetX <= this.viewportElement.offsetWidth && offsetX + scaledWidth >= 0 && offsetY <= this.viewportElement.offsetHeight && offsetY + scaledHeight >= 0) {
      this.ctx.fillStyle = this.backgroundRGBString;
      this.ctx.fillRect(offsetX, offsetY, scaledWidth, scaledHeight);
      if (scale === 1) {
        this.ctx.drawImage(image, offsetX, offsetY);
      } else {
        this.ctx.drawImage(image, offsetX, offsetY, scaledWidth, scaledHeight);
      }
    }
  }
  startSpinner() {
    if (this.browser.isLoadingHICFile && this.browser.userInteractionShield) {
      this.browser.userInteractionShield.style.display = "block";
    }
    this.faSpinnerElement.style.display = "inline-block";
    this.spinnerCount++;
  }
  stopSpinner() {
    this.spinnerCount--;
    if (this.spinnerCount === 0) {
      this.faSpinnerElement.style.display = "none";
    }
    this.spinnerCount = Math.max(0, this.spinnerCount);
  }
  addMouseHandlers(viewportElement) {
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let isMouseDown = false;
    let isSweepZooming = false;
    let mouseDown;
    let mouseLast;
    let mouseOver;
    const panMouseUpOrMouseOut = () => {
      if (this.isDragging) {
        this.isDragging = false;
        this.browser.eventBus.post(HICEvent("DragStopped"));
      }
      isMouseDown = false;
      mouseDown = mouseLast = void 0;
    };
    this.isDragging = false;
    if (!this.browser.isMobile) {
      viewportElement.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.browser.menuElement?.style.display === "block") {
          this.browser.hideMenu();
        }
        mouseLast = { x: e.offsetX, y: e.offsetY };
        mouseDown = { x: e.offsetX, y: e.offsetY };
        if (e.altKey) {
          isSweepZooming = true;
          const { top, left } = viewportElement.getBoundingClientRect();
          startX = e.clientX - left;
          startY = e.clientY - top;
          this.sweepZoom.initialize(startX, startY);
        }
        isMouseDown = true;
      });
      viewportElement.addEventListener("mousemove", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const coords = {
          x: e.offsetX,
          y: e.offsetY
        };
        const { top, left } = getOffset(viewportElement);
        const xy = {
          x: e.pageX - left,
          y: e.pageY - top
        };
        const { width, height } = viewportElement.getBoundingClientRect();
        xy.xNormalized = xy.x / width;
        xy.yNormalized = xy.y / height;
        this.browser.eventBus.post(HICEvent("UpdateContactMapMousePosition", xy, false));
        if (this.willShowCrosshairs) {
          this.browser.updateCrosshairs(xy);
          this.browser.showCrosshairs();
        }
        if (isMouseDown) {
          if (isSweepZooming) {
            const { left: left2, top: top2 } = viewportElement.getBoundingClientRect();
            currentX = e.clientX - left2;
            currentY = e.clientY - top2;
            const width2 = Math.abs(currentX - startX);
            const height2 = Math.abs(currentY - startY);
            const config = {
              left: `${Math.min(startX, currentX)}px`,
              top: `${Math.min(startY, currentY)}px`,
              width: `${width2}px`,
              height: `${height2}px`
            };
            this.sweepZoom.update(config);
          } else if (mouseDown.x && Math.abs(coords.x - mouseDown.x) > DRAG_THRESHOLD) {
            this.isDragging = true;
            const dx = mouseLast.x - coords.x;
            const dy = mouseLast.y - coords.y;
            this.browser.shiftPixels(dx, dy);
          }
          mouseLast = coords;
        }
      });
      viewportElement.addEventListener("mouseup", panMouseUpOrMouseOut);
      viewportElement.addEventListener("dblclick", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const mouseX = e.offsetX;
        const mouseY = e.offsetY;
        this.browser.zoomAndCenter(1, mouseX, mouseY);
      });
      viewportElement.addEventListener("mouseover", () => mouseOver = true);
      viewportElement.addEventListener("mouseout", () => mouseOver = void 0);
      viewportElement.addEventListener("mouseleave", () => {
        this.browser.layoutController.xAxisRuler.unhighlightWholeChromosome();
        this.browser.layoutController.yAxisRuler.unhighlightWholeChromosome();
        panMouseUpOrMouseOut();
      });
      document.addEventListener("keydown", (e) => {
        if (!this.willShowCrosshairs && mouseOver && e.shiftKey) {
          this.willShowCrosshairs = true;
          this.browser.eventBus.post(HICEvent("DidShowCrosshairs", "DidShowCrosshairs", false));
        }
      });
      document.addEventListener("keyup", () => {
        this.browser.hideCrosshairs();
        this.willShowCrosshairs = void 0;
        this.browser.eventBus.post(HICEvent("DidHideCrosshairs", "DidHideCrosshairs", false));
      });
      document.addEventListener("mouseup", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (isSweepZooming) {
          isSweepZooming = false;
          const sweepRect = {
            xPixel: Math.min(startX, currentX),
            yPixel: Math.min(startY, currentY),
            width: Math.abs(currentX - startX),
            height: Math.abs(currentY - startY)
          };
          this.sweepZoom.commit(sweepRect);
        }
      });
    }
  }
  /**
   * Add touch handlers.  Touches are mapped to one of the following application level events
   *  - double tap, equivalent to double click
   *  - move
   *  - pinch
   *
   * @param $viewport
   */
  addTouchHandlers(viewportElement) {
    let lastTouch, pinch;
    const translateTouchCoordinates = (e, target) => {
      const rect = target.getBoundingClientRect();
      return {
        x: e.pageX - rect.left,
        y: e.pageY - rect.top
      };
    };
    viewportElement.ontouchstart = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      let touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewportElement);
      let offsetX = touchCoords.x;
      let offsetY = touchCoords.y;
      const count = ev.targetTouches.length;
      const timeStamp = ev.timeStamp || Date.now();
      let resolved = false;
      if (count === 2) {
        touchCoords = translateTouchCoordinates(ev.targetTouches[1], viewportElement);
        offsetX = (offsetX + touchCoords.x) / 2;
        offsetY = (offsetY + touchCoords.y) / 2;
      }
      if (lastTouch && timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD && count > 1 && lastTouch.count === 1) {
        lastTouch = { x: offsetX, y: offsetY, timeStamp, count };
        return;
      }
      if (lastTouch && timeStamp - lastTouch.timeStamp < DOUBLE_TAP_TIME_THRESHOLD) {
        const dx = lastTouch.x - offsetX;
        const dy = lastTouch.y - offsetY;
        const dist = Math.hypot(dx, dy);
        const direction = lastTouch.count === 2 || count === 2 ? -1 : 1;
        if (dist < DOUBLE_TAP_DIST_THRESHOLD) {
          this.browser.zoomAndCenter(direction, offsetX, offsetY);
          lastTouch = void 0;
          resolved = true;
        }
      }
      if (!resolved) {
        lastTouch = { x: offsetX, y: offsetY, timeStamp, count };
      }
    };
    viewportElement.ontouchmove = throttle((ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (ev.targetTouches.length === 2) {
        const touchCoords1 = translateTouchCoordinates(ev.targetTouches[0], viewportElement);
        const touchCoords2 = translateTouchCoordinates(ev.targetTouches[1], viewportElement);
        const t = {
          x1: touchCoords1.x,
          y1: touchCoords1.y,
          x2: touchCoords2.x,
          y2: touchCoords2.y
        };
        pinch ? pinch.end = t : pinch = { start: t };
      } else {
        const touchCoords = translateTouchCoordinates(ev.targetTouches[0], viewportElement);
        const offsetX = touchCoords.x;
        const offsetY = touchCoords.y;
        if (lastTouch) {
          const dx = lastTouch.x - offsetX;
          const dy = lastTouch.y - offsetY;
          if (!isNaN(dx) && !isNaN(dy)) {
            this.isDragging = true;
            this.browser.shiftPixels(dx, dy);
          }
        }
        lastTouch = {
          x: offsetX,
          y: offsetY,
          timeStamp: ev.timeStamp || Date.now(),
          count: ev.targetTouches.length
        };
      }
    }, 50);
    viewportElement.ontouchend = (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (pinch && pinch.end) {
        const { start, end } = pinch;
        const dxStart = start.x2 - start.x1;
        const dyStart = start.y2 - start.y1;
        const dxEnd = end.x2 - end.x1;
        const dyEnd = end.y2 - end.y1;
        const distStart = Math.hypot(dxStart, dyStart);
        const distEnd = Math.hypot(dxEnd, dyEnd);
        const scale = distEnd / distStart;
        const anchorX = (start.x1 + start.x2) / 2;
        const anchorY = (start.y1 + start.y2) / 2;
        if (scale < 0.8 || scale > 1.2) {
          lastTouch = void 0;
          this.browser.pinchZoom(anchorX, anchorY, scale);
        }
      } else if (this.isDragging) {
        this.isDragging = false;
        this.browser.eventBus.post(HICEvent("DragStopped"));
      }
      pinch = void 0;
    };
  }
  async render2DTracks(track2DList, dataset, state) {
    const matrix = await dataset.getMatrix(state.chr1, state.chr2);
    const zoomData = matrix.getZoomDataByIndex(state.zoom, "BP");
    const { width, height } = this.getViewDimensions();
    const bpPerPixel = zoomData.zoom.binSize / state.pixelSize;
    const { xStartBP, yStartBP, xEndBP, yEndBP } = getLocus(dataset, state, width, height, bpPerPixel);
    zoomData.chr1.name;
    zoomData.chr2.name;
    zoomData.chr1.index === zoomData.chr2.index;
    this.ctx.save();
    this.ctx.lineWidth = 2;
    const renderFeatures = (xS, xE, yS, yE) => {
      if (xE < xStartBP || xS > xEndBP || yE < yStartBP || yS > yEndBP) ;
      else {
        const w = Math.max(1, (xE - xS) / bpPerPixel);
        const h = Math.max(1, (yE - yS) / bpPerPixel);
        const x = Math.floor((xS - xStartBP) / bpPerPixel);
        const y = Math.floor((yS - yStartBP) / bpPerPixel);
        this.ctx.strokeRect(x, y, w, h);
      }
    };
    const renderLowerFeatures = (track2D, features) => {
      for (const { chr1, x1: xS, x2: xE, y1: yS, y2: yE, color } of features) {
        this.ctx.strokeStyle = track2D.color || color;
        renderFeatures(xS, xE, yS, yE);
      }
    };
    const renderUpperFeatures = (track2D, features) => {
      for (const { chr1, x1: yS, x2: yE, y1: xS, y2: xE, color } of features) {
        this.ctx.strokeStyle = track2D.color || color;
        renderFeatures(xS, xE, yS, yE);
      }
    };
    for (const track2D of track2DList) {
      if (false === track2D.isVisible) {
        continue;
      }
      const features = track2D.getFeatures(zoomData.chr1.name, zoomData.chr1.name);
      if (features) {
        if ("COLLAPSED" === track2D.displayMode || void 0 === track2D.displayMode) {
          renderLowerFeatures(track2D, features);
          renderUpperFeatures(track2D, features);
        } else if ("lower" === track2D.displayMode) {
          renderLowerFeatures(track2D, features);
        } else if ("upper" === track2D.displayMode) {
          renderUpperFeatures(track2D, features);
        }
      }
    }
    this.ctx.restore();
  }
}
ContactMatrixView.defaultBackgroundColor = { r: 255, g: 255, b: 255 };
function colorScaleKey(state, displayMode) {
  return "" + state.chr1 + "_" + state.chr2 + "_" + state.zoom + "_" + state.normalization + "_" + displayMode;
}
const inProgressCache = {};
function inProgressTile(imageSize) {
  let image = inProgressCache[imageSize];
  if (!image) {
    image = document.createElement("canvas");
    image.width = imageSize;
    image.height = imageSize;
    const ctx2 = image.getContext("2d");
    ctx2.font = "24px sans-serif";
    ctx2.fillStyle = "rgb(230, 230, 230)";
    ctx2.fillRect(0, 0, image.width, image.height);
    ctx2.fillStyle = "black";
    for (let i = 100; i < imageSize; i += 300) {
      for (let j = 100; j < imageSize; j += 300) {
        ctx2.fillText("Loading...", i, j);
      }
    }
    inProgressCache[imageSize] = image;
  }
  return image;
}
function getMatrices(chr1, chr2) {
  var promises = [];
  if ("B" === this.displayMode && this.browser.controlDataset) {
    promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
  } else {
    promises.push(this.browser.dataset.getMatrix(chr1, chr2));
    if (this.displayMode && "A" !== this.displayMode && this.browser.controlDataset) {
      promises.push(this.browser.controlDataset.getMatrix(chr1, chr2));
    }
  }
  return Promise.all(promises);
}
function computePercentile(records, p) {
  const counts = records.map((r) => r.counts);
  counts.sort(function(a, b) {
    return a - b;
  });
  const idx = Math.floor(p / 100 * records.length);
  return counts[idx];
}
class ColorScaleWidget {
  constructor(browser, hicNavbarContainer) {
    this.browser = browser;
    const container = hicNavbarContainer.querySelector("div[id$='lower-hic-nav-bar-widget-container']");
    this.container = document.createElement("div");
    this.container.className = "hic-colorscale-widget-container";
    container.appendChild(this.container);
    const { r: _r, g: _g, b: _b } = ContactMatrixView.defaultBackgroundColor;
    this.mapBackgroundColorpickerButton = colorSwatch(IGVColor$1.rgbColor(_r, _g, _b));
    this.container.appendChild(this.mapBackgroundColorpickerButton);
    this.backgroundColorpicker = createColorPicker(browser, this.mapBackgroundColorpickerButton);
    const { r: nr, g: ng, b: nb } = defaultRatioColorScaleConfig.negative;
    this.minusButton = colorSwatch(IGVColor$1.rgbColor(nr, ng, nb));
    this.container.appendChild(this.minusButton);
    this.minusColorPicker = createColorPicker(browser, this.minusButton, "-");
    this.minusButton.style.display = "none";
    const { r, g, b } = defaultRatioColorScaleConfig.positive;
    this.plusButton = colorSwatch(IGVColor$1.rgbColor(r, g, b));
    this.container.appendChild(this.plusButton);
    this.plusColorPicker = createColorPicker(browser, this.plusButton, "+");
    this.minusButton.addEventListener("click", () => presentColorPicker(this.minusColorPicker, this.plusColorPicker, this.backgroundColorpicker));
    this.plusButton.addEventListener("click", () => presentColorPicker(this.plusColorPicker, this.minusColorPicker, this.backgroundColorpicker));
    this.mapBackgroundColorpickerButton.addEventListener("click", () => presentColorPicker(this.backgroundColorpicker, this.minusColorPicker, this.plusColorPicker));
    this.highColorscaleInput = document.createElement("input");
    this.highColorscaleInput.type = "text";
    this.highColorscaleInput.title = "color scale input";
    this.container.appendChild(this.highColorscaleInput);
    this.highColorscaleInput.addEventListener("change", (e) => {
      const numeric = numberUnFormatter(e.target.value);
      if (!isNaN(numeric)) {
        browser.setColorScaleThreshold(numeric);
      }
    });
    const minusIcon = createIconButton("fa-minus", "negative threshold", () => this.highColorscaleInput.value = updateThreshold(browser, 0.5));
    this.container.appendChild(minusIcon);
    const plusIcon = createIconButton("fa-plus", "positive threshold", () => this.highColorscaleInput.value = updateThreshold(browser, 2));
    this.container.appendChild(plusIcon);
    browser.eventBus.subscribe("ColorScale", (event) => {
      if (event.data instanceof ColorScale) {
        this.highColorscaleInput.value = event.data.threshold;
        paintSwatch(this.plusButton, event.data);
      } else if (event.data instanceof RatioColorScale) {
        this.highColorscaleInput.value = event.data.threshold;
        paintSwatch(this.minusButton, event.data.negativeScale);
        paintSwatch(this.plusButton, event.data.positiveScale);
      }
    });
    browser.eventBus.subscribe("DisplayMode", (event) => {
      if (event.data === "AOB" || event.data === "BOA") {
        this.minusButton.style.display = "block";
        paintSwatch(this.minusButton, browser.contactMatrixView.ratioColorScale.negativeScale);
        paintSwatch(this.plusButton, browser.contactMatrixView.ratioColorScale.positiveScale);
      } else {
        this.minusButton.style.display = "none";
        paintSwatch(this.plusButton, browser.contactMatrixView.colorScale);
      }
    });
    browser.eventBus.subscribe("MapLoad", () => {
      paintSwatch(this.mapBackgroundColorpickerButton, browser.contactMatrixView.backgroundColor);
    });
  }
}
function paintSwatch(swatch, { r, g, b }) {
  swatch.style.backgroundColor = IGVColor$1.rgbToHex(IGVColor$1.rgbColor(r, g, b));
}
function updateThreshold(browser, scaleFactor) {
  const colorScale = browser.getColorScale();
  browser.setColorScaleThreshold(colorScale.getThreshold() * scaleFactor);
  return numberFormatter$2(colorScale.getThreshold());
}
function createColorPicker(browser, parent, type) {
  let defaultColors, colorHandler;
  if (!type) {
    const { r, g, b } = ContactMatrixView.defaultBackgroundColor;
    defaultColors = [IGVColor$1.rgbToHex(IGVColor$1.rgbColor(r, g, b))];
    colorHandler = (hex) => {
      parent.style.backgroundColor = hex;
      const rgbString = IGVColor$1.hexToRgb(hex);
      const [r2, g2, b2] = parseRgbString(rgbString);
      browser.contactMatrixView.setBackgroundColor({ r: r2, g: g2, b: b2 });
    };
  } else {
    defaultColors = [defaultRatioColorScaleConfig.negative, defaultRatioColorScaleConfig.positive].map(({ r, g, b }) => IGVColor$1.rgbToHex(IGVColor$1.rgbColor(r, g, b)));
    colorHandler = (hex) => {
      parent.style.backgroundColor = hex;
      const rgbString = IGVColor$1.hexToRgb(hex);
      const [r, g, b] = parseRgbString(rgbString);
      browser.getColorScale().setColorComponents({ r, g, b }, type);
      browser.repaintMatrix();
    };
  }
  return new ColorPicker2({ parent, top: 64, left: 64, width: 432, defaultColors, colorHandler });
}
function presentColorPicker(presentable, hideableA, hideableB) {
  hideableA.hide();
  hideableB.hide();
  presentable.show();
}
function colorSwatch(rgbString) {
  const swatch = domUtils.div({ class: "igv-ui-color-swatch" });
  swatch.style.backgroundColor = IGVColor$1.rgbToHex(rgbString);
  return swatch;
}
function createIconButton(iconClass, title, onClick) {
  const icon = document.createElement("i");
  icon.className = `fa ${iconClass}`;
  icon.title = title;
  icon.addEventListener("click", onClick);
  return icon;
}
class ControlMapWidget {
  constructor(browser, hicNavbarContainer) {
    this.browser = browser;
    const parent = hicNavbarContainer.querySelector("div[id$='lower-hic-nav-bar-widget-container']");
    this.container = document.createElement("div");
    this.container.className = "hic-control-map-selector-container";
    this.container.style.display = "none";
    parent.appendChild(this.container);
    this.select = document.createElement("select");
    this.select.name = "control_map_selector";
    this.container.appendChild(this.select);
    const toggleContainer = document.createElement("div");
    this.container.appendChild(toggleContainer);
    const cycleContainer = document.createElement("div");
    this.container.appendChild(cycleContainer);
    this.controlMapHash = new ControlMapHash(browser, this.select, toggleContainer, cycleContainer, toggleArrowsUp(), toggleArrowsDown());
    browser.eventBus.subscribe("ControlMapLoad", () => {
      this.controlMapHash.updateOptions(browser.getDisplayMode());
      this.container.style.display = "block";
    });
    browser.eventBus.subscribe("MapLoad", () => {
      if (!browser.controlDataset) {
        this.container.style.display = "none";
      }
    });
    browser.eventBus.subscribe("DisplayMode", (event) => {
      this.controlMapHash.updateOptions(event.data);
    });
  }
  toggleDisplayMode() {
    this.controlMapHash.toggleDisplayMode();
  }
  toggleDisplayModeCycle() {
    this.controlMapHash.toggleDisplayModeCycle();
  }
  getDisplayModeCycle() {
    return this.controlMapHash.cycleID;
  }
}
class ControlMapHash {
  constructor(browser, select, toggle, cycle, imgA, imgB) {
    this.browser = browser;
    this.select = select;
    this.toggle = toggle;
    this.cycle = cycle;
    this.imgA = imgA;
    this.toggle.appendChild(this.imgA);
    this.imgB = imgB;
    this.toggle.appendChild(this.imgB);
    this.hash = {
      "A": { title: "A", value: "A", other: "B", hidden: this.imgB, shown: this.imgA },
      "B": { title: "B", value: "B", other: "A", hidden: this.imgA, shown: this.imgB },
      "AOB": { title: "A/B", value: "AOB", other: "BOA", hidden: this.imgB, shown: this.imgA },
      "BOA": { title: "B/A", value: "BOA", other: "AOB", hidden: this.imgA, shown: this.imgB }
    };
    this.select.addEventListener("change", (e) => {
      this.disableDisplayModeCycle();
      this.setDisplayMode(e.target.value);
    });
    this.toggle.addEventListener("click", () => {
      this.disableDisplayModeCycle();
      this.toggleDisplayMode();
    });
    this.cycleOutline = cycleOutline();
    cycle.appendChild(this.cycleOutline);
    this.cycleSolid = cycleSolid();
    cycle.appendChild(this.cycleSolid);
    this.cycleSolid.style.display = "none";
    cycle.addEventListener("click", () => {
      this.toggleDisplayModeCycle();
    });
    cycle.style.display = "none";
  }
  disableDisplayModeCycle() {
    if (this.cycleID) {
      clearTimeout(this.cycleID);
      this.cycleID = void 0;
      this.cycleSolid.style.display = "none";
      this.cycleOutline.style.display = "block";
    }
  }
  toggleDisplayModeCycle() {
    if (this.cycleID) {
      this.disableDisplayModeCycle();
    } else {
      this.doToggle();
      this.cycleSolid.style.display = "block";
      this.cycleOutline.style.display = "none";
    }
  }
  async doToggle() {
    this.cycleID = setTimeout(async () => {
      await this.toggleDisplayMode();
      this.doToggle();
    }, 2500);
  }
  async toggleDisplayMode() {
    const oldMode = this.browser.getDisplayMode();
    const newMode = this.hash[oldMode].other;
    await this.browser.setDisplayMode(newMode);
    this.hash[newMode].hidden.style.display = "none";
    this.hash[newMode].shown.style.display = "block";
    this.select.value = newMode;
  }
  setDisplayMode(mode) {
    this.hash[mode].hidden.style.display = "none";
    this.hash[mode].shown.style.display = "block";
    this.browser.setDisplayMode(mode);
  }
  updateOptions(displayMode) {
    this.imgA.style.display = "none";
    this.imgB.style.display = "none";
    this.select.innerHTML = "";
    Object.keys(this.hash).forEach((key) => {
      const item = this.hash[key];
      const option = document.createElement("option");
      option.value = item.value;
      option.textContent = item.title;
      if (displayMode === item.value) {
        option.selected = true;
        item.shown.style.display = "block";
      }
      this.select.appendChild(option);
    });
  }
}
function toggleArrowsUp() {
  const svg2 = document.createElement("div");
  svg2.innerHTML = "<svg>...</svg>";
  return svg2;
}
function toggleArrowsDown() {
  const svg2 = document.createElement("div");
  svg2.innerHTML = "<svg>...</svg>";
  return svg2;
}
function cycleOutline() {
  const svg2 = document.createElement("div");
  svg2.innerHTML = "<svg>...</svg>";
  return svg2;
}
function cycleSolid() {
  const svg2 = document.createElement("div");
  svg2.innerHTML = "<svg>...</svg>";
  return svg2;
}
class NormalizationWidget {
  constructor(browser, hicNavBarContainer) {
    this.browser = browser;
    const parent = hicNavBarContainer.querySelector("div[id$='lower-hic-nav-bar-widget-container']");
    this.container = document.createElement("div");
    this.container.className = "hic-normalization-selector-container";
    this.container.title = "Normalization";
    parent.appendChild(this.container);
    let label = document.createElement("div");
    label.textContent = "Norm";
    this.container.appendChild(label);
    this.normalizationSelector = document.createElement("select");
    this.normalizationSelector.name = "normalization_selector";
    this.normalizationSelector.addEventListener("change", () => {
      this.browser.setNormalization(this.normalizationSelector.value);
    });
    this.container.appendChild(this.normalizationSelector);
    this.spinner = document.createElement("div");
    this.spinner.textContent = "Loading ...";
    this.container.appendChild(this.spinner);
    this.spinner.style.display = "none";
    this.browser.eventBus.subscribe("MapLoad", this);
    this.browser.eventBus.subscribe("NormVectorIndexLoad", this);
    this.browser.eventBus.subscribe("NormalizationFileLoad", this);
    this.browser.eventBus.subscribe("NormalizationExternalChange", this);
  }
  startNotReady() {
    this.normalizationSelector.style.display = "none";
    this.spinner.style.display = "block";
  }
  stopNotReady() {
    this.spinner.style.display = "none";
    this.normalizationSelector.style.display = "block";
  }
  receiveEvent(event) {
    if ("NormVectorIndexLoad" === event.type) {
      this.updateOptions();
      this.stopNotReady();
    } else if ("NormalizationFileLoad" === event.type) {
      if (event.data === "start") {
        this.startNotReady();
      } else {
        this.stopNotReady();
      }
    } else if ("NormalizationExternalChange" === event.type) {
      Array.from(this.normalizationSelector.options).forEach((option) => {
        option.selected = option.value === event.data;
      });
    }
  }
  async updateOptions() {
    const labels = {
      NONE: "None",
      VC: "Coverage",
      VC_SQRT: "Coverage - Sqrt",
      KR: "Balanced",
      INTER_VC: "Interchromosomal Coverage",
      INTER_VC_SQRT: "Interchromosomal Coverage - Sqrt",
      INTER_KR: "Interchromosomal Balanced",
      GW_VC: "Genome-wide Coverage",
      GW_VC_SQRT: "Genome-wide Coverage - Sqrt",
      GW_KR: "Genome-wide Balanced"
    };
    const norm = this.browser.state.normalization;
    const normalizationTypes = await this.browser.getNormalizationOptions();
    if (normalizationTypes) {
      this.normalizationSelector.innerHTML = "";
      normalizationTypes.forEach((normalization) => {
        const option = document.createElement("option");
        option.value = normalization;
        option.textContent = labels[normalization] || normalization;
        if (norm === normalization) {
          option.selected = true;
        }
        this.normalizationSelector.appendChild(option);
      });
    }
  }
}
class SweepZoom {
  constructor(browser, targetElement) {
    this.browser = browser;
    this.targetElement = targetElement;
    this.rulerSweeperElement = targetElement.querySelector("div[id$='-sweep-zoom-container']");
    this.rulerSweeperElement.style.display = "none";
    this.sweepRect = {};
  }
  initialize(startX, startY) {
    this.rulerSweeperElement.style.left = `${startX}px`;
    this.rulerSweeperElement.style.top = `${startY}px`;
    this.rulerSweeperElement.style.width = "0px";
    this.rulerSweeperElement.style.height = "0px";
    this.rulerSweeperElement.style.display = "block";
  }
  update({ left, top, width, height }) {
    this.rulerSweeperElement.style.width = width;
    this.rulerSweeperElement.style.height = height;
    this.rulerSweeperElement.style.left = left;
    this.rulerSweeperElement.style.top = top;
  }
  commit({ xPixel, yPixel, width, height }) {
    this.rulerSweeperElement.style.display = "none";
    const { x, y, locus, zoom, pixelSize } = this.browser.state;
    const bpResolution = this.browser.dataset.bpResolutions[zoom];
    const xBP = (x + xPixel / pixelSize) * bpResolution;
    const yBP = (y + yPixel / pixelSize) * bpResolution;
    const widthBP = width / pixelSize * bpResolution;
    const heightBP = height / pixelSize * bpResolution;
    this.browser.goto(locus.x.chr, Math.round(xBP), Math.round(xBP + widthBP), locus.y.chr, Math.round(yBP), Math.round(yBP + heightBP));
  }
}
class ScrollbarWidget {
  constructor(browser, xAxisScrollbarContainerElement, yAxisScrollbarContainerElement) {
    this.browser = browser;
    this.isDragging = false;
    this.xAxisScrollbarContainerElement = xAxisScrollbarContainerElement;
    this.xAxisScrollbarElement = xAxisScrollbarContainerElement.querySelector("div[id$='-x-axis-scrollbar']");
    this.xLabelElement = this.xAxisScrollbarElement.querySelector("div");
    this.xLabelElement.textContent = "";
    this.yAxisScrollbarContainerElement = yAxisScrollbarContainerElement;
    this.yAxisScrollbarElement = yAxisScrollbarContainerElement.querySelector("div[id$='-y-axis-scrollbar']");
    this.yLabelElement = this.yAxisScrollbarElement.querySelector(".scrollbar-label-rotation-in-place");
    this.yLabelElement.textContent = "";
    this.browser.eventBus.subscribe("LocusChange", this);
  }
  receiveEvent(event) {
    if (!this.isDragging && event.type === "LocusChange") {
      const { state } = event.data;
      const { dataset } = this.browser;
      if (state.chr1 === 0) {
        this.xAxisScrollbarElement.style.display = "none";
        this.yAxisScrollbarElement.style.display = "none";
      } else {
        this.xAxisScrollbarElement.style.display = "block";
        this.yAxisScrollbarElement.style.display = "block";
        this.xAxisScrollbarContainerElement.style.display = "block";
        this.yAxisScrollbarContainerElement.style.display = "block";
        const { chr1, chr2, zoom, pixelSize, x, y } = state;
        const chromosomeLengthsBin = [chr1, chr2].map((chr) => dataset.chromosomes[chr].size / dataset.bpResolutions[zoom]);
        const chromosomeLengthsPixel = chromosomeLengthsBin.map((bin) => bin * pixelSize);
        const { width, height } = this.browser.contactMatrixView.getViewDimensions();
        const pixels = [width, height];
        const bins = pixels.map((pixel) => pixel / pixelSize);
        const percentages = bins.map((bin, i) => {
          const binPercentage = Math.min(bin, chromosomeLengthsBin[i]) / chromosomeLengthsBin[i];
          const pixelPercentage = Math.min(chromosomeLengthsPixel[i], pixels[i]) / pixels[i];
          return Math.max(1, Math.round(100 * binPercentage * pixelPercentage));
        });
        this.xAxisScrollbarElement.style.width = `${percentages[0]}%`;
        this.yAxisScrollbarElement.style.height = `${percentages[1]}%`;
        const xPercentage = Math.round(100 * x / chromosomeLengthsBin[0]);
        this.xAxisScrollbarElement.style.left = `${xPercentage}%`;
        const yPercentage = Math.round(100 * y / chromosomeLengthsBin[1]);
        this.yAxisScrollbarElement.style.top = `${yPercentage}%`;
        this.xLabelElement.textContent = dataset.chromosomes[chr1].name;
        this.yLabelElement.textContent = dataset.chromosomes[chr2].name;
      }
    }
  }
}
class ChromosomeSelector {
  constructor(browser, container) {
    this.browser = browser;
    this.container = container;
    this.xAxisSelector = container.querySelector("select[name='x-axis-selector']");
    this.yAxisSelector = container.querySelector("select[name='y-axis-selector']");
    this.initialize();
  }
  initialize() {
    this.xAxisSelector.addEventListener("change", () => this.syncSelectors(this.xAxisSelector, this.yAxisSelector));
    this.yAxisSelector.addEventListener("change", () => this.syncSelectors(this.yAxisSelector, this.xAxisSelector));
    const nextDiv = this.yAxisSelector.nextElementSibling;
    if (nextDiv) {
      nextDiv.addEventListener("click", async () => {
        const chrX = this.browser.dataset.chromosomes[parseInt(this.xAxisSelector.value, 10)];
        const chrY = this.browser.dataset.chromosomes[parseInt(this.yAxisSelector.value, 10)];
        const xLocus = this.browser.parseLocusString(chrX.name);
        const yLocus = this.browser.parseLocusString(chrY.name);
        await this.browser.setChromosomes(xLocus, yLocus);
      });
    }
    this.browser.eventBus.subscribe("MapLoad", (event) => {
      this.respondToDataLoadWithDataset(event.data);
    });
    this.browser.eventBus.subscribe("LocusChange", (event) => {
      this.respondToLocusChangeWithState(event.data.state);
    });
  }
  syncSelectors(sourceSelector, targetSelector) {
    const value = sourceSelector.value;
    if (parseInt(value, 10) === 0 || parseInt(targetSelector.value, 10) === 0) {
      targetSelector.value = value;
    }
  }
  respondToDataLoadWithDataset(dataset) {
    const { chromosomes } = dataset;
    const options2 = chromosomes.map(({ name: name2 }, index2) => `<option value="${index2}">${name2}</option>`).join("");
    this.xAxisSelector.innerHTML = options2;
    this.yAxisSelector.innerHTML = options2;
    this.xAxisSelector.value = this.browser.state.chr1;
    this.yAxisSelector.value = this.browser.state.chr2;
  }
  respondToLocusChangeWithState(state) {
    if (!this.xAxisSelector.options.length || !this.yAxisSelector.options.length) return;
    this.xAxisSelector.value = state.chr1;
    this.yAxisSelector.value = state.chr2;
  }
}
class AnnotationWidget {
  constructor(browser, container, { title, alertMessage }, trackListRetrievalCallback) {
    this.browser = browser;
    this.trackListRetrievalCallback = trackListRetrievalCallback;
    this.annotationPresentationButton(container, alertMessage);
    this.annotationPanel(browser.rootElement, title);
  }
  updateBody(tracks) {
    this.annotationPanelElement.querySelectorAll(".hic-annotation-row-container").forEach((el) => el.remove());
    if (tracks[0] instanceof Track2D) {
      for (let i = tracks.length - 1; i >= 0; i--) {
        this.annotationPanelRow(this.annotationPanelElement, tracks[i]);
      }
    } else {
      for (const trackRenderer of tracks) {
        this.annotationPanelRow(this.annotationPanelElement, trackRenderer);
      }
    }
  }
  annotationPresentationButton(parent, alertMessage) {
    const button = parent.querySelector("button");
    button.addEventListener("click", () => {
      const list = this.trackListRetrievalCallback();
      if (list.length > 0) {
        this.updateBody(this.trackListRetrievalCallback());
        this.annotationPanelElement.style.display = this.annotationPanelElement.style.display === "none" ? "flex" : "none";
      } else {
        Alert$1.presentAlert(alertMessage);
      }
      this.browser.hideMenu();
    });
  }
  annotationPanel(parent, title) {
    this.annotationPanelElement = document.createElement("div");
    this.annotationPanelElement.className = "hic-annotation-panel-container";
    parent.appendChild(this.annotationPanelElement);
    const panelHeader = document.createElement("div");
    panelHeader.className = "hic-annotation-panel-header";
    this.annotationPanelElement.appendChild(panelHeader);
    const titleDiv = document.createElement("div");
    titleDiv.textContent = title;
    panelHeader.appendChild(titleDiv);
    const closeButtonDiv = document.createElement("div");
    closeButtonDiv.className = "hic-menu-close-button";
    panelHeader.appendChild(closeButtonDiv);
    const closeIcon = document.createElement("i");
    closeIcon.className = "fa fa-times";
    closeButtonDiv.appendChild(closeIcon);
    closeIcon.addEventListener("click", () => {
      this.annotationPanelElement.style.display = this.annotationPanelElement.style.display === "none" ? "flex" : "none";
    });
    makeDraggable(this.annotationPanelElement, panelHeader);
    this.annotationPanelElement.style.display = "none";
  }
  annotationPanelRow(container, track) {
    const isTrack2D = track instanceof Track2D;
    const trackList = this.trackListRetrievalCallback();
    let trackRenderer;
    if (false === isTrack2D) {
      trackRenderer = track.x.track.trackView;
    }
    const rowContainer = document.createElement("div");
    rowContainer.className = "hic-annotation-row-container";
    container.appendChild(rowContainer);
    const row = document.createElement("div");
    row.className = "hic-annotation-modal-row";
    rowContainer.appendChild(row);
    const trackName = document.createElement("div");
    trackName.textContent = isTrack2D ? track.config.name : track.x.track.config.name;
    row.appendChild(trackName);
    if (isTrack2D) {
      const visibilityIcon = document.createElement("i");
      visibilityIcon.className = track.isVisible ? "fa fa-eye fa-lg" : "fa fa-eye-slash fa-lg";
      row.appendChild(visibilityIcon);
      visibilityIcon.addEventListener("click", () => {
        track.isVisible = !track.isVisible;
        visibilityIcon.className = track.isVisible ? "fa fa-eye fa-lg" : "fa fa-eye-slash fa-lg";
        this.browser.contactMatrixView.clearImageCaches();
        this.browser.contactMatrixView.update();
      });
    }
    if (isTrack2D) {
      const displayModeIcon = document.createElement("div");
      displayModeIcon.className = "matrix-diagonal-widget-container";
      switch (track.displayMode) {
        case "lower":
          displayModeIcon.classList.add("matrix-diagonal-widget-lower");
          break;
        case "upper":
          displayModeIcon.classList.add("matrix-diagonal-widget-upper");
          break;
        default:
          displayModeIcon.classList.add("matrix-diagonal-widget-all");
      }
      displayModeIcon.addEventListener("click", () => {
        this.displayModeHandler(displayModeIcon, track);
        this.browser.contactMatrixView.clearImageCaches();
        this.browser.contactMatrixView.update();
      });
      row.appendChild(displayModeIcon);
    }
    const colorpickerContainer = createAnnotationPanelColorpickerContainer(rowContainer, { width: 29 * 24 + 2 }, () => {
      const nextElement = row.nextElementSibling;
      if (nextElement && nextElement.classList.contains("hic-color-swatch-container")) {
        nextElement.style.display = nextElement.style.display === "none" ? "flex" : "none";
      }
    });
    const colorpickerButton = this.annotationColorSwatch(isTrack2D ? track.getColor() : track.x.track.color);
    row.appendChild(colorpickerButton);
    colorpickerButton.addEventListener("click", () => {
      const nextElement = row.nextElementSibling;
      if (nextElement && nextElement.classList.contains("hic-color-swatch-container")) {
        nextElement.style.display = nextElement.style.display === "none" ? "flex" : "none";
      }
    });
    colorpickerContainer.style.display = "none";
    const colorHandler = (color) => {
      const swatch = row.querySelector(".fa-square");
      if (swatch) {
        swatch.style.color = color;
      }
      if (isTrack2D) {
        track.color = color;
        this.browser.eventBus.post(HICEvent("TrackState2D", track));
      } else {
        trackRenderer.setColor(color);
      }
    };
    createColorSwatchSelector(colorpickerContainer, colorHandler);
    const upDownContainer = document.createElement("div");
    upDownContainer.className = "up-down-arrow-container";
    row.appendChild(upDownContainer);
    const upTrack = document.createElement("i");
    upTrack.className = "fa fa-arrow-up";
    upTrack.setAttribute("aria-hidden", "true");
    upDownContainer.appendChild(upTrack);
    const downTrack = document.createElement("i");
    downTrack.className = "fa fa-arrow-down";
    downTrack.setAttribute("aria-hidden", "true");
    upDownContainer.appendChild(downTrack);
    const hiddenColor = "#f7f7f7";
    if (trackList.length === 1) {
      upTrack.style.color = hiddenColor;
      downTrack.style.color = hiddenColor;
    } else if (track === trackList[0]) {
      const arrow = isTrack2D ? downTrack : upTrack;
      arrow.style.color = hiddenColor;
    } else if (track === trackList[trackList.length - 1]) {
      const arrow = isTrack2D ? upTrack : downTrack;
      arrow.style.color = hiddenColor;
    }
    const index2 = trackList.indexOf(track);
    const moveUp = () => {
      const temp = trackList[index2 + 1];
      trackList[index2 + 1] = trackList[index2];
      trackList[index2] = temp;
      if (isTrack2D) {
        this.browser.eventBus.post(HICEvent("TrackState2D", trackList));
        this.updateBody(trackList);
      } else {
        this.browser.updateLayout();
        this.updateBody(trackList);
      }
    };
    const moveDown = () => {
      const temp = trackList[index2 - 1];
      trackList[index2 - 1] = trackList[index2];
      trackList[index2] = temp;
      if (isTrack2D) {
        this.browser.eventBus.post(HICEvent("TrackState2D", trackList));
        this.updateBody(trackList);
      } else {
        this.browser.updateLayout();
        this.updateBody(trackList);
      }
    };
    upTrack.addEventListener("click", isTrack2D ? moveUp : moveDown);
    downTrack.addEventListener("click", isTrack2D ? moveDown : moveUp);
    const deleteIcon = document.createElement("i");
    deleteIcon.className = "fa fa-trash-o fa-lg";
    row.appendChild(deleteIcon);
    deleteIcon.addEventListener("click", () => {
      const index3 = trackList.indexOf(track);
      if (isTrack2D) {
        trackList.splice(index3, 1);
        this.browser.contactMatrixView.clearImageCaches();
        this.browser.contactMatrixView.update();
        this.browser.eventBus.post(HICEvent("TrackLoad2D", trackList));
      } else {
        this.browser.layoutController.removeTrackXYPair(track.x.track.trackRenderPair);
      }
      this.updateBody(trackList);
    });
  }
  displayModeHandler(icon, track2D) {
    if (icon.classList.contains("matrix-diagonal-widget-all")) {
      icon.classList.replace("matrix-diagonal-widget-all", "matrix-diagonal-widget-lower");
      track2D.displayMode = "lower";
    } else if (icon.classList.contains("matrix-diagonal-widget-lower")) {
      icon.classList.replace("matrix-diagonal-widget-lower", "matrix-diagonal-widget-upper");
      track2D.displayMode = "upper";
    } else {
      icon.classList.replace("matrix-diagonal-widget-upper", "matrix-diagonal-widget-all");
      track2D.displayMode = void 0;
    }
  }
  annotationColorSwatch(color) {
    const swatch = document.createElement("div");
    swatch.className = "igv-color-swatch";
    const icon = document.createElement("i");
    icon.className = "fa fa-square fa-lg";
    icon.style.color = color;
    swatch.appendChild(icon);
    return swatch;
  }
}
function createAnnotationPanelColorpickerContainer(parent, size, closeHandler) {
  const container = document.createElement("div");
  container.className = "hic-color-swatch-container";
  parent.appendChild(container);
  if (size && size.width) {
    container.style.width = `${size.width}px`;
  }
  if (size && size.height) {
    container.style.height = `${size.height}px`;
  }
  const header = document.createElement("div");
  container.appendChild(header);
  const closeButton = document.createElement("i");
  closeButton.className = "fa fa-times";
  header.appendChild(closeButton);
  closeButton.addEventListener("click", () => {
    closeHandler();
  });
  return container;
}
class BrowserUIManager {
  constructor(browser) {
    this.browser = browser;
    this.components = /* @__PURE__ */ new Map();
    this.initializeComponents();
  }
  initializeComponents() {
    const navContainer = getNavbarContainer(this.browser);
    this.components.set("locusGoto", new LocusGoto(this.browser, navContainer));
    this.components.set("resolutionSelector", new ResolutionSelector(this.browser, navContainer));
    this.getComponent("resolutionSelector").setResolutionLock(this.browser.resolutionLocked);
    this.components.set("colorScale", new ColorScaleWidget(this.browser, navContainer));
    this.components.set("controlMap", new ControlMapWidget(this.browser, navContainer));
    this.components.set("normalization", new NormalizationWidget(this.browser, navContainer));
    const chromosomeSelectorContainer = this.browser.menuElement.querySelector(".hic-chromosome-selector-widget-container");
    this.components.set("chromosomeSelector", new ChromosomeSelector(this.browser, chromosomeSelectorContainer));
    const annotationContainer = this.browser.menuElement.querySelector(".hic-annotation-presentation-button-container");
    const annotation2DWidgetConfig = {
      title: "2D Annotations",
      alertMessage: "No 2D annotations currently loaded for this map"
    };
    this.components.set("annotationWidget", new AnnotationWidget(this.browser, annotationContainer, annotation2DWidgetConfig, () => this.browser.tracks2D));
    const sweepZoom = new SweepZoom(this.browser, this.browser.layoutController.getContactMatrixViewport());
    const scrollbarWidget = new ScrollbarWidget(
      this.browser,
      this.browser.layoutController.getXAxisScrollbarContainer(),
      this.browser.layoutController.getYAxisScrollbarContainer()
    );
    const colorScale = new ColorScale(defaultColorScaleConfig);
    const ratioColorScale = new RatioColorScale(defaultRatioColorScaleConfig.threshold);
    ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.negative, "-");
    ratioColorScale.setColorComponents(defaultRatioColorScaleConfig.positive, "+");
    this.components.set("sweepZoom", sweepZoom);
    this.components.set("scrollbar", scrollbarWidget);
    this.components.set("colorScale", colorScale);
    this.components.set("ratioColorScale", ratioColorScale);
    const backgroundColor = this.browser.config.backgroundColor || ContactMatrixView.defaultBackgroundColor;
    this.components.set("contactMatrix", new ContactMatrixView(
      this.browser,
      this.browser.layoutController.getContactMatrixViewport(),
      sweepZoom,
      scrollbarWidget,
      colorScale,
      ratioColorScale,
      backgroundColor
    ));
  }
  getComponent(name2) {
    return this.components.get(name2);
  }
}
class SpinnerManager {
  constructor(contactMatrixView, userInteractionShield) {
    this.contactMatrixView = contactMatrixView;
    this.userInteractionShield = userInteractionShield;
  }
  startSpinner() {
    if (this.contactMatrixView) {
      this.contactMatrixView.startSpinner();
    }
  }
  stopSpinner() {
    if (this.contactMatrixView) {
      this.contactMatrixView.stopSpinner();
    }
  }
  showInteractionShield() {
    if (this.userInteractionShield) {
      this.userInteractionShield.style.display = "block";
    }
  }
  hideInteractionShield() {
    if (this.userInteractionShield) {
      this.userInteractionShield.style.display = "none";
    }
  }
}
class CrosshairManager {
  constructor(contactMatrixView, layoutController, browser) {
    this.contactMatrixView = contactMatrixView;
    this.layoutController = layoutController;
    this.browser = browser;
    this.customCrosshairsHandler = null;
  }
  updateCrosshairs({ x, y, xNormalized, yNormalized }) {
    const xGuide = y < 0 ? { left: "0px" } : { top: `${y}px`, left: "0px" };
    this.contactMatrixView.xGuideElement.style.left = xGuide.left;
    if (xGuide.top !== void 0) this.contactMatrixView.xGuideElement.style.top = xGuide.top;
    this.layoutController.xTrackGuideElement.style.left = xGuide.left;
    if (xGuide.top !== void 0) this.layoutController.xTrackGuideElement.style.top = xGuide.top;
    const yGuide = x < 0 ? { top: "0px" } : { top: "0px", left: `${x}px` };
    this.contactMatrixView.yGuideElement.style.top = yGuide.top;
    if (yGuide.left !== void 0) this.contactMatrixView.yGuideElement.style.left = yGuide.left;
    this.layoutController.yTrackGuideElement.style.top = yGuide.top;
    if (yGuide.left !== void 0) this.layoutController.yTrackGuideElement.style.left = yGuide.left;
    if (this.customCrosshairsHandler) {
      const { x: stateX, y: stateY, pixelSize } = this.browser.state;
      const resolution = this.browser.resolution();
      const xBP = (stateX + x / pixelSize) * resolution;
      const yBP = (stateY + y / pixelSize) * resolution;
      const { startBP: startXBP, endBP: endXBP } = this.browser.genomicState("x");
      const { startBP: startYBP, endBP: endYBP } = this.browser.genomicState("y");
      this.customCrosshairsHandler({
        xBP,
        yBP,
        startXBP,
        startYBP,
        endXBP,
        endYBP,
        interpolantX: xNormalized,
        interpolantY: yNormalized
      });
    }
  }
  setCustomCrosshairsHandler(crosshairsHandler) {
    this.customCrosshairsHandler = crosshairsHandler;
  }
  hideCrosshairs() {
    this.contactMatrixView.xGuideElement.style.display = "none";
    this.layoutController.xTrackGuideElement.style.display = "none";
    this.contactMatrixView.yGuideElement.style.display = "none";
    this.layoutController.yTrackGuideElement.style.display = "none";
  }
  showCrosshairs() {
    this.contactMatrixView.xGuideElement.style.display = "block";
    this.layoutController.xTrackGuideElement.style.display = "block";
    this.contactMatrixView.yGuideElement.style.display = "block";
    this.layoutController.yTrackGuideElement.style.display = "block";
  }
}
class MenuManager {
  constructor(rootElement, browser) {
    this.rootElement = rootElement;
    this.browser = browser;
    this.menuElement = null;
  }
  createMenu(rootElement) {
    const html2 = `
        <div class="hic-menu" style="display: none;">
            <div class="hic-menu-close-button">
                <i class="fa fa-times"></i>
            </div>
            <div class="hic-chromosome-selector-widget-container">
                <div>Chromosomes</div>
                <div>
                    <select name="x-axis-selector"></select>
                    <select name="y-axis-selector"></select>
                    <div></div>
                </div>
            </div>
            <div class="hic-annotation-presentation-button-container">
                <button type="button">2D Annotations</button>
            </div>
        </div>`;
    const template = document.createElement("template");
    template.innerHTML = html2.trim();
    const menuElement = template.content.firstChild;
    rootElement.appendChild(menuElement);
    const closeButton = menuElement.querySelector(".fa-times");
    closeButton.addEventListener("click", () => this.toggleMenu());
    this.menuElement = menuElement;
    return menuElement;
  }
  toggleMenu() {
    if (this.menuElement.style.display === "flex") {
      this.hideMenu();
    } else {
      this.showMenu();
    }
  }
  showMenu() {
    if (this.menuElement) {
      this.menuElement.style.display = "flex";
    }
  }
  hideMenu() {
    if (this.menuElement) {
      this.menuElement.style.display = "none";
    }
  }
  getMenuElement() {
    return this.menuElement;
  }
}
class CoordinateTransformer {
  /**
   * Calculate genomic state for a given axis
   * @param {Object} dataset - The dataset object
   * @param {Object} state - The browser state
   * @param {Object} contactMatrixView - The contact matrix view
   * @param {Object} genome - The genome object
   * @param {string} axis - Either 'x' or 'y'
   * @returns {Object} Genomic state object
   */
  static genomicState(dataset, state, contactMatrixView, genome, axis) {
    let width = contactMatrixView.getViewDimensions().width;
    let resolution = dataset.bpResolutions[state.zoom];
    const bpp = dataset.chromosomes[state.chr1].name.toLowerCase() === "all" ? genome.getGenomeLength() / width : resolution / state.pixelSize;
    const gs = { bpp };
    if (axis === "x") {
      gs.chromosome = dataset.chromosomes[state.chr1];
      gs.startBP = state.x * resolution;
      gs.endBP = gs.startBP + bpp * width;
    } else {
      gs.chromosome = dataset.chromosomes[state.chr2];
      gs.startBP = state.y * resolution;
      gs.endBP = gs.startBP + bpp * contactMatrixView.getViewDimensions().height;
    }
    return gs;
  }
  /**
   * Get current resolution from dataset and state
   * @param {Object} dataset - The dataset object
   * @param {Object} state - The browser state
   * @returns {number} Current resolution
   */
  static resolution(dataset, state) {
    return dataset.bpResolutions[state.zoom];
  }
  /**
   * Find the closest matching zoom index for the target resolution
   * @param {number} targetResolution - Target resolution to find
   * @param {Array} resolutionArray - Array of resolutions or objects with index and binSize
   * @returns {number} Matching zoom index
   */
  static findMatchingZoomIndex(targetResolution, resolutionArray) {
    const isObject = resolutionArray.length > 0 && resolutionArray[0].index !== void 0;
    for (let z = resolutionArray.length - 1; z > 0; z--) {
      const binSize = isObject ? resolutionArray[z].binSize : resolutionArray[z];
      const index2 = isObject ? resolutionArray[z].index : z;
      if (binSize >= targetResolution) {
        return index2;
      }
    }
    return 0;
  }
}
async function geneSearch(genomeId, featureName) {
  const searchServiceURL = `https://portals.broadinstitute.org/webservices/igv/locus?genome=${genomeId}&name=${encodeURIComponent(featureName)}`;
  try {
    const data = await igvxhr$1.loadString(searchServiceURL);
    const results = parseSearchResults(data);
    return results.length ? results[0] : void 0;
  } catch (error) {
    console.error(`Error fetching gene data for "${featureName}":`, error);
    return void 0;
  }
}
function parseSearchResults(data) {
  const parsed = splitLines$6(data).filter((line) => line.trim() !== "").map((line) => line.split("	")).filter((tokens) => tokens.length >= 3).map((tokens) => tokens[1]);
  return parsed;
}
class LocusParser {
  /**
   * Parse a locus string into a locus object
   * @param {string} locus - The locus string to parse
   * @param {Object} genome - The genome object
   * @returns {Object|undefined} Parsed locus object or undefined if invalid
   */
  static parseLocusString(locus, genome) {
    const trimmedLocus = locus.trim().toLowerCase();
    if (trimmedLocus === "all") {
      const wholeGenomeChr = genome.chromosomes.find((chr) => chr.name.toLowerCase() === "all");
      if (wholeGenomeChr) {
        return {
          chr: wholeGenomeChr.name,
          wholeChr: true,
          start: 0,
          end: wholeGenomeChr.size
        };
      } else {
        return void 0;
      }
    }
    const [chrName, range] = trimmedLocus.split(":");
    const chromosome = genome.getChromosome(chrName);
    if (!chromosome) {
      return void 0;
    }
    const locusObject = {
      chr: chromosome.name,
      wholeChr: void 0 === range && "All" !== chromosome.name
    };
    if (true === locusObject.wholeChr || "All" === chromosome.name) {
      locusObject.start = 0;
      locusObject.end = chromosome.size;
    } else {
      const [startStr, endStr] = range.split("-").map((part) => part.replace(/,/g, ""));
      locusObject.start = isNaN(startStr) ? void 0 : parseInt(startStr, 10) - 1;
      locusObject.end = isNaN(endStr) ? void 0 : parseInt(endStr, 10);
    }
    return locusObject;
  }
  /**
   * Look up a feature or gene by name
   * @param {string} name - The name to look up
   * @param {Object} genome - The genome object
   * @param {Object} state - The browser state (for setting selectedGene)
   * @returns {Object|undefined} Parsed locus object or undefined if not found
   */
  static async lookupFeatureOrGene(name2, genome, state) {
    const trimmedName = name2.trim();
    const upperName = trimmedName.toUpperCase();
    if (genome.featureDB.has(upperName)) {
      Globals.selectedGene = trimmedName;
      state.selectedGene = Globals.selectedGene;
      const { chr, start, end } = genome.featureDB.get(upperName);
      return this.parseLocusString(`${chr}:${start + 1}-${end}`, genome);
    }
    const geneResult = await geneSearch(genome.id, trimmedName);
    if (geneResult) {
      Globals.selectedGene = trimmedName;
      state.selectedGene = Globals.selectedGene;
      return this.parseLocusString(geneResult, genome);
    }
    return void 0;
  }
}
class ZoomCalculator {
  /**
   * Calculate minimum zoom level for given chromosomes
   * @param {number} chr1 - First chromosome index
   * @param {number} chr2 - Second chromosome index
   * @param {Object} dataset - The dataset object
   * @param {Object} contactMatrixView - The contact matrix view
   * @returns {Promise<number>} Minimum zoom index
   */
  static async minZoom(chr1, chr2, dataset, contactMatrixView) {
    const chromosome1 = dataset.chromosomes[chr1];
    const chromosome2 = dataset.chromosomes[chr2];
    const { width, height } = contactMatrixView.getViewDimensions();
    const binSize = Math.max(chromosome1.size / width, chromosome2.size / height);
    const matrix = await dataset.getMatrix(chr1, chr2);
    if (!matrix) {
      throw new Error(`Data not available for chromosomes ${chromosome1.name} - ${chromosome2.name}`);
    }
    return matrix.findZoomForResolution(binSize);
  }
  /**
   * Calculate minimum pixel size for given chromosomes and zoom
   * @param {number} chr1 - First chromosome index
   * @param {number} chr2 - Second chromosome index
   * @param {number} zoomIndex - Zoom index
   * @param {Object} dataset - The dataset object
   * @param {Object} contactMatrixView - The contact matrix view
   * @returns {Promise<number>} Minimum pixel size
   */
  static async minPixelSize(chr1, chr2, zoomIndex, dataset, contactMatrixView) {
    const chr1Length = dataset.chromosomes[chr1].size;
    const chr2Length = dataset.chromosomes[chr2].size;
    const matrix = await dataset.getMatrix(chr1, chr2);
    const { zoom } = matrix.getZoomDataByIndex(zoomIndex, "BP");
    const nBins1 = chr1Length / zoom.binSize;
    const nBins2 = chr2Length / zoom.binSize;
    const { width, height } = contactMatrixView.getViewDimensions();
    return Math.min(width / nBins1, height / nBins2);
  }
}
class NavigationService {
  constructor(browser) {
    this.browser = browser;
  }
  /**
   * Navigate to specific coordinates
   * @param {string} chr1 - First chromosome
   * @param {number} bpX - X coordinate in base pairs
   * @param {number} bpXMax - X end coordinate in base pairs
   * @param {string} chr2 - Second chromosome
   * @param {number} bpY - Y coordinate in base pairs
   * @param {number} bpYMax - Y end coordinate in base pairs
   */
  goto(chr1, bpX, bpXMax, chr2, bpY, bpYMax) {
    const { width, height } = this.browser.contactMatrixView.getViewDimensions();
    const { chrChanged, resolutionChanged } = this.browser.state.updateWithLoci(chr1, bpX, bpXMax, chr2, bpY, bpYMax, this.browser, width, height);
    this.browser.contactMatrixView.clearImageCaches();
    this.browser.update(HICEvent("LocusChange", { state: this.browser.state, resolutionChanged, chrChanged }));
  }
  /**
   * Find the closest matching zoom index for the target resolution
   * @param {number} targetResolution - Target resolution to find
   * @param {Array} resolutionArray - Array of resolutions or objects with index and binSize
   * @returns {number} Matching zoom index
   */
  findMatchingZoomIndex(targetResolution, resolutionArray) {
    return CoordinateTransformer.findMatchingZoomIndex(targetResolution, resolutionArray);
  }
  /**
   * Handle pinch zoom gesture
   * @param {number} anchorPx - Anchor position in pixels (should not move after transformation)
   * @param {number} anchorPy - Anchor position in pixels
   * @param {number} scaleFactor - Scale factor (>1 for zoom in, <1 for zoom out)
   */
  async pinchZoom(anchorPx, anchorPy, scaleFactor) {
    if (this.browser.state.chr1 === 0) {
      await this.zoomAndCenter(1, anchorPx, anchorPy);
    } else {
      try {
        this.browser.startSpinner();
        const bpResolutions = this.browser.getResolutions();
        const currentResolution = bpResolutions[this.browser.state.zoom];
        let newBinSize;
        let newZoom;
        let newPixelSize;
        let resolutionChanged;
        if (this.browser.resolutionLocked || this.browser.state.zoom === bpResolutions.length - 1 && scaleFactor > 1 || this.browser.state.zoom === 0 && scaleFactor < 1) {
          newBinSize = currentResolution.binSize;
          newPixelSize = Math.min(128, this.browser.state.pixelSize * scaleFactor);
          newZoom = this.browser.state.zoom;
          resolutionChanged = false;
        } else {
          const targetBinSize = currentResolution.binSize / this.browser.state.pixelSize / scaleFactor;
          newZoom = this.findMatchingZoomIndex(targetBinSize, bpResolutions);
          newBinSize = bpResolutions[newZoom].binSize;
          resolutionChanged = newZoom !== this.browser.state.zoom;
          newPixelSize = Math.min(128, newBinSize / targetBinSize);
        }
        const z = await this.browser.minZoom(this.browser.state.chr1, this.browser.state.chr2);
        if (!this.browser.resolutionLocked && scaleFactor < 1 && newZoom < z) {
          const xLocus = LocusParser.parseLocusString("1", this.browser.genome);
          const yLocus = { ...xLocus };
          await this.browser.setChromosomes(xLocus, yLocus);
        } else {
          await this.browser.state.panWithZoom(newZoom, newPixelSize, anchorPx, anchorPy, newBinSize, this.browser, this.browser.dataset, this.browser.contactMatrixView.getViewDimensions(), bpResolutions);
          await this.browser.contactMatrixView.zoomIn(anchorPx, anchorPy, 1 / scaleFactor);
          await this.browser.update(HICEvent("LocusChange", { state: this.browser.state, resolutionChanged, chrChanged: false }));
        }
      } finally {
        this.browser.stopSpinner();
      }
    }
  }
  /**
   * Zoom and center on bins at given screen coordinates
   * @param {number} direction - Direction of zoom (positive for zoom in, negative for zoom out)
   * @param {number} centerPX - Screen coordinate to center on
   * @param {number} centerPY - Screen coordinate to center on
   * @returns {Promise<void>}
   */
  async zoomAndCenter(direction, centerPX, centerPY) {
    if (void 0 === this.browser.dataset) {
      console.warn("Dataset is undefined");
      return;
    }
    if (this.browser.dataset.isWholeGenome(this.browser.state.chr1) && direction > 0) {
      const genomeCoordX = centerPX * this.browser.dataset.wholeGenomeResolution / this.browser.state.pixelSize;
      const genomeCoordY = centerPY * this.browser.dataset.wholeGenomeResolution / this.browser.state.pixelSize;
      const chrX = this.browser.genome.getChromosomeForCoordinate(genomeCoordX);
      const chrY = this.browser.genome.getChromosomeForCoordinate(genomeCoordY);
      const xLocus = { chr: chrX.name, start: 0, end: chrX.size, wholeChr: true };
      const yLocus = { chr: chrY.name, start: 0, end: chrY.size, wholeChr: true };
      await this.browser.setChromosomes(xLocus, yLocus);
    } else {
      const { width, height } = this.browser.contactMatrixView.getViewDimensions();
      const dx = centerPX === void 0 ? 0 : centerPX - width / 2;
      this.browser.state.x += dx / this.browser.state.pixelSize;
      const dy = centerPY === void 0 ? 0 : centerPY - height / 2;
      this.browser.state.y += dy / this.browser.state.pixelSize;
      const resolutions = this.browser.getResolutions();
      const directionPositive = direction > 0 && this.browser.state.zoom === resolutions[resolutions.length - 1].index;
      const directionNegative = direction < 0 && this.browser.state.zoom === resolutions[0].index;
      if (this.browser.resolutionLocked || directionPositive || directionNegative) {
        const minPS = await this.browser.minPixelSize(this.browser.state.chr1, this.browser.state.chr2, this.browser.state.zoom);
        const newPixelSize = Math.max(Math.min(128, this.browser.state.pixelSize * (direction > 0 ? 2 : 0.5)), minPS);
        const shiftRatio = (newPixelSize - this.browser.state.pixelSize) / newPixelSize;
        this.browser.state.pixelSize = newPixelSize;
        this.browser.state.x += shiftRatio * (width / this.browser.state.pixelSize);
        this.browser.state.y += shiftRatio * (height / this.browser.state.pixelSize);
        this.browser.state.clampXY(this.browser.dataset, this.browser.contactMatrixView.getViewDimensions());
        this.browser.state.configureLocus(this.browser, this.browser.dataset, { width, height });
        this.browser.update(HICEvent("LocusChange", { state: this.browser.state, resolutionChanged: false, chrChanged: false }));
      } else {
        let i;
        for (i = 0; i < resolutions.length; i++) {
          if (this.browser.state.zoom === resolutions[i].index) break;
        }
        if (i) {
          const newZoom = resolutions[i + direction].index;
          this.setZoom(newZoom);
        }
      }
    }
  }
  /**
   * Set the current zoom state
   * @param {number} zoom - Index to the datasets resolution array (dataset.bpResolutions)
   * @returns {Promise<void>}
   */
  async setZoom(zoom) {
    const resolutionChanged = await this.browser.state.setWithZoom(zoom, this.browser.contactMatrixView.getViewDimensions(), this.browser, this.browser.dataset);
    await this.browser.contactMatrixView.zoomIn();
    this.browser.update(HICEvent("LocusChange", { state: this.browser.state, resolutionChanged, chrChanged: false }));
  }
}
class StateManager {
  constructor(browser) {
    this.browser = browser;
  }
  /**
   * Set the matrix state. Used to restore state from a bookmark
   * @param {Object} state - Browser state
   */
  async setState(state) {
    const chrChanged = !this.browser.state || this.browser.state.chr1 !== state.chr1 || this.browser.state.chr2 !== state.chr2;
    this.browser.state = state.clone();
    const minPS = await this.browser.minPixelSize(this.browser.state.chr1, this.browser.state.chr2, this.browser.state.zoom);
    this.browser.state.pixelSize = Math.max(state.pixelSize, minPS);
    if (void 0 === state.locus) {
      const viewDimensions = this.browser.contactMatrixView.getViewDimensions();
      this.browser.state.configureLocus(this.browser, this.browser.dataset, viewDimensions);
    }
    const hicEvent = new HICEvent("LocusChange", { state: this.browser.state, resolutionChanged: true, chrChanged });
    this.browser.update(hicEvent);
    this.browser.eventBus.post(hicEvent);
  }
  /**
   * Return a modified state object used for synching
   * Other datasets might have different chromosome ordering and resolution arrays
   */
  getSyncState() {
    return {
      chr1Name: this.browser.dataset.chromosomes[this.browser.state.chr1].name,
      chr2Name: this.browser.dataset.chromosomes[this.browser.state.chr2].name,
      binSize: this.browser.dataset.bpResolutions[this.browser.state.zoom],
      binX: this.browser.state.x,
      // TODO: translate to lower right corner
      binY: this.browser.state.y,
      pixelSize: this.browser.state.pixelSize
    };
  }
  /**
   * Return true if this browser can be synced to the given state
   * @param {Object} syncState - State to check compatibility with
   * @returns {boolean} Whether browser can be synced
   */
  canBeSynched(syncState) {
    if (false === this.browser.synchable) return false;
    return this.browser.dataset && this.browser.dataset.getChrIndexFromName(syncState.chr1Name) !== void 0 && this.browser.dataset.getChrIndexFromName(syncState.chr2Name) !== void 0;
  }
  /**
   * Sync this browser's state to match the target state
   * @param {Object} targetState - State to sync to
   */
  async syncState(targetState) {
    if (!targetState || false === this.browser.synchable) return;
    if (!this.browser.dataset) return;
    const { zoomChanged, chrChanged } = this.browser.state.sync(targetState, this.browser, this.browser.genome, this.browser.dataset);
    const payload = { state: this.browser.state, resolutionChanged: zoomChanged, chrChanged };
    this.browser.update(HICEvent("LocusChange", payload, false));
  }
}
class BrowserLifecycleManager {
  constructor(browser) {
    this.browser = browser;
  }
  /**
   * Reset the browser to initial state
   */
  reset() {
    this.browser.layoutController.removeAllTrackXYPairs();
    this.browser.contactMatrixView.clearImageCaches();
    this.browser.tracks2D = [];
    this.browser.tracks = [];
    this.browser.contactMapLabel.textContent = "";
    this.browser.contactMapLabel.title = "";
    this.browser.controlMapLabel.textContent = "";
    this.browser.controlMapLabel.title = "";
    this.browser.dataset = void 0;
    this.browser.controlDataset = void 0;
    this.unsyncSelf();
  }
  /**
   * Clear current session but keep browser alive
   */
  clearSession() {
    this.browser.dataset = void 0;
    this.browser.controlDataset = void 0;
    this.browser.setDisplayMode("A");
    this.unsyncSelf();
  }
  /**
   * Remove reference to self from all synchedBrowsers lists
   */
  unsyncSelf() {
    const allBrowsers2 = getAllBrowsers();
    for (let b of allBrowsers2) {
      b.unsync(this.browser);
    }
  }
  /**
   * Remove the reference browser from this collection of synched browsers
   * @param {Object} browser - Browser to remove from sync list
   */
  unsync(browser) {
    const list = [...this.browser.synchedBrowsers];
    this.browser.synchedBrowsers = new Set(list.filter((b) => b !== browser));
  }
}
const DEFAULT_PIXEL_SIZE = 1;
const MAX_PIXEL_SIZE = 128;
const DEFAULT_ANNOTATION_COLOR$1 = "rgb(22, 129, 198)";
class HICBrowser {
  constructor(appContainer, config) {
    this.config = config;
    this.figureMode = config.figureMode || config.miniMode;
    this.resolutionLocked = false;
    this.eventBus = new EventBus();
    this.showTrackLabelAndGutter = true;
    this.id = `browser_${domUtils.guid()}`;
    this.trackPairs = [];
    this.tracks2D = [];
    this.normVectorFiles = [];
    this.synchable = config.synchable !== false;
    this.synchedBrowsers = /* @__PURE__ */ new Set();
    this.isMobile = isMobile();
    this.rootElement = document.createElement("div");
    this.rootElement.className = "hic-root unselect";
    appContainer.appendChild(this.rootElement);
    if (config.width && config.height) {
      setViewportSize(config.width, config.height);
    }
    this.layoutController = new LayoutController(this, this.rootElement);
    this.inputDialog = new InputDialog2(appContainer, this);
    this.menuManager = new MenuManager(this.rootElement, this);
    this.menuElement = this.menuManager.createMenu(this.rootElement);
    this.menuElement.style.display = "none";
    this.ui = new BrowserUIManager(this);
    this.contactMatrixView = this.ui.getComponent("contactMatrix");
    this.userInteractionShield = document.createElement("div");
    this.userInteractionShield.className = "hic-root-prevent-interaction";
    this.rootElement.appendChild(this.userInteractionShield);
    this.userInteractionShield.style.display = "none";
    this.spinnerManager = new SpinnerManager(this.contactMatrixView, this.userInteractionShield);
    this.crosshairManager = new CrosshairManager(this.contactMatrixView, this.layoutController, this);
    this.navigationService = new NavigationService(this);
    this.stateManager = new StateManager(this);
    this.lifecycleManager = new BrowserLifecycleManager(this);
    this.hideCrosshairs();
  }
  async init(config) {
    this.pending = /* @__PURE__ */ new Map();
    this.eventBus.hold();
    this.contactMatrixView.disableUpdates = true;
    try {
      this.contactMatrixView.startSpinner();
      this.userInteractionShield.style.display = "block";
      await this.loadHicFile(config, true);
      if (config.controlUrl) {
        await this.loadHicControlFile({
          url: config.controlUrl,
          name: config.controlName,
          nvi: config.controlNvi,
          isControl: true
        }, true);
      }
      if (config.cycle) {
        config.displayMode = "A";
      }
      if (config.displayMode) {
        this.contactMatrixView.displayMode = config.displayMode;
        this.eventBus.post({ type: "DisplayMode", data: config.displayMode });
      }
      if (config.colorScale) {
        if (config.normalization) {
          this.state.normalization = config.normalization;
        }
        this.contactMatrixView.setColorScale(config.colorScale);
        this.eventBus.post({ type: "ColorScale", data: this.contactMatrixView.getColorScale() });
      }
      const promises = [];
      if (config.tracks) {
        promises.push(this.loadTracks(config.tracks));
      }
      if (config.normVectorFiles) {
        config.normVectorFiles.forEach((nv) => {
          promises.push(this.loadNormalizationFile(nv));
        });
      }
      await Promise.all(promises);
      if (config.normalization) {
        const normalizations = await this.getNormalizationOptions();
        const validNormalizations = new Set(normalizations);
        this.state.normalization = validNormalizations.has(config.normalization) ? config.normalization : "NONE";
      }
      const tmp = this.contactMatrixView.colorScaleThresholdCache;
      this.eventBus.release();
      this.contactMatrixView.colorScaleThresholdCache = tmp;
      if (config.cycle) {
        this.ui.getComponent("controlMap").toggleDisplayModeCycle();
      } else {
        await this.update();
      }
    } finally {
      this.contactMatrixView.stopSpinner();
      this.userInteractionShield.style.display = "none";
      this.contactMatrixView.disableUpdates = false;
      this.contactMatrixView.update();
    }
  }
  toggleTrackLabelAndGutterState() {
    this.showTrackLabelAndGutter = !this.showTrackLabelAndGutter;
  }
  toggleMenu() {
    this.menuManager.toggleMenu();
  }
  showMenu() {
    this.menuManager.showMenu();
  }
  hideMenu() {
    this.menuManager.hideMenu();
  }
  startSpinner() {
    this.spinnerManager.startSpinner();
  }
  stopSpinner() {
    this.spinnerManager.stopSpinner();
  }
  async setDisplayMode(mode) {
    await this.contactMatrixView.setDisplayMode(mode);
    this.eventBus.post(HICEvent("DisplayMode", mode));
  }
  getDisplayMode() {
    return this.contactMatrixView ? this.contactMatrixView.displayMode : void 0;
  }
  async getNormalizationOptions() {
    if (!this.dataset) return [];
    const baseOptions = await this.dataset.getNormalizationOptions();
    if (this.controlDataset) {
      let controlOptions = await this.controlDataset.getNormalizationOptions();
      controlOptions = new Set(controlOptions);
      return baseOptions.filter((base) => controlOptions.has(base));
    } else {
      return baseOptions;
    }
  }
  /**
   * Return usable resolutions, that is the union of resolutions between dataset and controlDataset.
   * @returns {{index: *, binSize: *}[]|Array}
   */
  getResolutions() {
    if (!this.dataset) return [];
    const baseResolutions = this.dataset.bpResolutions.map(function(resolution, index2) {
      return { index: index2, binSize: resolution };
    });
    if (this.controlDataset) {
      let controlResolutions = new Set(this.controlDataset.bpResolutions);
      return baseResolutions.filter((base) => controlResolutions.has(base.binSize));
    } else {
      return baseResolutions;
    }
  }
  isWholeGenome() {
    return this.dataset && this.state && this.dataset.isWholeGenome(this.state.chr1);
  }
  getColorScale() {
    if (!this.contactMatrixView) return void 0;
    switch (this.getDisplayMode()) {
      case "AOB":
      case "BOA":
        return this.contactMatrixView.ratioColorScale;
      case "AMB":
        return this.contactMatrixView.diffColorScale;
      default:
        return this.contactMatrixView.colorScale;
    }
  }
  setColorScaleThreshold(threshold) {
    this.contactMatrixView.setColorScaleThreshold(threshold);
  }
  updateCrosshairs({ x, y, xNormalized, yNormalized }) {
    this.crosshairManager.updateCrosshairs({ x, y, xNormalized, yNormalized });
  }
  setCustomCrosshairsHandler(crosshairsHandler) {
    this.crosshairManager.setCustomCrosshairsHandler(crosshairsHandler);
  }
  hideCrosshairs() {
    this.crosshairManager.hideCrosshairs();
  }
  showCrosshairs() {
    this.crosshairManager.showCrosshairs();
  }
  genomicState(axis) {
    return CoordinateTransformer.genomicState(this.dataset, this.state, this.contactMatrixView, this.genome, axis);
  }
  /**
   * Load a list of 1D genome tracks (wig, etc).
   *
   * NOTE: public API function
   *
   * @param configs
   */
  async loadTracks(configs) {
    const errorPrefix = configs.length === 1 ? `Error loading track ${configs[0].name}` : "Error loading tracks";
    try {
      this.contactMatrixView.startSpinner();
      const tracks = [];
      const promises2D = [];
      for (let config of configs) {
        const fileName = isFile(config.url) ? config.url.name : config.filename || await getFilename$3(config.url);
        const extension = getExtension(fileName);
        if (["fasta", "fa"].includes(extension)) {
          config.type = config.format = "sequence";
        }
        if (!config.format) {
          config.format = index$1.TrackUtils.inferFileFormat(fileName);
        }
        if (config.type === "annotation") {
          config.displayMode = "COLLAPSED";
          if (config.color === DEFAULT_ANNOTATION_COLOR$1) {
            delete config.color;
          }
        }
        if (config.max === void 0) {
          config.autoscale = true;
        }
        const { trackHeight } = getLayoutDimensions();
        config.height = trackHeight;
        if (config.format === void 0 || ["bedpe", "interact"].includes(config.format)) {
          promises2D.push(Track2D.loadTrack2D(config, this.genome));
        } else {
          const track = await index$1.createTrack(config, this);
          if (typeof track.postInit === "function") {
            await track.postInit();
          }
          tracks.push(track);
        }
      }
      if (tracks.length > 0) {
        this.layoutController.updateLayoutWithTracks(tracks);
        const gearContainer = document.querySelector(".hic-igv-right-hand-gutter");
        if (this.showTrackLabelAndGutter) {
          gearContainer.style.display = "block";
        } else {
          gearContainer.style.display = "none";
        }
        await this.updateLayout();
      }
      if (promises2D.length > 0) {
        const tracks2D = await Promise.all(promises2D);
        if (tracks2D && tracks2D.length > 0) {
          this.tracks2D = this.tracks2D.concat(tracks2D);
          this.eventBus.post(HICEvent("TrackLoad2D", this.tracks2D));
        }
      }
    } catch (error) {
      presentError(errorPrefix, error);
      console.error(error);
    } finally {
      this.contactMatrixView.stopSpinner();
    }
  }
  async loadNormalizationFile(url) {
    if (!this.dataset) return;
    this.eventBus.post(HICEvent("NormalizationFileLoad", "start"));
    const normVectors = await this.dataset.hicFile.readNormalizationVectorFile(url, this.dataset.chromosomes);
    for (let type of normVectors["types"]) {
      if (!this.dataset.normalizationTypes) {
        this.dataset.normalizationTypes = [];
      }
      if (!this.dataset.normalizationTypes.includes(type)) {
        this.dataset.normalizationTypes.push(type);
      }
      this.eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
    }
    return normVectors;
  }
  /**
   * Render the XY pair of tracks.
   *
   * @param xy
   */
  async renderTrackXY(xy) {
    try {
      this.startSpinner();
      await xy.updateViews();
    } finally {
      this.stopSpinner();
    }
  }
  reset() {
    this.lifecycleManager.reset();
  }
  clearSession() {
    this.lifecycleManager.clearSession();
  }
  /**
   * Remove reference to self from all synchedBrowsers lists.
   */
  unsyncSelf() {
    this.lifecycleManager.unsyncSelf();
  }
  /**
   * Remove the reference browser from this collection of synched browsers
   * @param browser
   */
  unsync(browser) {
    this.lifecycleManager.unsync(browser);
  }
  /**
   * Load a .hic file
   *
   * NOTE: public API function
   *
   * @return a promise for a dataset
   * @param config
   * @param noUpdates
   */
  async loadHicFile(config, noUpdates) {
    if (!config.url) {
      console.log("No .hic url specified");
      return void 0;
    }
    this.clearSession();
    try {
      this.contactMatrixView.startSpinner();
      if (!noUpdates) {
        this.userInteractionShield.style.display = "block";
      }
      const name2 = extractName(config);
      const prefix = this.controlDataset ? "A: " : "";
      this.contactMapLabel.textContent = prefix + name2;
      this.contactMapLabel.title = name2;
      config.name = name2;
      const hicFileAlert = (str) => {
        this.eventBus.post(HICEvent("NormalizationExternalChange", "NONE"));
        Alert$1.presentAlert(str);
      };
      this.dataset = await Dataset2.loadDataset(Object.assign({ alert: hicFileAlert }, config));
      this.dataset.name = name2;
      const previousGenomeId = this.genome ? this.genome.id : void 0;
      this.genome = new Genome2(this.dataset.genomeId, this.dataset.chromosomes);
      if (this.genome.id !== previousGenomeId) {
        EventBus.globalBus.post(HICEvent("GenomeChange", this.genome.id));
      }
      if (config.locus) {
        this.state = State.default(config);
        await this.parseGotoInput(config.locus);
      } else if (config.state) {
        if (typeof config.state === "string") {
          await this.setState(State.parse(config.state));
        } else if (typeof config.state === "object") {
          await this.setState(State.fromJSON(config.state));
        } else {
          alert("config.state is of unknown type");
          console.error("config.state is of unknown type");
        }
      } else if (config.synchState && this.canBeSynched(config.synchState)) {
        await this.syncState(config.synchState);
      } else {
        this.state = State.default(config);
        await this.parseGotoInput("all");
      }
      this.eventBus.post(HICEvent("MapLoad", this.dataset));
      if (!config.nvi && typeof config.url === "string") {
        const url = new URL(config.url);
        const key = encodeURIComponent(url.hostname + url.pathname);
        if (nvi.hasOwnProperty(key)) {
          config.nvi = nvi[key];
        }
      }
      if (config.nvi) {
        await this.dataset.getNormVectorIndex(config);
        this.eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
      } else {
        this.dataset.getNormVectorIndex(config).then((normVectorIndex) => {
          if (!config.isControl) {
            this.eventBus.post(HICEvent("NormVectorIndexLoad", this.dataset));
          }
        });
      }
      syncBrowsers();
      const compatibleBrowsers = getAllBrowsers().filter((b) => b !== this && b.dataset && b.dataset.isCompatible(this.dataset));
      if (compatibleBrowsers.length > 0) {
        await this.syncState(compatibleBrowsers[0].getSyncState());
      }
    } catch (error) {
      this.contactMapLabel.textContent = "";
      this.contactMapLabel.title = "";
      config.name = name;
      throw error;
    } finally {
      this.stopSpinner();
      if (!noUpdates) {
        this.userInteractionShield.style.display = "none";
      }
    }
  }
  /**
   * Load a .hic file for a control map
   *
   * NOTE: public API function
   *
   * @return a promise for a dataset
   * @param config
   */
  async loadHicControlFile(config, noUpdates) {
    try {
      this.userInteractionShield.style.display = "block";
      this.contactMatrixView.startSpinner();
      this.controlUrl = config.url;
      const name2 = extractName(config);
      config.name = name2;
      const hicFileAlert = (str) => {
        this.eventBus.post(HICEvent("NormalizationExternalChange", "NONE"));
        Alert$1.presentAlert(str);
      };
      const controlDataset = await Dataset2.loadDataset(Object.assign({ alert: hicFileAlert }, config));
      controlDataset.name = name2;
      if (!this.dataset || this.dataset.isCompatible(controlDataset)) {
        this.controlDataset = controlDataset;
        if (this.dataset) {
          this.contactMapLabel.textContent = "A: " + this.dataset.name;
        }
        this.controlMapLabel.textContent = "B: " + controlDataset.name;
        this.controlMapLabel.title = controlDataset.name;
        await controlDataset.getNormVectorIndex(config);
        this.eventBus.post(HICEvent("ControlMapLoad", this.controlDataset));
        if (!noUpdates) {
          this.update();
        }
      } else {
        Alert$1.presentAlert('"B" map genome (' + controlDataset.genomeId + ') does not match "A" map genome (' + this.genome.id + ")");
      }
    } finally {
      this.userInteractionShield.style.display = "none";
      this.stopSpinner();
    }
  }
  async parseGotoInput(input) {
    const loci = input.trim().split(" ");
    let xLocus = this.parseLocusString(loci[0]) || await this.lookupFeatureOrGene(loci[0]);
    if (!xLocus && loci[0].toLowerCase() === "all") {
      if (this.dataset && this.dataset.wholeGenomeChromosome) {
        const wholeGenomeChr = this.dataset.wholeGenomeChromosome;
        xLocus = {
          chr: wholeGenomeChr.name,
          wholeChr: true,
          start: 0,
          end: wholeGenomeChr.size
        };
      } else {
        console.error(`No whole genome chromosome available for "all" locus`);
        return;
      }
    }
    if (!xLocus) {
      console.error(`No feature found with name ${loci[0]}`);
      alert(`No feature found with name ${loci[0]}`);
      return;
    }
    let yLocus = loci[1] ? this.parseLocusString(loci[1]) : { ...xLocus };
    if (!yLocus) {
      yLocus = { ...xLocus };
    }
    if (xLocus.wholeChr && yLocus.wholeChr || "All" === xLocus.chr && "All" === yLocus.chr) {
      await this.setChromosomes(xLocus, yLocus);
    } else {
      this.goto(xLocus.chr, xLocus.start, xLocus.end, yLocus.chr, yLocus.start, yLocus.end);
    }
  }
  parseLocusString(locus) {
    return LocusParser.parseLocusString(locus, this.genome);
  }
  async lookupFeatureOrGene(name2) {
    return LocusParser.lookupFeatureOrGene(name2, this.genome, this.state);
  }
  goto(chr1, bpX, bpXMax, chr2, bpY, bpYMax) {
    this.navigationService.goto(chr1, bpX, bpXMax, chr2, bpY, bpYMax);
  }
  /**
   * Find the closest matching zoom index (index into the dataset resolutions array) for the target resolution.
   *
   * resolutionAraay can be either
   *   (1) an array of bin sizes
   *   (2) an array of objects with index and bin size
   * @param targetResolution
   * @param resolutionArray
   * @returns {number}
   */
  findMatchingZoomIndex(targetResolution, resolutionArray) {
    return this.navigationService.findMatchingZoomIndex(targetResolution, resolutionArray);
  }
  /**
   * @param scaleFactor Values range from greater then 1 to decimal values less then one
   *                    Value > 1 are magnification (zoom in)
   *                    Decimal values (.9, .75, .25, etc.) are minification (zoom out)
   * @param anchorPx -- anchor position in pixels (should not move after transformation)
   * @param anchorPy
   */
  async pinchZoom(anchorPx, anchorPy, scaleFactor) {
    return this.navigationService.pinchZoom(anchorPx, anchorPy, scaleFactor);
  }
  // Zoom in response to a double-click
  /**
   * Zoom and center on bins at given screen coordinates.  Supports double-click zoom, pinch zoom.
   * @param direction
   * @param centerPX  screen coordinate to center on
   * @param centerPY  screen coordinate to center on
   * @returns {Promise<void>}
   */
  async zoomAndCenter(direction, centerPX, centerPY) {
    return this.navigationService.zoomAndCenter(direction, centerPX, centerPY);
  }
  /**
   * Set the current zoom state and opctionally center over supplied coordinates.
   * @param zoom - index to the datasets resolution array (dataset.bpResolutions)
   * @returns {Promise<void>}
   */
  async setZoom(zoom) {
    return this.navigationService.setZoom(zoom);
  }
  async setChromosomes(xLocus, yLocus) {
    const { index: chr1Index } = this.genome.getChromosome(xLocus.chr);
    const { index: chr2Index } = this.genome.getChromosome(yLocus.chr);
    this.state.chr1 = Math.min(chr1Index, chr2Index);
    this.state.x = 0;
    this.state.chr2 = Math.max(chr1Index, chr2Index);
    this.state.y = 0;
    this.state.locus = {
      x: { chr: xLocus.chr, start: xLocus.start, end: xLocus.end },
      y: { chr: yLocus.chr, start: yLocus.start, end: yLocus.end }
    };
    if (xLocus.wholeChr && yLocus.wholeChr) {
      this.state.zoom = await this.minZoom(this.state.chr1, this.state.chr2);
      const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
      this.state.pixelSize = Math.min(100, Math.max(DEFAULT_PIXEL_SIZE, minPS));
    } else {
      this.state.zoom = 0;
      const minPS = await this.minPixelSize(this.state.chr1, this.state.chr2, this.state.zoom);
      this.state.pixelSize = Math.max(this.state.pixelSize, minPS);
    }
    await this.update(HICEvent("LocusChange", { state: this.state, resolutionChanged: true, chrChanged: true }));
  }
  /**
   * Called on loading tracks
   * @returns {Promise<void>}
   */
  async updateLayout() {
    this.state.clampXY(this.dataset, this.contactMatrixView.getViewDimensions());
    for (const trackXYPair of this.trackPairs) {
      trackXYPair.x.viewportElement.style.order = `${this.trackPairs.indexOf(trackXYPair)}`;
      trackXYPair.y.viewportElement.style.order = `${this.trackPairs.indexOf(trackXYPair)}`;
      trackXYPair.x.syncCanvas();
      trackXYPair.y.syncCanvas();
    }
    this.layoutController.xAxisRuler.update();
    this.layoutController.yAxisRuler.update();
    setTrackReorderArrowColors(this.trackPairs);
    await this.update();
  }
  /**
   * Set the matrix state.  Used to restore state from a bookmark
   * @param state  browser state
   */
  async setState(state) {
    return this.stateManager.setState(state);
  }
  /**
   * Return a modified state object used for synching.  Other datasets might have different chromosome ordering
   * and resolution arrays
   */
  getSyncState() {
    return this.stateManager.getSyncState();
  }
  /**
   * Return true if this browser can be synced to the given state
   * @param syncState
   */
  canBeSynched(syncState) {
    return this.stateManager.canBeSynched(syncState);
  }
  async syncState(targetState) {
    return this.stateManager.syncState(targetState);
  }
  setNormalization(normalization) {
    this.state.normalization = normalization;
    this.eventBus.post(HICEvent("NormalizationChange", this.state.normalization));
  }
  shiftPixels(dx, dy) {
    if (void 0 === this.dataset) {
      console.warn("dataset is undefined");
      return;
    }
    this.state.panShift(dx, dy, this, this.dataset, this.contactMatrixView.getViewDimensions());
    const locusChangeEvent = HICEvent("LocusChange", {
      state: this.state,
      resolutionChanged: false,
      dragging: true,
      chrChanged: false
    });
    locusChangeEvent.dragging = true;
    this.update(locusChangeEvent);
    this.eventBus.post(locusChangeEvent);
  }
  /**
   * Update the maps and tracks.  This method can be called from the browser event thread repeatedly, for example
   * while mouse dragging.  If called while an update is in progress queue the event for processing later.  It
   * is only neccessary to queue the most recent recently received event, so a simple instance variable will suffice
   * for the queue.
   *
   * @param event
   */
  async update(event) {
    if (this.updating) {
      const type = event ? event.type : "NONE";
      this.pending.set(type, event);
    } else {
      this.updating = true;
      try {
        this.startSpinner();
        if (event !== void 0 && "LocusChange" === event.type) {
          this.layoutController.xAxisRuler.locusChange(event);
          this.layoutController.yAxisRuler.locusChange(event);
        }
        const promises = [];
        for (let xyTrackRenderPair of this.trackPairs) {
          promises.push(this.renderTrackXY(xyTrackRenderPair));
        }
        promises.push(this.contactMatrixView.update(event));
        await Promise.all(promises);
        if (event && event.propogate) {
          let syncState1 = this.getSyncState();
          for (const browser of [...this.synchedBrowsers]) {
            browser.syncState(syncState1);
          }
        }
      } finally {
        this.updating = false;
        if (this.pending.size > 0) {
          const events = [];
          for (let [k, v] of this.pending) {
            events.push(v);
          }
          this.pending.clear();
          for (let e of events) {
            this.update(e);
          }
        }
        if (event) {
          this.eventBus.post(event);
        }
        this.stopSpinner();
      }
    }
  }
  repaintMatrix() {
    this.contactMatrixView.imageTileCache = {};
    this.contactMatrixView.initialImage = void 0;
    this.contactMatrixView.update();
  }
  resolution() {
    return CoordinateTransformer.resolution(this.dataset, this.state);
  }
  /**
   * Serialize a 1D track to JSON.
   * Only tracks with string URLs are serialized (local File objects are excluded).
   * 
   * @param {TrackRenderer} trackRenderer - The track renderer containing the track
   * @returns {Object|null} Serialized track object or null if not serializable
   */
  serializeTrack1D(trackRenderer) {
    const track = trackRenderer.x.track;
    const config = track.config;
    if (typeof config.url === "string") {
      const t = { url: config.url };
      if (config.type) {
        t.type = config.type;
      }
      if (config.format) {
        t.format = config.format;
      }
      if (track.name) {
        t.name = track.name;
      }
      if (track.dataRange) {
        t.min = track.dataRange.min;
        t.max = track.dataRange.max;
      }
      if (track.color) {
        t.color = track.color;
      }
      return t;
    } else if ("sequence" === config.type) {
      return { type: "sequence", format: "sequence" };
    }
    return null;
  }
  /**
   * Serialize a 2D track to JSON.
   * Only tracks with string URLs are serialized (local File objects are excluded).
   * 
   * @param {Track2D} track2D - The 2D track to serialize
   * @returns {Object|null} Serialized track object or null if not serializable
   */
  serializeTrack2D(track2D) {
    if (typeof track2D.config.url === "string") {
      return track2D.toJSON();
    }
    return null;
  }
  toJSON() {
    if (!(this.dataset && this.dataset.url)) return "{}";
    const jsonOBJ = {};
    jsonOBJ.backgroundColor = this.contactMatrixView.stringifyBackgroundColor();
    jsonOBJ.url = this.dataset.url;
    if (this.dataset.name) {
      jsonOBJ.name = this.dataset.name;
    }
    jsonOBJ.state = this.state.toJSON();
    jsonOBJ.colorScale = this.contactMatrixView.getColorScale().stringify();
    if (Globals.selectedGene) {
      jsonOBJ.selectedGene = Globals.selectedGene;
    }
    let nviString = this.dataset.hicFile.config.nvi;
    if (nviString) {
      jsonOBJ.nvi = nviString;
    }
    if (this.controlDataset) {
      jsonOBJ.controlUrl = this.controlUrl;
      if (this.controlDataset.name) {
        jsonOBJ.controlName = this.controlDataset.name;
      }
      const displayMode = this.getDisplayMode();
      if (displayMode) {
        jsonOBJ.displayMode = this.getDisplayMode();
      }
      nviString = this.controlDataset.hicFile.config.nvi;
      if (nviString) {
        jsonOBJ.controlNvi = nviString;
      }
      const controlMapWidget = this.ui.getComponent("controlMap");
      if (controlMapWidget.getDisplayModeCycle() !== void 0) {
        jsonOBJ.cycle = true;
      }
    }
    if (this.trackPairs.length > 0 || this.tracks2D.length > 0) {
      const tracks = [];
      jsonOBJ.tracks = tracks;
      for (const trackRenderer of this.trackPairs) {
        const serialized = this.serializeTrack1D(trackRenderer);
        if (serialized) {
          tracks.push(serialized);
        }
      }
      for (const track2D of this.tracks2D) {
        const serialized = this.serializeTrack2D(track2D);
        if (serialized) {
          tracks.push(serialized);
        }
      }
    }
    return jsonOBJ;
  }
  async minZoom(chr1, chr2) {
    return ZoomCalculator.minZoom(chr1, chr2, this.dataset, this.contactMatrixView);
  }
  async minPixelSize(chr1, chr2, zoomIndex) {
    return ZoomCalculator.minPixelSize(chr1, chr2, zoomIndex, this.dataset, this.contactMatrixView);
  }
}
let allBrowsers = [];
let currentBrowser;
async function createBrowser(hicContainer, config, callback) {
  setDefaults(config);
  if (isString$3(config.colorScale)) config.colorScale = ColorScale.parse(config.colorScale);
  if (isString$3(config.backgroundColor)) config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
  const browser = new HICBrowser(hicContainer, config);
  await browser.init(config);
  if (typeof callback === "function") callback();
  allBrowsers.push(browser);
  setCurrentBrowser(browser);
  if (allBrowsers.length > 1) {
    allBrowsers.forEach((b) => b.browserPanelDeleteButton.style.display = "block");
  }
  return browser;
}
async function createBrowserList(hicContainer, session) {
  const configList = session.browsers || [session];
  allBrowsers = [];
  const initPromises = [];
  for (const config of configList) {
    setDefaults(config);
    if (isString$3(config.colorScale)) {
      config.colorScale = ColorScale.parse(config.colorScale);
    }
    if (isString$3(config.backgroundColor)) {
      config.backgroundColor = ContactMatrixView.parseBackgroundColor(config.backgroundColor);
    }
    if (session.syncDatasets === false) {
      config.synchable = false;
    }
    const browser = new HICBrowser(hicContainer, config);
    allBrowsers.push(browser);
    initPromises.push(browser.init(config));
  }
  await Promise.all(initPromises);
  setCurrentBrowser(allBrowsers[0]);
  if (allBrowsers.length > 1) {
    allBrowsers.forEach((b) => b.browserPanelDeleteButton.style.display = "block");
  }
}
function deleteAllBrowsers() {
  for (let b of allBrowsers) {
    b.rootElement.remove();
  }
  allBrowsers = [];
}
function setCurrentBrowser(browser) {
  if (browser === void 0) {
    currentBrowser?.rootElement.classList.remove("hic-root-selected");
    currentBrowser = browser;
    return;
  }
  if (browser !== currentBrowser) {
    currentBrowser?.rootElement.classList.remove("hic-root-selected");
    browser.rootElement.classList.add("hic-root-selected");
    currentBrowser = browser;
    EventBus.globalBus.post(HICEvent("BrowserSelect", browser));
  }
}
function deleteBrowser(browser) {
  browser.unsyncSelf();
  browser.rootElement.remove();
  allBrowsers = allBrowsers.filter((b) => b !== browser);
  if (allBrowsers.length <= 1) {
    allBrowsers.forEach((b) => b.browserPanelDeleteButton.style.display = "none");
  }
}
function getCurrentBrowser() {
  return currentBrowser;
}
function syncBrowsers(browsers) {
  const synchableBrowsers = allBrowsers.filter((b) => b.synchable !== false && b.dataset !== void 0);
  synchableBrowsers.forEach((b1) => {
    synchableBrowsers.forEach((b2) => {
      if (b1 !== b2 && b1.dataset.isCompatible(b2.dataset)) {
        b1.synchedBrowsers.add(b2);
        b2.synchedBrowsers.add(b1);
      }
    });
  });
}
function getAllBrowsers() {
  return allBrowsers;
}
function setDefaults(config) {
  if (config.figureMode === true) {
    config.showLocusGoto = false;
    config.showHicContactMapLabel = false;
    config.showChromosomeSelector = false;
  } else {
    config.showLocusGoto = config.showLocusGoto ?? true;
    config.showHicContactMapLabel = config.showHicContactMapLabel ?? true;
    config.showChromosomeSelector = config.showChromosomeSelector ?? true;
  }
}
const version = "2.5.3";
function detectLocalFiles(browser) {
  const result = {
    hasLocalHicFile: false,
    localTracks1D: 0,
    localTracks2D: 0
  };
  if (browser.dataset && !browser.dataset.url) {
    result.hasLocalHicFile = true;
  }
  if (browser.trackPairs && browser.trackPairs.length > 0) {
    for (const trackRenderer of browser.trackPairs) {
      const track = trackRenderer.x?.track;
      const config = track?.config;
      if (config && config.type === "sequence") {
        continue;
      }
      if (config && config.url && isFile(config.url)) {
        result.localTracks1D++;
      }
    }
  }
  if (browser.tracks2D && browser.tracks2D.length > 0) {
    for (const track2D of browser.tracks2D) {
      const config = track2D?.config;
      if (config && config.url && isFile(config.url)) {
        result.localTracks2D++;
      }
    }
  }
  return result;
}
function toJSON() {
  const jsonOBJ = {};
  const browserJson = [];
  const allBrowsers2 = getAllBrowsers();
  let totalLocalHicFiles = 0;
  let totalLocalTracks1D = 0;
  let totalLocalTracks2D = 0;
  for (let browser of allBrowsers2) {
    const localFiles = detectLocalFiles(browser);
    if (localFiles.hasLocalHicFile) {
      totalLocalHicFiles++;
    }
    totalLocalTracks1D += localFiles.localTracks1D;
    totalLocalTracks2D += localFiles.localTracks2D;
    browserJson.push(browser.toJSON());
  }
  jsonOBJ.browsers = browserJson;
  if (Globals.selectedGene) {
    jsonOBJ["selectedGene"] = Globals.selectedGene;
  }
  const captionDiv = document.getElementById("hic-caption");
  if (captionDiv) {
    var captionText = captionDiv.textContent;
    if (captionText) {
      captionText = captionText.trim();
      if (captionText) {
        jsonOBJ.caption = captionText;
      }
    }
  }
  if (totalLocalHicFiles > 0 || totalLocalTracks1D > 0 || totalLocalTracks2D > 0) {
    const warningParts = [];
    if (totalLocalHicFiles > 0) {
      warningParts.push(`${totalLocalHicFiles} Hi-C file${totalLocalHicFiles > 1 ? "s" : ""}`);
    }
    if (totalLocalTracks1D > 0) {
      warningParts.push(`${totalLocalTracks1D} 1D track${totalLocalTracks1D > 1 ? "s" : ""}`);
    }
    if (totalLocalTracks2D > 0) {
      warningParts.push(`${totalLocalTracks2D} 2D track${totalLocalTracks2D > 1 ? "s" : ""}`);
    }
    const warningMessage = `Warning: ${warningParts.join(", ")} with local files ${totalLocalHicFiles + totalLocalTracks1D + totalLocalTracks2D > 1 ? "were" : "was"} not saved to the session. Local files cannot be serialized and will need to be reloaded manually.`;
    Alert$1.presentAlert(warningMessage);
  }
  return jsonOBJ;
}
function compressedSession() {
  const jsonString = JSON.stringify(toJSON());
  return `session=blob:${compressString$1(jsonString)}`;
}
async function restoreSession(container, session) {
  deleteAllBrowsers();
  if (session.hasOwnProperty("selectedGene")) {
    Globals.selectedGene = session.selectedGene;
  }
  if (session.hasOwnProperty("caption")) {
    const captionText = session.caption;
    var captionDiv = document.getElementById("hic-caption");
    if (captionDiv) {
      captionDiv.textContent = captionText;
    }
  }
  await createBrowserList(container, session);
  if (false !== session.syncDatasets) {
    syncBrowsers();
  }
}
const DEFAULT_ANNOTATION_COLOR = "rgb(22, 129, 198)";
const urlShortcuts = {
  "*s3e/": "https://hicfiles.s3.amazonaws.com/external/",
  "*s3/": "https://hicfiles.s3.amazonaws.com/",
  "*s3e_/": "http://hicfiles.s3.amazonaws.com/external/",
  "*s3_/": "http://hicfiles.s3.amazonaws.com/",
  "*enc/": "https://www.encodeproject.org/files/"
};
async function extractConfig(queryString) {
  let query = extractQuery(queryString);
  let sessionConfig;
  if (query.hasOwnProperty("session")) {
    if (query.session.startsWith("blob:") || query.session.startsWith("data:")) {
      sessionConfig = JSON.parse(uncompressString$1(query.session.substr(5)));
    }
  }
  if (query.hasOwnProperty("juiceboxURL")) {
    const jbURL = await expandURL(query["juiceboxURL"]);
    query = extractQuery(jbURL);
  }
  if (query.hasOwnProperty("juicebox") || query.hasOwnProperty("juiceboxData")) {
    let q;
    if (query.hasOwnProperty("juiceboxData")) {
      q = uncompressString$1(query["juiceboxData"]);
    } else {
      q = query["juicebox"];
      if (q.startsWith("%7B")) {
        q = decodeURIComponent(q);
      }
    }
    q = q.substr(1, q.length - 2);
    const parts = q.split("},{");
    const browsers = [];
    for (let p of parts) {
      const qObj = extractQuery(decodeURIComponent(p));
      browsers.push(decodeQuery(qObj));
    }
    sessionConfig = { browsers };
  }
  const uriDecode = true;
  const queryConfig = decodeQuery(query, uriDecode);
  if (queryConfig.url) {
    sessionConfig = queryConfig;
  }
  if (sessionConfig) {
    if (sessionConfig.browsers) {
      for (let b of sessionConfig.browsers) {
        fixDefaults(b);
      }
    } else {
      fixDefaults(sessionConfig);
    }
  }
  return sessionConfig;
}
function fixDefaults(browserConfig) {
  if (browserConfig.tracks) {
    for (let t of browserConfig.tracks) {
      if (t.color === DEFAULT_ANNOTATION_COLOR) {
        delete t.color;
      }
      if (t.min !== void 0 && Number.isNaN(t.min)) {
        delete t.min;
      }
      if (t.max !== void 0 && Number.isNaN(t.max)) {
        delete t.max;
      }
      t.displayMode = "COLLAPSED";
    }
  }
}
function decodeQuery(query, uriDecode) {
  const config = {};
  let hicUrl = query["hicUrl"];
  const name2 = query["name"];
  let stateString = query["state"];
  let colorScale = query["colorScale"];
  let trackString = query["tracks"];
  const selectedGene = query["selectedGene"];
  const nvi2 = query["nvi"];
  let controlUrl = query["controlUrl"];
  const controlName = query["controlName"];
  const displayMode = query["displayMode"];
  const controlNvi = query["controlNvi"];
  const cycle = query["cycle"];
  if (hicUrl) {
    hicUrl = paramDecode(hicUrl, uriDecode);
    Object.keys(urlShortcuts).forEach(function(key) {
      var value = urlShortcuts[key];
      if (hicUrl.startsWith(key)) hicUrl = hicUrl.replace(key, value);
    });
    config.url = hicUrl;
  }
  if (name2) {
    config.name = paramDecode(name2, uriDecode);
  }
  if (controlUrl) {
    controlUrl = paramDecode(controlUrl, uriDecode);
    Object.keys(urlShortcuts).forEach(function(key) {
      var value = urlShortcuts[key];
      if (controlUrl.startsWith(key)) controlUrl = controlUrl.replace(key, value);
    });
    config.controlUrl = controlUrl;
  }
  if (controlName) {
    config.controlName = paramDecode(controlName, uriDecode);
  }
  if (stateString) {
    stateString = paramDecode(stateString, uriDecode);
    config.state = State.parse(stateString);
  }
  if (colorScale) {
    colorScale = paramDecode(colorScale, uriDecode);
    config.colorScale = ColorScale.parse(colorScale);
  }
  if (displayMode) {
    config.displayMode = paramDecode(displayMode, uriDecode);
  }
  if (trackString) {
    trackString = paramDecode(trackString, uriDecode);
    config.tracks = destringifyTracksV0(trackString);
    if (config.tracks && config.oauthToken) {
      config.tracks.forEach(function(t) {
        t.oauthToken = config.oauthToken;
      });
    }
  }
  if (selectedGene) {
    Globals.selectedGene = selectedGene;
  }
  config.cycle = cycle;
  if (nvi2) {
    config.nvi = paramDecode(nvi2, uriDecode);
  }
  if (controlNvi) {
    config.controlNvi = paramDecode(controlNvi, uriDecode);
  }
  return config;
  function destringifyTracksV0(tracks) {
    const trackStringList = tracks.split("|||");
    const configList = [];
    for (let trackString2 of trackStringList) {
      const tokens = trackString2.split("|");
      const color = tokens.pop();
      let url = tokens.length > 1 ? tokens[0] : trackString2;
      if (url && url.trim().length > 0 && "undefined" !== url) {
        const keys = Object.keys(urlShortcuts);
        for (let key of keys) {
          var value = urlShortcuts[key];
          if (url.startsWith(key)) {
            url = url.replace(key, value);
            break;
          }
        }
        const trackConfig = { url };
        if (tokens.length > 1) {
          trackConfig.name = replaceAll(tokens[1], "$", "|");
        }
        if (tokens.length > 2) {
          const dataRangeString = tokens[2];
          if (dataRangeString.startsWith("-")) {
            const r = dataRangeString.substring(1).split("-");
            trackConfig.min = -parseFloat(r[0]);
            trackConfig.max = parseFloat(r[1]);
          } else {
            const r = dataRangeString.split("-");
            trackConfig.min = parseFloat(r[0]);
            trackConfig.max = parseFloat(r[1]);
          }
        }
        if (color) {
          trackConfig.color = color;
        }
        configList.push(trackConfig);
      }
    }
    return configList;
  }
}
function paramDecode(str, uriDecode) {
  if (uriDecode) {
    return decodeURIComponent(str);
  } else {
    var s = replaceAll(str, "%26", "&");
    s = replaceAll(s, "%20", " ");
    s = replaceAll(s, "+", " ");
    s = replaceAll(s, "%7C", "|");
    s = replaceAll(s, "%23", "#");
    s = replaceAll(s, "%3F", "?");
    s = replaceAll(s, "%3D", "=");
    return s;
  }
}
function replaceAll(str, target, replacement) {
  return str.split(target).join(replacement);
}
function extractQuery(uri) {
  var i1, i2, i, j, s, query, tokens;
  query = {};
  i1 = uri.indexOf("?");
  i2 = uri.lastIndexOf("#");
  const i3 = uri.indexOf("=");
  if (i1 > i3) i1 = -1;
  if (i2 < 0) i2 = uri.length;
  for (i = i1 + 1; i < i2; ) {
    j = uri.indexOf("&", i);
    if (j < 0) j = i2;
    s = uri.substring(i, j);
    tokens = s.split("=", 2);
    if (tokens.length === 2) {
      query[tokens[0]] = tokens[1];
    }
    i = j + 1;
  }
  return query;
}
async function expandURL(url) {
  const endpoint = `https://api-ssl.bitly.com/v4/expand`;
  const id = url.startsWith("http://") ? url.substring(7) : url.substring(8);
  const message = {
    "bitlink_id": id
  };
  const response = await fetch(endpoint, {
    method: "POST",
    // or 'PUT'
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${btoa("ttsf9snz")}`
    },
    body: JSON.stringify(message)
  });
  if (!response.ok) {
    throw new Error(`Network error (${response.status}): ${response.statusText}`);
  }
  const json = await response.json();
  let longUrl = json.long_url;
  longUrl = longUrl.replace("{", "%7B").replace("}", "%7D");
  return longUrl;
}
async function init$1(container, config) {
  Alert$1.init(container);
  if (false !== config.queryParametersSupported) {
    const queryConfig = await extractConfig(window.location.href);
    if (queryConfig) {
      config = queryConfig;
    }
  }
  await restoreSession(container, config);
  const allBrowsers2 = getAllBrowsers();
  return allBrowsers2.length === 1 ? allBrowsers2[0] : allBrowsers2;
}
const index = {
  version,
  init: init$1,
  toJSON,
  restoreSession,
  compressedSession,
  createBrowser,
  getCurrentBrowser,
  setCurrentBrowser,
  getAllBrowsers,
  igvxhr: igvxhr$1,
  EventBus
};
export {
  index as default
};
//# sourceMappingURL=juicebox.esm.js.map
